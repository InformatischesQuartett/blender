
#ifndef __UNIPLUG_BLENDER_CPP_H__
#define __UNIPLUG_BLENDER_CPP_H__

#include <string>
#include <array>
#include <vector>
#include <map>
#include <string.h> /* for memcpy */
#include <Python.h>

namespace UniplugBL {

/**************** Declarations ****************/

class Struct;
class Property;
class BoolProperty;
class IntProperty;
class FloatProperty;
class StringProperty;
class EnumProperty;
class EnumPropertyItem;
class PointerProperty;
class CollectionProperty;
class Function;
class BlenderRNA;
class UnknownType;
class AnyType;
class ID;
class ImagePreview;
class PropertyGroupItem;
class PropertyGroup;
class IDMaterials;
class Library;
class Texture;
class CloudsTexture;
class WoodTexture;
class MarbleTexture;
class MagicTexture;
class BlendTexture;
class StucciTexture;
class NoiseTexture;
class ImageTexture;
class EnvironmentMapTexture;
class MusgraveTexture;
class VoronoiTexture;
class DistortedNoiseTexture;
class PointDensity;
class PointDensityTexture;
class VoxelData;
class VoxelDataTexture;
class OceanTexData;
class OceanTexture;
class TextureSlot;
class EnvironmentMap;
class TexMapping;
class ColorMapping;
class Action;
class ActionFCurves;
class ActionGroups;
class ActionPoseMarkers;
class ActionGroup;
class DopeSheet;
class AnimData;
class NlaTracks;
class AnimDataDrivers;
class KeyingSet;
class KeyingSetPaths;
class KeyingSetPath;
class KeyingSetInfo;
class AnimViz;
class AnimVizOnionSkinning;
class AnimVizMotionPaths;
class MotionPath;
class MotionPathVert;
class Actuator;
class ActionActuator;
class ObjectActuator;
class CameraActuator;
class SoundActuator;
class PropertyActuator;
class ConstraintActuator;
class EditObjectActuator;
class SceneActuator;
class RandomActuator;
class MessageActuator;
class GameActuator;
class VisibilityActuator;
class Filter2DActuator;
class ParentActuator;
class StateActuator;
class ArmatureActuator;
class SteeringActuator;
class MouseActuator;
class Armature;
class ArmatureBones;
class ArmatureEditBones;
class Bone;
class EditBone;
class BoidRule;
class BoidRuleGoal;
class BoidRuleAvoid;
class BoidRuleAvoidCollision;
class BoidRuleFollowLeader;
class BoidRuleAverageSpeed;
class BoidRuleFight;
class BoidState;
class BoidSettings;
class Brush;
class BrushCapabilities;
class SculptToolCapabilities;
class ImapaintToolCapabilities;
class BrushTextureSlot;
class OperatorStrokeElement;
class Camera;
class CameraStereoData;
class ClothSolverResult;
class ClothSettings;
class ClothCollisionSettings;
class CurveMapPoint;
class CurveMap;
class CurveMapPoints;
class CurveMapping;
class ColorRampElement;
class ColorRamp;
class ColorRampElements;
class Histogram;
class Scopes;
class ColorManagedDisplaySettings;
class ColorManagedViewSettings;
class ColorManagedInputColorspaceSettings;
class ColorManagedSequencerColorspaceSettings;
class Constraint;
class ConstraintTarget;
class ChildOfConstraint;
class PythonConstraint;
class StretchToConstraint;
class FollowPathConstraint;
class LockedTrackConstraint;
class ActionConstraint;
class CopyScaleConstraint;
class MaintainVolumeConstraint;
class CopyLocationConstraint;
class CopyRotationConstraint;
class CopyTransformsConstraint;
class FloorConstraint;
class TrackToConstraint;
class KinematicConstraint;
class RigidBodyJointConstraint;
class ClampToConstraint;
class LimitDistanceConstraint;
class LimitScaleConstraint;
class LimitRotationConstraint;
class LimitLocationConstraint;
class TransformConstraint;
class ShrinkwrapConstraint;
class DampedTrackConstraint;
class SplineIKConstraint;
class PivotConstraint;
class FollowTrackConstraint;
class CameraSolverConstraint;
class ObjectSolverConstraint;
class Context;
class Controller;
class ExpressionController;
class PythonController;
class AndController;
class OrController;
class NorController;
class NandController;
class XorController;
class XnorController;
class Curve;
class CurveSplines;
class SurfaceCurve;
class TextCurve;
class TextBox;
class TextCharacterFormat;
class SplinePoint;
class BezierSplinePoint;
class Spline;
class SplinePoints;
class SplineBezierPoints;
class Depsgraph;
class DynamicPaintCanvasSettings;
class DynamicPaintSurfaces;
class DynamicPaintBrushSettings;
class DynamicPaintSurface;
class FCurve;
class FCurveKeyframePoints;
class FCurveModifiers;
class Keyframe;
class FCurveSample;
class DriverTarget;
class DriverVariable;
class Driver;
class ChannelDriverVariables;
class FModifier;
class FModifierGenerator;
class FModifierFunctionGenerator;
class FModifierEnvelope;
class FModifierEnvelopeControlPoints;
class FModifierEnvelopeControlPoint;
class FModifierCycles;
class FModifierPython;
class FModifierLimits;
class FModifierNoise;
class FModifierStepped;
class FluidSettings;
class DomainFluidSettings;
class FluidMeshVertex;
class FluidFluidSettings;
class ObstacleFluidSettings;
class InflowFluidSettings;
class OutflowFluidSettings;
class ParticleFluidSettings;
class ControlFluidSettings;
class GreasePencil;
class GreasePencilLayers;
class GPencilLayer;
class GPencilFrames;
class GPencilFrame;
class GPencilStrokes;
class GPencilStroke;
class GPencilStrokePoints;
class GPencilStrokePoint;
class Group;
class GroupObjects;
class RenderSlot;
class RenderSlots;
class Image;
class ImageUser;
class ImagePackedFile;
class Key;
class ShapeKey;
class ShapeKeyPoint;
class ShapeKeyCurvePoint;
class ShapeKeyBezierPoint;
class Lamp;
class LampTextureSlots;
class PointLamp;
class AreaLamp;
class SpotLamp;
class SunLamp;
class LampSkySettings;
class HemiLamp;
class LampTextureSlot;
class Lattice;
class LatticePoint;
class LineStyleModifier;
class LineStyleColorModifier;
class LineStyleColorModifier_AlongStroke;
class LineStyleColorModifier_DistanceFromCamera;
class LineStyleColorModifier_DistanceFromObject;
class LineStyleColorModifier_Material;
class LineStyleAlphaModifier;
class LineStyleAlphaModifier_AlongStroke;
class LineStyleAlphaModifier_DistanceFromCamera;
class LineStyleAlphaModifier_DistanceFromObject;
class LineStyleAlphaModifier_Material;
class LineStyleThicknessModifier;
class LineStyleThicknessModifier_AlongStroke;
class LineStyleThicknessModifier_DistanceFromCamera;
class LineStyleThicknessModifier_DistanceFromObject;
class LineStyleThicknessModifier_Material;
class LineStyleThicknessModifier_Calligraphy;
class LineStyleGeometryModifier;
class LineStyleGeometryModifier_Sampling;
class LineStyleGeometryModifier_BezierCurve;
class LineStyleGeometryModifier_SinusDisplacement;
class LineStyleGeometryModifier_SpatialNoise;
class LineStyleGeometryModifier_PerlinNoise1D;
class LineStyleGeometryModifier_PerlinNoise2D;
class LineStyleGeometryModifier_BackboneStretcher;
class LineStyleGeometryModifier_TipRemover;
class LineStyleGeometryModifier_Polygonalization;
class LineStyleGeometryModifier_GuidingLines;
class LineStyleGeometryModifier_Blueprint;
class LineStyleGeometryModifier_2DOffset;
class LineStyleGeometryModifier_2DTransform;
class FreestyleLineStyle;
class LineStyleTextureSlots;
class LineStyleColorModifiers;
class LineStyleAlphaModifiers;
class LineStyleThicknessModifiers;
class LineStyleGeometryModifiers;
class LineStyleTextureSlot;
class BlendData;
class BlendDataCameras;
class BlendDataScenes;
class BlendDataObjects;
class BlendDataMaterials;
class BlendDataNodeTrees;
class BlendDataMeshes;
class BlendDataLamps;
class BlendDataLibraries;
class BlendDataScreens;
class BlendDataWindowManagers;
class BlendDataImages;
class BlendDataLattices;
class BlendDataCurves;
class BlendDataMetaBalls;
class BlendDataFonts;
class BlendDataTextures;
class BlendDataBrushes;
class BlendDataWorlds;
class BlendDataGroups;
class BlendDataTexts;
class BlendDataSpeakers;
class BlendDataSounds;
class BlendDataArmatures;
class BlendDataActions;
class BlendDataParticles;
class BlendDataPalettes;
class BlendDataGreasePencils;
class BlendDataMovieClips;
class BlendDataMasks;
class BlendDataLineStyles;
class Material;
class MaterialTextureSlots;
class TexPaintSlot;
class MaterialRaytraceMirror;
class MaterialRaytraceTransparency;
class MaterialVolume;
class MaterialHalo;
class MaterialSubsurfaceScattering;
class MaterialTextureSlot;
class MaterialStrand;
class MaterialPhysics;
class MaterialGameSettings;
class Mesh;
class MeshVertices;
class MeshEdges;
class MeshTessFaces;
class MeshLoops;
class MeshPolygons;
class UVLoopLayers;
class TessfaceUVTextures;
class UVTextures;
class VertexColors;
class LoopColors;
class VertexFloatProperties;
class VertexIntProperties;
class VertexStringProperties;
class PolygonFloatProperties;
class PolygonIntProperties;
class PolygonStringProperties;
class MeshSkinVertexLayer;
class MeshSkinVertex;
class MeshPaintMaskLayer;
class MeshPaintMaskProperty;
class MeshVertex;
class VertexGroupElement;
class MeshEdge;
class MeshTessFace;
class MeshLoop;
class MeshPolygon;
class MeshUVLoopLayer;
class MeshUVLoop;
class MeshTextureFaceLayer;
class MeshTextureFace;
class MeshTexturePolyLayer;
class MeshTexturePoly;
class MeshColorLayer;
class MeshColor;
class MeshLoopColorLayer;
class MeshLoopColor;
class MeshVertexFloatPropertyLayer;
class MeshVertexFloatProperty;
class MeshPolygonFloatPropertyLayer;
class MeshPolygonFloatProperty;
class MeshVertexIntPropertyLayer;
class MeshVertexIntProperty;
class MeshPolygonIntPropertyLayer;
class MeshPolygonIntProperty;
class MeshVertexStringPropertyLayer;
class MeshVertexStringProperty;
class MeshPolygonStringPropertyLayer;
class MeshPolygonStringProperty;
class MetaElement;
class MetaBall;
class MetaBallElements;
class Modifier;
class SubsurfModifier;
class LatticeModifier;
class CurveModifier;
class BuildModifier;
class MirrorModifier;
class DecimateModifier;
class WaveModifier;
class ArmatureModifier;
class HookModifier;
class SoftBodyModifier;
class BooleanModifier;
class ArrayModifier;
class EdgeSplitModifier;
class DisplaceModifier;
class UVProjectModifier;
class UVProjector;
class SmoothModifier;
class CorrectiveSmoothModifier;
class CastModifier;
class MeshDeformModifier;
class ParticleSystemModifier;
class ParticleInstanceModifier;
class ExplodeModifier;
class ClothModifier;
class CollisionModifier;
class BevelModifier;
class ShrinkwrapModifier;
class FluidSimulationModifier;
class MaskModifier;
class SimpleDeformModifier;
class WarpModifier;
class MultiresModifier;
class SurfaceModifier;
class SmokeModifier;
class SolidifyModifier;
class ScrewModifier;
class UVWarpModifier;
class VertexWeightEditModifier;
class VertexWeightMixModifier;
class VertexWeightProximityModifier;
class DynamicPaintModifier;
class OceanModifier;
class RemeshModifier;
class SkinModifier;
class LaplacianSmoothModifier;
class TriangulateModifier;
class MeshCacheModifier;
class LaplacianDeformModifier;
class WireframeModifier;
class DataTransferModifier;
class NormalEditModifier;
class NlaTrack;
class NlaStrips;
class NlaStrip;
class NodeSocket;
class NodeSocketInterface;
class Node;
class NodeInputs;
class NodeOutputs;
class NodeLink;
class NodeInternalSocketTemplate;
class NodeInternal;
class ShaderNode;
class CompositorNode;
class TextureNode;
class NodeTree;
class Nodes;
class NodeLinks;
class NodeTreeInputs;
class NodeTreeOutputs;
class NodeSocketStandard;
class NodeSocketInterfaceStandard;
class NodeSocketFloat;
class NodeSocketInterfaceFloat;
class NodeSocketFloatUnsigned;
class NodeSocketInterfaceFloatUnsigned;
class NodeSocketFloatPercentage;
class NodeSocketInterfaceFloatPercentage;
class NodeSocketFloatFactor;
class NodeSocketInterfaceFloatFactor;
class NodeSocketFloatAngle;
class NodeSocketInterfaceFloatAngle;
class NodeSocketFloatTime;
class NodeSocketInterfaceFloatTime;
class NodeSocketInt;
class NodeSocketInterfaceInt;
class NodeSocketIntUnsigned;
class NodeSocketInterfaceIntUnsigned;
class NodeSocketIntPercentage;
class NodeSocketInterfaceIntPercentage;
class NodeSocketIntFactor;
class NodeSocketInterfaceIntFactor;
class NodeSocketBool;
class NodeSocketInterfaceBool;
class NodeSocketVector;
class NodeSocketInterfaceVector;
class NodeSocketVectorTranslation;
class NodeSocketInterfaceVectorTranslation;
class NodeSocketVectorDirection;
class NodeSocketInterfaceVectorDirection;
class NodeSocketVectorVelocity;
class NodeSocketInterfaceVectorVelocity;
class NodeSocketVectorAcceleration;
class NodeSocketInterfaceVectorAcceleration;
class NodeSocketVectorEuler;
class NodeSocketInterfaceVectorEuler;
class NodeSocketVectorXYZ;
class NodeSocketInterfaceVectorXYZ;
class NodeSocketColor;
class NodeSocketInterfaceColor;
class NodeSocketString;
class NodeSocketInterfaceString;
class NodeSocketShader;
class NodeSocketInterfaceShader;
class NodeSocketVirtual;
class CompositorNodeTree;
class ShaderNodeTree;
class TextureNodeTree;
class NodeFrame;
class NodeGroup;
class NodeGroupInput;
class NodeGroupOutput;
class NodeReroute;
class ShaderNodeOutput;
class ShaderNodeMaterial;
class ShaderNodeRGB;
class ShaderNodeValue;
class ShaderNodeMixRGB;
class ShaderNodeValToRGB;
class ShaderNodeRGBToBW;
class ShaderNodeTexture;
class ShaderNodeNormal;
class ShaderNodeGamma;
class ShaderNodeBrightContrast;
class ShaderNodeGeometry;
class ShaderNodeMapping;
class ShaderNodeVectorCurve;
class ShaderNodeRGBCurve;
class ShaderNodeCameraData;
class ShaderNodeLampData;
class ShaderNodeMath;
class ShaderNodeVectorMath;
class ShaderNodeSqueeze;
class ShaderNodeExtendedMaterial;
class ShaderNodeInvert;
class ShaderNodeSeparateRGB;
class ShaderNodeCombineRGB;
class ShaderNodeHueSaturation;
class ShaderNodeOutputMaterial;
class ShaderNodeOutputLamp;
class ShaderNodeOutputWorld;
class ShaderNodeOutputLineStyle;
class ShaderNodeFresnel;
class ShaderNodeLayerWeight;
class ShaderNodeMixShader;
class ShaderNodeAddShader;
class ShaderNodeAttribute;
class ShaderNodeAmbientOcclusion;
class ShaderNodeBackground;
class ShaderNodeHoldout;
class ShaderNodeBsdfAnisotropic;
class ShaderNodeBsdfDiffuse;
class ShaderNodeBsdfGlossy;
class ShaderNodeBsdfGlass;
class ShaderNodeBsdfRefraction;
class ShaderNodeBsdfTranslucent;
class ShaderNodeBsdfTransparent;
class ShaderNodeBsdfVelvet;
class ShaderNodeBsdfToon;
class ShaderNodeBsdfHair;
class ShaderNodeSubsurfaceScattering;
class ShaderNodeVolumeAbsorption;
class ShaderNodeVolumeScatter;
class ShaderNodeEmission;
class ShaderNodeNewGeometry;
class ShaderNodeLightPath;
class ShaderNodeLightFalloff;
class ShaderNodeObjectInfo;
class ShaderNodeParticleInfo;
class ShaderNodeHairInfo;
class ShaderNodeWireframe;
class ShaderNodeWavelength;
class ShaderNodeBlackbody;
class ShaderNodeBump;
class ShaderNodeNormalMap;
class ShaderNodeTangent;
class ShaderNodeScript;
class ShaderNodeTexImage;
class ShaderNodeTexEnvironment;
class ShaderNodeTexSky;
class ShaderNodeTexGradient;
class ShaderNodeTexNoise;
class ShaderNodeTexMagic;
class ShaderNodeTexWave;
class ShaderNodeTexMusgrave;
class ShaderNodeTexVoronoi;
class ShaderNodeTexChecker;
class ShaderNodeTexBrick;
class ShaderNodeTexCoord;
class ShaderNodeVectorTransform;
class ShaderNodeSeparateHSV;
class ShaderNodeCombineHSV;
class ShaderNodeUVMap;
class ShaderNodeUVAlongStroke;
class ShaderNodeSeparateXYZ;
class ShaderNodeCombineXYZ;
class CompositorNodeViewer;
class CompositorNodeRGB;
class CompositorNodeValue;
class CompositorNodeMixRGB;
class CompositorNodeValToRGB;
class CompositorNodeRGBToBW;
class CompositorNodeNormal;
class CompositorNodeCurveVec;
class CompositorNodeCurveRGB;
class CompositorNodeAlphaOver;
class CompositorNodeBlur;
class CompositorNodeFilter;
class CompositorNodeMapValue;
class CompositorNodeMapRange;
class CompositorNodeTime;
class CompositorNodeVecBlur;
class CompositorNodeSepRGBA;
class CompositorNodeSepHSVA;
class CompositorNodeSetAlpha;
class CompositorNodeHueSat;
class CompositorNodeImage;
class CompositorNodeRLayers;
class CompositorNodeComposite;
class CompositorNodeOutputFile;
class CompositorNodeOutputFileFileSlots;
class CompositorNodeOutputFileLayerSlots;
class CompositorNodeTexture;
class CompositorNodeTranslate;
class CompositorNodeZcombine;
class CompositorNodeCombRGBA;
class CompositorNodeDilateErode;
class CompositorNodeInpaint;
class CompositorNodeDespeckle;
class CompositorNodeRotate;
class CompositorNodeScale;
class CompositorNodeSepYCCA;
class CompositorNodeCombYCCA;
class CompositorNodeSepYUVA;
class CompositorNodeCombYUVA;
class CompositorNodeDiffMatte;
class CompositorNodeColorSpill;
class CompositorNodeChromaMatte;
class CompositorNodeChannelMatte;
class CompositorNodeFlip;
class CompositorNodeSplitViewer;
class CompositorNodeMapUV;
class CompositorNodeIDMask;
class CompositorNodeDoubleEdgeMask;
class CompositorNodeDefocus;
class CompositorNodeDisplace;
class CompositorNodeCombHSVA;
class CompositorNodeMath;
class CompositorNodeLumaMatte;
class CompositorNodeBrightContrast;
class CompositorNodeGamma;
class CompositorNodeInvert;
class CompositorNodeNormalize;
class CompositorNodeCrop;
class CompositorNodeDBlur;
class CompositorNodeBilateralblur;
class CompositorNodePremulKey;
class CompositorNodeGlare;
class CompositorNodeTonemap;
class CompositorNodeLensdist;
class CompositorNodeLevels;
class CompositorNodeColorMatte;
class CompositorNodeDistanceMatte;
class CompositorNodeColorBalance;
class CompositorNodeHueCorrect;
class CompositorNodeMovieClip;
class CompositorNodeTransform;
class CompositorNodeStabilize;
class CompositorNodeMovieDistortion;
class CompositorNodeBoxMask;
class CompositorNodeEllipseMask;
class CompositorNodeBokehImage;
class CompositorNodeBokehBlur;
class CompositorNodeSwitch;
class CompositorNodeSwitchView;
class CompositorNodeColorCorrection;
class CompositorNodeMask;
class CompositorNodeKeyingScreen;
class CompositorNodeKeying;
class CompositorNodeTrackPos;
class CompositorNodePixelate;
class CompositorNodePlaneTrackDeform;
class CompositorNodeCornerPin;
class CompositorNodeSunBeams;
class TextureNodeOutput;
class TextureNodeChecker;
class TextureNodeTexture;
class TextureNodeBricks;
class TextureNodeMath;
class TextureNodeMixRGB;
class TextureNodeRGBToBW;
class TextureNodeValToRGB;
class TextureNodeImage;
class TextureNodeCurveRGB;
class TextureNodeInvert;
class TextureNodeHueSaturation;
class TextureNodeCurveTime;
class TextureNodeRotate;
class TextureNodeViewer;
class TextureNodeTranslate;
class TextureNodeCoordinates;
class TextureNodeDistance;
class TextureNodeCompose;
class TextureNodeDecompose;
class TextureNodeValToNor;
class TextureNodeScale;
class TextureNodeAt;
class TextureNodeTexVoronoi;
class TextureNodeTexBlend;
class TextureNodeTexMagic;
class TextureNodeTexMarble;
class TextureNodeTexClouds;
class TextureNodeTexWood;
class TextureNodeTexMusgrave;
class TextureNodeTexNoise;
class TextureNodeTexStucci;
class TextureNodeTexDistNoise;
class ShaderNodeGroup;
class CompositorNodeGroup;
class TextureNodeGroup;
class NodeCustomGroup;
class NodeOutputFileSlotFile;
class NodeOutputFileSlotLayer;
class NodeInstanceHash;
class Object;
class ObjectModifiers;
class ObjectConstraints;
class VertexGroups;
class ParticleSystems;
class GameObjectSettings;
class ObjectBase;
class VertexGroup;
class MaterialSlot;
class DupliObject;
class LodLevel;
class PointCache;
class PointCaches;
class CollisionSettings;
class EffectorWeights;
class FieldSettings;
class GameSoftBodySettings;
class SoftBodySettings;
class PackedFile;
class PaletteColor;
class Palette;
class PaletteColors;
class ParticleTarget;
class SPHFluidSettings;
class ParticleHairKey;
class ParticleKey;
class ChildParticle;
class Particle;
class ParticleDupliWeight;
class ParticleSystem;
class ParticleSettingsTextureSlot;
class ParticleSettings;
class ParticleSettingsTextureSlots;
class Pose;
class BoneGroups;
class PoseBone;
class PoseBoneConstraints;
class IKParam;
class Itasc;
class BoneGroup;
class GameProperty;
class GameBooleanProperty;
class GameIntProperty;
class GameFloatProperty;
class GameTimerProperty;
class GameStringProperty;
class RenderEngine;
class RenderResult;
class RenderView;
class RenderLayer;
class RenderPasses;
class RenderPass;
class BakePixel;
class RigidBodyWorld;
class RigidBodyObject;
class RigidBodyConstraint;
class Scene;
class SceneBases;
class SceneObjects;
class KeyingSets;
class KeyingSetsAll;
class TimelineMarkers;
class ToolSettings;
class UnifiedPaintSettings;
class MeshStatVis;
class UnitSettings;
class Stereo3dFormat;
class ImageFormatSettings;
class SceneGameData;
class SceneGameRecastData;
class TransformOrientation;
class SelectedUvElement;
class DisplaySafeAreas;
class FFmpegSettings;
class RenderSettings;
class RenderLayers;
class RenderViews;
class BakeSettings;
class SceneRenderLayer;
class FreestyleLineSet;
class FreestyleModuleSettings;
class FreestyleSettings;
class FreestyleModules;
class Linesets;
class GPUSSAOSettings;
class GPUDOFSettings;
class GPUFXSettings;
class SceneRenderView;
class Screen;
class Area;
class AreaSpaces;
class Region;
class View2D;
class PaintCurve;
class Paint;
class Sculpt;
class UvSculpt;
class VertexPaint;
class ImagePaint;
class ParticleEdit;
class ParticleBrush;
class Sensor;
class AlwaysSensor;
class NearSensor;
class MouseSensor;
class KeyboardSensor;
class PropertySensor;
class ArmatureSensor;
class ActuatorSensor;
class DelaySensor;
class CollisionSensor;
class RadarSensor;
class RandomSensor;
class RaySensor;
class MessageSensor;
class JoystickSensor;
class SequenceColorBalanceData;
class SequenceElement;
class SequenceProxy;
class SequenceColorBalance;
class SequenceCrop;
class SequenceTransform;
class Sequence;
class SequenceModifiers;
class SequenceEditor;
class Sequences;
class ImageSequence;
class SequenceElements;
class MetaSequence;
class SceneSequence;
class MovieSequence;
class MovieClipSequence;
class MaskSequence;
class SoundSequence;
class EffectSequence;
class AddSequence;
class AdjustmentSequence;
class AlphaOverSequence;
class AlphaUnderSequence;
class ColorSequence;
class CrossSequence;
class GammaCrossSequence;
class GlowSequence;
class MulticamSequence;
class MultiplySequence;
class OverDropSequence;
class SpeedControlSequence;
class SubtractSequence;
class TransformSequence;
class WipeSequence;
class GaussianBlurSequence;
class SequenceModifier;
class ColorBalanceModifier;
class CurvesModifier;
class HueCorrectModifier;
class BrightContrastModifier;
class SmokeDomainSettings;
class SmokeFlowSettings;
class SmokeCollSettings;
class Space;
class SpaceImageEditor;
class SpaceUVEditor;
class SpaceSequenceEditor;
class SpaceTextEditor;
class FileSelectParams;
class FileBrowserFSMenuEntry;
class SpaceFileBrowser;
class SpaceOutliner;
class BackgroundImage;
class SpaceView3D;
class BackgroundImages;
class RegionView3D;
class SpaceProperties;
class SpaceDopeSheetEditor;
class SpaceGraphEditor;
class SpaceNLA;
class SpaceTimeline;
class SpaceConsole;
class ConsoleLine;
class SpaceInfo;
class SpaceUserPreferences;
class NodeTreePath;
class SpaceNodeEditor;
class SpaceNodeEditorPath;
class SpaceLogicEditor;
class SpaceClipEditor;
class Speaker;
class TextLine;
class Text;
class TimelineMarker;
class Sound;
class UILayout;
class Panel;
class UIList;
class Header;
class Menu;
class ThemeFontStyle;
class ThemeStyle;
class ThemeWidgetColors;
class ThemeWidgetStateColors;
class ThemePanelColors;
class ThemeGradientColors;
class ThemeUserInterface;
class ThemeSpaceGeneric;
class ThemeSpaceGradient;
class ThemeSpaceListGeneric;
class ThemeView3D;
class ThemeGraphEditor;
class ThemeFileBrowser;
class ThemeNLAEditor;
class ThemeDopeSheet;
class ThemeImageEditor;
class ThemeSequenceEditor;
class ThemeProperties;
class ThemeTextEditor;
class ThemeTimeline;
class ThemeNodeEditor;
class ThemeOutliner;
class ThemeInfo;
class ThemeUserPreferences;
class ThemeConsole;
class ThemeLogicEditor;
class ThemeClipEditor;
class ThemeBoneColorSet;
class Theme;
class UserSolidLight;
class WalkNavigation;
class UserPreferences;
class Addons;
class PathCompareCollection;
class UserPreferencesView;
class UserPreferencesEdit;
class UserPreferencesInput;
class UserPreferencesFilePaths;
class UserPreferencesSystem;
class Addon;
class AddonPreferences;
class PathCompare;
class VectorFont;
class Operator;
class OperatorProperties;
class OperatorOptions;
class OperatorMousePath;
class OperatorFileListElement;
class Macro;
class OperatorMacro;
class Event;
class Timer;
class UIPopupMenu;
class UIPieMenu;
class Window;
class Stereo3dDisplay;
class WindowManager;
class KeyConfigurations;
class KeyConfig;
class KeyMaps;
class KeyMap;
class KeyMapItems;
class KeyMapItem;
class World;
class WorldTextureSlots;
class WorldLighting;
class WorldMistSettings;
class WorldTextureSlot;
class MovieClip;
class MovieClipProxy;
class MovieClipUser;
class MovieClipScopes;
class MovieTrackingSettings;
class MovieTrackingCamera;
class MovieTrackingMarker;
class MovieTrackingTrack;
class MovieTrackingMarkers;
class MovieTrackingPlaneMarker;
class MovieTrackingPlaneTrack;
class MovieTrackingPlaneMarkers;
class MovieTrackingTracks;
class MovieTrackingPlaneTracks;
class MovieTrackingObjectTracks;
class MovieTrackingObjectPlaneTracks;
class MovieTrackingStabilization;
class MovieTrackingReconstructedCameras;
class MovieReconstructedCamera;
class MovieTrackingReconstruction;
class MovieTrackingObject;
class MovieTrackingDopesheet;
class MovieTracking;
class MovieTrackingObjects;
class MaskParent;
class MaskSplinePointUW;
class MaskSplinePoint;
class MaskSpline;
class MaskSplines;
class MaskSplinePoints;
class MaskLayer;
class Mask;
class MaskLayers;

/**************** pyUniplug Definition ****************/

class pyUniplug {
protected:
	PyObject* pyobjref;
public:
	pyUniplug(PyObject* pyobj)
	{
		pyobjref = pyobj;
	}

	pyUniplug()
	{
		pyobjref = PyImport_ImportModule("bpy");
	}

	Context context();
};

/**************** Struct Definition ****************/

/**
 * RNA structure definition
 */
class Struct : public pyUniplug {
public:
	Struct(PyObject* pyobj) : pyUniplug(pyobj) {}

	Struct() : pyUniplug(0)
	{
		// not implemented
	}

	/** Getter: Human readable name */
	std::string name() { /* not implemented */ throw NULL; }
	/** Setter: Human readable name */
	void name(const std::string& value) { /* not implemented */ }

	/** Getter: Unique name used in the code and scripting */
	std::string identifier() { /* not implemented */ throw NULL; }
	/** Setter: Unique name used in the code and scripting */
	void identifier(const std::string& value) { /* not implemented */ }

	/** Getter: Description of the Struct's purpose */
	std::string description() { /* not implemented */ throw NULL; }
	/** Setter: Description of the Struct's purpose */
	void description(const std::string& value) { /* not implemented */ }

	/** Getter: Translation context of the struct's name */
	std::string translation_context() { /* not implemented */ throw NULL; }
	/** Setter: Translation context of the struct's name */
	void translation_context(const std::string& value) { /* not implemented */ }

	/** Getter: Struct definition this is derived from */
	Struct base_value() {
		/* not implemented */ throw NULL;
	}

	/** Getter: Struct in which this struct is always nested, and to which it logically belongs */
	Struct nested() {
		/* not implemented */ throw NULL;
	}

	/** Getter: Property that gives the name of the struct */
	StringProperty name_property();

	/** Getter: Properties in the struct */
	std::map<std::string, Property> properties();
	/** Setter: Properties in the struct */
	void properties(std::map<std::string, Property> value);

	/** Getter:  */
	std::map<std::string, Function> functions();
	/** Setter:  */
	void functions(std::map<std::string, Function> value);

};

/**************** Property Definition ****************/

/**
 * RNA property definition
 */
class Property : public pyUniplug {
public:
	Property(PyObject* pyobj) : pyUniplug(pyobj) {}

	Property() : pyUniplug(0)
	{
		// not implemented
	}

	/** Getter: Human readable name */
	std::string name() { /* not implemented */ throw NULL; }
	/** Setter: Human readable name */
	void name(const std::string& value) { /* not implemented */ }

	/** Getter: Unique name used in the code and scripting */
	std::string identifier() { /* not implemented */ throw NULL; }
	/** Setter: Unique name used in the code and scripting */
	void identifier(const std::string& value) { /* not implemented */ }

	/** Getter: Description of the property for tooltips */
	std::string description() { /* not implemented */ throw NULL; }
	/** Setter: Description of the property for tooltips */
	void description(const std::string& value) { /* not implemented */ }

	/** Getter: Translation context of the property's name */
	std::string translation_context() { /* not implemented */ throw NULL; }
	/** Setter: Translation context of the property's name */
	void translation_context(const std::string& value) { /* not implemented */ }

	enum type_enum {
		type_BOOLEAN = 0,
		type_INT = 1,
		type_FLOAT = 2,
		type_STRING = 3,
		type_ENUM = 4,
		type_POINTER = 5,
		type_COLLECTION = 6,
	};

	/** Getter: Data type of the property */
	type_enum type() { /* not implemented */ throw NULL; }
	/** Setter: Data type of the property */
	void type(type_enum value) { /* not implemented */ }

	enum subtype_enum {
		subtype_NONE = 0,
		subtype_FILE_PATH = 1,
		subtype_DIR_PATH = 2,
		subtype_PIXEL = 12,
		subtype_UNSIGNED = 13,
		subtype_PERCENTAGE = 14,
		subtype_FACTOR = 15,
		subtype_ANGLE = 327696,
		subtype_TIME = 393233,
		subtype_DISTANCE = 65554,
		subtype_COLOR = 20,
		subtype_TRANSLATION = 65557,
		subtype_DIRECTION = 22,
		subtype_MATRIX = 25,
		subtype_EULER = 327706,
		subtype_QUATERNION = 27,
		subtype_XYZ = 29,
		subtype_COLOR_GAMMA = 30,
		subtype_COORDINATES = 31,
		subtype_LAYER = 40,
		subtype_LAYER_MEMBERSHIP = 41,
	};

	/** Getter: Semantic interpretation of the property */
	subtype_enum subtype() { /* not implemented */ throw NULL; }
	/** Setter: Semantic interpretation of the property */
	void subtype(subtype_enum value) { /* not implemented */ }

	/** Getter: Struct definition used for properties assigned to this item */
	Struct srna() {
		/* not implemented */ throw NULL;
	}

	enum unit_enum {
		unit_NONE = 0,
		unit_LENGTH = 65536,
		unit_AREA = 131072,
		unit_VOLUME = 196608,
		unit_ROTATION = 327680,
		unit_TIME = 393216,
		unit_VELOCITY = 458752,
		unit_ACCELERATION = 524288,
		unit_CAMERA = 589824,
	};

	/** Getter: Type of units for this property */
	unit_enum unit() { /* not implemented */ throw NULL; }
	/** Setter: Type of units for this property */
	void unit(unit_enum value) { /* not implemented */ }

	enum icon_enum {
		icon_NONE = 0,
		icon_QUESTION = 1,
		icon_ERROR = 2,
		icon_CANCEL = 3,
		icon_TRIA_RIGHT = 4,
		icon_TRIA_DOWN = 5,
		icon_TRIA_LEFT = 6,
		icon_TRIA_UP = 7,
		icon_ARROW_LEFTRIGHT = 8,
		icon_PLUS = 9,
		icon_DISCLOSURE_TRI_DOWN = 10,
		icon_DISCLOSURE_TRI_RIGHT = 11,
		icon_RADIOBUT_OFF = 12,
		icon_RADIOBUT_ON = 13,
		icon_MENU_PANEL = 14,
		icon_BLENDER = 15,
		icon_GRIP = 16,
		icon_DOT = 17,
		icon_COLLAPSEMENU = 18,
		icon_X = 19,
		icon_GO_LEFT = 21,
		icon_PLUG = 22,
		icon_UI = 23,
		icon_NODE = 24,
		icon_NODE_SEL = 25,
		icon_FULLSCREEN = 26,
		icon_SPLITSCREEN = 27,
		icon_RIGHTARROW_THIN = 28,
		icon_BORDERMOVE = 29,
		icon_VIEWZOOM = 30,
		icon_ZOOMIN = 31,
		icon_ZOOMOUT = 32,
		icon_PANEL_CLOSE = 33,
		icon_COPY_ID = 34,
		icon_EYEDROPPER = 35,
		icon_LINK_AREA = 36,
		icon_AUTO = 37,
		icon_CHECKBOX_DEHLT = 38,
		icon_CHECKBOX_HLT = 39,
		icon_UNLOCKED = 40,
		icon_LOCKED = 41,
		icon_UNPINNED = 42,
		icon_PINNED = 43,
		icon_SCREEN_BACK = 44,
		icon_RIGHTARROW = 45,
		icon_DOWNARROW_HLT = 46,
		icon_DOTSUP = 47,
		icon_DOTSDOWN = 48,
		icon_LINK = 49,
		icon_INLINK = 50,
		icon_PLUGIN = 51,
		icon_HELP = 52,
		icon_GHOST_ENABLED = 53,
		icon_COLOR = 54,
		icon_LINKED = 55,
		icon_UNLINKED = 56,
		icon_HAND = 57,
		icon_ZOOM_ALL = 58,
		icon_ZOOM_SELECTED = 59,
		icon_ZOOM_PREVIOUS = 60,
		icon_ZOOM_IN = 61,
		icon_ZOOM_OUT = 62,
		icon_RENDER_REGION = 63,
		icon_BORDER_RECT = 64,
		icon_BORDER_LASSO = 65,
		icon_FREEZE = 66,
		icon_STYLUS_PRESSURE = 67,
		icon_GHOST_DISABLED = 68,
		icon_NEW = 69,
		icon_FILE_TICK = 70,
		icon_QUIT = 71,
		icon_URL = 72,
		icon_RECOVER_LAST = 73,
		icon_FULLSCREEN_ENTER = 75,
		icon_FULLSCREEN_EXIT = 76,
		icon_BLANK1 = 77,
		icon_LAMP = 78,
		icon_MATERIAL = 79,
		icon_TEXTURE = 80,
		icon_ANIM = 81,
		icon_WORLD = 82,
		icon_SCENE = 83,
		icon_EDIT = 84,
		icon_GAME = 85,
		icon_RADIO = 86,
		icon_SCRIPT = 87,
		icon_PARTICLES = 88,
		icon_PHYSICS = 89,
		icon_SPEAKER = 90,
		icon_TEXTURE_SHADED = 91,
		icon_VIEW3D = 104,
		icon_IPO = 105,
		icon_OOPS = 106,
		icon_BUTS = 107,
		icon_FILESEL = 108,
		icon_IMAGE_COL = 109,
		icon_INFO = 110,
		icon_SEQUENCE = 111,
		icon_TEXT = 112,
		icon_IMASEL = 113,
		icon_SOUND = 114,
		icon_ACTION = 115,
		icon_NLA = 116,
		icon_SCRIPTWIN = 117,
		icon_TIME = 118,
		icon_NODETREE = 119,
		icon_LOGIC = 120,
		icon_CONSOLE = 121,
		icon_PREFERENCES = 122,
		icon_CLIP = 123,
		icon_ASSET_MANAGER = 124,
		icon_OBJECT_DATAMODE = 130,
		icon_EDITMODE_HLT = 131,
		icon_FACESEL_HLT = 132,
		icon_VPAINT_HLT = 133,
		icon_TPAINT_HLT = 134,
		icon_WPAINT_HLT = 135,
		icon_SCULPTMODE_HLT = 136,
		icon_POSE_HLT = 137,
		icon_PARTICLEMODE = 138,
		icon_LIGHTPAINT = 139,
		icon_SCENE_DATA = 156,
		icon_RENDERLAYERS = 157,
		icon_WORLD_DATA = 158,
		icon_OBJECT_DATA = 159,
		icon_MESH_DATA = 160,
		icon_CURVE_DATA = 161,
		icon_META_DATA = 162,
		icon_LATTICE_DATA = 163,
		icon_LAMP_DATA = 164,
		icon_MATERIAL_DATA = 165,
		icon_TEXTURE_DATA = 166,
		icon_ANIM_DATA = 167,
		icon_CAMERA_DATA = 168,
		icon_PARTICLE_DATA = 169,
		icon_LIBRARY_DATA_DIRECT = 170,
		icon_GROUP = 171,
		icon_ARMATURE_DATA = 172,
		icon_POSE_DATA = 173,
		icon_BONE_DATA = 174,
		icon_CONSTRAINT = 175,
		icon_SHAPEKEY_DATA = 176,
		icon_CONSTRAINT_BONE = 177,
		icon_CAMERA_STEREO = 178,
		icon_PACKAGE = 179,
		icon_UGLYPACKAGE = 180,
		icon_BRUSH_DATA = 182,
		icon_IMAGE_DATA = 183,
		icon_FILE = 184,
		icon_FCURVE = 185,
		icon_FONT_DATA = 186,
		icon_RENDER_RESULT = 187,
		icon_SURFACE_DATA = 188,
		icon_EMPTY_DATA = 189,
		icon_SETTINGS = 190,
		icon_RENDER_ANIMATION = 191,
		icon_RENDER_STILL = 192,
		icon_BOIDS = 194,
		icon_STRANDS = 195,
		icon_LIBRARY_DATA_INDIRECT = 196,
		icon_GREASEPENCIL = 197,
		icon_LINE_DATA = 198,
		icon_GROUP_BONE = 200,
		icon_GROUP_VERTEX = 201,
		icon_GROUP_VCOL = 202,
		icon_GROUP_UVS = 203,
		icon_RNA = 206,
		icon_RNA_ADD = 207,
		icon_OUTLINER_OB_EMPTY = 234,
		icon_OUTLINER_OB_MESH = 235,
		icon_OUTLINER_OB_CURVE = 236,
		icon_OUTLINER_OB_LATTICE = 237,
		icon_OUTLINER_OB_META = 238,
		icon_OUTLINER_OB_LAMP = 239,
		icon_OUTLINER_OB_CAMERA = 240,
		icon_OUTLINER_OB_ARMATURE = 241,
		icon_OUTLINER_OB_FONT = 242,
		icon_OUTLINER_OB_SURFACE = 243,
		icon_OUTLINER_OB_SPEAKER = 244,
		icon_RESTRICT_VIEW_OFF = 253,
		icon_RESTRICT_VIEW_ON = 254,
		icon_RESTRICT_SELECT_OFF = 255,
		icon_RESTRICT_SELECT_ON = 256,
		icon_RESTRICT_RENDER_OFF = 257,
		icon_RESTRICT_RENDER_ON = 258,
		icon_OUTLINER_DATA_EMPTY = 260,
		icon_OUTLINER_DATA_MESH = 261,
		icon_OUTLINER_DATA_CURVE = 262,
		icon_OUTLINER_DATA_LATTICE = 263,
		icon_OUTLINER_DATA_META = 264,
		icon_OUTLINER_DATA_LAMP = 265,
		icon_OUTLINER_DATA_CAMERA = 266,
		icon_OUTLINER_DATA_ARMATURE = 267,
		icon_OUTLINER_DATA_FONT = 268,
		icon_OUTLINER_DATA_SURFACE = 269,
		icon_OUTLINER_DATA_SPEAKER = 270,
		icon_OUTLINER_DATA_POSE = 271,
		icon_MESH_PLANE = 286,
		icon_MESH_CUBE = 287,
		icon_MESH_CIRCLE = 288,
		icon_MESH_UVSPHERE = 289,
		icon_MESH_ICOSPHERE = 290,
		icon_MESH_GRID = 291,
		icon_MESH_MONKEY = 292,
		icon_MESH_CYLINDER = 293,
		icon_MESH_TORUS = 294,
		icon_MESH_CONE = 295,
		icon_LAMP_POINT = 298,
		icon_LAMP_SUN = 299,
		icon_LAMP_SPOT = 300,
		icon_LAMP_HEMI = 301,
		icon_LAMP_AREA = 302,
		icon_META_EMPTY = 305,
		icon_META_PLANE = 306,
		icon_META_CUBE = 307,
		icon_META_BALL = 308,
		icon_META_ELLIPSOID = 309,
		icon_META_CAPSULE = 310,
		icon_SURFACE_NCURVE = 312,
		icon_SURFACE_NCIRCLE = 313,
		icon_SURFACE_NSURFACE = 314,
		icon_SURFACE_NCYLINDER = 315,
		icon_SURFACE_NSPHERE = 316,
		icon_SURFACE_NTORUS = 317,
		icon_CURVE_BEZCURVE = 321,
		icon_CURVE_BEZCIRCLE = 322,
		icon_CURVE_NCURVE = 323,
		icon_CURVE_NCIRCLE = 324,
		icon_CURVE_PATH = 325,
		icon_COLOR_RED = 331,
		icon_COLOR_GREEN = 332,
		icon_COLOR_BLUE = 333,
		icon_TRIA_RIGHT_BAR = 334,
		icon_TRIA_DOWN_BAR = 335,
		icon_TRIA_LEFT_BAR = 336,
		icon_TRIA_UP_BAR = 337,
		icon_FORCE_FORCE = 338,
		icon_FORCE_WIND = 339,
		icon_FORCE_VORTEX = 340,
		icon_FORCE_MAGNETIC = 341,
		icon_FORCE_HARMONIC = 342,
		icon_FORCE_CHARGE = 343,
		icon_FORCE_LENNARDJONES = 344,
		icon_FORCE_TEXTURE = 345,
		icon_FORCE_CURVE = 346,
		icon_FORCE_BOID = 347,
		icon_FORCE_TURBULENCE = 348,
		icon_FORCE_DRAG = 349,
		icon_FORCE_SMOKEFLOW = 350,
		icon_MODIFIER = 442,
		icon_MOD_WAVE = 443,
		icon_MOD_BUILD = 444,
		icon_MOD_DECIM = 445,
		icon_MOD_MIRROR = 446,
		icon_MOD_SOFT = 447,
		icon_MOD_SUBSURF = 448,
		icon_HOOK = 449,
		icon_MOD_PHYSICS = 450,
		icon_MOD_PARTICLES = 451,
		icon_MOD_BOOLEAN = 452,
		icon_MOD_EDGESPLIT = 453,
		icon_MOD_ARRAY = 454,
		icon_MOD_UVPROJECT = 455,
		icon_MOD_DISPLACE = 456,
		icon_MOD_CURVE = 457,
		icon_MOD_LATTICE = 458,
		icon_CONSTRAINT_DATA = 459,
		icon_MOD_ARMATURE = 460,
		icon_MOD_SHRINKWRAP = 461,
		icon_MOD_CAST = 462,
		icon_MOD_MESHDEFORM = 463,
		icon_MOD_BEVEL = 464,
		icon_MOD_SMOOTH = 465,
		icon_MOD_SIMPLEDEFORM = 466,
		icon_MOD_MASK = 467,
		icon_MOD_CLOTH = 468,
		icon_MOD_EXPLODE = 469,
		icon_MOD_FLUIDSIM = 470,
		icon_MOD_MULTIRES = 471,
		icon_MOD_SMOKE = 472,
		icon_MOD_SOLIDIFY = 473,
		icon_MOD_SCREW = 474,
		icon_MOD_VERTEX_WEIGHT = 475,
		icon_MOD_DYNAMICPAINT = 476,
		icon_MOD_REMESH = 477,
		icon_MOD_OCEAN = 478,
		icon_MOD_WARP = 479,
		icon_MOD_SKIN = 480,
		icon_MOD_TRIANGULATE = 481,
		icon_MOD_WIREFRAME = 482,
		icon_MOD_DATA_TRANSFER = 483,
		icon_MOD_NORMALEDIT = 484,
		icon_REC = 494,
		icon_PLAY = 495,
		icon_FF = 496,
		icon_REW = 497,
		icon_PAUSE = 498,
		icon_PREV_KEYFRAME = 499,
		icon_NEXT_KEYFRAME = 500,
		icon_PLAY_AUDIO = 501,
		icon_PLAY_REVERSE = 502,
		icon_PREVIEW_RANGE = 503,
		icon_ACTION_TWEAK = 504,
		icon_PMARKER_ACT = 505,
		icon_PMARKER_SEL = 506,
		icon_PMARKER = 507,
		icon_MARKER_HLT = 508,
		icon_MARKER = 509,
		icon_SPACE2 = 510,
		icon_SPACE3 = 511,
		icon_KEYINGSET = 512,
		icon_KEY_DEHLT = 513,
		icon_KEY_HLT = 514,
		icon_MUTE_IPO_OFF = 515,
		icon_MUTE_IPO_ON = 516,
		icon_VISIBLE_IPO_OFF = 517,
		icon_VISIBLE_IPO_ON = 518,
		icon_DRIVER = 519,
		icon_SOLO_OFF = 520,
		icon_SOLO_ON = 521,
		icon_FRAME_PREV = 522,
		icon_FRAME_NEXT = 523,
		icon_NLA_PUSHDOWN = 524,
		icon_IPO_CONSTANT = 525,
		icon_IPO_LINEAR = 526,
		icon_IPO_BEZIER = 527,
		icon_IPO_SINE = 528,
		icon_IPO_QUAD = 529,
		icon_IPO_CUBIC = 530,
		icon_IPO_QUART = 531,
		icon_IPO_QUINT = 532,
		icon_IPO_EXPO = 533,
		icon_IPO_CIRC = 534,
		icon_IPO_BOUNCE = 535,
		icon_IPO_ELASTIC = 536,
		icon_IPO_BACK = 537,
		icon_IPO_EASE_IN = 538,
		icon_IPO_EASE_OUT = 539,
		icon_IPO_EASE_IN_OUT = 540,
		icon_VERTEXSEL = 546,
		icon_EDGESEL = 547,
		icon_FACESEL = 548,
		icon_LOOPSEL = 549,
		icon_ROTATE = 551,
		icon_CURSOR = 552,
		icon_ROTATECOLLECTION = 553,
		icon_ROTATECENTER = 554,
		icon_ROTACTIVE = 555,
		icon_ALIGN = 556,
		icon_SMOOTHCURVE = 558,
		icon_SPHERECURVE = 559,
		icon_ROOTCURVE = 560,
		icon_SHARPCURVE = 561,
		icon_LINCURVE = 562,
		icon_NOCURVE = 563,
		icon_RNDCURVE = 564,
		icon_PROP_OFF = 565,
		icon_PROP_ON = 566,
		icon_PROP_CON = 567,
		icon_SCULPT_DYNTOPO = 568,
		icon_PARTICLE_POINT = 569,
		icon_PARTICLE_TIP = 570,
		icon_PARTICLE_PATH = 571,
		icon_MAN_TRANS = 572,
		icon_MAN_ROT = 573,
		icon_MAN_SCALE = 574,
		icon_MANIPUL = 575,
		icon_SNAP_OFF = 576,
		icon_SNAP_ON = 577,
		icon_SNAP_NORMAL = 578,
		icon_SNAP_INCREMENT = 579,
		icon_SNAP_VERTEX = 580,
		icon_SNAP_EDGE = 581,
		icon_SNAP_FACE = 582,
		icon_SNAP_VOLUME = 583,
		icon_STICKY_UVS_LOC = 585,
		icon_STICKY_UVS_DISABLE = 586,
		icon_STICKY_UVS_VERT = 587,
		icon_CLIPUV_DEHLT = 588,
		icon_CLIPUV_HLT = 589,
		icon_SNAP_PEEL_OBJECT = 590,
		icon_GRID = 591,
		icon_PASTEDOWN = 598,
		icon_COPYDOWN = 599,
		icon_PASTEFLIPUP = 600,
		icon_PASTEFLIPDOWN = 601,
		icon_SNAP_SURFACE = 606,
		icon_AUTOMERGE_ON = 607,
		icon_AUTOMERGE_OFF = 608,
		icon_RETOPO = 609,
		icon_UV_VERTEXSEL = 610,
		icon_UV_EDGESEL = 611,
		icon_UV_FACESEL = 612,
		icon_UV_ISLANDSEL = 613,
		icon_UV_SYNC_SELECT = 614,
		icon_BBOX = 624,
		icon_WIRE = 625,
		icon_SOLID = 626,
		icon_SMOOTH = 627,
		icon_POTATO = 628,
		icon_ORTHO = 630,
		icon_LOCKVIEW_OFF = 633,
		icon_LOCKVIEW_ON = 634,
		icon_AXIS_SIDE = 636,
		icon_AXIS_FRONT = 637,
		icon_AXIS_TOP = 638,
		icon_NDOF_DOM = 639,
		icon_NDOF_TURN = 640,
		icon_NDOF_FLY = 641,
		icon_NDOF_TRANS = 642,
		icon_LAYER_USED = 643,
		icon_LAYER_ACTIVE = 644,
		icon_SORTALPHA = 676,
		icon_SORTBYEXT = 677,
		icon_SORTTIME = 678,
		icon_SORTSIZE = 679,
		icon_LONGDISPLAY = 680,
		icon_SHORTDISPLAY = 681,
		icon_GHOST = 682,
		icon_IMGDISPLAY = 683,
		icon_SAVE_AS = 684,
		icon_SAVE_COPY = 685,
		icon_BOOKMARKS = 686,
		icon_FONTPREVIEW = 687,
		icon_FILTER = 688,
		icon_NEWFOLDER = 689,
		icon_OPEN_RECENT = 690,
		icon_FILE_PARENT = 691,
		icon_FILE_REFRESH = 692,
		icon_FILE_FOLDER = 693,
		icon_FILE_BLANK = 694,
		icon_FILE_BLEND = 695,
		icon_FILE_IMAGE = 696,
		icon_FILE_MOVIE = 697,
		icon_FILE_SCRIPT = 698,
		icon_FILE_SOUND = 699,
		icon_FILE_FONT = 700,
		icon_FILE_TEXT = 701,
		icon_RECOVER_AUTO = 702,
		icon_SAVE_PREFS = 703,
		icon_LINK_BLEND = 704,
		icon_APPEND_BLEND = 705,
		icon_IMPORT = 706,
		icon_EXPORT = 707,
		icon_EXTERNAL_DATA = 708,
		icon_LOAD_FACTORY = 709,
		icon_LOOP_BACK = 715,
		icon_LOOP_FORWARDS = 716,
		icon_BACK = 717,
		icon_FORWARD = 718,
		icon_FILE_HIDDEN = 725,
		icon_FILE_BACKUP = 726,
		icon_DISK_DRIVE = 727,
		icon_MATPLANE = 728,
		icon_MATSPHERE = 729,
		icon_MATCUBE = 730,
		icon_MONKEY = 731,
		icon_HAIR = 732,
		icon_ALIASED = 733,
		icon_ANTIALIASED = 734,
		icon_MAT_SPHERE_SKY = 735,
		icon_WORDWRAP_OFF = 740,
		icon_WORDWRAP_ON = 741,
		icon_SYNTAX_OFF = 742,
		icon_SYNTAX_ON = 743,
		icon_LINENUMBERS_OFF = 744,
		icon_LINENUMBERS_ON = 745,
		icon_SCRIPTPLUGINS = 746,
		icon_SEQ_SEQUENCER = 754,
		icon_SEQ_PREVIEW = 755,
		icon_SEQ_LUMA_WAVEFORM = 756,
		icon_SEQ_CHROMA_SCOPE = 757,
		icon_SEQ_HISTOGRAM = 758,
		icon_SEQ_SPLITVIEW = 759,
		icon_IMAGE_RGB = 763,
		icon_IMAGE_RGB_ALPHA = 764,
		icon_IMAGE_ALPHA = 765,
		icon_IMAGE_ZDEPTH = 766,
		icon_IMAGEFILE = 767,
		icon_BRUSH_ADD = 780,
		icon_BRUSH_BLOB = 781,
		icon_BRUSH_BLUR = 782,
		icon_BRUSH_CLAY = 783,
		icon_BRUSH_CLAY_STRIPS = 784,
		icon_BRUSH_CLONE = 785,
		icon_BRUSH_CREASE = 786,
		icon_BRUSH_DARKEN = 787,
		icon_BRUSH_FILL = 788,
		icon_BRUSH_FLATTEN = 789,
		icon_BRUSH_GRAB = 790,
		icon_BRUSH_INFLATE = 791,
		icon_BRUSH_LAYER = 792,
		icon_BRUSH_LIGHTEN = 793,
		icon_BRUSH_MASK = 794,
		icon_BRUSH_MIX = 795,
		icon_BRUSH_MULTIPLY = 796,
		icon_BRUSH_NUDGE = 797,
		icon_BRUSH_PINCH = 798,
		icon_BRUSH_SCRAPE = 799,
		icon_BRUSH_SCULPT_DRAW = 800,
		icon_BRUSH_SMEAR = 801,
		icon_BRUSH_SMOOTH = 802,
		icon_BRUSH_SNAKE_HOOK = 803,
		icon_BRUSH_SOFTEN = 804,
		icon_BRUSH_SUBTRACT = 805,
		icon_BRUSH_TEXDRAW = 806,
		icon_BRUSH_TEXFILL = 807,
		icon_BRUSH_TEXMASK = 808,
		icon_BRUSH_THUMB = 809,
		icon_BRUSH_ROTATE = 810,
		icon_BRUSH_VERTEXDRAW = 811,
		icon_MATCAP_01 = 812,
		icon_MATCAP_02 = 813,
		icon_MATCAP_03 = 814,
		icon_MATCAP_04 = 815,
		icon_MATCAP_05 = 816,
		icon_MATCAP_06 = 817,
		icon_MATCAP_07 = 818,
		icon_MATCAP_08 = 819,
		icon_MATCAP_09 = 820,
		icon_MATCAP_10 = 821,
		icon_MATCAP_11 = 822,
		icon_MATCAP_12 = 823,
		icon_MATCAP_13 = 824,
		icon_MATCAP_14 = 825,
		icon_MATCAP_15 = 826,
		icon_MATCAP_16 = 827,
		icon_MATCAP_17 = 828,
		icon_MATCAP_18 = 829,
		icon_MATCAP_19 = 830,
		icon_MATCAP_20 = 831,
		icon_MATCAP_21 = 832,
		icon_MATCAP_22 = 833,
		icon_MATCAP_23 = 834,
		icon_MATCAP_24 = 835,
		icon_VIEW3D_VEC = 836,
		icon_EDIT_VEC = 837,
		icon_EDITMODE_VEC_DEHLT = 838,
		icon_EDITMODE_VEC_HLT = 839,
		icon_DISCLOSURE_TRI_RIGHT_VEC = 840,
		icon_DISCLOSURE_TRI_DOWN_VEC = 841,
		icon_MOVE_UP_VEC = 842,
		icon_MOVE_DOWN_VEC = 843,
		icon_X_VEC = 844,
		icon_SMALL_TRI_RIGHT_VEC = 845,
	};

	/** Getter: Icon of the item */
	icon_enum icon() { /* not implemented */ throw NULL; }
	/** Setter: Icon of the item */
	void icon(icon_enum value) { /* not implemented */ }

	/** Getter: Property is editable through RNA */
	bool is_readonly() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "is_readonly")) == 1;
	}

	/** Setter: Property is editable through RNA */
	void is_readonly(bool value) {
		PyObject_SetAttrString(pyobjref, "is_readonly", Py_BuildValue("i", value));
	}

	/** Getter: Property is animatable through RNA */
	bool is_animatable() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "is_animatable")) == 1;
	}

	/** Setter: Property is animatable through RNA */
	void is_animatable(bool value) {
		PyObject_SetAttrString(pyobjref, "is_animatable", Py_BuildValue("i", value));
	}

	/** Getter: False when this property is an optional argument in an RNA function */
	bool is_required() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "is_required")) == 1;
	}

	/** Setter: False when this property is an optional argument in an RNA function */
	void is_required(bool value) {
		PyObject_SetAttrString(pyobjref, "is_required", Py_BuildValue("i", value));
	}

	/** Getter: True when the property is optional in a Python function implementing an RNA function */
	bool is_argument_optional() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "is_argument_optional")) == 1;
	}

	/** Setter: True when the property is optional in a Python function implementing an RNA function */
	void is_argument_optional(bool value) {
		PyObject_SetAttrString(pyobjref, "is_argument_optional", Py_BuildValue("i", value));
	}

	/** Getter: True when this value can't be set to None */
	bool is_never_none() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "is_never_none")) == 1;
	}

	/** Setter: True when this value can't be set to None */
	void is_never_none(bool value) {
		PyObject_SetAttrString(pyobjref, "is_never_none", Py_BuildValue("i", value));
	}

	/** Getter: True when the property is hidden */
	bool is_hidden() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "is_hidden")) == 1;
	}

	/** Setter: True when the property is hidden */
	void is_hidden(bool value) {
		PyObject_SetAttrString(pyobjref, "is_hidden", Py_BuildValue("i", value));
	}

	/** Getter: True when the property is not saved in presets */
	bool is_skip_save() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "is_skip_save")) == 1;
	}

	/** Setter: True when the property is not saved in presets */
	void is_skip_save(bool value) {
		PyObject_SetAttrString(pyobjref, "is_skip_save", Py_BuildValue("i", value));
	}

	/** Getter: True when this property is an output value from an RNA function */
	bool is_output() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "is_output")) == 1;
	}

	/** Setter: True when this property is an output value from an RNA function */
	void is_output(bool value) {
		PyObject_SetAttrString(pyobjref, "is_output", Py_BuildValue("i", value));
	}

	/** Getter: Property is registered as part of type registration */
	bool is_registered() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "is_registered")) == 1;
	}

	/** Setter: Property is registered as part of type registration */
	void is_registered(bool value) {
		PyObject_SetAttrString(pyobjref, "is_registered", Py_BuildValue("i", value));
	}

	/** Getter: Property is optionally registered as part of type registration */
	bool is_registered_optional() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "is_registered_optional")) == 1;
	}

	/** Setter: Property is optionally registered as part of type registration */
	void is_registered_optional(bool value) {
		PyObject_SetAttrString(pyobjref, "is_registered_optional", Py_BuildValue("i", value));
	}

	/** Getter: Property has been dynamically created at runtime */
	bool is_runtime() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "is_runtime")) == 1;
	}

	/** Setter: Property has been dynamically created at runtime */
	void is_runtime(bool value) {
		PyObject_SetAttrString(pyobjref, "is_runtime", Py_BuildValue("i", value));
	}

	/** Getter: True when multiple enums  */
	bool is_enum_flag() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "is_enum_flag")) == 1;
	}

	/** Setter: True when multiple enums  */
	void is_enum_flag(bool value) {
		PyObject_SetAttrString(pyobjref, "is_enum_flag", Py_BuildValue("i", value));
	}

	/** Getter: Property is editable from linked instances (changes not saved) */
	bool is_library_editable() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "is_library_editable")) == 1;
	}

	/** Setter: Property is editable from linked instances (changes not saved) */
	void is_library_editable(bool value) {
		PyObject_SetAttrString(pyobjref, "is_library_editable", Py_BuildValue("i", value));
	}

};

/**************** Boolean Definition ****************/

/**
 * RNA boolean property definition
 */
class BoolProperty : public Property {
public:
	BoolProperty(PyObject* pyobj) : Property(pyobj) {}

	BoolProperty() : Property(0)
	{
		// not implemented
	}

	/** Getter: Default value for this number */
	bool default_value() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "default")) == 1;
	}

	/** Setter: Default value for this number */
	void default_value(bool value) {
		PyObject_SetAttrString(pyobjref, "default", Py_BuildValue("i", value));
	}

	/** Getter: Default value for this array */
	std::array<bool, 3> default_array() {
		// TODO: MISSING DEREF! USE #DEFINE!
		PyObject *seqval = PyObject_GetAttrString(pyobjref, "default_array");
		std::array<bool, 3> resarr;
		for (int i = 0; i < 3; i++)
			resarr[i] = PyLong_AsLong(PySequence_GetItem(seqval, i)) == 1;
		return resarr;
	}

	/** Setter: Default value for this array */
	void default_array(bool values[3]) { /* not implemented */ }

	/** Getter: Maximum length of the array, 0 means unlimited */
	int array_length() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "array_length"));
	}

	/** Setter: Maximum length of the array, 0 means unlimited */
	void array_length(int value) {
		PyObject_SetAttrString(pyobjref, "array_length", Py_BuildValue("i", value));
	}

};

/**************** Int Definition ****************/

/**
 * RNA integer number property definition
 */
class IntProperty : public Property {
public:
	IntProperty(PyObject* pyobj) : Property(pyobj) {}

	IntProperty() : Property(0)
	{
		// not implemented
	}

	/** Getter: Default value for this number */
	int default_value() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "default"));
	}

	/** Setter: Default value for this number */
	void default_value(int value) {
		PyObject_SetAttrString(pyobjref, "default", Py_BuildValue("i", value));
	}

	/** Getter: Default value for this array */
	std::array<int, 3> default_array() {
		// TODO: MISSING DEREF! USE #DEFINE!
		PyObject *seqval = PyObject_GetAttrString(pyobjref, "default_array");
		std::array<int, 3> resarr;
		for (int i = 0; i < 3; i++)
			resarr[i] = PyLong_AsLong(PySequence_GetItem(seqval, i));
		return resarr;
	}

	/** Setter: Default value for this array */
	void default_array(int values[3]) { /* not implemented */ }

	/** Getter: Maximum length of the array, 0 means unlimited */
	int array_length() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "array_length"));
	}

	/** Setter: Maximum length of the array, 0 means unlimited */
	void array_length(int value) {
		PyObject_SetAttrString(pyobjref, "array_length", Py_BuildValue("i", value));
	}

	/** Getter: Minimum value used by buttons */
	int hard_min() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "hard_min"));
	}

	/** Setter: Minimum value used by buttons */
	void hard_min(int value) {
		PyObject_SetAttrString(pyobjref, "hard_min", Py_BuildValue("i", value));
	}

	/** Getter: Maximum value used by buttons */
	int hard_max() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "hard_max"));
	}

	/** Setter: Maximum value used by buttons */
	void hard_max(int value) {
		PyObject_SetAttrString(pyobjref, "hard_max", Py_BuildValue("i", value));
	}

	/** Getter: Minimum value used by buttons */
	int soft_min() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "soft_min"));
	}

	/** Setter: Minimum value used by buttons */
	void soft_min(int value) {
		PyObject_SetAttrString(pyobjref, "soft_min", Py_BuildValue("i", value));
	}

	/** Getter: Maximum value used by buttons */
	int soft_max() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "soft_max"));
	}

	/** Setter: Maximum value used by buttons */
	void soft_max(int value) {
		PyObject_SetAttrString(pyobjref, "soft_max", Py_BuildValue("i", value));
	}

	/** Getter: Step size used by number buttons, for floats 1/100th of the step size */
	int step() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "step"));
	}

	/** Setter: Step size used by number buttons, for floats 1/100th of the step size */
	void step(int value) {
		PyObject_SetAttrString(pyobjref, "step", Py_BuildValue("i", value));
	}

};

/**************** Float Definition ****************/

/**
 * RNA floating pointer number property definition
 */
class FloatProperty : public Property {
public:
	FloatProperty(PyObject* pyobj) : Property(pyobj) {}

	FloatProperty() : Property(0)
	{
		// not implemented
	}

	/** Getter: Default value for this number */
	float default_value() { /* not implemented */ throw NULL; }
	/** Setter: Default value for this number */
	void default_value(float value) {
		PyObject_SetAttrString(pyobjref, "default", Py_BuildValue("f", value));
	}

	/** Getter: Default value for this array */
	std::array<float, 3> default_array() {
		// TODO: MISSING DEREF! USE #DEFINE!
		PyObject *seqval = PyObject_GetAttrString(pyobjref, "default_array");
		std::array<float, 3> resarr;
		for (int i = 0; i < 3; i++)
			resarr[i] = (float)PyFloat_AsDouble(PySequence_GetItem(seqval, i));
		return resarr;
	}

	/** Setter: Default value for this array */
	void default_array(float values[3]) { /* not implemented */ }

	/** Getter: Maximum length of the array, 0 means unlimited */
	int array_length() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "array_length"));
	}

	/** Setter: Maximum length of the array, 0 means unlimited */
	void array_length(int value) {
		PyObject_SetAttrString(pyobjref, "array_length", Py_BuildValue("i", value));
	}

	/** Getter: Minimum value used by buttons */
	float hard_min() { /* not implemented */ throw NULL; }
	/** Setter: Minimum value used by buttons */
	void hard_min(float value) {
		PyObject_SetAttrString(pyobjref, "hard_min", Py_BuildValue("f", value));
	}

	/** Getter: Maximum value used by buttons */
	float hard_max() { /* not implemented */ throw NULL; }
	/** Setter: Maximum value used by buttons */
	void hard_max(float value) {
		PyObject_SetAttrString(pyobjref, "hard_max", Py_BuildValue("f", value));
	}

	/** Getter: Minimum value used by buttons */
	float soft_min() { /* not implemented */ throw NULL; }
	/** Setter: Minimum value used by buttons */
	void soft_min(float value) {
		PyObject_SetAttrString(pyobjref, "soft_min", Py_BuildValue("f", value));
	}

	/** Getter: Maximum value used by buttons */
	float soft_max() { /* not implemented */ throw NULL; }
	/** Setter: Maximum value used by buttons */
	void soft_max(float value) {
		PyObject_SetAttrString(pyobjref, "soft_max", Py_BuildValue("f", value));
	}

	/** Getter: Step size used by number buttons, for floats 1/100th of the step size */
	float step() { /* not implemented */ throw NULL; }
	/** Setter: Step size used by number buttons, for floats 1/100th of the step size */
	void step(float value) {
		PyObject_SetAttrString(pyobjref, "step", Py_BuildValue("f", value));
	}

	/** Getter: Number of digits after the dot used by buttons */
	int precision() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "precision"));
	}

	/** Setter: Number of digits after the dot used by buttons */
	void precision(int value) {
		PyObject_SetAttrString(pyobjref, "precision", Py_BuildValue("i", value));
	}

};

/**************** String Definition ****************/

/**
 * RNA text string property definition
 */
class StringProperty : public Property {
public:
	StringProperty(PyObject* pyobj) : Property(pyobj) {}

	StringProperty() : Property(0)
	{
		// not implemented
	}

	/** Getter: string default value */
	std::string default_value() { /* not implemented */ throw NULL; }
	/** Setter: string default value */
	void default_value(const std::string& value) { /* not implemented */ }

	/** Getter: Maximum length of the string, 0 means unlimited */
	int length_max() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "length_max"));
	}

	/** Setter: Maximum length of the string, 0 means unlimited */
	void length_max(int value) {
		PyObject_SetAttrString(pyobjref, "length_max", Py_BuildValue("i", value));
	}

};

/**************** Enum Definition ****************/

/**
 * RNA enumeration property definition, to choose from a number of predefined options
 */
class EnumProperty : public Property {
public:
	EnumProperty(PyObject* pyobj) : Property(pyobj) {}

	EnumProperty() : Property(0)
	{
		// not implemented
	}

	enum default_value_enum {
		default_value_DUMMY = 0,
	};

	/** Getter: Default value for this enum */
	default_value_enum default_value() { /* not implemented */ throw NULL; }
	/** Setter: Default value for this enum */
	void default_value(default_value_enum value) { /* not implemented */ }

	enum default_flag_enum {
		default_flag_DUMMY = 0,
	};

	/** Getter: Default value for this enum */
	default_flag_enum default_flag() { /* not implemented */ throw NULL; }
	/** Setter: Default value for this enum */
	void default_flag(default_flag_enum value) { /* not implemented */ }

	/** Getter: Possible values for the property */
	std::map<std::string, EnumPropertyItem> enum_items();
	/** Setter: Possible values for the property */
	void enum_items(std::map<std::string, EnumPropertyItem> value);

};

/**************** Enum Item Definition ****************/

/**
 * Definition of a choice in an RNA enum property
 */
class EnumPropertyItem : public pyUniplug {
public:
	EnumPropertyItem(PyObject* pyobj) : pyUniplug(pyobj) {}

	EnumPropertyItem() : pyUniplug(0)
	{
		// not implemented
	}

	/** Getter: Human readable name */
	std::string name() { /* not implemented */ throw NULL; }
	/** Setter: Human readable name */
	void name(const std::string& value) { /* not implemented */ }

	/** Getter: Description of the item's purpose */
	std::string description() { /* not implemented */ throw NULL; }
	/** Setter: Description of the item's purpose */
	void description(const std::string& value) { /* not implemented */ }

	/** Getter: Unique name used in the code and scripting */
	std::string identifier() { /* not implemented */ throw NULL; }
	/** Setter: Unique name used in the code and scripting */
	void identifier(const std::string& value) { /* not implemented */ }

	/** Getter: Value of the item */
	int value() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "value"));
	}

	/** Setter: Value of the item */
	void value(int value) {
		PyObject_SetAttrString(pyobjref, "value", Py_BuildValue("i", value));
	}

	enum icon_enum {
		icon_NONE = 0,
		icon_QUESTION = 1,
		icon_ERROR = 2,
		icon_CANCEL = 3,
		icon_TRIA_RIGHT = 4,
		icon_TRIA_DOWN = 5,
		icon_TRIA_LEFT = 6,
		icon_TRIA_UP = 7,
		icon_ARROW_LEFTRIGHT = 8,
		icon_PLUS = 9,
		icon_DISCLOSURE_TRI_DOWN = 10,
		icon_DISCLOSURE_TRI_RIGHT = 11,
		icon_RADIOBUT_OFF = 12,
		icon_RADIOBUT_ON = 13,
		icon_MENU_PANEL = 14,
		icon_BLENDER = 15,
		icon_GRIP = 16,
		icon_DOT = 17,
		icon_COLLAPSEMENU = 18,
		icon_X = 19,
		icon_GO_LEFT = 21,
		icon_PLUG = 22,
		icon_UI = 23,
		icon_NODE = 24,
		icon_NODE_SEL = 25,
		icon_FULLSCREEN = 26,
		icon_SPLITSCREEN = 27,
		icon_RIGHTARROW_THIN = 28,
		icon_BORDERMOVE = 29,
		icon_VIEWZOOM = 30,
		icon_ZOOMIN = 31,
		icon_ZOOMOUT = 32,
		icon_PANEL_CLOSE = 33,
		icon_COPY_ID = 34,
		icon_EYEDROPPER = 35,
		icon_LINK_AREA = 36,
		icon_AUTO = 37,
		icon_CHECKBOX_DEHLT = 38,
		icon_CHECKBOX_HLT = 39,
		icon_UNLOCKED = 40,
		icon_LOCKED = 41,
		icon_UNPINNED = 42,
		icon_PINNED = 43,
		icon_SCREEN_BACK = 44,
		icon_RIGHTARROW = 45,
		icon_DOWNARROW_HLT = 46,
		icon_DOTSUP = 47,
		icon_DOTSDOWN = 48,
		icon_LINK = 49,
		icon_INLINK = 50,
		icon_PLUGIN = 51,
		icon_HELP = 52,
		icon_GHOST_ENABLED = 53,
		icon_COLOR = 54,
		icon_LINKED = 55,
		icon_UNLINKED = 56,
		icon_HAND = 57,
		icon_ZOOM_ALL = 58,
		icon_ZOOM_SELECTED = 59,
		icon_ZOOM_PREVIOUS = 60,
		icon_ZOOM_IN = 61,
		icon_ZOOM_OUT = 62,
		icon_RENDER_REGION = 63,
		icon_BORDER_RECT = 64,
		icon_BORDER_LASSO = 65,
		icon_FREEZE = 66,
		icon_STYLUS_PRESSURE = 67,
		icon_GHOST_DISABLED = 68,
		icon_NEW = 69,
		icon_FILE_TICK = 70,
		icon_QUIT = 71,
		icon_URL = 72,
		icon_RECOVER_LAST = 73,
		icon_FULLSCREEN_ENTER = 75,
		icon_FULLSCREEN_EXIT = 76,
		icon_BLANK1 = 77,
		icon_LAMP = 78,
		icon_MATERIAL = 79,
		icon_TEXTURE = 80,
		icon_ANIM = 81,
		icon_WORLD = 82,
		icon_SCENE = 83,
		icon_EDIT = 84,
		icon_GAME = 85,
		icon_RADIO = 86,
		icon_SCRIPT = 87,
		icon_PARTICLES = 88,
		icon_PHYSICS = 89,
		icon_SPEAKER = 90,
		icon_TEXTURE_SHADED = 91,
		icon_VIEW3D = 104,
		icon_IPO = 105,
		icon_OOPS = 106,
		icon_BUTS = 107,
		icon_FILESEL = 108,
		icon_IMAGE_COL = 109,
		icon_INFO = 110,
		icon_SEQUENCE = 111,
		icon_TEXT = 112,
		icon_IMASEL = 113,
		icon_SOUND = 114,
		icon_ACTION = 115,
		icon_NLA = 116,
		icon_SCRIPTWIN = 117,
		icon_TIME = 118,
		icon_NODETREE = 119,
		icon_LOGIC = 120,
		icon_CONSOLE = 121,
		icon_PREFERENCES = 122,
		icon_CLIP = 123,
		icon_ASSET_MANAGER = 124,
		icon_OBJECT_DATAMODE = 130,
		icon_EDITMODE_HLT = 131,
		icon_FACESEL_HLT = 132,
		icon_VPAINT_HLT = 133,
		icon_TPAINT_HLT = 134,
		icon_WPAINT_HLT = 135,
		icon_SCULPTMODE_HLT = 136,
		icon_POSE_HLT = 137,
		icon_PARTICLEMODE = 138,
		icon_LIGHTPAINT = 139,
		icon_SCENE_DATA = 156,
		icon_RENDERLAYERS = 157,
		icon_WORLD_DATA = 158,
		icon_OBJECT_DATA = 159,
		icon_MESH_DATA = 160,
		icon_CURVE_DATA = 161,
		icon_META_DATA = 162,
		icon_LATTICE_DATA = 163,
		icon_LAMP_DATA = 164,
		icon_MATERIAL_DATA = 165,
		icon_TEXTURE_DATA = 166,
		icon_ANIM_DATA = 167,
		icon_CAMERA_DATA = 168,
		icon_PARTICLE_DATA = 169,
		icon_LIBRARY_DATA_DIRECT = 170,
		icon_GROUP = 171,
		icon_ARMATURE_DATA = 172,
		icon_POSE_DATA = 173,
		icon_BONE_DATA = 174,
		icon_CONSTRAINT = 175,
		icon_SHAPEKEY_DATA = 176,
		icon_CONSTRAINT_BONE = 177,
		icon_CAMERA_STEREO = 178,
		icon_PACKAGE = 179,
		icon_UGLYPACKAGE = 180,
		icon_BRUSH_DATA = 182,
		icon_IMAGE_DATA = 183,
		icon_FILE = 184,
		icon_FCURVE = 185,
		icon_FONT_DATA = 186,
		icon_RENDER_RESULT = 187,
		icon_SURFACE_DATA = 188,
		icon_EMPTY_DATA = 189,
		icon_SETTINGS = 190,
		icon_RENDER_ANIMATION = 191,
		icon_RENDER_STILL = 192,
		icon_BOIDS = 194,
		icon_STRANDS = 195,
		icon_LIBRARY_DATA_INDIRECT = 196,
		icon_GREASEPENCIL = 197,
		icon_LINE_DATA = 198,
		icon_GROUP_BONE = 200,
		icon_GROUP_VERTEX = 201,
		icon_GROUP_VCOL = 202,
		icon_GROUP_UVS = 203,
		icon_RNA = 206,
		icon_RNA_ADD = 207,
		icon_OUTLINER_OB_EMPTY = 234,
		icon_OUTLINER_OB_MESH = 235,
		icon_OUTLINER_OB_CURVE = 236,
		icon_OUTLINER_OB_LATTICE = 237,
		icon_OUTLINER_OB_META = 238,
		icon_OUTLINER_OB_LAMP = 239,
		icon_OUTLINER_OB_CAMERA = 240,
		icon_OUTLINER_OB_ARMATURE = 241,
		icon_OUTLINER_OB_FONT = 242,
		icon_OUTLINER_OB_SURFACE = 243,
		icon_OUTLINER_OB_SPEAKER = 244,
		icon_RESTRICT_VIEW_OFF = 253,
		icon_RESTRICT_VIEW_ON = 254,
		icon_RESTRICT_SELECT_OFF = 255,
		icon_RESTRICT_SELECT_ON = 256,
		icon_RESTRICT_RENDER_OFF = 257,
		icon_RESTRICT_RENDER_ON = 258,
		icon_OUTLINER_DATA_EMPTY = 260,
		icon_OUTLINER_DATA_MESH = 261,
		icon_OUTLINER_DATA_CURVE = 262,
		icon_OUTLINER_DATA_LATTICE = 263,
		icon_OUTLINER_DATA_META = 264,
		icon_OUTLINER_DATA_LAMP = 265,
		icon_OUTLINER_DATA_CAMERA = 266,
		icon_OUTLINER_DATA_ARMATURE = 267,
		icon_OUTLINER_DATA_FONT = 268,
		icon_OUTLINER_DATA_SURFACE = 269,
		icon_OUTLINER_DATA_SPEAKER = 270,
		icon_OUTLINER_DATA_POSE = 271,
		icon_MESH_PLANE = 286,
		icon_MESH_CUBE = 287,
		icon_MESH_CIRCLE = 288,
		icon_MESH_UVSPHERE = 289,
		icon_MESH_ICOSPHERE = 290,
		icon_MESH_GRID = 291,
		icon_MESH_MONKEY = 292,
		icon_MESH_CYLINDER = 293,
		icon_MESH_TORUS = 294,
		icon_MESH_CONE = 295,
		icon_LAMP_POINT = 298,
		icon_LAMP_SUN = 299,
		icon_LAMP_SPOT = 300,
		icon_LAMP_HEMI = 301,
		icon_LAMP_AREA = 302,
		icon_META_EMPTY = 305,
		icon_META_PLANE = 306,
		icon_META_CUBE = 307,
		icon_META_BALL = 308,
		icon_META_ELLIPSOID = 309,
		icon_META_CAPSULE = 310,
		icon_SURFACE_NCURVE = 312,
		icon_SURFACE_NCIRCLE = 313,
		icon_SURFACE_NSURFACE = 314,
		icon_SURFACE_NCYLINDER = 315,
		icon_SURFACE_NSPHERE = 316,
		icon_SURFACE_NTORUS = 317,
		icon_CURVE_BEZCURVE = 321,
		icon_CURVE_BEZCIRCLE = 322,
		icon_CURVE_NCURVE = 323,
		icon_CURVE_NCIRCLE = 324,
		icon_CURVE_PATH = 325,
		icon_COLOR_RED = 331,
		icon_COLOR_GREEN = 332,
		icon_COLOR_BLUE = 333,
		icon_TRIA_RIGHT_BAR = 334,
		icon_TRIA_DOWN_BAR = 335,
		icon_TRIA_LEFT_BAR = 336,
		icon_TRIA_UP_BAR = 337,
		icon_FORCE_FORCE = 338,
		icon_FORCE_WIND = 339,
		icon_FORCE_VORTEX = 340,
		icon_FORCE_MAGNETIC = 341,
		icon_FORCE_HARMONIC = 342,
		icon_FORCE_CHARGE = 343,
		icon_FORCE_LENNARDJONES = 344,
		icon_FORCE_TEXTURE = 345,
		icon_FORCE_CURVE = 346,
		icon_FORCE_BOID = 347,
		icon_FORCE_TURBULENCE = 348,
		icon_FORCE_DRAG = 349,
		icon_FORCE_SMOKEFLOW = 350,
		icon_MODIFIER = 442,
		icon_MOD_WAVE = 443,
		icon_MOD_BUILD = 444,
		icon_MOD_DECIM = 445,
		icon_MOD_MIRROR = 446,
		icon_MOD_SOFT = 447,
		icon_MOD_SUBSURF = 448,
		icon_HOOK = 449,
		icon_MOD_PHYSICS = 450,
		icon_MOD_PARTICLES = 451,
		icon_MOD_BOOLEAN = 452,
		icon_MOD_EDGESPLIT = 453,
		icon_MOD_ARRAY = 454,
		icon_MOD_UVPROJECT = 455,
		icon_MOD_DISPLACE = 456,
		icon_MOD_CURVE = 457,
		icon_MOD_LATTICE = 458,
		icon_CONSTRAINT_DATA = 459,
		icon_MOD_ARMATURE = 460,
		icon_MOD_SHRINKWRAP = 461,
		icon_MOD_CAST = 462,
		icon_MOD_MESHDEFORM = 463,
		icon_MOD_BEVEL = 464,
		icon_MOD_SMOOTH = 465,
		icon_MOD_SIMPLEDEFORM = 466,
		icon_MOD_MASK = 467,
		icon_MOD_CLOTH = 468,
		icon_MOD_EXPLODE = 469,
		icon_MOD_FLUIDSIM = 470,
		icon_MOD_MULTIRES = 471,
		icon_MOD_SMOKE = 472,
		icon_MOD_SOLIDIFY = 473,
		icon_MOD_SCREW = 474,
		icon_MOD_VERTEX_WEIGHT = 475,
		icon_MOD_DYNAMICPAINT = 476,
		icon_MOD_REMESH = 477,
		icon_MOD_OCEAN = 478,
		icon_MOD_WARP = 479,
		icon_MOD_SKIN = 480,
		icon_MOD_TRIANGULATE = 481,
		icon_MOD_WIREFRAME = 482,
		icon_MOD_DATA_TRANSFER = 483,
		icon_MOD_NORMALEDIT = 484,
		icon_REC = 494,
		icon_PLAY = 495,
		icon_FF = 496,
		icon_REW = 497,
		icon_PAUSE = 498,
		icon_PREV_KEYFRAME = 499,
		icon_NEXT_KEYFRAME = 500,
		icon_PLAY_AUDIO = 501,
		icon_PLAY_REVERSE = 502,
		icon_PREVIEW_RANGE = 503,
		icon_ACTION_TWEAK = 504,
		icon_PMARKER_ACT = 505,
		icon_PMARKER_SEL = 506,
		icon_PMARKER = 507,
		icon_MARKER_HLT = 508,
		icon_MARKER = 509,
		icon_SPACE2 = 510,
		icon_SPACE3 = 511,
		icon_KEYINGSET = 512,
		icon_KEY_DEHLT = 513,
		icon_KEY_HLT = 514,
		icon_MUTE_IPO_OFF = 515,
		icon_MUTE_IPO_ON = 516,
		icon_VISIBLE_IPO_OFF = 517,
		icon_VISIBLE_IPO_ON = 518,
		icon_DRIVER = 519,
		icon_SOLO_OFF = 520,
		icon_SOLO_ON = 521,
		icon_FRAME_PREV = 522,
		icon_FRAME_NEXT = 523,
		icon_NLA_PUSHDOWN = 524,
		icon_IPO_CONSTANT = 525,
		icon_IPO_LINEAR = 526,
		icon_IPO_BEZIER = 527,
		icon_IPO_SINE = 528,
		icon_IPO_QUAD = 529,
		icon_IPO_CUBIC = 530,
		icon_IPO_QUART = 531,
		icon_IPO_QUINT = 532,
		icon_IPO_EXPO = 533,
		icon_IPO_CIRC = 534,
		icon_IPO_BOUNCE = 535,
		icon_IPO_ELASTIC = 536,
		icon_IPO_BACK = 537,
		icon_IPO_EASE_IN = 538,
		icon_IPO_EASE_OUT = 539,
		icon_IPO_EASE_IN_OUT = 540,
		icon_VERTEXSEL = 546,
		icon_EDGESEL = 547,
		icon_FACESEL = 548,
		icon_LOOPSEL = 549,
		icon_ROTATE = 551,
		icon_CURSOR = 552,
		icon_ROTATECOLLECTION = 553,
		icon_ROTATECENTER = 554,
		icon_ROTACTIVE = 555,
		icon_ALIGN = 556,
		icon_SMOOTHCURVE = 558,
		icon_SPHERECURVE = 559,
		icon_ROOTCURVE = 560,
		icon_SHARPCURVE = 561,
		icon_LINCURVE = 562,
		icon_NOCURVE = 563,
		icon_RNDCURVE = 564,
		icon_PROP_OFF = 565,
		icon_PROP_ON = 566,
		icon_PROP_CON = 567,
		icon_SCULPT_DYNTOPO = 568,
		icon_PARTICLE_POINT = 569,
		icon_PARTICLE_TIP = 570,
		icon_PARTICLE_PATH = 571,
		icon_MAN_TRANS = 572,
		icon_MAN_ROT = 573,
		icon_MAN_SCALE = 574,
		icon_MANIPUL = 575,
		icon_SNAP_OFF = 576,
		icon_SNAP_ON = 577,
		icon_SNAP_NORMAL = 578,
		icon_SNAP_INCREMENT = 579,
		icon_SNAP_VERTEX = 580,
		icon_SNAP_EDGE = 581,
		icon_SNAP_FACE = 582,
		icon_SNAP_VOLUME = 583,
		icon_STICKY_UVS_LOC = 585,
		icon_STICKY_UVS_DISABLE = 586,
		icon_STICKY_UVS_VERT = 587,
		icon_CLIPUV_DEHLT = 588,
		icon_CLIPUV_HLT = 589,
		icon_SNAP_PEEL_OBJECT = 590,
		icon_GRID = 591,
		icon_PASTEDOWN = 598,
		icon_COPYDOWN = 599,
		icon_PASTEFLIPUP = 600,
		icon_PASTEFLIPDOWN = 601,
		icon_SNAP_SURFACE = 606,
		icon_AUTOMERGE_ON = 607,
		icon_AUTOMERGE_OFF = 608,
		icon_RETOPO = 609,
		icon_UV_VERTEXSEL = 610,
		icon_UV_EDGESEL = 611,
		icon_UV_FACESEL = 612,
		icon_UV_ISLANDSEL = 613,
		icon_UV_SYNC_SELECT = 614,
		icon_BBOX = 624,
		icon_WIRE = 625,
		icon_SOLID = 626,
		icon_SMOOTH = 627,
		icon_POTATO = 628,
		icon_ORTHO = 630,
		icon_LOCKVIEW_OFF = 633,
		icon_LOCKVIEW_ON = 634,
		icon_AXIS_SIDE = 636,
		icon_AXIS_FRONT = 637,
		icon_AXIS_TOP = 638,
		icon_NDOF_DOM = 639,
		icon_NDOF_TURN = 640,
		icon_NDOF_FLY = 641,
		icon_NDOF_TRANS = 642,
		icon_LAYER_USED = 643,
		icon_LAYER_ACTIVE = 644,
		icon_SORTALPHA = 676,
		icon_SORTBYEXT = 677,
		icon_SORTTIME = 678,
		icon_SORTSIZE = 679,
		icon_LONGDISPLAY = 680,
		icon_SHORTDISPLAY = 681,
		icon_GHOST = 682,
		icon_IMGDISPLAY = 683,
		icon_SAVE_AS = 684,
		icon_SAVE_COPY = 685,
		icon_BOOKMARKS = 686,
		icon_FONTPREVIEW = 687,
		icon_FILTER = 688,
		icon_NEWFOLDER = 689,
		icon_OPEN_RECENT = 690,
		icon_FILE_PARENT = 691,
		icon_FILE_REFRESH = 692,
		icon_FILE_FOLDER = 693,
		icon_FILE_BLANK = 694,
		icon_FILE_BLEND = 695,
		icon_FILE_IMAGE = 696,
		icon_FILE_MOVIE = 697,
		icon_FILE_SCRIPT = 698,
		icon_FILE_SOUND = 699,
		icon_FILE_FONT = 700,
		icon_FILE_TEXT = 701,
		icon_RECOVER_AUTO = 702,
		icon_SAVE_PREFS = 703,
		icon_LINK_BLEND = 704,
		icon_APPEND_BLEND = 705,
		icon_IMPORT = 706,
		icon_EXPORT = 707,
		icon_EXTERNAL_DATA = 708,
		icon_LOAD_FACTORY = 709,
		icon_LOOP_BACK = 715,
		icon_LOOP_FORWARDS = 716,
		icon_BACK = 717,
		icon_FORWARD = 718,
		icon_FILE_HIDDEN = 725,
		icon_FILE_BACKUP = 726,
		icon_DISK_DRIVE = 727,
		icon_MATPLANE = 728,
		icon_MATSPHERE = 729,
		icon_MATCUBE = 730,
		icon_MONKEY = 731,
		icon_HAIR = 732,
		icon_ALIASED = 733,
		icon_ANTIALIASED = 734,
		icon_MAT_SPHERE_SKY = 735,
		icon_WORDWRAP_OFF = 740,
		icon_WORDWRAP_ON = 741,
		icon_SYNTAX_OFF = 742,
		icon_SYNTAX_ON = 743,
		icon_LINENUMBERS_OFF = 744,
		icon_LINENUMBERS_ON = 745,
		icon_SCRIPTPLUGINS = 746,
		icon_SEQ_SEQUENCER = 754,
		icon_SEQ_PREVIEW = 755,
		icon_SEQ_LUMA_WAVEFORM = 756,
		icon_SEQ_CHROMA_SCOPE = 757,
		icon_SEQ_HISTOGRAM = 758,
		icon_SEQ_SPLITVIEW = 759,
		icon_IMAGE_RGB = 763,
		icon_IMAGE_RGB_ALPHA = 764,
		icon_IMAGE_ALPHA = 765,
		icon_IMAGE_ZDEPTH = 766,
		icon_IMAGEFILE = 767,
		icon_BRUSH_ADD = 780,
		icon_BRUSH_BLOB = 781,
		icon_BRUSH_BLUR = 782,
		icon_BRUSH_CLAY = 783,
		icon_BRUSH_CLAY_STRIPS = 784,
		icon_BRUSH_CLONE = 785,
		icon_BRUSH_CREASE = 786,
		icon_BRUSH_DARKEN = 787,
		icon_BRUSH_FILL = 788,
		icon_BRUSH_FLATTEN = 789,
		icon_BRUSH_GRAB = 790,
		icon_BRUSH_INFLATE = 791,
		icon_BRUSH_LAYER = 792,
		icon_BRUSH_LIGHTEN = 793,
		icon_BRUSH_MASK = 794,
		icon_BRUSH_MIX = 795,
		icon_BRUSH_MULTIPLY = 796,
		icon_BRUSH_NUDGE = 797,
		icon_BRUSH_PINCH = 798,
		icon_BRUSH_SCRAPE = 799,
		icon_BRUSH_SCULPT_DRAW = 800,
		icon_BRUSH_SMEAR = 801,
		icon_BRUSH_SMOOTH = 802,
		icon_BRUSH_SNAKE_HOOK = 803,
		icon_BRUSH_SOFTEN = 804,
		icon_BRUSH_SUBTRACT = 805,
		icon_BRUSH_TEXDRAW = 806,
		icon_BRUSH_TEXFILL = 807,
		icon_BRUSH_TEXMASK = 808,
		icon_BRUSH_THUMB = 809,
		icon_BRUSH_ROTATE = 810,
		icon_BRUSH_VERTEXDRAW = 811,
		icon_MATCAP_01 = 812,
		icon_MATCAP_02 = 813,
		icon_MATCAP_03 = 814,
		icon_MATCAP_04 = 815,
		icon_MATCAP_05 = 816,
		icon_MATCAP_06 = 817,
		icon_MATCAP_07 = 818,
		icon_MATCAP_08 = 819,
		icon_MATCAP_09 = 820,
		icon_MATCAP_10 = 821,
		icon_MATCAP_11 = 822,
		icon_MATCAP_12 = 823,
		icon_MATCAP_13 = 824,
		icon_MATCAP_14 = 825,
		icon_MATCAP_15 = 826,
		icon_MATCAP_16 = 827,
		icon_MATCAP_17 = 828,
		icon_MATCAP_18 = 829,
		icon_MATCAP_19 = 830,
		icon_MATCAP_20 = 831,
		icon_MATCAP_21 = 832,
		icon_MATCAP_22 = 833,
		icon_MATCAP_23 = 834,
		icon_MATCAP_24 = 835,
		icon_VIEW3D_VEC = 836,
		icon_EDIT_VEC = 837,
		icon_EDITMODE_VEC_DEHLT = 838,
		icon_EDITMODE_VEC_HLT = 839,
		icon_DISCLOSURE_TRI_RIGHT_VEC = 840,
		icon_DISCLOSURE_TRI_DOWN_VEC = 841,
		icon_MOVE_UP_VEC = 842,
		icon_MOVE_DOWN_VEC = 843,
		icon_X_VEC = 844,
		icon_SMALL_TRI_RIGHT_VEC = 845,
	};

	/** Getter: Icon of the item */
	icon_enum icon() { /* not implemented */ throw NULL; }
	/** Setter: Icon of the item */
	void icon(icon_enum value) { /* not implemented */ }

};

/**************** Pointer Definition ****************/

/**
 * RNA pointer property to point to another RNA struct
 */
class PointerProperty : public Property {
public:
	PointerProperty(PyObject* pyobj) : Property(pyobj) {}

	PointerProperty() : Property(0)
	{
		// not implemented
	}

	/** Getter: Fixed pointer type, empty if variable type */
	Struct fixed_type() {
		/* not implemented */ throw NULL;
	}

};

/**************** Collection Definition ****************/

/**
 * RNA collection property to define lists, arrays and mappings
 */
class CollectionProperty : public Property {
public:
	CollectionProperty(PyObject* pyobj) : Property(pyobj) {}

	CollectionProperty() : Property(0)
	{
		// not implemented
	}

	/** Getter: Fixed pointer type, empty if variable type */
	Struct fixed_type() {
		/* not implemented */ throw NULL;
	}

};

/**************** Function Definition ****************/

/**
 * RNA function definition
 */
class Function : public pyUniplug {
public:
	Function(PyObject* pyobj) : pyUniplug(pyobj) {}

	Function() : pyUniplug(0)
	{
		// not implemented
	}

	/** Getter: Unique name used in the code and scripting */
	std::string identifier() { /* not implemented */ throw NULL; }
	/** Setter: Unique name used in the code and scripting */
	void identifier(const std::string& value) { /* not implemented */ }

	/** Getter: Description of the Function's purpose */
	std::string description() { /* not implemented */ throw NULL; }
	/** Setter: Description of the Function's purpose */
	void description(const std::string& value) { /* not implemented */ }

	/** Getter: Parameters for the function */
	std::map<std::string, Property> parameters() {
		// TODO: MISSING DEREF! USE #DEFINE!
		PyObject *seqval = PyObject_GetAttrString(pyobjref, "parameters");
		PyObject *seqkeys = PyObject_CallMethod(seqval, "keys", NULL);
		std::map<std::string, Property> resmap;
		for (int i = 0; i < PySequence_Length(seqval); i++) {
			PyObject *keyobj = PySequence_GetItem(seqkeys, i);
			std::string key = PyBytes_AsString(PyUnicode_AsASCIIString(keyobj));
			Property value = Property(PySequence_GetItem(seqval, i));
			resmap.insert(std::pair<std::string,Property>(key, value));
		}
		return resmap;
	}

	/** Setter: Parameters for the function */
	void parameters(std::map<std::string, Property> value) { /* not implemented */ }

	/** Getter: Function is registered as callback as part of type registration */
	bool is_registered() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "is_registered")) == 1;
	}

	/** Setter: Function is registered as callback as part of type registration */
	void is_registered(bool value) {
		PyObject_SetAttrString(pyobjref, "is_registered", Py_BuildValue("i", value));
	}

	/** Getter: Function is optionally registered as callback part of type registration */
	bool is_registered_optional() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "is_registered_optional")) == 1;
	}

	/** Setter: Function is optionally registered as callback part of type registration */
	void is_registered_optional(bool value) {
		PyObject_SetAttrString(pyobjref, "is_registered_optional", Py_BuildValue("i", value));
	}

	/** Getter: Function does not pass its self as an argument (becomes a static method in python) */
	bool use_self() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_self")) == 1;
	}

	/** Setter: Function does not pass its self as an argument (becomes a static method in python) */
	void use_self(bool value) {
		PyObject_SetAttrString(pyobjref, "use_self", Py_BuildValue("i", value));
	}

	/** Getter: Function passes its self type as an argument (becomes a class method in python if use_self is false) */
	bool use_self_type() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_self_type")) == 1;
	}

	/** Setter: Function passes its self type as an argument (becomes a class method in python if use_self is false) */
	void use_self_type(bool value) {
		PyObject_SetAttrString(pyobjref, "use_self_type", Py_BuildValue("i", value));
	}

};

/**************** Blender RNA ****************/

/**
 * Blender RNA structure definitions
 */
class BlenderRNA : public pyUniplug {
public:
	BlenderRNA(PyObject* pyobj) : pyUniplug(pyobj) {}

	BlenderRNA() : pyUniplug(0)
	{
		// not implemented
	}

	/** Getter:  */
	std::map<std::string, Struct> structs() {
		// TODO: MISSING DEREF! USE #DEFINE!
		PyObject *seqval = PyObject_GetAttrString(pyobjref, "structs");
		PyObject *seqkeys = PyObject_CallMethod(seqval, "keys", NULL);
		std::map<std::string, Struct> resmap;
		for (int i = 0; i < PySequence_Length(seqval); i++) {
			PyObject *keyobj = PySequence_GetItem(seqkeys, i);
			std::string key = PyBytes_AsString(PyUnicode_AsASCIIString(keyobj));
			Struct value = Struct(PySequence_GetItem(seqval, i));
			resmap.insert(std::pair<std::string,Struct>(key, value));
		}
		return resmap;
	}

	/** Setter:  */
	void structs(std::map<std::string, Struct> value) { /* not implemented */ }

};

/**************** Unknown Type ****************/

/**
 * Stub RNA type used for pointers to unknown or internal data
 */
class UnknownType : public pyUniplug {
public:
	UnknownType(PyObject* pyobj) : pyUniplug(pyobj) {}

	UnknownType() : pyUniplug(0)
	{
		// not implemented
	}

};

/**************** Any Type ****************/

/**
 * RNA type used for pointers to any possible data
 */
class AnyType : public pyUniplug {
public:
	AnyType(PyObject* pyobj) : pyUniplug(pyobj) {}

	AnyType() : pyUniplug(0)
	{
		// not implemented
	}

};

/**************** ID ****************/

/**
 * Base type for datablocks, defining a unique name, linking from other libraries and garbage collection
 */
class ID : public pyUniplug {
public:
	ID(PyObject* pyobj) : pyUniplug(pyobj) {}

	ID() : pyUniplug(0)
	{
		// not implemented
	}

	/** Getter: Unique datablock ID name */
	std::string name() { /* not implemented */ throw NULL; }
	/** Setter: Unique datablock ID name */
	void name(const std::string& value) { /* not implemented */ }

	/** Getter: Number of times this datablock is referenced */
	int users() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "users"));
	}

	/** Setter: Number of times this datablock is referenced */
	void users(int value) {
		PyObject_SetAttrString(pyobjref, "users", Py_BuildValue("i", value));
	}

	/** Getter: Save this datablock even if it has no users */
	bool use_fake_user() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_fake_user")) == 1;
	}

	/** Setter: Save this datablock even if it has no users */
	void use_fake_user(bool value) {
		PyObject_SetAttrString(pyobjref, "use_fake_user", Py_BuildValue("i", value));
	}

	/** Getter: Tools can use this to tag data for their own purposes (initial state is undefined) */
	bool tag() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "tag")) == 1;
	}

	/** Setter: Tools can use this to tag data for their own purposes (initial state is undefined) */
	void tag(bool value) {
		PyObject_SetAttrString(pyobjref, "tag", Py_BuildValue("i", value));
	}

	/** Getter: Datablock is tagged for recalculation */
	bool is_updated() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "is_updated")) == 1;
	}

	/** Setter: Datablock is tagged for recalculation */
	void is_updated(bool value) {
		PyObject_SetAttrString(pyobjref, "is_updated", Py_BuildValue("i", value));
	}

	/** Getter: Datablock data is tagged for recalculation */
	bool is_updated_data() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "is_updated_data")) == 1;
	}

	/** Setter: Datablock data is tagged for recalculation */
	void is_updated_data(bool value) {
		PyObject_SetAttrString(pyobjref, "is_updated_data", Py_BuildValue("i", value));
	}

	/** Getter: Is this ID block linked indirectly */
	bool is_library_indirect() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "is_library_indirect")) == 1;
	}

	/** Setter: Is this ID block linked indirectly */
	void is_library_indirect(bool value) {
		PyObject_SetAttrString(pyobjref, "is_library_indirect", Py_BuildValue("i", value));
	}

	/** Getter: Library file the datablock is linked from */
	Library library();

	/**
	 * Create a copy of this datablock (not supported for all datablocks)
	 * @return New copy of the ID
	 */
	ID copy()
	{
		// not implemented
		return ID();
	}

	/**
	 * Clear the user count of a datablock so its not saved, on reload the data will be removed
	 */
	void user_clear()
	{
		// not implemented
	}

	/**
	 * Create animation data to this ID, note that not all ID types support this
	 * @return New animation data or NULL
	 */
	AnimData animation_data_create();

	/**
	 * Clear animation on this this ID
	 */
	void animation_data_clear()
	{
		// not implemented
	}

	/**
	 * Enum: items
	 */
	enum items {
		items_OBJECT = 1,	
		items_DATA = 2,	
		items_TIME = 4	
	};

	/**
	 * Tag the ID to update its display data, e.g. when calling :class:`bpy.types.Scene.update`
	 * @param Type of updates to perform
	 */
	void update_tag(items refresh)
	{
		// not implemented
	}

};

/**************** Image Preview ****************/

/**
 * Preview image and icon
 */
class ImagePreview : public pyUniplug {
public:
	ImagePreview(PyObject* pyobj) : pyUniplug(pyobj) {}

	ImagePreview() : pyUniplug(0)
	{
		// not implemented
	}

	/** Getter: True if this preview image has been modified by py script,and is no more auto-generated by Blender */
	bool is_image_custom() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "is_image_custom")) == 1;
	}

	/** Setter: True if this preview image has been modified by py script,and is no more auto-generated by Blender */
	void is_image_custom(bool value) {
		PyObject_SetAttrString(pyobjref, "is_image_custom", Py_BuildValue("i", value));
	}

	/** Getter: Width and height in pixels */
	std::array<int, 2> image_size() {
		// TODO: MISSING DEREF! USE #DEFINE!
		PyObject *seqval = PyObject_GetAttrString(pyobjref, "image_size");
		std::array<int, 2> resarr;
		for (int i = 0; i < 2; i++)
			resarr[i] = PyLong_AsLong(PySequence_GetItem(seqval, i));
		return resarr;
	}

	/** Setter: Width and height in pixels */
	void image_size(int values[2]) { /* not implemented */ }

	/** Getter: Image pixels, as bytes (always RGBA 32bits) */
	std::vector<int> image_pixels() {
		// TODO: MISSING DEREF! USE #DEFINE!
		PyObject *seqval = PyObject_GetAttrString(pyobjref, "image_pixels");
		std::vector<int> resvec;
		for (int i = 0; i < PySequence_Length(seqval); i++)
			resvec.push_back(PyLong_AsLong(PySequence_GetItem(seqval, i)));
		return resvec;
	}

	/** Setter: Image pixels, as bytes (always RGBA 32bits) */
	void image_pixels(int values[]) { /* not implemented */ }

	/** Getter: True if this preview icon has been modified by py script,and is no more auto-generated by Blender */
	bool is_icon_custom() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "is_icon_custom")) == 1;
	}

	/** Setter: True if this preview icon has been modified by py script,and is no more auto-generated by Blender */
	void is_icon_custom(bool value) {
		PyObject_SetAttrString(pyobjref, "is_icon_custom", Py_BuildValue("i", value));
	}

	/** Getter: Width and height in pixels */
	std::array<int, 2> icon_size() {
		// TODO: MISSING DEREF! USE #DEFINE!
		PyObject *seqval = PyObject_GetAttrString(pyobjref, "icon_size");
		std::array<int, 2> resarr;
		for (int i = 0; i < 2; i++)
			resarr[i] = PyLong_AsLong(PySequence_GetItem(seqval, i));
		return resarr;
	}

	/** Setter: Width and height in pixels */
	void icon_size(int values[2]) { /* not implemented */ }

	/** Getter: Icon pixels, as bytes (always RGBA 32bits) */
	std::vector<int> icon_pixels() {
		// TODO: MISSING DEREF! USE #DEFINE!
		PyObject *seqval = PyObject_GetAttrString(pyobjref, "icon_pixels");
		std::vector<int> resvec;
		for (int i = 0; i < PySequence_Length(seqval); i++)
			resvec.push_back(PyLong_AsLong(PySequence_GetItem(seqval, i)));
		return resvec;
	}

	/** Setter: Icon pixels, as bytes (always RGBA 32bits) */
	void icon_pixels(int values[]) { /* not implemented */ }

	/** Getter: Unique integer identifying this preview as an icon (zero means invalid) */
	int icon_id() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "icon_id"));
	}

	/** Setter: Unique integer identifying this preview as an icon (zero means invalid) */
	void icon_id(int value) {
		PyObject_SetAttrString(pyobjref, "icon_id", Py_BuildValue("i", value));
	}

	/**
	 * Reload the preview from its source path
	 */
	void reload()
	{
		// not implemented
	}

};

/**************** ID Property ****************/

/**
 * Property that stores arbitrary, user defined properties
 */
class PropertyGroupItem : public pyUniplug {
public:
	PropertyGroupItem(PyObject* pyobj) : pyUniplug(pyobj) {}

	PropertyGroupItem() : pyUniplug(0)
	{
		// not implemented
	}

	/** Getter:  */
	std::string string_value() { /* not implemented */ throw NULL; }
	/** Setter:  */
	void string_value(const std::string& value) { /* not implemented */ }

	/** Getter:  */
	int int_value() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "int"));
	}

	/** Setter:  */
	void int_value(int value) {
		PyObject_SetAttrString(pyobjref, "int", Py_BuildValue("i", value));
	}

	/** Getter:  */
	std::array<int, 1> int_array() {
		// TODO: MISSING DEREF! USE #DEFINE!
		PyObject *seqval = PyObject_GetAttrString(pyobjref, "int_array");
		std::array<int, 1> resarr;
		for (int i = 0; i < 1; i++)
			resarr[i] = PyLong_AsLong(PySequence_GetItem(seqval, i));
		return resarr;
	}

	/** Setter:  */
	void int_array(int values[1]) { /* not implemented */ }

	/** Getter:  */
	float float_value() { /* not implemented */ throw NULL; }
	/** Setter:  */
	void float_value(float value) {
		PyObject_SetAttrString(pyobjref, "float", Py_BuildValue("f", value));
	}

	/** Getter:  */
	std::array<float, 1> float_array() {
		// TODO: MISSING DEREF! USE #DEFINE!
		PyObject *seqval = PyObject_GetAttrString(pyobjref, "float_array");
		std::array<float, 1> resarr;
		for (int i = 0; i < 1; i++)
			resarr[i] = (float)PyFloat_AsDouble(PySequence_GetItem(seqval, i));
		return resarr;
	}

	/** Setter:  */
	void float_array(float values[1]) { /* not implemented */ }

	/** Getter:  */
	float double_value() { /* not implemented */ throw NULL; }
	/** Setter:  */
	void double_value(float value) {
		PyObject_SetAttrString(pyobjref, "double", Py_BuildValue("f", value));
	}

	/** Getter:  */
	std::array<float, 1> double_array() {
		// TODO: MISSING DEREF! USE #DEFINE!
		PyObject *seqval = PyObject_GetAttrString(pyobjref, "double_array");
		std::array<float, 1> resarr;
		for (int i = 0; i < 1; i++)
			resarr[i] = (float)PyFloat_AsDouble(PySequence_GetItem(seqval, i));
		return resarr;
	}

	/** Setter:  */
	void double_array(float values[1]) { /* not implemented */ }

	/** Getter:  */
	PropertyGroup group();

	/** Getter:  */
	std::map<std::string, PropertyGroup> collection();
	/** Setter:  */
	void collection(std::map<std::string, PropertyGroup> value);

	/** Getter:  */
	std::map<std::string, PropertyGroup> idp_array();
	/** Setter:  */
	void idp_array(std::map<std::string, PropertyGroup> value);

};

/**************** ID Property Group ****************/

/**
 * Group of ID properties
 */
class PropertyGroup : public pyUniplug {
public:
	PropertyGroup(PyObject* pyobj) : pyUniplug(pyobj) {}

	PropertyGroup() : pyUniplug(0)
	{
		// not implemented
	}

	/** Getter: Unique name used in the code and scripting */
	std::string name() { /* not implemented */ throw NULL; }
	/** Setter: Unique name used in the code and scripting */
	void name(const std::string& value) { /* not implemented */ }

};

/**************** Library ****************/

/**
 * External .blend file from which data is linked
 */
class Library : public ID {
public:
	Library(PyObject* pyobj) : ID(pyobj) {}

	Library() : ID(0)
	{
		// not implemented
	}

	/** Getter: Path to the library .blend file */
	std::string filepath() { /* not implemented */ throw NULL; }
	/** Setter: Path to the library .blend file */
	void filepath(const std::string& value) { /* not implemented */ }

	/** Getter:  */
	Library parent() {
		/* not implemented */ throw NULL;
	}

	/** Getter:  */
	PackedFile packed_file();

};

/**************** Texture ****************/

/**
 * Texture datablock used by materials, lamps, worlds and brushes
 */
class Texture : public ID {
public:
	Texture(PyObject* pyobj) : ID(pyobj) {}

	Texture() : ID(0)
	{
		// not implemented
	}

	enum type_enum {
		type_NONE = 0,
		type_BLEND = 5,
		type_CLOUDS = 1,
		type_DISTORTED_NOISE = 13,
		type_ENVIRONMENT_MAP = 10,
		type_IMAGE = 8,
		type_MAGIC = 4,
		type_MARBLE = 3,
		type_MUSGRAVE = 11,
		type_NOISE = 7,
		type_OCEAN = 16,
		type_POINT_DENSITY = 14,
		type_STUCCI = 6,
		type_VORONOI = 12,
		type_VOXEL_DATA = 15,
		type_WOOD = 2,
	};

	/** Getter:  */
	type_enum type() { /* not implemented */ throw NULL; }
	/** Setter:  */
	void type(type_enum value) { /* not implemented */ }

	/** Getter: Set negative texture RGB and intensity values to zero, for some uses like displacement this option can be disabled to get the full range */
	bool use_clamp() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_clamp")) == 1;
	}

	/** Setter: Set negative texture RGB and intensity values to zero, for some uses like displacement this option can be disabled to get the full range */
	void use_clamp(bool value) {
		PyObject_SetAttrString(pyobjref, "use_clamp", Py_BuildValue("i", value));
	}

	/** Getter: Toggle color ramp operations */
	bool use_color_ramp() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_color_ramp")) == 1;
	}

	/** Setter: Toggle color ramp operations */
	void use_color_ramp(bool value) {
		PyObject_SetAttrString(pyobjref, "use_color_ramp", Py_BuildValue("i", value));
	}

	/** Getter:  */
	ColorRamp color_ramp();

	/** Getter: Adjust the brightness of the texture */
	float intensity() { /* not implemented */ throw NULL; }
	/** Setter: Adjust the brightness of the texture */
	void intensity(float value) {
		PyObject_SetAttrString(pyobjref, "intensity", Py_BuildValue("f", value));
	}

	/** Getter: Adjust the contrast of the texture */
	float contrast() { /* not implemented */ throw NULL; }
	/** Setter: Adjust the contrast of the texture */
	void contrast(float value) {
		PyObject_SetAttrString(pyobjref, "contrast", Py_BuildValue("f", value));
	}

	/** Getter: Adjust the saturation of colors in the texture */
	float saturation() { /* not implemented */ throw NULL; }
	/** Setter: Adjust the saturation of colors in the texture */
	void saturation(float value) {
		PyObject_SetAttrString(pyobjref, "saturation", Py_BuildValue("f", value));
	}

	/** Getter:  */
	float factor_red() { /* not implemented */ throw NULL; }
	/** Setter:  */
	void factor_red(float value) {
		PyObject_SetAttrString(pyobjref, "factor_red", Py_BuildValue("f", value));
	}

	/** Getter:  */
	float factor_green() { /* not implemented */ throw NULL; }
	/** Setter:  */
	void factor_green(float value) {
		PyObject_SetAttrString(pyobjref, "factor_green", Py_BuildValue("f", value));
	}

	/** Getter:  */
	float factor_blue() { /* not implemented */ throw NULL; }
	/** Setter:  */
	void factor_blue(float value) {
		PyObject_SetAttrString(pyobjref, "factor_blue", Py_BuildValue("f", value));
	}

	/** Getter: Show Alpha in Preview Render */
	bool use_preview_alpha() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_preview_alpha")) == 1;
	}

	/** Setter: Show Alpha in Preview Render */
	void use_preview_alpha(bool value) {
		PyObject_SetAttrString(pyobjref, "use_preview_alpha", Py_BuildValue("i", value));
	}

	/** Getter: Make this a node-based texture */
	bool use_nodes() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_nodes")) == 1;
	}

	/** Setter: Make this a node-based texture */
	void use_nodes(bool value) {
		PyObject_SetAttrString(pyobjref, "use_nodes", Py_BuildValue("i", value));
	}

	/** Getter: Node tree for node-based textures */
	NodeTree node_tree();

	/** Getter: Animation data for this datablock */
	AnimData animation_data();

	/**
	 * Evaluate the texture at the coordinates given
	 * @param Param 'value'
	 * @return (null)
	 */
	std::array<float, 4> evaluate(float value[3])
	{
		// not implemented
		throw NULL;
	}

};

/**************** Clouds Texture ****************/

/**
 * Procedural noise texture
 */
class CloudsTexture : public Texture {
public:
	CloudsTexture(PyObject* pyobj) : Texture(pyobj) {}

	CloudsTexture() : Texture(0)
	{
		// not implemented
	}

	/** Getter: Scaling for noise input */
	float noise_scale() { /* not implemented */ throw NULL; }
	/** Setter: Scaling for noise input */
	void noise_scale(float value) {
		PyObject_SetAttrString(pyobjref, "noise_scale", Py_BuildValue("f", value));
	}

	/** Getter: Depth of the cloud calculation */
	int noise_depth() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "noise_depth"));
	}

	/** Setter: Depth of the cloud calculation */
	void noise_depth(int value) {
		PyObject_SetAttrString(pyobjref, "noise_depth", Py_BuildValue("i", value));
	}

	enum noise_basis_enum {
		noise_basis_BLENDER_ORIGINAL = 0,
		noise_basis_ORIGINAL_PERLIN = 1,
		noise_basis_IMPROVED_PERLIN = 2,
		noise_basis_VORONOI_F1 = 3,
		noise_basis_VORONOI_F2 = 4,
		noise_basis_VORONOI_F3 = 5,
		noise_basis_VORONOI_F4 = 6,
		noise_basis_VORONOI_F2_F1 = 7,
		noise_basis_VORONOI_CRACKLE = 8,
		noise_basis_CELL_NOISE = 14,
	};

	/** Getter: Noise basis used for turbulence */
	noise_basis_enum noise_basis() { /* not implemented */ throw NULL; }
	/** Setter: Noise basis used for turbulence */
	void noise_basis(noise_basis_enum value) { /* not implemented */ }

	enum noise_type_enum {
		noise_type_SOFT_NOISE = 0,
		noise_type_HARD_NOISE = 1,
	};

	/** Getter:  */
	noise_type_enum noise_type() { /* not implemented */ throw NULL; }
	/** Setter:  */
	void noise_type(noise_type_enum value) { /* not implemented */ }

	enum cloud_type_enum {
		cloud_type_GRAYSCALE = 0,
		cloud_type_COLOR = 1,
	};

	/** Getter: Determine whether Noise returns grayscale or RGB values */
	cloud_type_enum cloud_type() { /* not implemented */ throw NULL; }
	/** Setter: Determine whether Noise returns grayscale or RGB values */
	void cloud_type(cloud_type_enum value) { /* not implemented */ }

	/** Getter: Size of derivative offset used for calculating normal */
	float nabla() { /* not implemented */ throw NULL; }
	/** Setter: Size of derivative offset used for calculating normal */
	void nabla(float value) {
		PyObject_SetAttrString(pyobjref, "nabla", Py_BuildValue("f", value));
	}

};

/**************** Wood Texture ****************/

/**
 * Procedural noise texture
 */
class WoodTexture : public Texture {
public:
	WoodTexture(PyObject* pyobj) : Texture(pyobj) {}

	WoodTexture() : Texture(0)
	{
		// not implemented
	}

	/** Getter: Scaling for noise input */
	float noise_scale() { /* not implemented */ throw NULL; }
	/** Setter: Scaling for noise input */
	void noise_scale(float value) {
		PyObject_SetAttrString(pyobjref, "noise_scale", Py_BuildValue("f", value));
	}

	/** Getter: Turbulence of the bandnoise and ringnoise types */
	float turbulence() { /* not implemented */ throw NULL; }
	/** Setter: Turbulence of the bandnoise and ringnoise types */
	void turbulence(float value) {
		PyObject_SetAttrString(pyobjref, "turbulence", Py_BuildValue("f", value));
	}

	enum noise_basis_enum {
		noise_basis_BLENDER_ORIGINAL = 0,
		noise_basis_ORIGINAL_PERLIN = 1,
		noise_basis_IMPROVED_PERLIN = 2,
		noise_basis_VORONOI_F1 = 3,
		noise_basis_VORONOI_F2 = 4,
		noise_basis_VORONOI_F3 = 5,
		noise_basis_VORONOI_F4 = 6,
		noise_basis_VORONOI_F2_F1 = 7,
		noise_basis_VORONOI_CRACKLE = 8,
		noise_basis_CELL_NOISE = 14,
	};

	/** Getter: Noise basis used for turbulence */
	noise_basis_enum noise_basis() { /* not implemented */ throw NULL; }
	/** Setter: Noise basis used for turbulence */
	void noise_basis(noise_basis_enum value) { /* not implemented */ }

	enum noise_type_enum {
		noise_type_SOFT_NOISE = 0,
		noise_type_HARD_NOISE = 1,
	};

	/** Getter:  */
	noise_type_enum noise_type() { /* not implemented */ throw NULL; }
	/** Setter:  */
	void noise_type(noise_type_enum value) { /* not implemented */ }

	enum wood_type_enum {
		wood_type_BANDS = 0,
		wood_type_RINGS = 1,
		wood_type_BANDNOISE = 2,
		wood_type_RINGNOISE = 3,
	};

	/** Getter:  */
	wood_type_enum wood_type() { /* not implemented */ throw NULL; }
	/** Setter:  */
	void wood_type(wood_type_enum value) { /* not implemented */ }

	enum noise_basis_2_enum {
		noise_basis_2_SIN = 0,
		noise_basis_2_SAW = 1,
		noise_basis_2_TRI = 2,
	};

	/** Getter:  */
	noise_basis_2_enum noise_basis_2() { /* not implemented */ throw NULL; }
	/** Setter:  */
	void noise_basis_2(noise_basis_2_enum value) { /* not implemented */ }

	/** Getter: Size of derivative offset used for calculating normal */
	float nabla() { /* not implemented */ throw NULL; }
	/** Setter: Size of derivative offset used for calculating normal */
	void nabla(float value) {
		PyObject_SetAttrString(pyobjref, "nabla", Py_BuildValue("f", value));
	}

};

/**************** Marble Texture ****************/

/**
 * Procedural noise texture
 */
class MarbleTexture : public Texture {
public:
	MarbleTexture(PyObject* pyobj) : Texture(pyobj) {}

	MarbleTexture() : Texture(0)
	{
		// not implemented
	}

	/** Getter: Scaling for noise input */
	float noise_scale() { /* not implemented */ throw NULL; }
	/** Setter: Scaling for noise input */
	void noise_scale(float value) {
		PyObject_SetAttrString(pyobjref, "noise_scale", Py_BuildValue("f", value));
	}

	/** Getter: Turbulence of the bandnoise and ringnoise types */
	float turbulence() { /* not implemented */ throw NULL; }
	/** Setter: Turbulence of the bandnoise and ringnoise types */
	void turbulence(float value) {
		PyObject_SetAttrString(pyobjref, "turbulence", Py_BuildValue("f", value));
	}

	/** Getter: Depth of the cloud calculation */
	int noise_depth() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "noise_depth"));
	}

	/** Setter: Depth of the cloud calculation */
	void noise_depth(int value) {
		PyObject_SetAttrString(pyobjref, "noise_depth", Py_BuildValue("i", value));
	}

	enum noise_type_enum {
		noise_type_SOFT_NOISE = 0,
		noise_type_HARD_NOISE = 1,
	};

	/** Getter:  */
	noise_type_enum noise_type() { /* not implemented */ throw NULL; }
	/** Setter:  */
	void noise_type(noise_type_enum value) { /* not implemented */ }

	enum marble_type_enum {
		marble_type_SOFT = 0,
		marble_type_SHARP = 1,
		marble_type_SHARPER = 2,
	};

	/** Getter:  */
	marble_type_enum marble_type() { /* not implemented */ throw NULL; }
	/** Setter:  */
	void marble_type(marble_type_enum value) { /* not implemented */ }

	enum noise_basis_enum {
		noise_basis_BLENDER_ORIGINAL = 0,
		noise_basis_ORIGINAL_PERLIN = 1,
		noise_basis_IMPROVED_PERLIN = 2,
		noise_basis_VORONOI_F1 = 3,
		noise_basis_VORONOI_F2 = 4,
		noise_basis_VORONOI_F3 = 5,
		noise_basis_VORONOI_F4 = 6,
		noise_basis_VORONOI_F2_F1 = 7,
		noise_basis_VORONOI_CRACKLE = 8,
		noise_basis_CELL_NOISE = 14,
	};

	/** Getter: Noise basis used for turbulence */
	noise_basis_enum noise_basis() { /* not implemented */ throw NULL; }
	/** Setter: Noise basis used for turbulence */
	void noise_basis(noise_basis_enum value) { /* not implemented */ }

	enum noise_basis_2_enum {
		noise_basis_2_SIN = 0,
		noise_basis_2_SAW = 1,
		noise_basis_2_TRI = 2,
	};

	/** Getter:  */
	noise_basis_2_enum noise_basis_2() { /* not implemented */ throw NULL; }
	/** Setter:  */
	void noise_basis_2(noise_basis_2_enum value) { /* not implemented */ }

	/** Getter: Size of derivative offset used for calculating normal */
	float nabla() { /* not implemented */ throw NULL; }
	/** Setter: Size of derivative offset used for calculating normal */
	void nabla(float value) {
		PyObject_SetAttrString(pyobjref, "nabla", Py_BuildValue("f", value));
	}

};

/**************** Magic Texture ****************/

/**
 * Procedural noise texture
 */
class MagicTexture : public Texture {
public:
	MagicTexture(PyObject* pyobj) : Texture(pyobj) {}

	MagicTexture() : Texture(0)
	{
		// not implemented
	}

	/** Getter: Turbulence of the noise */
	float turbulence() { /* not implemented */ throw NULL; }
	/** Setter: Turbulence of the noise */
	void turbulence(float value) {
		PyObject_SetAttrString(pyobjref, "turbulence", Py_BuildValue("f", value));
	}

	/** Getter: Depth of the noise */
	int noise_depth() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "noise_depth"));
	}

	/** Setter: Depth of the noise */
	void noise_depth(int value) {
		PyObject_SetAttrString(pyobjref, "noise_depth", Py_BuildValue("i", value));
	}

};

/**************** Blend Texture ****************/

/**
 * Procedural color blending texture
 */
class BlendTexture : public Texture {
public:
	BlendTexture(PyObject* pyobj) : Texture(pyobj) {}

	BlendTexture() : Texture(0)
	{
		// not implemented
	}

	enum progression_enum {
		progression_LINEAR = 0,
		progression_QUADRATIC = 1,
		progression_EASING = 2,
		progression_DIAGONAL = 3,
		progression_SPHERICAL = 4,
		progression_QUADRATIC_SPHERE = 5,
		progression_RADIAL = 6,
	};

	/** Getter: Style of the color blending */
	progression_enum progression() { /* not implemented */ throw NULL; }
	/** Setter: Style of the color blending */
	void progression(progression_enum value) { /* not implemented */ }

	enum use_flip_axis_enum {
		use_flip_axis_HORIZONTAL = 0,
		use_flip_axis_VERTICAL = 2,
	};

	/** Getter: Flip the texture's X and Y axis */
	use_flip_axis_enum use_flip_axis() { /* not implemented */ throw NULL; }
	/** Setter: Flip the texture's X and Y axis */
	void use_flip_axis(use_flip_axis_enum value) { /* not implemented */ }

};

/**************** Stucci Texture ****************/

/**
 * Procedural noise texture
 */
class StucciTexture : public Texture {
public:
	StucciTexture(PyObject* pyobj) : Texture(pyobj) {}

	StucciTexture() : Texture(0)
	{
		// not implemented
	}

	/** Getter: Turbulence of the noise */
	float turbulence() { /* not implemented */ throw NULL; }
	/** Setter: Turbulence of the noise */
	void turbulence(float value) {
		PyObject_SetAttrString(pyobjref, "turbulence", Py_BuildValue("f", value));
	}

	enum noise_basis_enum {
		noise_basis_BLENDER_ORIGINAL = 0,
		noise_basis_ORIGINAL_PERLIN = 1,
		noise_basis_IMPROVED_PERLIN = 2,
		noise_basis_VORONOI_F1 = 3,
		noise_basis_VORONOI_F2 = 4,
		noise_basis_VORONOI_F3 = 5,
		noise_basis_VORONOI_F4 = 6,
		noise_basis_VORONOI_F2_F1 = 7,
		noise_basis_VORONOI_CRACKLE = 8,
		noise_basis_CELL_NOISE = 14,
	};

	/** Getter: Noise basis used for turbulence */
	noise_basis_enum noise_basis() { /* not implemented */ throw NULL; }
	/** Setter: Noise basis used for turbulence */
	void noise_basis(noise_basis_enum value) { /* not implemented */ }

	/** Getter: Scaling for noise input */
	float noise_scale() { /* not implemented */ throw NULL; }
	/** Setter: Scaling for noise input */
	void noise_scale(float value) {
		PyObject_SetAttrString(pyobjref, "noise_scale", Py_BuildValue("f", value));
	}

	enum noise_type_enum {
		noise_type_SOFT_NOISE = 0,
		noise_type_HARD_NOISE = 1,
	};

	/** Getter:  */
	noise_type_enum noise_type() { /* not implemented */ throw NULL; }
	/** Setter:  */
	void noise_type(noise_type_enum value) { /* not implemented */ }

	enum stucci_type_enum {
		stucci_type_PLASTIC = 0,
		stucci_type_WALL_IN = 1,
		stucci_type_WALL_OUT = 2,
	};

	/** Getter:  */
	stucci_type_enum stucci_type() { /* not implemented */ throw NULL; }
	/** Setter:  */
	void stucci_type(stucci_type_enum value) { /* not implemented */ }

};

/**************** Noise Texture ****************/

/**
 * Procedural noise texture
 */
class NoiseTexture : public Texture {
public:
	NoiseTexture(PyObject* pyobj) : Texture(pyobj) {}

	NoiseTexture() : Texture(0)
	{
		// not implemented
	}

};

/**************** Image Texture ****************/

/**
 * 
 */
class ImageTexture : public Texture {
public:
	ImageTexture(PyObject* pyobj) : Texture(pyobj) {}

	ImageTexture() : Texture(0)
	{
		// not implemented
	}

	/** Getter: Interpolate pixels using selected filter */
	bool use_interpolation() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_interpolation")) == 1;
	}

	/** Setter: Interpolate pixels using selected filter */
	void use_interpolation(bool value) {
		PyObject_SetAttrString(pyobjref, "use_interpolation", Py_BuildValue("i", value));
	}

	/** Getter: Flip the texture's X and Y axis */
	bool use_flip_axis() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_flip_axis")) == 1;
	}

	/** Setter: Flip the texture's X and Y axis */
	void use_flip_axis(bool value) {
		PyObject_SetAttrString(pyobjref, "use_flip_axis", Py_BuildValue("i", value));
	}

	/** Getter: Use the alpha channel information in the image */
	bool use_alpha() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_alpha")) == 1;
	}

	/** Setter: Use the alpha channel information in the image */
	void use_alpha(bool value) {
		PyObject_SetAttrString(pyobjref, "use_alpha", Py_BuildValue("i", value));
	}

	/** Getter: Calculate an alpha channel based on RGB values in the image */
	bool use_calculate_alpha() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_calculate_alpha")) == 1;
	}

	/** Setter: Calculate an alpha channel based on RGB values in the image */
	void use_calculate_alpha(bool value) {
		PyObject_SetAttrString(pyobjref, "use_calculate_alpha", Py_BuildValue("i", value));
	}

	/** Getter: Invert all the alpha values in the image */
	bool invert_alpha() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "invert_alpha")) == 1;
	}

	/** Setter: Invert all the alpha values in the image */
	void invert_alpha(bool value) {
		PyObject_SetAttrString(pyobjref, "invert_alpha", Py_BuildValue("i", value));
	}

	/** Getter: Use auto-generated MIP maps for the image */
	bool use_mipmap() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_mipmap")) == 1;
	}

	/** Setter: Use auto-generated MIP maps for the image */
	void use_mipmap(bool value) {
		PyObject_SetAttrString(pyobjref, "use_mipmap", Py_BuildValue("i", value));
	}

	/** Getter: Use Gauss filter to sample down MIP maps */
	bool use_mipmap_gauss() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_mipmap_gauss")) == 1;
	}

	/** Setter: Use Gauss filter to sample down MIP maps */
	void use_mipmap_gauss(bool value) {
		PyObject_SetAttrString(pyobjref, "use_mipmap_gauss", Py_BuildValue("i", value));
	}

	enum filter_type_enum {
		filter_type_BOX = 0,
		filter_type_EWA = 1,
		filter_type_FELINE = 2,
		filter_type_AREA = 3,
	};

	/** Getter: Texture filter to use for sampling image */
	filter_type_enum filter_type() { /* not implemented */ throw NULL; }
	/** Setter: Texture filter to use for sampling image */
	void filter_type(filter_type_enum value) { /* not implemented */ }

	/** Getter: Maximum number of samples (higher gives less blur at distant/oblique angles, but is also slower) */
	int filter_probes() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "filter_probes"));
	}

	/** Setter: Maximum number of samples (higher gives less blur at distant/oblique angles, but is also slower) */
	void filter_probes(int value) {
		PyObject_SetAttrString(pyobjref, "filter_probes", Py_BuildValue("i", value));
	}

	/** Getter: Maximum eccentricity (higher gives less blur at distant/oblique angles, but is also slower) */
	int filter_eccentricity() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "filter_eccentricity"));
	}

	/** Setter: Maximum eccentricity (higher gives less blur at distant/oblique angles, but is also slower) */
	void filter_eccentricity(int value) {
		PyObject_SetAttrString(pyobjref, "filter_eccentricity", Py_BuildValue("i", value));
	}

	/** Getter: Use Filter Size as a minimal filter value in pixels */
	bool use_filter_size_min() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_filter_size_min")) == 1;
	}

	/** Setter: Use Filter Size as a minimal filter value in pixels */
	void use_filter_size_min(bool value) {
		PyObject_SetAttrString(pyobjref, "use_filter_size_min", Py_BuildValue("i", value));
	}

	/** Getter: Multiply the filter size used by MIP Map and Interpolation */
	float filter_size() { /* not implemented */ throw NULL; }
	/** Setter: Multiply the filter size used by MIP Map and Interpolation */
	void filter_size(float value) {
		PyObject_SetAttrString(pyobjref, "filter_size", Py_BuildValue("f", value));
	}

	enum extension_enum {
		extension_EXTEND = 1,
		extension_CLIP = 2,
		extension_CLIP_CUBE = 4,
		extension_REPEAT = 3,
		extension_CHECKER = 5,
	};

	/** Getter: How the image is extrapolated past its original bounds */
	extension_enum extension() { /* not implemented */ throw NULL; }
	/** Setter: How the image is extrapolated past its original bounds */
	void extension(extension_enum value) { /* not implemented */ }

	/** Getter: Repetition multiplier in the X direction */
	int repeat_x() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "repeat_x"));
	}

	/** Setter: Repetition multiplier in the X direction */
	void repeat_x(int value) {
		PyObject_SetAttrString(pyobjref, "repeat_x", Py_BuildValue("i", value));
	}

	/** Getter: Repetition multiplier in the Y direction */
	int repeat_y() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "repeat_y"));
	}

	/** Setter: Repetition multiplier in the Y direction */
	void repeat_y(int value) {
		PyObject_SetAttrString(pyobjref, "repeat_y", Py_BuildValue("i", value));
	}

	/** Getter: Mirror the image repetition on the X direction */
	bool use_mirror_x() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_mirror_x")) == 1;
	}

	/** Setter: Mirror the image repetition on the X direction */
	void use_mirror_x(bool value) {
		PyObject_SetAttrString(pyobjref, "use_mirror_x", Py_BuildValue("i", value));
	}

	/** Getter: Mirror the image repetition on the Y direction */
	bool use_mirror_y() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_mirror_y")) == 1;
	}

	/** Setter: Mirror the image repetition on the Y direction */
	void use_mirror_y(bool value) {
		PyObject_SetAttrString(pyobjref, "use_mirror_y", Py_BuildValue("i", value));
	}

	/** Getter: Odd checker tiles */
	bool use_checker_odd() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_checker_odd")) == 1;
	}

	/** Setter: Odd checker tiles */
	void use_checker_odd(bool value) {
		PyObject_SetAttrString(pyobjref, "use_checker_odd", Py_BuildValue("i", value));
	}

	/** Getter: Even checker tiles */
	bool use_checker_even() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_checker_even")) == 1;
	}

	/** Setter: Even checker tiles */
	void use_checker_even(bool value) {
		PyObject_SetAttrString(pyobjref, "use_checker_even", Py_BuildValue("i", value));
	}

	/** Getter: Distance between checker tiles */
	float checker_distance() { /* not implemented */ throw NULL; }
	/** Setter: Distance between checker tiles */
	void checker_distance(float value) {
		PyObject_SetAttrString(pyobjref, "checker_distance", Py_BuildValue("f", value));
	}

	/** Getter: Minimum X value to crop the image */
	float crop_min_x() { /* not implemented */ throw NULL; }
	/** Setter: Minimum X value to crop the image */
	void crop_min_x(float value) {
		PyObject_SetAttrString(pyobjref, "crop_min_x", Py_BuildValue("f", value));
	}

	/** Getter: Minimum Y value to crop the image */
	float crop_min_y() { /* not implemented */ throw NULL; }
	/** Setter: Minimum Y value to crop the image */
	void crop_min_y(float value) {
		PyObject_SetAttrString(pyobjref, "crop_min_y", Py_BuildValue("f", value));
	}

	/** Getter: Maximum X value to crop the image */
	float crop_max_x() { /* not implemented */ throw NULL; }
	/** Setter: Maximum X value to crop the image */
	void crop_max_x(float value) {
		PyObject_SetAttrString(pyobjref, "crop_max_x", Py_BuildValue("f", value));
	}

	/** Getter: Maximum Y value to crop the image */
	float crop_max_y() { /* not implemented */ throw NULL; }
	/** Setter: Maximum Y value to crop the image */
	void crop_max_y(float value) {
		PyObject_SetAttrString(pyobjref, "crop_max_y", Py_BuildValue("f", value));
	}

	/** Getter:  */
	Image image();

	/** Getter: Parameters defining which layer, pass and frame of the image is displayed */
	ImageUser image_user();

	/** Getter: Use image RGB values for normal mapping */
	bool use_normal_map() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_normal_map")) == 1;
	}

	/** Setter: Use image RGB values for normal mapping */
	void use_normal_map(bool value) {
		PyObject_SetAttrString(pyobjref, "use_normal_map", Py_BuildValue("i", value));
	}

	/** Getter: Use red and green as derivative values */
	bool use_derivative_map() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_derivative_map")) == 1;
	}

	/** Setter: Use red and green as derivative values */
	void use_derivative_map(bool value) {
		PyObject_SetAttrString(pyobjref, "use_derivative_map", Py_BuildValue("i", value));
	}

};

/**************** Environment Map ****************/

/**
 * Environment map texture
 */
class EnvironmentMapTexture : public Texture {
public:
	EnvironmentMapTexture(PyObject* pyobj) : Texture(pyobj) {}

	EnvironmentMapTexture() : Texture(0)
	{
		// not implemented
	}

	/** Getter: Source image file to read the environment map from */
	Image image();

	/** Getter: Parameters defining which layer, pass and frame of the image is displayed */
	ImageUser image_user();

	/** Getter: Use auto-generated MIP maps for the image */
	bool use_mipmap() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_mipmap")) == 1;
	}

	/** Setter: Use auto-generated MIP maps for the image */
	void use_mipmap(bool value) {
		PyObject_SetAttrString(pyobjref, "use_mipmap", Py_BuildValue("i", value));
	}

	/** Getter: Use Gauss filter to sample down MIP maps */
	bool use_mipmap_gauss() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_mipmap_gauss")) == 1;
	}

	/** Setter: Use Gauss filter to sample down MIP maps */
	void use_mipmap_gauss(bool value) {
		PyObject_SetAttrString(pyobjref, "use_mipmap_gauss", Py_BuildValue("i", value));
	}

	enum filter_type_enum {
		filter_type_BOX = 0,
		filter_type_EWA = 1,
		filter_type_FELINE = 2,
		filter_type_AREA = 3,
	};

	/** Getter: Texture filter to use for sampling image */
	filter_type_enum filter_type() { /* not implemented */ throw NULL; }
	/** Setter: Texture filter to use for sampling image */
	void filter_type(filter_type_enum value) { /* not implemented */ }

	/** Getter: Maximum number of samples (higher gives less blur at distant/oblique angles, but is also slower) */
	int filter_probes() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "filter_probes"));
	}

	/** Setter: Maximum number of samples (higher gives less blur at distant/oblique angles, but is also slower) */
	void filter_probes(int value) {
		PyObject_SetAttrString(pyobjref, "filter_probes", Py_BuildValue("i", value));
	}

	/** Getter: Maximum eccentricity (higher gives less blur at distant/oblique angles, but is also slower) */
	int filter_eccentricity() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "filter_eccentricity"));
	}

	/** Setter: Maximum eccentricity (higher gives less blur at distant/oblique angles, but is also slower) */
	void filter_eccentricity(int value) {
		PyObject_SetAttrString(pyobjref, "filter_eccentricity", Py_BuildValue("i", value));
	}

	/** Getter: Use Filter Size as a minimal filter value in pixels */
	bool use_filter_size_min() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_filter_size_min")) == 1;
	}

	/** Setter: Use Filter Size as a minimal filter value in pixels */
	void use_filter_size_min(bool value) {
		PyObject_SetAttrString(pyobjref, "use_filter_size_min", Py_BuildValue("i", value));
	}

	/** Getter: Multiply the filter size used by MIP Map and Interpolation */
	float filter_size() { /* not implemented */ throw NULL; }
	/** Setter: Multiply the filter size used by MIP Map and Interpolation */
	void filter_size(float value) {
		PyObject_SetAttrString(pyobjref, "filter_size", Py_BuildValue("f", value));
	}

	/** Getter: Get the environment map associated with this texture */
	EnvironmentMap environment_map();

};

/**************** Musgrave ****************/

/**
 * Procedural musgrave texture
 */
class MusgraveTexture : public Texture {
public:
	MusgraveTexture(PyObject* pyobj) : Texture(pyobj) {}

	MusgraveTexture() : Texture(0)
	{
		// not implemented
	}

	enum musgrave_type_enum {
		musgrave_type_MULTIFRACTAL = 0,
		musgrave_type_RIDGED_MULTIFRACTAL = 1,
		musgrave_type_HYBRID_MULTIFRACTAL = 2,
		musgrave_type_FBM = 3,
		musgrave_type_HETERO_TERRAIN = 4,
	};

	/** Getter: Fractal noise algorithm */
	musgrave_type_enum musgrave_type() { /* not implemented */ throw NULL; }
	/** Setter: Fractal noise algorithm */
	void musgrave_type(musgrave_type_enum value) { /* not implemented */ }

	/** Getter: Highest fractal dimension */
	float dimension_max() { /* not implemented */ throw NULL; }
	/** Setter: Highest fractal dimension */
	void dimension_max(float value) {
		PyObject_SetAttrString(pyobjref, "dimension_max", Py_BuildValue("f", value));
	}

	/** Getter: Gap between successive frequencies */
	float lacunarity() { /* not implemented */ throw NULL; }
	/** Setter: Gap between successive frequencies */
	void lacunarity(float value) {
		PyObject_SetAttrString(pyobjref, "lacunarity", Py_BuildValue("f", value));
	}

	/** Getter: Number of frequencies used */
	float octaves() { /* not implemented */ throw NULL; }
	/** Setter: Number of frequencies used */
	void octaves(float value) {
		PyObject_SetAttrString(pyobjref, "octaves", Py_BuildValue("f", value));
	}

	/** Getter: The fractal offset */
	float offset() { /* not implemented */ throw NULL; }
	/** Setter: The fractal offset */
	void offset(float value) {
		PyObject_SetAttrString(pyobjref, "offset", Py_BuildValue("f", value));
	}

	/** Getter: The gain multiplier */
	float gain() { /* not implemented */ throw NULL; }
	/** Setter: The gain multiplier */
	void gain(float value) {
		PyObject_SetAttrString(pyobjref, "gain", Py_BuildValue("f", value));
	}

	/** Getter: Intensity of the noise */
	float noise_intensity() { /* not implemented */ throw NULL; }
	/** Setter: Intensity of the noise */
	void noise_intensity(float value) {
		PyObject_SetAttrString(pyobjref, "noise_intensity", Py_BuildValue("f", value));
	}

	/** Getter: Scaling for noise input */
	float noise_scale() { /* not implemented */ throw NULL; }
	/** Setter: Scaling for noise input */
	void noise_scale(float value) {
		PyObject_SetAttrString(pyobjref, "noise_scale", Py_BuildValue("f", value));
	}

	enum noise_basis_enum {
		noise_basis_BLENDER_ORIGINAL = 0,
		noise_basis_ORIGINAL_PERLIN = 1,
		noise_basis_IMPROVED_PERLIN = 2,
		noise_basis_VORONOI_F1 = 3,
		noise_basis_VORONOI_F2 = 4,
		noise_basis_VORONOI_F3 = 5,
		noise_basis_VORONOI_F4 = 6,
		noise_basis_VORONOI_F2_F1 = 7,
		noise_basis_VORONOI_CRACKLE = 8,
		noise_basis_CELL_NOISE = 14,
	};

	/** Getter: Noise basis used for turbulence */
	noise_basis_enum noise_basis() { /* not implemented */ throw NULL; }
	/** Setter: Noise basis used for turbulence */
	void noise_basis(noise_basis_enum value) { /* not implemented */ }

	/** Getter: Size of derivative offset used for calculating normal */
	float nabla() { /* not implemented */ throw NULL; }
	/** Setter: Size of derivative offset used for calculating normal */
	void nabla(float value) {
		PyObject_SetAttrString(pyobjref, "nabla", Py_BuildValue("f", value));
	}

};

/**************** Voronoi ****************/

/**
 * Procedural voronoi texture
 */
class VoronoiTexture : public Texture {
public:
	VoronoiTexture(PyObject* pyobj) : Texture(pyobj) {}

	VoronoiTexture() : Texture(0)
	{
		// not implemented
	}

	/** Getter: Voronoi feature weight 1 */
	float weight_1() { /* not implemented */ throw NULL; }
	/** Setter: Voronoi feature weight 1 */
	void weight_1(float value) {
		PyObject_SetAttrString(pyobjref, "weight_1", Py_BuildValue("f", value));
	}

	/** Getter: Voronoi feature weight 2 */
	float weight_2() { /* not implemented */ throw NULL; }
	/** Setter: Voronoi feature weight 2 */
	void weight_2(float value) {
		PyObject_SetAttrString(pyobjref, "weight_2", Py_BuildValue("f", value));
	}

	/** Getter: Voronoi feature weight 3 */
	float weight_3() { /* not implemented */ throw NULL; }
	/** Setter: Voronoi feature weight 3 */
	void weight_3(float value) {
		PyObject_SetAttrString(pyobjref, "weight_3", Py_BuildValue("f", value));
	}

	/** Getter: Voronoi feature weight 4 */
	float weight_4() { /* not implemented */ throw NULL; }
	/** Setter: Voronoi feature weight 4 */
	void weight_4(float value) {
		PyObject_SetAttrString(pyobjref, "weight_4", Py_BuildValue("f", value));
	}

	/** Getter: Minkowski exponent */
	float minkovsky_exponent() { /* not implemented */ throw NULL; }
	/** Setter: Minkowski exponent */
	void minkovsky_exponent(float value) {
		PyObject_SetAttrString(pyobjref, "minkovsky_exponent", Py_BuildValue("f", value));
	}

	enum distance_metric_enum {
		distance_metric_DISTANCE = 0,
		distance_metric_DISTANCE_SQUARED = 1,
		distance_metric_MANHATTAN = 2,
		distance_metric_CHEBYCHEV = 3,
		distance_metric_MINKOVSKY_HALF = 4,
		distance_metric_MINKOVSKY_FOUR = 5,
		distance_metric_MINKOVSKY = 6,
	};

	/** Getter: Algorithm used to calculate distance of sample points to feature points */
	distance_metric_enum distance_metric() { /* not implemented */ throw NULL; }
	/** Setter: Algorithm used to calculate distance of sample points to feature points */
	void distance_metric(distance_metric_enum value) { /* not implemented */ }

	enum color_mode_enum {
		color_mode_INTENSITY = 0,
		color_mode_POSITION = 1,
		color_mode_POSITION_OUTLINE = 2,
		color_mode_POSITION_OUTLINE_INTENSITY = 3,
	};

	/** Getter:  */
	color_mode_enum color_mode() { /* not implemented */ throw NULL; }
	/** Setter:  */
	void color_mode(color_mode_enum value) { /* not implemented */ }

	/** Getter: Scales the intensity of the noise */
	float noise_intensity() { /* not implemented */ throw NULL; }
	/** Setter: Scales the intensity of the noise */
	void noise_intensity(float value) {
		PyObject_SetAttrString(pyobjref, "noise_intensity", Py_BuildValue("f", value));
	}

	/** Getter: Scaling for noise input */
	float noise_scale() { /* not implemented */ throw NULL; }
	/** Setter: Scaling for noise input */
	void noise_scale(float value) {
		PyObject_SetAttrString(pyobjref, "noise_scale", Py_BuildValue("f", value));
	}

	/** Getter: Size of derivative offset used for calculating normal */
	float nabla() { /* not implemented */ throw NULL; }
	/** Setter: Size of derivative offset used for calculating normal */
	void nabla(float value) {
		PyObject_SetAttrString(pyobjref, "nabla", Py_BuildValue("f", value));
	}

};

/**************** Distorted Noise ****************/

/**
 * Procedural distorted noise texture
 */
class DistortedNoiseTexture : public Texture {
public:
	DistortedNoiseTexture(PyObject* pyobj) : Texture(pyobj) {}

	DistortedNoiseTexture() : Texture(0)
	{
		// not implemented
	}

	/** Getter: Amount of distortion */
	float distortion() { /* not implemented */ throw NULL; }
	/** Setter: Amount of distortion */
	void distortion(float value) {
		PyObject_SetAttrString(pyobjref, "distortion", Py_BuildValue("f", value));
	}

	/** Getter: Scaling for noise input */
	float noise_scale() { /* not implemented */ throw NULL; }
	/** Setter: Scaling for noise input */
	void noise_scale(float value) {
		PyObject_SetAttrString(pyobjref, "noise_scale", Py_BuildValue("f", value));
	}

	enum noise_basis_enum {
		noise_basis_BLENDER_ORIGINAL = 0,
		noise_basis_ORIGINAL_PERLIN = 1,
		noise_basis_IMPROVED_PERLIN = 2,
		noise_basis_VORONOI_F1 = 3,
		noise_basis_VORONOI_F2 = 4,
		noise_basis_VORONOI_F3 = 5,
		noise_basis_VORONOI_F4 = 6,
		noise_basis_VORONOI_F2_F1 = 7,
		noise_basis_VORONOI_CRACKLE = 8,
		noise_basis_CELL_NOISE = 14,
	};

	/** Getter: Noise basis used for turbulence */
	noise_basis_enum noise_basis() { /* not implemented */ throw NULL; }
	/** Setter: Noise basis used for turbulence */
	void noise_basis(noise_basis_enum value) { /* not implemented */ }

	enum noise_distortion_enum {
		noise_distortion_BLENDER_ORIGINAL = 0,
		noise_distortion_ORIGINAL_PERLIN = 1,
		noise_distortion_IMPROVED_PERLIN = 2,
		noise_distortion_VORONOI_F1 = 3,
		noise_distortion_VORONOI_F2 = 4,
		noise_distortion_VORONOI_F3 = 5,
		noise_distortion_VORONOI_F4 = 6,
		noise_distortion_VORONOI_F2_F1 = 7,
		noise_distortion_VORONOI_CRACKLE = 8,
		noise_distortion_CELL_NOISE = 14,
	};

	/** Getter: Noise basis for the distortion */
	noise_distortion_enum noise_distortion() { /* not implemented */ throw NULL; }
	/** Setter: Noise basis for the distortion */
	void noise_distortion(noise_distortion_enum value) { /* not implemented */ }

	/** Getter: Size of derivative offset used for calculating normal */
	float nabla() { /* not implemented */ throw NULL; }
	/** Setter: Size of derivative offset used for calculating normal */
	void nabla(float value) {
		PyObject_SetAttrString(pyobjref, "nabla", Py_BuildValue("f", value));
	}

};

/**************** PointDensity ****************/

/**
 * Point density settings
 */
class PointDensity : public pyUniplug {
public:
	PointDensity(PyObject* pyobj) : pyUniplug(pyobj) {}

	PointDensity() : pyUniplug(0)
	{
		// not implemented
	}

	enum point_source_enum {
		point_source_PARTICLE_SYSTEM = 0,
		point_source_OBJECT = 1,
	};

	/** Getter: Point data to use as renderable point density */
	point_source_enum point_source() { /* not implemented */ throw NULL; }
	/** Setter: Point data to use as renderable point density */
	void point_source(point_source_enum value) { /* not implemented */ }

	/** Getter: Object to take point data from */
	Object object_value();

	/** Getter: Particle System to render as points */
	ParticleSystem particle_system();

	enum particle_cache_space_enum {
		particle_cache_space_OBJECT_LOCATION = 0,
		particle_cache_space_OBJECT_SPACE = 1,
		particle_cache_space_WORLD_SPACE = 2,
	};

	/** Getter: Coordinate system to cache particles in */
	particle_cache_space_enum particle_cache_space() { /* not implemented */ throw NULL; }
	/** Setter: Coordinate system to cache particles in */
	void particle_cache_space(particle_cache_space_enum value) { /* not implemented */ }

	enum vertex_cache_space_enum {
		vertex_cache_space_OBJECT_LOCATION = 0,
		vertex_cache_space_OBJECT_SPACE = 1,
		vertex_cache_space_WORLD_SPACE = 2,
	};

	/** Getter: Coordinate system to cache vertices in */
	vertex_cache_space_enum vertex_cache_space() { /* not implemented */ throw NULL; }
	/** Setter: Coordinate system to cache vertices in */
	void vertex_cache_space(vertex_cache_space_enum value) { /* not implemented */ }

	/** Getter: Radius from the shaded sample to look for points within */
	float radius() { /* not implemented */ throw NULL; }
	/** Setter: Radius from the shaded sample to look for points within */
	void radius(float value) {
		PyObject_SetAttrString(pyobjref, "radius", Py_BuildValue("f", value));
	}

	enum falloff_enum {
		falloff_STANDARD = 0,
		falloff_SMOOTH = 1,
		falloff_SOFT = 2,
		falloff_CONSTANT = 3,
		falloff_ROOT = 4,
		falloff_PARTICLE_AGE = 5,
		falloff_PARTICLE_VELOCITY = 6,
	};

	/** Getter: Method of attenuating density by distance from the point */
	falloff_enum falloff() { /* not implemented */ throw NULL; }
	/** Setter: Method of attenuating density by distance from the point */
	void falloff(falloff_enum value) { /* not implemented */ }

	/** Getter: Softness of the 'soft' falloff option */
	float falloff_soft() { /* not implemented */ throw NULL; }
	/** Setter: Softness of the 'soft' falloff option */
	void falloff_soft(float value) {
		PyObject_SetAttrString(pyobjref, "falloff_soft", Py_BuildValue("f", value));
	}

	enum color_source_enum {
		color_source_CONSTANT = 0,
		color_source_PARTICLE_AGE = 1,
		color_source_PARTICLE_SPEED = 2,
		color_source_PARTICLE_VELOCITY = 3,
	};

	/** Getter: Data to derive color results from */
	color_source_enum color_source() { /* not implemented */ throw NULL; }
	/** Setter: Data to derive color results from */
	void color_source(color_source_enum value) { /* not implemented */ }

	/** Getter: Multiplier to bring particle speed within an acceptable range */
	float speed_scale() { /* not implemented */ throw NULL; }
	/** Setter: Multiplier to bring particle speed within an acceptable range */
	void speed_scale(float value) {
		PyObject_SetAttrString(pyobjref, "speed_scale", Py_BuildValue("f", value));
	}

	/** Getter: Multiplier to bring particle speed within an acceptable range */
	float falloff_speed_scale() { /* not implemented */ throw NULL; }
	/** Setter: Multiplier to bring particle speed within an acceptable range */
	void falloff_speed_scale(float value) {
		PyObject_SetAttrString(pyobjref, "falloff_speed_scale", Py_BuildValue("f", value));
	}

	/** Getter:  */
	ColorRamp color_ramp();

	/** Getter:  */
	CurveMapping falloff_curve();

	/** Getter: Use a custom falloff curve */
	bool use_falloff_curve() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_falloff_curve")) == 1;
	}

	/** Setter: Use a custom falloff curve */
	void use_falloff_curve(bool value) {
		PyObject_SetAttrString(pyobjref, "use_falloff_curve", Py_BuildValue("i", value));
	}

	/** Getter: Add directed noise to the density at render-time */
	bool use_turbulence() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_turbulence")) == 1;
	}

	/** Setter: Add directed noise to the density at render-time */
	void use_turbulence(bool value) {
		PyObject_SetAttrString(pyobjref, "use_turbulence", Py_BuildValue("i", value));
	}

	/** Getter: Scale of the added turbulent noise */
	float turbulence_scale() { /* not implemented */ throw NULL; }
	/** Setter: Scale of the added turbulent noise */
	void turbulence_scale(float value) {
		PyObject_SetAttrString(pyobjref, "turbulence_scale", Py_BuildValue("f", value));
	}

	/** Getter: Strength of the added turbulent noise */
	float turbulence_strength() { /* not implemented */ throw NULL; }
	/** Setter: Strength of the added turbulent noise */
	void turbulence_strength(float value) {
		PyObject_SetAttrString(pyobjref, "turbulence_strength", Py_BuildValue("f", value));
	}

	/** Getter: Level of detail in the added turbulent noise */
	int turbulence_depth() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "turbulence_depth"));
	}

	/** Setter: Level of detail in the added turbulent noise */
	void turbulence_depth(int value) {
		PyObject_SetAttrString(pyobjref, "turbulence_depth", Py_BuildValue("i", value));
	}

	enum turbulence_influence_enum {
		turbulence_influence_STATIC = 0,
		turbulence_influence_PARTICLE_VELOCITY = 1,
		turbulence_influence_PARTICLE_AGE = 2,
		turbulence_influence_GLOBAL_TIME = 3,
	};

	/** Getter: Method for driving added turbulent noise */
	turbulence_influence_enum turbulence_influence() { /* not implemented */ throw NULL; }
	/** Setter: Method for driving added turbulent noise */
	void turbulence_influence(turbulence_influence_enum value) { /* not implemented */ }

	enum noise_basis_enum {
		noise_basis_BLENDER_ORIGINAL = 0,
		noise_basis_ORIGINAL_PERLIN = 1,
		noise_basis_IMPROVED_PERLIN = 2,
		noise_basis_VORONOI_F1 = 3,
		noise_basis_VORONOI_F2 = 4,
		noise_basis_VORONOI_F3 = 5,
		noise_basis_VORONOI_F4 = 6,
		noise_basis_VORONOI_F2_F1 = 7,
		noise_basis_VORONOI_CRACKLE = 8,
		noise_basis_CELL_NOISE = 14,
	};

	/** Getter: Noise formula used for turbulence */
	noise_basis_enum noise_basis() { /* not implemented */ throw NULL; }
	/** Setter: Noise formula used for turbulence */
	void noise_basis(noise_basis_enum value) { /* not implemented */ }

};

/**************** Point Density ****************/

/**
 * Settings for the Point Density texture
 */
class PointDensityTexture : public Texture {
public:
	PointDensityTexture(PyObject* pyobj) : Texture(pyobj) {}

	PointDensityTexture() : Texture(0)
	{
		// not implemented
	}

	/** Getter: The point density settings associated with this texture */
	PointDensity point_density() {
		/* not implemented */ throw NULL;
	}

};

/**************** VoxelData ****************/

/**
 * Voxel data settings
 */
class VoxelData : public pyUniplug {
public:
	VoxelData(PyObject* pyobj) : pyUniplug(pyobj) {}

	VoxelData() : pyUniplug(0)
	{
		// not implemented
	}

	enum interpolation_enum {
		interpolation_NEREASTNEIGHBOR = 0,
		interpolation_TRILINEAR = 1,
		interpolation_QUADRATIC = 2,
		interpolation_TRICUBIC_CATROM = 3,
		interpolation_TRICUBIC_BSPLINE = 4,
	};

	/** Getter: Method to interpolate/smooth values between voxel cells */
	interpolation_enum interpolation() { /* not implemented */ throw NULL; }
	/** Setter: Method to interpolate/smooth values between voxel cells */
	void interpolation(interpolation_enum value) { /* not implemented */ }

	enum smoke_data_type_enum {
		smoke_data_type_SMOKEDENSITY = 0,
		smoke_data_type_SMOKEFLAME = 3,
		smoke_data_type_SMOKEHEAT = 1,
		smoke_data_type_SMOKEVEL = 2,
	};

	/** Getter: Simulation value to be used as a texture */
	smoke_data_type_enum smoke_data_type() { /* not implemented */ throw NULL; }
	/** Setter: Simulation value to be used as a texture */
	void smoke_data_type(smoke_data_type_enum value) { /* not implemented */ }

	enum hair_data_type_enum {
		hair_data_type_HAIRDENSITY = 0,
		hair_data_type_HAIRRESTDENSITY = 3,
		hair_data_type_HAIRVELOCITY = 1,
		hair_data_type_HAIRENERGY = 2,
	};

	/** Getter: Simulation value to be used as a texture */
	hair_data_type_enum hair_data_type() { /* not implemented */ throw NULL; }
	/** Setter: Simulation value to be used as a texture */
	void hair_data_type(hair_data_type_enum value) { /* not implemented */ }

	enum extension_enum {
		extension_EXTEND = 1,
		extension_CLIP = 2,
		extension_REPEAT = 3,
	};

	/** Getter: How the texture is extrapolated past its original bounds */
	extension_enum extension() { /* not implemented */ throw NULL; }
	/** Setter: How the texture is extrapolated past its original bounds */
	void extension(extension_enum value) { /* not implemented */ }

	/** Getter: Multiplier for intensity values */
	float intensity() { /* not implemented */ throw NULL; }
	/** Setter: Multiplier for intensity values */
	void intensity(float value) {
		PyObject_SetAttrString(pyobjref, "intensity", Py_BuildValue("f", value));
	}

	enum file_format_enum {
		file_format_BLENDER_VOXEL = 0,
		file_format_RAW_8BIT = 1,
		file_format_IMAGE_SEQUENCE = 3,
		file_format_SMOKE = 4,
		file_format_HAIR = 5,
	};

	/** Getter: Format of the source data set to render */
	file_format_enum file_format() { /* not implemented */ throw NULL; }
	/** Setter: Format of the source data set to render */
	void file_format(file_format_enum value) { /* not implemented */ }

	/** Getter: The external source data file to use */
	std::string filepath() { /* not implemented */ throw NULL; }
	/** Setter: The external source data file to use */
	void filepath(const std::string& value) { /* not implemented */ }

	/** Getter: Resolution of the voxel grid */
	std::array<int, 3> resolution() {
		// TODO: MISSING DEREF! USE #DEFINE!
		PyObject *seqval = PyObject_GetAttrString(pyobjref, "resolution");
		std::array<int, 3> resarr;
		for (int i = 0; i < 3; i++)
			resarr[i] = PyLong_AsLong(PySequence_GetItem(seqval, i));
		return resarr;
	}

	/** Setter: Resolution of the voxel grid */
	void resolution(int values[3]) { /* not implemented */ }

	/** Getter: Always render a still frame from the voxel data sequence */
	bool use_still_frame() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_still_frame")) == 1;
	}

	/** Setter: Always render a still frame from the voxel data sequence */
	void use_still_frame(bool value) {
		PyObject_SetAttrString(pyobjref, "use_still_frame", Py_BuildValue("i", value));
	}

	/** Getter: The frame number to always use */
	int still_frame() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "still_frame"));
	}

	/** Setter: The frame number to always use */
	void still_frame(int value) {
		PyObject_SetAttrString(pyobjref, "still_frame", Py_BuildValue("i", value));
	}

	/** Getter: Object used as the smoke simulation domain */
	Object domain_object();

};

/**************** Voxel Data ****************/

/**
 * Settings for the Voxel Data texture
 */
class VoxelDataTexture : public Texture {
public:
	VoxelDataTexture(PyObject* pyobj) : Texture(pyobj) {}

	VoxelDataTexture() : Texture(0)
	{
		// not implemented
	}

	/** Getter: The voxel data associated with this texture */
	VoxelData voxel_data() {
		/* not implemented */ throw NULL;
	}

	/** Getter:  */
	Image image();

	/** Getter: Parameters defining which layer, pass and frame of the image is displayed */
	ImageUser image_user();

};

/**************** Ocean ****************/

/**
 * Ocean Texture settings
 */
class OceanTexData : public pyUniplug {
public:
	OceanTexData(PyObject* pyobj) : pyUniplug(pyobj) {}

	OceanTexData() : pyUniplug(0)
	{
		// not implemented
	}

	enum output_enum {
		output_DISPLACEMENT = 1,
		output_FOAM = 2,
		output_JPLUS = 3,
		output_EMINUS = 4,
		output_EPLUS = 5,
	};

	/** Getter: The data that is output by the texture */
	output_enum output() { /* not implemented */ throw NULL; }
	/** Setter: The data that is output by the texture */
	void output(output_enum value) { /* not implemented */ }

	/** Getter: Object containing the ocean modifier */
	Object ocean_object();

};

/**************** Ocean ****************/

/**
 * Settings for the Ocean texture
 */
class OceanTexture : public Texture {
public:
	OceanTexture(PyObject* pyobj) : Texture(pyobj) {}

	OceanTexture() : Texture(0)
	{
		// not implemented
	}

	/** Getter: The ocean data associated with this texture */
	OceanTexData ocean() {
		/* not implemented */ throw NULL;
	}

};

/**************** Texture Slot ****************/

/**
 * Texture slot defining the mapping and influence of a texture
 */
class TextureSlot : public pyUniplug {
public:
	TextureSlot(PyObject* pyobj) : pyUniplug(pyobj) {}

	TextureSlot() : pyUniplug(0)
	{
		// not implemented
	}

	/** Getter: Texture datablock used by this texture slot */
	Texture texture() {
		/* not implemented */ throw NULL;
	}

	/** Getter: Texture slot name */
	std::string name() { /* not implemented */ throw NULL; }
	/** Setter: Texture slot name */
	void name(const std::string& value) { /* not implemented */ }

	/** Getter: Fine tune of the texture mapping X, Y and Z locations */
	std::array<float, 3> offset() {
		// TODO: MISSING DEREF! USE #DEFINE!
		PyObject *seqval = PyObject_GetAttrString(pyobjref, "offset");
		std::array<float, 3> resarr;
		for (int i = 0; i < 3; i++)
			resarr[i] = (float)PyFloat_AsDouble(PySequence_GetItem(seqval, i));
		return resarr;
	}

	/** Setter: Fine tune of the texture mapping X, Y and Z locations */
	void offset(float values[3]) { /* not implemented */ }

	/** Getter: Set scaling for the texture's X, Y and Z sizes */
	std::array<float, 3> scale() {
		// TODO: MISSING DEREF! USE #DEFINE!
		PyObject *seqval = PyObject_GetAttrString(pyobjref, "scale");
		std::array<float, 3> resarr;
		for (int i = 0; i < 3; i++)
			resarr[i] = (float)PyFloat_AsDouble(PySequence_GetItem(seqval, i));
		return resarr;
	}

	/** Setter: Set scaling for the texture's X, Y and Z sizes */
	void scale(float values[3]) { /* not implemented */ }

	/** Getter: Default color for textures that don't return RGB or when RGB to intensity is enabled */
	std::array<float, 3> color() {
		// TODO: MISSING DEREF! USE #DEFINE!
		PyObject *seqval = PyObject_GetAttrString(pyobjref, "color");
		std::array<float, 3> resarr;
		for (int i = 0; i < 3; i++)
			resarr[i] = (float)PyFloat_AsDouble(PySequence_GetItem(seqval, i));
		return resarr;
	}

	/** Setter: Default color for textures that don't return RGB or when RGB to intensity is enabled */
	void color(float values[3]) { /* not implemented */ }

	enum blend_type_enum {
		blend_type_MIX = 0,
		blend_type_ADD = 2,
		blend_type_SUBTRACT = 3,
		blend_type_MULTIPLY = 1,
		blend_type_SCREEN = 8,
		blend_type_OVERLAY = 9,
		blend_type_DIFFERENCE = 6,
		blend_type_DIVIDE = 4,
		blend_type_DARKEN = 5,
		blend_type_LIGHTEN = 7,
		blend_type_HUE = 10,
		blend_type_SATURATION = 11,
		blend_type_VALUE = 12,
		blend_type_COLOR = 13,
		blend_type_SOFT_LIGHT = 15,
		blend_type_LINEAR_LIGHT = 16,
	};

	/** Getter: Mode used to apply the texture */
	blend_type_enum blend_type() { /* not implemented */ throw NULL; }
	/** Setter: Mode used to apply the texture */
	void blend_type(blend_type_enum value) { /* not implemented */ }

	/** Getter: Use this texture as a blending value on the next texture */
	bool use_stencil() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_stencil")) == 1;
	}

	/** Setter: Use this texture as a blending value on the next texture */
	void use_stencil(bool value) {
		PyObject_SetAttrString(pyobjref, "use_stencil", Py_BuildValue("i", value));
	}

	/** Getter: Invert the values of the texture to reverse its effect */
	bool invert() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "invert")) == 1;
	}

	/** Setter: Invert the values of the texture to reverse its effect */
	void invert(bool value) {
		PyObject_SetAttrString(pyobjref, "invert", Py_BuildValue("i", value));
	}

	/** Getter: Convert texture RGB values to intensity (gray) values */
	bool use_rgb_to_intensity() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_rgb_to_intensity")) == 1;
	}

	/** Setter: Convert texture RGB values to intensity (gray) values */
	void use_rgb_to_intensity(bool value) {
		PyObject_SetAttrString(pyobjref, "use_rgb_to_intensity", Py_BuildValue("i", value));
	}

	/** Getter: Value to use for Ref, Spec, Amb, Emit, Alpha, RayMir, TransLu and Hard */
	float default_value() { /* not implemented */ throw NULL; }
	/** Setter: Value to use for Ref, Spec, Amb, Emit, Alpha, RayMir, TransLu and Hard */
	void default_value(float value) {
		PyObject_SetAttrString(pyobjref, "default_value", Py_BuildValue("f", value));
	}

	enum output_node_enum {
		output_node_DUMMY = 0,
	};

	/** Getter: Which output node to use, for node-based textures */
	output_node_enum output_node() { /* not implemented */ throw NULL; }
	/** Setter: Which output node to use, for node-based textures */
	void output_node(output_node_enum value) { /* not implemented */ }

};

/**************** EnvironmentMap ****************/

/**
 * Environment map created by the renderer and cached for subsequent renders
 */
class EnvironmentMap : public pyUniplug {
public:
	EnvironmentMap(PyObject* pyobj) : pyUniplug(pyobj) {}

	EnvironmentMap() : pyUniplug(0)
	{
		// not implemented
	}

	enum source_enum {
		source_STATIC = 0,
		source_ANIMATED = 1,
		source_IMAGE_FILE = 2,
	};

	/** Getter:  */
	source_enum source() { /* not implemented */ throw NULL; }
	/** Setter:  */
	void source(source_enum value) { /* not implemented */ }

	/** Getter: Object to use as the environment map's viewpoint location */
	Object viewpoint_object();

	enum mapping_enum {
		mapping_CUBE = 0,
		mapping_PLANE = 1,
	};

	/** Getter:  */
	mapping_enum mapping() { /* not implemented */ throw NULL; }
	/** Setter:  */
	void mapping(mapping_enum value) { /* not implemented */ }

	/** Getter: Objects nearer than this are not visible to map */
	float clip_start() { /* not implemented */ throw NULL; }
	/** Setter: Objects nearer than this are not visible to map */
	void clip_start(float value) {
		PyObject_SetAttrString(pyobjref, "clip_start", Py_BuildValue("f", value));
	}

	/** Getter: Objects further than this are not visible to map */
	float clip_end() { /* not implemented */ throw NULL; }
	/** Setter: Objects further than this are not visible to map */
	void clip_end(float value) {
		PyObject_SetAttrString(pyobjref, "clip_end", Py_BuildValue("f", value));
	}

	/** Getter:  */
	float zoom() { /* not implemented */ throw NULL; }
	/** Setter:  */
	void zoom(float value) {
		PyObject_SetAttrString(pyobjref, "zoom", Py_BuildValue("f", value));
	}

	/** Getter: Hide objects on these layers when generating the Environment Map */
	std::array<bool, 20> layers_ignore() {
		// TODO: MISSING DEREF! USE #DEFINE!
		PyObject *seqval = PyObject_GetAttrString(pyobjref, "layers_ignore");
		std::array<bool, 20> resarr;
		for (int i = 0; i < 20; i++)
			resarr[i] = PyLong_AsLong(PySequence_GetItem(seqval, i)) == 1;
		return resarr;
	}

	/** Setter: Hide objects on these layers when generating the Environment Map */
	void layers_ignore(bool values[20]) { /* not implemented */ }

	/** Getter: Pixel resolution of the rendered environment map */
	int resolution() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "resolution"));
	}

	/** Setter: Pixel resolution of the rendered environment map */
	void resolution(int value) {
		PyObject_SetAttrString(pyobjref, "resolution", Py_BuildValue("i", value));
	}

	/** Getter: Number of times a map will be rendered recursively (mirror effects) */
	int depth() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "depth"));
	}

	/** Setter: Number of times a map will be rendered recursively (mirror effects) */
	void depth(int value) {
		PyObject_SetAttrString(pyobjref, "depth", Py_BuildValue("i", value));
	}

	/** Getter: True if this map is ready for use, False if it needs rendering */
	bool is_valid() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "is_valid")) == 1;
	}

	/** Setter: True if this map is ready for use, False if it needs rendering */
	void is_valid(bool value) {
		PyObject_SetAttrString(pyobjref, "is_valid", Py_BuildValue("i", value));
	}

	/**
	 * Discard the environment map and free it from memory
	 */
	void clear()
	{
		// not implemented
	}

	/**
	 * Save the environment map to disc using the scene render settings
	 * @param Location of the output file
	 * @param Overrides the scene from which image parameters are taken
	 * @param Flat array describing the X,Y position of each cube face in the output image, where 1 is the size of a face - order is [+Z -Z +Y -X -Y +X] (use -1 to skip a face)
	 */
	void save(const std::string filepath, Scene scene, float layout[12]);

};

/**************** Texture Mapping ****************/

/**
 * Texture coordinate mapping settings
 */
class TexMapping : public pyUniplug {
public:
	TexMapping(PyObject* pyobj) : pyUniplug(pyobj) {}

	TexMapping() : pyUniplug(0)
	{
		// not implemented
	}

	enum vector_type_enum {
		vector_type_TEXTURE = 1,
		vector_type_POINT = 0,
		vector_type_VECTOR = 2,
		vector_type_NORMAL = 3,
	};

	/** Getter: Type of vector that the mapping transforms */
	vector_type_enum vector_type() { /* not implemented */ throw NULL; }
	/** Setter: Type of vector that the mapping transforms */
	void vector_type(vector_type_enum value) { /* not implemented */ }

	/** Getter:  */
	std::array<float, 3> translation() {
		// TODO: MISSING DEREF! USE #DEFINE!
		PyObject *seqval = PyObject_GetAttrString(pyobjref, "translation");
		std::array<float, 3> resarr;
		for (int i = 0; i < 3; i++)
			resarr[i] = (float)PyFloat_AsDouble(PySequence_GetItem(seqval, i));
		return resarr;
	}

	/** Setter:  */
	void translation(float values[3]) { /* not implemented */ }

	/** Getter:  */
	std::array<float, 3> rotation() {
		// TODO: MISSING DEREF! USE #DEFINE!
		PyObject *seqval = PyObject_GetAttrString(pyobjref, "rotation");
		std::array<float, 3> resarr;
		for (int i = 0; i < 3; i++)
			resarr[i] = (float)PyFloat_AsDouble(PySequence_GetItem(seqval, i));
		return resarr;
	}

	/** Setter:  */
	void rotation(float values[3]) { /* not implemented */ }

	/** Getter:  */
	std::array<float, 3> scale() {
		// TODO: MISSING DEREF! USE #DEFINE!
		PyObject *seqval = PyObject_GetAttrString(pyobjref, "scale");
		std::array<float, 3> resarr;
		for (int i = 0; i < 3; i++)
			resarr[i] = (float)PyFloat_AsDouble(PySequence_GetItem(seqval, i));
		return resarr;
	}

	/** Setter:  */
	void scale(float values[3]) { /* not implemented */ }

	/** Getter: Minimum value for clipping */
	std::array<float, 3> min() {
		// TODO: MISSING DEREF! USE #DEFINE!
		PyObject *seqval = PyObject_GetAttrString(pyobjref, "min");
		std::array<float, 3> resarr;
		for (int i = 0; i < 3; i++)
			resarr[i] = (float)PyFloat_AsDouble(PySequence_GetItem(seqval, i));
		return resarr;
	}

	/** Setter: Minimum value for clipping */
	void min(float values[3]) { /* not implemented */ }

	/** Getter: Maximum value for clipping */
	std::array<float, 3> max() {
		// TODO: MISSING DEREF! USE #DEFINE!
		PyObject *seqval = PyObject_GetAttrString(pyobjref, "max");
		std::array<float, 3> resarr;
		for (int i = 0; i < 3; i++)
			resarr[i] = (float)PyFloat_AsDouble(PySequence_GetItem(seqval, i));
		return resarr;
	}

	/** Setter: Maximum value for clipping */
	void max(float values[3]) { /* not implemented */ }

	/** Getter: Whether to use minimum clipping value */
	bool use_min() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_min")) == 1;
	}

	/** Setter: Whether to use minimum clipping value */
	void use_min(bool value) {
		PyObject_SetAttrString(pyobjref, "use_min", Py_BuildValue("i", value));
	}

	/** Getter: Whether to use maximum clipping value */
	bool use_max() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_max")) == 1;
	}

	/** Setter: Whether to use maximum clipping value */
	void use_max(bool value) {
		PyObject_SetAttrString(pyobjref, "use_max", Py_BuildValue("i", value));
	}

	enum mapping_x_enum {
		mapping_x_NONE = 0,
		mapping_x_X = 1,
		mapping_x_Y = 2,
		mapping_x_Z = 3,
	};

	/** Getter:  */
	mapping_x_enum mapping_x() { /* not implemented */ throw NULL; }
	/** Setter:  */
	void mapping_x(mapping_x_enum value) { /* not implemented */ }

	enum mapping_y_enum {
		mapping_y_NONE = 0,
		mapping_y_X = 1,
		mapping_y_Y = 2,
		mapping_y_Z = 3,
	};

	/** Getter:  */
	mapping_y_enum mapping_y() { /* not implemented */ throw NULL; }
	/** Setter:  */
	void mapping_y(mapping_y_enum value) { /* not implemented */ }

	enum mapping_z_enum {
		mapping_z_NONE = 0,
		mapping_z_X = 1,
		mapping_z_Y = 2,
		mapping_z_Z = 3,
	};

	/** Getter:  */
	mapping_z_enum mapping_z() { /* not implemented */ throw NULL; }
	/** Setter:  */
	void mapping_z(mapping_z_enum value) { /* not implemented */ }

	enum mapping_enum {
		mapping_FLAT = 0,
		mapping_CUBE = 1,
		mapping_TUBE = 2,
		mapping_SPHERE = 3,
	};

	/** Getter:  */
	mapping_enum mapping() { /* not implemented */ throw NULL; }
	/** Setter:  */
	void mapping(mapping_enum value) { /* not implemented */ }

};

/**************** Color Mapping ****************/

/**
 * Color mapping settings
 */
class ColorMapping : public pyUniplug {
public:
	ColorMapping(PyObject* pyobj) : pyUniplug(pyobj) {}

	ColorMapping() : pyUniplug(0)
	{
		// not implemented
	}

	/** Getter: Toggle color ramp operations */
	bool use_color_ramp() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_color_ramp")) == 1;
	}

	/** Setter: Toggle color ramp operations */
	void use_color_ramp(bool value) {
		PyObject_SetAttrString(pyobjref, "use_color_ramp", Py_BuildValue("i", value));
	}

	/** Getter:  */
	ColorRamp color_ramp();

	/** Getter: Adjust the brightness of the texture */
	float brightness() { /* not implemented */ throw NULL; }
	/** Setter: Adjust the brightness of the texture */
	void brightness(float value) {
		PyObject_SetAttrString(pyobjref, "brightness", Py_BuildValue("f", value));
	}

	/** Getter: Adjust the contrast of the texture */
	float contrast() { /* not implemented */ throw NULL; }
	/** Setter: Adjust the contrast of the texture */
	void contrast(float value) {
		PyObject_SetAttrString(pyobjref, "contrast", Py_BuildValue("f", value));
	}

	/** Getter: Adjust the saturation of colors in the texture */
	float saturation() { /* not implemented */ throw NULL; }
	/** Setter: Adjust the saturation of colors in the texture */
	void saturation(float value) {
		PyObject_SetAttrString(pyobjref, "saturation", Py_BuildValue("f", value));
	}

	enum blend_type_enum {
		blend_type_MIX = 0,
		blend_type_ADD = 2,
		blend_type_SUBTRACT = 3,
		blend_type_MULTIPLY = 1,
		blend_type_SCREEN = 8,
		blend_type_OVERLAY = 9,
		blend_type_DIFFERENCE = 6,
		blend_type_DIVIDE = 4,
		blend_type_DARKEN = 5,
		blend_type_LIGHTEN = 7,
		blend_type_HUE = 10,
		blend_type_SATURATION = 11,
		blend_type_VALUE = 12,
		blend_type_COLOR = 13,
		blend_type_SOFT_LIGHT = 15,
		blend_type_LINEAR_LIGHT = 16,
	};

	/** Getter: Mode used to mix with texture output color */
	blend_type_enum blend_type() { /* not implemented */ throw NULL; }
	/** Setter: Mode used to mix with texture output color */
	void blend_type(blend_type_enum value) { /* not implemented */ }

	/** Getter: Blend color to mix with texture output color */
	std::array<float, 3> blend_color() {
		// TODO: MISSING DEREF! USE #DEFINE!
		PyObject *seqval = PyObject_GetAttrString(pyobjref, "blend_color");
		std::array<float, 3> resarr;
		for (int i = 0; i < 3; i++)
			resarr[i] = (float)PyFloat_AsDouble(PySequence_GetItem(seqval, i));
		return resarr;
	}

	/** Setter: Blend color to mix with texture output color */
	void blend_color(float values[3]) { /* not implemented */ }

	/** Getter:  */
	float blend_factor() { /* not implemented */ throw NULL; }
	/** Setter:  */
	void blend_factor(float value) {
		PyObject_SetAttrString(pyobjref, "blend_factor", Py_BuildValue("f", value));
	}

};

/**************** ID Materials ****************/

/**
 * Collection of materials
 */
class IDMaterials : public pyUniplug {
public:
	IDMaterials(PyObject* pyobj) : pyUniplug(pyobj) {}

	IDMaterials() : pyUniplug(0)
	{
		// not implemented
	}

	/**
	 * Add a new material to the data block
	 * @param Material to add
	 */
	void append(Material material);

	/**
	 * Remove a material from the data block
	 * @param Index of material to remove
	 * @param Update data by re-adjusting the material slots assigned
	 * @return Material to remove
	 */
	Material pop(int index = -1, bool update_data = false);

	/**
	 * Remove all materials from the data block
	 * @param Update data by re-adjusting the material slots assigned
	 */
	void clear(bool update_data = false)
	{
		// not implemented
	}

};

/**************** Action F-Curves ****************/

/**
 * Collection of action F-Curves
 */
class ActionFCurves : public pyUniplug {
public:
	ActionFCurves(PyObject* pyobj) : pyUniplug(pyobj) {}

	ActionFCurves() : pyUniplug(0)
	{
		// not implemented
	}

	/**
	 * Add a keyframe to the F-Curve
	 * @param F-Curve data path to use
	 * @param Array index
	 * @param Acton group to add this F-Curve into
	 * @return Newly created F-Curve
	 */
	FCurve create(const std::string data_path, int index = 0, const std::string action_group = NULL);

	/**
	 * Remove action group
	 * @param F-Curve to remove
	 */
	void remove(FCurve fcurve);

};

/**************** Action Groups ****************/

/**
 * Collection of action groups
 */
class ActionGroups : public pyUniplug {
public:
	ActionGroups(PyObject* pyobj) : pyUniplug(pyobj) {}

	ActionGroups() : pyUniplug(0)
	{
		// not implemented
	}

	/**
	 * Create a new action group and add it to the action
	 * @param New name for the action group
	 * @return Newly created action group
	 */
	ActionGroup create(const std::string name);

	/**
	 * Remove action group
	 * @param Action group to remove
	 */
	void remove(ActionGroup action_group);

};

/**************** Action Pose Markers ****************/

/**
 * Collection of timeline markers
 */
class ActionPoseMarkers : public pyUniplug {
public:
	ActionPoseMarkers(PyObject* pyobj) : pyUniplug(pyobj) {}

	ActionPoseMarkers() : pyUniplug(0)
	{
		// not implemented
	}

	/** Getter: Active pose marker for this action */
	TimelineMarker active();

	/** Getter: Index of active pose marker */
	int active_index() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "active_index"));
	}

	/** Setter: Index of active pose marker */
	void active_index(int value) {
		PyObject_SetAttrString(pyobjref, "active_index", Py_BuildValue("i", value));
	}

	/**
	 * Add a pose marker to the action
	 * @param New name for the marker (not unique)
	 * @return Newly created marker
	 */
	TimelineMarker create(const std::string name);

	/**
	 * Remove a timeline marker
	 * @param Timeline marker to remove
	 */
	void remove(TimelineMarker marker);

};

/**************** NLA Tracks ****************/

/**
 * Collection of NLA Tracks
 */
class NlaTracks : public pyUniplug {
public:
	NlaTracks(PyObject* pyobj) : pyUniplug(pyobj) {}

	NlaTracks() : pyUniplug(0)
	{
		// not implemented
	}

	/** Getter: Active Object constraint */
	NlaTrack active();

	/**
	 * Add a new NLA Track
	 * @param NLA Track to add the new one after
	 * @return New NLA Track
	 */
	NlaTrack create(NlaTrack prev);

	/**
	 * Remove a NLA Track
	 * @param NLA Track to remove
	 */
	void remove(NlaTrack track);

};

/**************** Drivers ****************/

/**
 * Collection of Driver F-Curves
 */
class AnimDataDrivers : public pyUniplug {
public:
	AnimDataDrivers(PyObject* pyobj) : pyUniplug(pyobj) {}

	AnimDataDrivers() : pyUniplug(0)
	{
		// not implemented
	}

	/**
	 * Add a new driver given an existing one
	 * @param Existing Driver F-Curve to use as template for a new one
	 * @return New Driver F-Curve
	 */
	FCurve from_existing(FCurve src_driver);

};

/**************** Keying set paths ****************/

/**
 * Collection of keying set paths
 */
class KeyingSetPaths : public pyUniplug {
public:
	KeyingSetPaths(PyObject* pyobj) : pyUniplug(pyobj) {}

	KeyingSetPaths() : pyUniplug(0)
	{
		// not implemented
	}

	/** Getter: Active Keying Set used to insert/delete keyframes */
	KeyingSetPath active();

	/** Getter: Current Keying Set index */
	int active_index() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "active_index"));
	}

	/** Setter: Current Keying Set index */
	void active_index(int value) {
		PyObject_SetAttrString(pyobjref, "active_index", Py_BuildValue("i", value));
	}

	/**
	 * Enum: keyingset_path_grouping_items
	 */
	enum keyingset_path_grouping_items {
		keyingset_path_grouping_items_NAMED = 0,	
		keyingset_path_grouping_items_NONE = 1,	
		keyingset_path_grouping_items_KEYINGSET = 2	
	};

	/**
	 * Add a new path for the Keying Set
	 * @return Path created and added to the Keying Set
	 * @param ID-Datablock for the destination
	 * @param RNA-Path to destination property
	 * @param The index of the destination property (i.e. axis of Location/Rotation/etc.), or -1 for the entire array
	 * @param Method used to define which Group-name to use
	 * @param Name of Action Group to assign destination to (only if grouping mode is to use this name)
	 */
	KeyingSetPath add(ID target_id, const std::string data_path, int index = -1, keyingset_path_grouping_items group_method = keyingset_path_grouping_items_KEYINGSET, const std::string group_name = NULL);

	/**
	 * Remove the given path from the Keying Set
	 * @param Param 'path'
	 */
	void remove(KeyingSetPath path);

	/**
	 * Remove all the paths from the Keying Set
	 */
	void clear()
	{
		// not implemented
	}

};

/**************** Armature Bones ****************/

/**
 * Collection of armature bones
 */
class ArmatureBones : public pyUniplug {
public:
	ArmatureBones(PyObject* pyobj) : pyUniplug(pyobj) {}

	ArmatureBones() : pyUniplug(0)
	{
		// not implemented
	}

	/** Getter: Armature's active bone */
	Bone active();

};

/**************** Armature EditBones ****************/

/**
 * Collection of armature edit bones
 */
class ArmatureEditBones : public pyUniplug {
public:
	ArmatureEditBones(PyObject* pyobj) : pyUniplug(pyobj) {}

	ArmatureEditBones() : pyUniplug(0)
	{
		// not implemented
	}

	/** Getter: Armatures active edit bone */
	EditBone active();

	/**
	 * Add a new bone
	 * @param New name for the bone
	 * @return Newly created edit bone
	 */
	EditBone create(const std::string name);

	/**
	 * Remove an existing bone from the armature
	 * @param EditBone to remove
	 */
	void remove(EditBone bone);

};

/**************** Curve Map Point ****************/

/**
 * Collection of Curve Map Points
 */
class CurveMapPoints : public pyUniplug {
public:
	CurveMapPoints(PyObject* pyobj) : pyUniplug(pyobj) {}

	CurveMapPoints() : pyUniplug(0)
	{
		// not implemented
	}

	/**
	 * Add point to CurveMap
	 * @param Position to add point
	 * @param Value of point
	 * @return New point
	 */
	CurveMapPoint create(float position, float value);

	/**
	 * Delete point from CurveMap
	 * @param PointElement to remove
	 */
	void remove(CurveMapPoint point);

};

/**************** Color Ramp Elements ****************/

/**
 * Collection of Color Ramp Elements
 */
class ColorRampElements : public pyUniplug {
public:
	ColorRampElements(PyObject* pyobj) : pyUniplug(pyobj) {}

	ColorRampElements() : pyUniplug(0)
	{
		// not implemented
	}

	/**
	 * Add element to ColorRamp
	 * @param Position to add element
	 * @return New element
	 */
	ColorRampElement create(float position);

	/**
	 * Delete element from ColorRamp
	 * @param Element to remove
	 */
	void remove(ColorRampElement element);

};

/**************** Curve Splines ****************/

/**
 * Collection of curve splines
 */
class CurveSplines : public pyUniplug {
public:
	CurveSplines(PyObject* pyobj) : pyUniplug(pyobj) {}

	CurveSplines() : pyUniplug(0)
	{
		// not implemented
	}

	/** Getter: Active curve spline */
	Spline active();

	/**
	 * Enum: curve_type_items
	 */
	enum curve_type_items {
		curve_type_items_POLY = 0,	
		curve_type_items_BEZIER = 1,	
		curve_type_items_BSPLINE = 2,	
		curve_type_items_CARDINAL = 3,	
		curve_type_items_NURBS = 4	
	};

	/**
	 * Add a new spline to the curve
	 * @param type for the new spline
	 * @return The newly created spline
	 */
	Spline create(curve_type_items type);

	/**
	 * Remove a spline from a curve
	 * @param The spline to remove
	 */
	void remove(Spline spline);

	/**
	 * Remove all splines from a curve
	 */
	void clear()
	{
		// not implemented
	}

};

/**************** Spline Points ****************/

/**
 * Collection of spline points
 */
class SplinePoints : public pyUniplug {
public:
	SplinePoints(PyObject* pyobj) : pyUniplug(pyobj) {}

	SplinePoints() : pyUniplug(0)
	{
		// not implemented
	}

	/**
	 * Add a number of points to this spline
	 * @param Number of points to add to the spline
	 */
	void add(int count = 1)
	{
		// not implemented
	}

};

/**************** Spline Bezier Points ****************/

/**
 * Collection of spline bezirt points
 */
class SplineBezierPoints : public pyUniplug {
public:
	SplineBezierPoints(PyObject* pyobj) : pyUniplug(pyobj) {}

	SplineBezierPoints() : pyUniplug(0)
	{
		// not implemented
	}

	/**
	 * Add a number of points to this spline
	 * @param Number of points to add to the spline
	 */
	void add(int count = 1)
	{
		// not implemented
	}

};

/**************** Canvas Surfaces ****************/

/**
 * Collection of Dynamic Paint Canvas surfaces
 */
class DynamicPaintSurfaces : public pyUniplug {
public:
	DynamicPaintSurfaces(PyObject* pyobj) : pyUniplug(pyobj) {}

	DynamicPaintSurfaces() : pyUniplug(0)
	{
		// not implemented
	}

	/** Getter:  */
	int active_index() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "active_index"));
	}

	/** Setter:  */
	void active_index(int value) {
		PyObject_SetAttrString(pyobjref, "active_index", Py_BuildValue("i", value));
	}

	/** Getter: Active Dynamic Paint surface being displayed */
	DynamicPaintSurface active();

};

/**************** Keyframe Points ****************/

/**
 * Collection of keyframe points
 */
class FCurveKeyframePoints : public pyUniplug {
public:
	FCurveKeyframePoints(PyObject* pyobj) : pyUniplug(pyobj) {}

	FCurveKeyframePoints() : pyUniplug(0)
	{
		// not implemented
	}

	/**
	 * Enum: items
	 */
	enum items {
		items_REPLACE = 16,	/**< Don't add any new keyframes, but just replace existing ones */
		items_NEEDED = 1,	/**< Only adds keyframes that are needed */
		items_FAST = 4	/**< Fast keyframe insertion to avoid recalculating the curve each time */
	};

	/**
	 * Add a keyframe point to a F-Curve
	 * @param X Value of this keyframe point
	 * @param Y Value of this keyframe point
	 * @param Keyframe options
	 * @return Newly created keyframe
	 */
	Keyframe insert(float frame, float value, items options);

	/**
	 * Add a keyframe point to a F-Curve
	 * @param Number of points to add to the spline
	 */
	void add(int count = 1)
	{
		// not implemented
	}

	/**
	 * Remove keyframe from an F-Curve
	 * @param Keyframe to remove
	 * @param Fast keyframe removal to avoid recalculating the curve each time
	 */
	void remove(Keyframe keyframe, bool fast = false);

};

/**************** F-Curve Modifiers ****************/

/**
 * Collection of F-Curve Modifiers
 */
class FCurveModifiers : public pyUniplug {
public:
	FCurveModifiers(PyObject* pyobj) : pyUniplug(pyobj) {}

	FCurveModifiers() : pyUniplug(0)
	{
		// not implemented
	}

	/** Getter: Active F-Curve Modifier */
	FModifier active();

	/**
	 * Enum: fmodifier_type_items
	 */
	enum fmodifier_type_items {
		fmodifier_type_items_NULL = 0,	
		fmodifier_type_items_GENERATOR = 1,	/**< Generate a curve using a factorized or expanded polynomial */
		fmodifier_type_items_FNGENERATOR = 2,	/**< Generate a curve using standard math functions such as sin and cos */
		fmodifier_type_items_ENVELOPE = 3,	/**< Reshape F-Curve values - e.g. change amplitude of movements */
		fmodifier_type_items_CYCLES = 4,	/**< Cyclic extend/repeat keyframe sequence */
		fmodifier_type_items_NOISE = 5,	/**< Add pseudo-random noise on top of F-Curves */
		fmodifier_type_items_PYTHON = 7,	
		fmodifier_type_items_LIMITS = 8,	/**< Restrict maximum and minimum values of F-Curve */
		fmodifier_type_items_STEPPED = 9	/**< Snap values to nearest grid-step - e.g. for a stop-motion look */
	};

	/**
	 * Add a constraint to this object
	 * @return New fmodifier
	 * @param Constraint type to add
	 */
	FModifier create(fmodifier_type_items type);

	/**
	 * Remove a modifier from this F-Curve
	 * @param Removed modifier
	 */
	void remove(FModifier modifier);

};

/**************** ChannelDriver Variables ****************/

/**
 * Collection of channel driver Variables
 */
class ChannelDriverVariables : public pyUniplug {
public:
	ChannelDriverVariables(PyObject* pyobj) : pyUniplug(pyobj) {}

	ChannelDriverVariables() : pyUniplug(0)
	{
		// not implemented
	}

	/**
	 * Add a new variable for the driver
	 * @return Newly created Driver Variable
	 */
	DriverVariable create();

	/**
	 * Remove an existing variable from the driver
	 * @param Variable to remove from the driver
	 */
	void remove(DriverVariable variable);

};

/**************** Control Points ****************/

/**
 * Control points defining the shape of the envelope
 */
class FModifierEnvelopeControlPoints : public pyUniplug {
public:
	FModifierEnvelopeControlPoints(PyObject* pyobj) : pyUniplug(pyobj) {}

	FModifierEnvelopeControlPoints() : pyUniplug(0)
	{
		// not implemented
	}

	/**
	 * Add a control point to a FModifierEnvelope
	 * @param Frame to add this control-point
	 * @return Newly created control-point
	 */
	FModifierEnvelopeControlPoint add(float frame);

	/**
	 * Remove a control-point from an FModifierEnvelope
	 * @param Control-point to remove
	 */
	void remove(FModifierEnvelopeControlPoint point);

};

/**************** Grease Pencil Layers ****************/

/**
 * Collection of grease pencil layers
 */
class GreasePencilLayers : public pyUniplug {
public:
	GreasePencilLayers(PyObject* pyobj) : pyUniplug(pyobj) {}

	GreasePencilLayers() : pyUniplug(0)
	{
		// not implemented
	}

	/** Getter: Active grease pencil layer */
	GPencilLayer active();

	/** Getter: Index of active grease pencil layer */
	int active_index() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "active_index"));
	}

	/** Setter: Index of active grease pencil layer */
	void active_index(int value) {
		PyObject_SetAttrString(pyobjref, "active_index", Py_BuildValue("i", value));
	}

	/**
	 * Add a new grease pencil layer
	 * @param Name of the layer
	 * @param Set the newly created layer to the active layer
	 * @return The newly created layer
	 */
	GPencilLayer create(const std::string name, bool set_active = false);

	/**
	 * Remove a grease pencil layer
	 * @param The layer to remove
	 */
	void remove(GPencilLayer layer);

};

/**************** Grease Pencil Frames ****************/

/**
 * Collection of grease pencil frames
 */
class GPencilFrames : public pyUniplug {
public:
	GPencilFrames(PyObject* pyobj) : pyUniplug(pyobj) {}

	GPencilFrames() : pyUniplug(0)
	{
		// not implemented
	}

	/**
	 * Add a new grease pencil frame
	 * @param The frame on which this sketch appears
	 * @return The newly created frame
	 */
	GPencilFrame create(int frame_number);

	/**
	 * Remove a grease pencil frame
	 * @param The frame to remove
	 */
	void remove(GPencilFrame frame);

	/**
	 * Copy a grease pencil frame
	 * @param The source frame
	 * @return The newly copied frame
	 */
	GPencilFrame copy(GPencilFrame source);

};

/**************** Grease Pencil Frames ****************/

/**
 * Collection of grease pencil stroke
 */
class GPencilStrokes : public pyUniplug {
public:
	GPencilStrokes(PyObject* pyobj) : pyUniplug(pyobj) {}

	GPencilStrokes() : pyUniplug(0)
	{
		// not implemented
	}

	/**
	 * Add a new grease pencil stroke
	 * @return The newly created stroke
	 */
	GPencilStroke create();

	/**
	 * Remove a grease pencil stroke
	 * @param The stroke to remove
	 */
	void remove(GPencilStroke stroke);

};

/**************** Grease Pencil Stroke Points ****************/

/**
 * Collection of grease pencil stroke points
 */
class GPencilStrokePoints : public pyUniplug {
public:
	GPencilStrokePoints(PyObject* pyobj) : pyUniplug(pyobj) {}

	GPencilStrokePoints() : pyUniplug(0)
	{
		// not implemented
	}

	/**
	 * Add a new grease pencil stroke point
	 * @param Number of points to add to the stroke
	 */
	void add(int count = 1)
	{
		// not implemented
	}

	/**
	 * Remove a grease pencil stroke point
	 * @param point index
	 */
	void pop(int index = -1)
	{
		// not implemented
	}

};

/**************** Group Objects ****************/

/**
 * Collection of group objects
 */
class GroupObjects : public pyUniplug {
public:
	GroupObjects(PyObject* pyobj) : pyUniplug(pyobj) {}

	GroupObjects() : pyUniplug(0)
	{
		// not implemented
	}

	/**
	 * Add this object to a group
	 * @param Object to add
	 */
	void link(Object object_value);

	/**
	 * Remove this object to a group
	 * @param Object to remove
	 */
	void unlink(Object object_value);

};

/**************** Render Slots ****************/

/**
 * Collection of the render slots
 */
class RenderSlots : public pyUniplug {
public:
	RenderSlots(PyObject* pyobj) : pyUniplug(pyobj) {}

	RenderSlots() : pyUniplug(0)
	{
		// not implemented
	}

	/** Getter: Active render slot of the image */
	RenderSlot active();

	/** Getter: Index of an active render slot of the image */
	int active_index() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "active_index"));
	}

	/** Setter: Index of an active render slot of the image */
	void active_index(int value) {
		PyObject_SetAttrString(pyobjref, "active_index", Py_BuildValue("i", value));
	}

};

/**************** Texture Slots ****************/

/**
 * Collection of texture slots
 */
class LampTextureSlots : public pyUniplug {
public:
	LampTextureSlots(PyObject* pyobj) : pyUniplug(pyobj) {}

	LampTextureSlots() : pyUniplug(0)
	{
		// not implemented
	}

	/**
	 * Function: add
	 * @return The newly initialized mtex
	 */
	LampTextureSlot add();

	/**
	 * Function: create
	 * @param Slot index to initialize
	 * @return The newly initialized mtex
	 */
	LampTextureSlot create(int index);

	/**
	 * Function: clear
	 * @param Slot index to clear
	 */
	void clear(int index)
	{
		// not implemented
	}

};

/**************** Texture Slots ****************/

/**
 * Collection of texture slots
 */
class LineStyleTextureSlots : public pyUniplug {
public:
	LineStyleTextureSlots(PyObject* pyobj) : pyUniplug(pyobj) {}

	LineStyleTextureSlots() : pyUniplug(0)
	{
		// not implemented
	}

	/**
	 * Function: add
	 * @return The newly initialized mtex
	 */
	LineStyleTextureSlot add();

	/**
	 * Function: create
	 * @param Slot index to initialize
	 * @return The newly initialized mtex
	 */
	LineStyleTextureSlot create(int index);

	/**
	 * Function: clear
	 * @param Slot index to clear
	 */
	void clear(int index)
	{
		// not implemented
	}

};

/**************** Color Modifiers ****************/

/**
 * Color modifiers for changing line colors
 */
class LineStyleColorModifiers : public pyUniplug {
public:
	LineStyleColorModifiers(PyObject* pyobj) : pyUniplug(pyobj) {}

	LineStyleColorModifiers() : pyUniplug(0)
	{
		// not implemented
	}

	/**
	 * Enum: linestyle_color_modifier_type_items
	 */
	enum linestyle_color_modifier_type_items {
		linestyle_color_modifier_type_items_ALONG_STROKE = 1,	
		linestyle_color_modifier_type_items_DISTANCE_FROM_CAMERA = 2,	
		linestyle_color_modifier_type_items_DISTANCE_FROM_OBJECT = 3,	
		linestyle_color_modifier_type_items_MATERIAL = 4	
	};

	/**
	 * Add a color modifier to line style
	 * @param New name for the color modifier (not unique)
	 * @param Color modifier type to add
	 * @return Newly added color modifier
	 */
	LineStyleColorModifier create(const std::string name, linestyle_color_modifier_type_items type);

	/**
	 * Remove a color modifier from line style
	 * @param Color modifier to remove
	 */
	void remove(LineStyleColorModifier modifier);

};

/**************** Alpha Modifiers ****************/

/**
 * Alpha modifiers for changing line alphas
 */
class LineStyleAlphaModifiers : public pyUniplug {
public:
	LineStyleAlphaModifiers(PyObject* pyobj) : pyUniplug(pyobj) {}

	LineStyleAlphaModifiers() : pyUniplug(0)
	{
		// not implemented
	}

	/**
	 * Enum: linestyle_alpha_modifier_type_items
	 */
	enum linestyle_alpha_modifier_type_items {
		linestyle_alpha_modifier_type_items_ALONG_STROKE = 1,	
		linestyle_alpha_modifier_type_items_DISTANCE_FROM_CAMERA = 2,	
		linestyle_alpha_modifier_type_items_DISTANCE_FROM_OBJECT = 3,	
		linestyle_alpha_modifier_type_items_MATERIAL = 4	
	};

	/**
	 * Add a alpha modifier to line style
	 * @param New name for the alpha modifier (not unique)
	 * @param Alpha modifier type to add
	 * @return Newly added alpha modifier
	 */
	LineStyleAlphaModifier create(const std::string name, linestyle_alpha_modifier_type_items type);

	/**
	 * Remove a alpha modifier from line style
	 * @param Alpha modifier to remove
	 */
	void remove(LineStyleAlphaModifier modifier);

};

/**************** Thickness Modifiers ****************/

/**
 * Thickness modifiers for changing line thicknesss
 */
class LineStyleThicknessModifiers : public pyUniplug {
public:
	LineStyleThicknessModifiers(PyObject* pyobj) : pyUniplug(pyobj) {}

	LineStyleThicknessModifiers() : pyUniplug(0)
	{
		// not implemented
	}

	/**
	 * Enum: linestyle_thickness_modifier_type_items
	 */
	enum linestyle_thickness_modifier_type_items {
		linestyle_thickness_modifier_type_items_ALONG_STROKE = 1,	
		linestyle_thickness_modifier_type_items_CALLIGRAPHY = 13,	
		linestyle_thickness_modifier_type_items_DISTANCE_FROM_CAMERA = 2,	
		linestyle_thickness_modifier_type_items_DISTANCE_FROM_OBJECT = 3,	
		linestyle_thickness_modifier_type_items_MATERIAL = 4	
	};

	/**
	 * Add a thickness modifier to line style
	 * @param New name for the thickness modifier (not unique)
	 * @param Thickness modifier type to add
	 * @return Newly added thickness modifier
	 */
	LineStyleThicknessModifier create(const std::string name, linestyle_thickness_modifier_type_items type);

	/**
	 * Remove a thickness modifier from line style
	 * @param Thickness modifier to remove
	 */
	void remove(LineStyleThicknessModifier modifier);

};

/**************** Geometry Modifiers ****************/

/**
 * Geometry modifiers for changing line geometrys
 */
class LineStyleGeometryModifiers : public pyUniplug {
public:
	LineStyleGeometryModifiers(PyObject* pyobj) : pyUniplug(pyobj) {}

	LineStyleGeometryModifiers() : pyUniplug(0)
	{
		// not implemented
	}

	/**
	 * Enum: linestyle_geometry_modifier_type_items
	 */
	enum linestyle_geometry_modifier_type_items {
		linestyle_geometry_modifier_type_items_2D_OFFSET = 17,	
		linestyle_geometry_modifier_type_items_2D_TRANSFORM = 18,	
		linestyle_geometry_modifier_type_items_BACKBONE_STRETCHER = 11,	
		linestyle_geometry_modifier_type_items_BEZIER_CURVE = 6,	
		linestyle_geometry_modifier_type_items_BLUEPRINT = 16,	
		linestyle_geometry_modifier_type_items_GUIDING_LINES = 15,	
		linestyle_geometry_modifier_type_items_PERLIN_NOISE_1D = 9,	
		linestyle_geometry_modifier_type_items_PERLIN_NOISE_2D = 10,	
		linestyle_geometry_modifier_type_items_POLYGONIZATION = 14,	
		linestyle_geometry_modifier_type_items_SAMPLING = 5,	
		linestyle_geometry_modifier_type_items_SINUS_DISPLACEMENT = 7,	
		linestyle_geometry_modifier_type_items_SPATIAL_NOISE = 8,	
		linestyle_geometry_modifier_type_items_TIP_REMOVER = 12	
	};

	/**
	 * Add a geometry modifier to line style
	 * @param New name for the geometry modifier (not unique)
	 * @param Geometry modifier type to add
	 * @return Newly added geometry modifier
	 */
	LineStyleGeometryModifier create(const std::string name, linestyle_geometry_modifier_type_items type);

	/**
	 * Remove a geometry modifier from line style
	 * @param Geometry modifier to remove
	 */
	void remove(LineStyleGeometryModifier modifier);

};

/**************** Main Cameras ****************/

/**
 * Collection of cameras
 */
class BlendDataCameras : public pyUniplug {
public:
	BlendDataCameras(PyObject* pyobj) : pyUniplug(pyobj) {}

	BlendDataCameras() : pyUniplug(0)
	{
		// not implemented
	}

	/** Getter:  */
	bool is_updated() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "is_updated")) == 1;
	}

	/** Setter:  */
	void is_updated(bool value) {
		PyObject_SetAttrString(pyobjref, "is_updated", Py_BuildValue("i", value));
	}

	/**
	 * Add a new camera to the main database
	 * @param New name for the datablock
	 * @return New camera datablock
	 */
	Camera create(const std::string name);

	/**
	 * Remove a camera from the current blendfile
	 * @param Camera to remove
	 */
	void remove(Camera camera);

	/**
	 * Function: tag
	 * @param Param 'value'
	 */
	void tag(bool value)
	{
		// not implemented
	}

};

/**************** Main Scenes ****************/

/**
 * Collection of scenes
 */
class BlendDataScenes : public pyUniplug {
public:
	BlendDataScenes(PyObject* pyobj) : pyUniplug(pyobj) {}

	BlendDataScenes() : pyUniplug(0)
	{
		// not implemented
	}

	/** Getter:  */
	bool is_updated() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "is_updated")) == 1;
	}

	/** Setter:  */
	void is_updated(bool value) {
		PyObject_SetAttrString(pyobjref, "is_updated", Py_BuildValue("i", value));
	}

	/**
	 * Add a new scene to the main database
	 * @param New name for the datablock
	 * @return New scene datablock
	 */
	Scene create(const std::string name);

	/**
	 * Remove a scene from the current blendfile
	 * @param Scene to remove
	 */
	void remove(Scene scene);

	/**
	 * Function: tag
	 * @param Param 'value'
	 */
	void tag(bool value)
	{
		// not implemented
	}

};

/**************** Main Objects ****************/

/**
 * Collection of objects
 */
class BlendDataObjects : public pyUniplug {
public:
	BlendDataObjects(PyObject* pyobj) : pyUniplug(pyobj) {}

	BlendDataObjects() : pyUniplug(0)
	{
		// not implemented
	}

	/** Getter:  */
	bool is_updated() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "is_updated")) == 1;
	}

	/** Setter:  */
	void is_updated(bool value) {
		PyObject_SetAttrString(pyobjref, "is_updated", Py_BuildValue("i", value));
	}

	/**
	 * Add a new object to the main database
	 * @param New name for the datablock
	 * @param Object data or None for an empty object
	 * @return New object datablock
	 */
	Object create(const std::string name, ID object_data);

	/**
	 * Remove a object from the current blendfile
	 * @param Object to remove
	 */
	void remove(Object object_value);

	/**
	 * Function: tag
	 * @param Param 'value'
	 */
	void tag(bool value)
	{
		// not implemented
	}

};

/**************** Main Materials ****************/

/**
 * Collection of materials
 */
class BlendDataMaterials : public pyUniplug {
public:
	BlendDataMaterials(PyObject* pyobj) : pyUniplug(pyobj) {}

	BlendDataMaterials() : pyUniplug(0)
	{
		// not implemented
	}

	/** Getter:  */
	bool is_updated() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "is_updated")) == 1;
	}

	/** Setter:  */
	void is_updated(bool value) {
		PyObject_SetAttrString(pyobjref, "is_updated", Py_BuildValue("i", value));
	}

	/**
	 * Add a new material to the main database
	 * @param New name for the datablock
	 * @return New material datablock
	 */
	Material create(const std::string name);

	/**
	 * Remove a material from the current blendfile
	 * @param Material to remove
	 */
	void remove(Material material);

	/**
	 * Function: tag
	 * @param Param 'value'
	 */
	void tag(bool value)
	{
		// not implemented
	}

};

/**************** Main Node Trees ****************/

/**
 * Collection of node trees
 */
class BlendDataNodeTrees : public pyUniplug {
public:
	BlendDataNodeTrees(PyObject* pyobj) : pyUniplug(pyobj) {}

	BlendDataNodeTrees() : pyUniplug(0)
	{
		// not implemented
	}

	/** Getter:  */
	bool is_updated() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "is_updated")) == 1;
	}

	/** Setter:  */
	void is_updated(bool value) {
		PyObject_SetAttrString(pyobjref, "is_updated", Py_BuildValue("i", value));
	}

	/**
	 * Enum: dummy_items
	 */
	enum dummy_items {
		dummy_items_DUMMY = 0	
	};

	/**
	 * Add a new node tree to the main database
	 * @param New name for the datablock
	 * @param The type of node_group to add
	 * @return New node tree datablock
	 */
	NodeTree create(const std::string name, dummy_items type);

	/**
	 * Remove a node tree from the current blendfile
	 * @param Node tree to remove
	 */
	void remove(NodeTree tree);

	/**
	 * Function: tag
	 * @param Param 'value'
	 */
	void tag(bool value)
	{
		// not implemented
	}

};

/**************** Main Meshes ****************/

/**
 * Collection of meshes
 */
class BlendDataMeshes : public pyUniplug {
public:
	BlendDataMeshes(PyObject* pyobj) : pyUniplug(pyobj) {}

	BlendDataMeshes() : pyUniplug(0)
	{
		// not implemented
	}

	/** Getter:  */
	bool is_updated() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "is_updated")) == 1;
	}

	/** Setter:  */
	void is_updated(bool value) {
		PyObject_SetAttrString(pyobjref, "is_updated", Py_BuildValue("i", value));
	}

	/**
	 * Add a new mesh to the main database
	 * @param New name for the datablock
	 * @return New mesh datablock
	 */
	Mesh create(const std::string name);

	/**
	 * Enum: mesh_type_items
	 */
	enum mesh_type_items {
		mesh_type_items_PREVIEW = 1,	/**< Apply modifier preview settings */
		mesh_type_items_RENDER = 2	/**< Apply modifier render settings */
	};

	/**
	 * Add a new mesh created from object with modifiers applied
	 * @param Scene within which to evaluate modifiers
	 * @param Object to create mesh from
	 * @param Apply modifiers
	 * @param Modifier settings to apply
	 * @param Calculate tessellation faces
	 * @param Calculate undeformed vertex coordinates
	 * @return Mesh created from object, remove it if it is only used for export
	 */
	Mesh new_from_object(Scene scene, Object object_value, bool apply_modifiers, mesh_type_items settings, bool calc_tessface = true, bool calc_undeformed = false);

	/**
	 * Remove a mesh from the current blendfile
	 * @param Mesh to remove
	 */
	void remove(Mesh mesh);

	/**
	 * Function: tag
	 * @param Param 'value'
	 */
	void tag(bool value)
	{
		// not implemented
	}

};

/**************** Main Lamps ****************/

/**
 * Collection of lamps
 */
class BlendDataLamps : public pyUniplug {
public:
	BlendDataLamps(PyObject* pyobj) : pyUniplug(pyobj) {}

	BlendDataLamps() : pyUniplug(0)
	{
		// not implemented
	}

	/** Getter:  */
	bool is_updated() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "is_updated")) == 1;
	}

	/** Setter:  */
	void is_updated(bool value) {
		PyObject_SetAttrString(pyobjref, "is_updated", Py_BuildValue("i", value));
	}

	/**
	 * Enum: lamp_type_items
	 */
	enum lamp_type_items {
		lamp_type_items_POINT = 0,	/**< Omnidirectional point light source */
		lamp_type_items_SUN = 1,	/**< Constant direction parallel ray light source */
		lamp_type_items_SPOT = 2,	/**< Directional cone light source */
		lamp_type_items_HEMI = 3,	/**< 180 degree constant light source */
		lamp_type_items_AREA = 4	/**< Directional area light source */
	};

	/**
	 * Add a new lamp to the main database
	 * @param New name for the datablock
	 * @param The type of texture to add
	 * @return New lamp datablock
	 */
	Lamp create(const std::string name, lamp_type_items type);

	/**
	 * Remove a lamp from the current blendfile
	 * @param Lamp to remove
	 */
	void remove(Lamp lamp);

	/**
	 * Function: tag
	 * @param Param 'value'
	 */
	void tag(bool value)
	{
		// not implemented
	}

};

/**************** Main Libraries ****************/

/**
 * Collection of libraries
 */
class BlendDataLibraries : public pyUniplug {
public:
	BlendDataLibraries(PyObject* pyobj) : pyUniplug(pyobj) {}

	BlendDataLibraries() : pyUniplug(0)
	{
		// not implemented
	}

	/** Getter:  */
	bool is_updated() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "is_updated")) == 1;
	}

	/** Setter:  */
	void is_updated(bool value) {
		PyObject_SetAttrString(pyobjref, "is_updated", Py_BuildValue("i", value));
	}

	/**
	 * Function: tag
	 * @param Param 'value'
	 */
	void tag(bool value)
	{
		// not implemented
	}

};

/**************** Main Screens ****************/

/**
 * Collection of screens
 */
class BlendDataScreens : public pyUniplug {
public:
	BlendDataScreens(PyObject* pyobj) : pyUniplug(pyobj) {}

	BlendDataScreens() : pyUniplug(0)
	{
		// not implemented
	}

	/** Getter:  */
	bool is_updated() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "is_updated")) == 1;
	}

	/** Setter:  */
	void is_updated(bool value) {
		PyObject_SetAttrString(pyobjref, "is_updated", Py_BuildValue("i", value));
	}

	/**
	 * Function: tag
	 * @param Param 'value'
	 */
	void tag(bool value)
	{
		// not implemented
	}

};

/**************** Main Window Managers ****************/

/**
 * Collection of window managers
 */
class BlendDataWindowManagers : public pyUniplug {
public:
	BlendDataWindowManagers(PyObject* pyobj) : pyUniplug(pyobj) {}

	BlendDataWindowManagers() : pyUniplug(0)
	{
		// not implemented
	}

	/** Getter:  */
	bool is_updated() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "is_updated")) == 1;
	}

	/** Setter:  */
	void is_updated(bool value) {
		PyObject_SetAttrString(pyobjref, "is_updated", Py_BuildValue("i", value));
	}

	/**
	 * Function: tag
	 * @param Param 'value'
	 */
	void tag(bool value)
	{
		// not implemented
	}

};

/**************** Main Images ****************/

/**
 * Collection of images
 */
class BlendDataImages : public pyUniplug {
public:
	BlendDataImages(PyObject* pyobj) : pyUniplug(pyobj) {}

	BlendDataImages() : pyUniplug(0)
	{
		// not implemented
	}

	/** Getter:  */
	bool is_updated() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "is_updated")) == 1;
	}

	/** Setter:  */
	void is_updated(bool value) {
		PyObject_SetAttrString(pyobjref, "is_updated", Py_BuildValue("i", value));
	}

	/**
	 * Add a new image to the main database
	 * @param New name for the datablock
	 * @param Width of the image
	 * @param Height of the image
	 * @param Use alpha channel
	 * @param Create an image with floating point color
	 * @param Create left and right views
	 * @return New image datablock
	 */
	Image create(const std::string name, int width, int height, bool alpha = false, bool float_buffer = false, bool stereo3d = false);

	/**
	 * Load a new image into the main database
	 * @param path of the file to load
	 * @return New image datablock
	 */
	Image load(const std::string filepath);

	/**
	 * Remove an image from the current blendfile
	 * @param Image to remove
	 */
	void remove(Image image);

	/**
	 * Function: tag
	 * @param Param 'value'
	 */
	void tag(bool value)
	{
		// not implemented
	}

};

/**************** Main Lattices ****************/

/**
 * Collection of lattices
 */
class BlendDataLattices : public pyUniplug {
public:
	BlendDataLattices(PyObject* pyobj) : pyUniplug(pyobj) {}

	BlendDataLattices() : pyUniplug(0)
	{
		// not implemented
	}

	/** Getter:  */
	bool is_updated() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "is_updated")) == 1;
	}

	/** Setter:  */
	void is_updated(bool value) {
		PyObject_SetAttrString(pyobjref, "is_updated", Py_BuildValue("i", value));
	}

	/**
	 * Add a new lattice to the main database
	 * @param New name for the datablock
	 * @return New lattices datablock
	 */
	Lattice create(const std::string name);

	/**
	 * Remove a lattice from the current blendfile
	 * @param Lattice to remove
	 */
	void remove(Lattice lattice);

	/**
	 * Function: tag
	 * @param Param 'value'
	 */
	void tag(bool value)
	{
		// not implemented
	}

};

/**************** Main Curves ****************/

/**
 * Collection of curves
 */
class BlendDataCurves : public pyUniplug {
public:
	BlendDataCurves(PyObject* pyobj) : pyUniplug(pyobj) {}

	BlendDataCurves() : pyUniplug(0)
	{
		// not implemented
	}

	/** Getter:  */
	bool is_updated() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "is_updated")) == 1;
	}

	/** Setter:  */
	void is_updated(bool value) {
		PyObject_SetAttrString(pyobjref, "is_updated", Py_BuildValue("i", value));
	}

	/**
	 * Enum: object_type_curve_items
	 */
	enum object_type_curve_items {
		object_type_curve_items_CURVE = 2,	
		object_type_curve_items_SURFACE = 3,	
		object_type_curve_items_FONT = 4	
	};

	/**
	 * Add a new curve to the main database
	 * @param New name for the datablock
	 * @param The type of curve to add
	 * @return New curve datablock
	 */
	Curve create(const std::string name, object_type_curve_items type);

	/**
	 * Remove a curve from the current blendfile
	 * @param Curve to remove
	 */
	void remove(Curve curve);

	/**
	 * Function: tag
	 * @param Param 'value'
	 */
	void tag(bool value)
	{
		// not implemented
	}

};

/**************** Main Metaballs ****************/

/**
 * Collection of metaballs
 */
class BlendDataMetaBalls : public pyUniplug {
public:
	BlendDataMetaBalls(PyObject* pyobj) : pyUniplug(pyobj) {}

	BlendDataMetaBalls() : pyUniplug(0)
	{
		// not implemented
	}

	/** Getter:  */
	bool is_updated() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "is_updated")) == 1;
	}

	/** Setter:  */
	void is_updated(bool value) {
		PyObject_SetAttrString(pyobjref, "is_updated", Py_BuildValue("i", value));
	}

	/**
	 * Add a new metaball to the main database
	 * @param New name for the datablock
	 * @return New metaball datablock
	 */
	MetaBall create(const std::string name);

	/**
	 * Remove a metaball from the current blendfile
	 * @param Metaball to remove
	 */
	void remove(MetaBall metaball);

	/**
	 * Function: tag
	 * @param Param 'value'
	 */
	void tag(bool value)
	{
		// not implemented
	}

};

/**************** Main Fonts ****************/

/**
 * Collection of fonts
 */
class BlendDataFonts : public pyUniplug {
public:
	BlendDataFonts(PyObject* pyobj) : pyUniplug(pyobj) {}

	BlendDataFonts() : pyUniplug(0)
	{
		// not implemented
	}

	/** Getter:  */
	bool is_updated() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "is_updated")) == 1;
	}

	/** Setter:  */
	void is_updated(bool value) {
		PyObject_SetAttrString(pyobjref, "is_updated", Py_BuildValue("i", value));
	}

	/**
	 * Load a new font into the main database
	 * @param path of the font to load
	 * @return New font datablock
	 */
	VectorFont load(const std::string filepath);

	/**
	 * Remove a font from the current blendfile
	 * @param Font to remove
	 */
	void remove(VectorFont vfont);

	/**
	 * Function: tag
	 * @param Param 'value'
	 */
	void tag(bool value)
	{
		// not implemented
	}

};

/**************** Main Textures ****************/

/**
 * Collection of groups
 */
class BlendDataTextures : public pyUniplug {
public:
	BlendDataTextures(PyObject* pyobj) : pyUniplug(pyobj) {}

	BlendDataTextures() : pyUniplug(0)
	{
		// not implemented
	}

	/** Getter:  */
	bool is_updated() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "is_updated")) == 1;
	}

	/** Setter:  */
	void is_updated(bool value) {
		PyObject_SetAttrString(pyobjref, "is_updated", Py_BuildValue("i", value));
	}

	/**
	 * Enum: texture_type_items
	 */
	enum texture_type_items {
		texture_type_items_NONE = 0,	
		texture_type_items_BLEND = 5,	/**< Procedural - create a ramp texture */
		texture_type_items_CLOUDS = 1,	/**< Procedural - create a cloud-like fractal noise texture */
		texture_type_items_DISTORTED_NOISE = 13,	/**< Procedural - noise texture distorted by two noise algorithms */
		texture_type_items_ENVIRONMENT_MAP = 10,	/**< Create a render of the environment mapped to a texture */
		texture_type_items_IMAGE = 8,	/**< Allow for images or movies to be used as textures */
		texture_type_items_MAGIC = 4,	/**< Procedural - color texture based on trigonometric functions */
		texture_type_items_MARBLE = 3,	/**< Procedural - marble-like noise texture with wave generated bands */
		texture_type_items_MUSGRAVE = 11,	/**< Procedural - highly flexible fractal noise texture */
		texture_type_items_NOISE = 7,	/**< Procedural - random noise, gives a different result every time, for every frame, for every pixel */
		texture_type_items_OCEAN = 16,	/**< Use a texture generated by an Ocean modifier */
		texture_type_items_POINT_DENSITY = 14,	
		texture_type_items_STUCCI = 6,	/**< Procedural - create a fractal noise texture */
		texture_type_items_VORONOI = 12,	/**< Procedural - create cell-like patterns based on Worley noise */
		texture_type_items_VOXEL_DATA = 15,	/**< Create a 3D texture based on volumetric data */
		texture_type_items_WOOD = 2	/**< Procedural - wave generated bands or rings, with optional noise */
	};

	/**
	 * Add a new texture to the main database
	 * @param New name for the datablock
	 * @param The type of texture to add
	 * @return New texture datablock
	 */
	Texture create(const std::string name, texture_type_items type)
	{
		// not implemented
		return Texture();
	}

	/**
	 * Remove a texture from the current blendfile
	 * @param Texture to remove
	 */
	void remove(Texture texture)
	{
		// not implemented
	}

	/**
	 * Function: tag
	 * @param Param 'value'
	 */
	void tag(bool value)
	{
		// not implemented
	}

};

/**************** Main Brushes ****************/

/**
 * Collection of brushes
 */
class BlendDataBrushes : public pyUniplug {
public:
	BlendDataBrushes(PyObject* pyobj) : pyUniplug(pyobj) {}

	BlendDataBrushes() : pyUniplug(0)
	{
		// not implemented
	}

	/** Getter:  */
	bool is_updated() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "is_updated")) == 1;
	}

	/** Setter:  */
	void is_updated(bool value) {
		PyObject_SetAttrString(pyobjref, "is_updated", Py_BuildValue("i", value));
	}

	/**
	 * Add a new brush to the main database
	 * @param New name for the datablock
	 * @return New brush datablock
	 */
	Brush create(const std::string name);

	/**
	 * Remove a brush from the current blendfile
	 * @param Brush to remove
	 */
	void remove(Brush brush);

	/**
	 * Function: tag
	 * @param Param 'value'
	 */
	void tag(bool value)
	{
		// not implemented
	}

};

/**************** Main Worlds ****************/

/**
 * Collection of worlds
 */
class BlendDataWorlds : public pyUniplug {
public:
	BlendDataWorlds(PyObject* pyobj) : pyUniplug(pyobj) {}

	BlendDataWorlds() : pyUniplug(0)
	{
		// not implemented
	}

	/** Getter:  */
	bool is_updated() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "is_updated")) == 1;
	}

	/** Setter:  */
	void is_updated(bool value) {
		PyObject_SetAttrString(pyobjref, "is_updated", Py_BuildValue("i", value));
	}

	/**
	 * Add a new world to the main database
	 * @param New name for the datablock
	 * @return New world datablock
	 */
	World create(const std::string name);

	/**
	 * Remove a world from the current blendfile
	 * @param World to remove
	 */
	void remove(World world);

	/**
	 * Function: tag
	 * @param Param 'value'
	 */
	void tag(bool value)
	{
		// not implemented
	}

};

/**************** Main Groups ****************/

/**
 * Collection of groups
 */
class BlendDataGroups : public pyUniplug {
public:
	BlendDataGroups(PyObject* pyobj) : pyUniplug(pyobj) {}

	BlendDataGroups() : pyUniplug(0)
	{
		// not implemented
	}

	/** Getter:  */
	bool is_updated() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "is_updated")) == 1;
	}

	/** Setter:  */
	void is_updated(bool value) {
		PyObject_SetAttrString(pyobjref, "is_updated", Py_BuildValue("i", value));
	}

	/**
	 * Add a new group to the main database
	 * @param New name for the datablock
	 * @return New group datablock
	 */
	Group create(const std::string name);

	/**
	 * Remove a group from the current blendfile
	 * @param Group to remove
	 */
	void remove(Group group);

	/**
	 * Function: tag
	 * @param Param 'value'
	 */
	void tag(bool value)
	{
		// not implemented
	}

};

/**************** Main Texts ****************/

/**
 * Collection of texts
 */
class BlendDataTexts : public pyUniplug {
public:
	BlendDataTexts(PyObject* pyobj) : pyUniplug(pyobj) {}

	BlendDataTexts() : pyUniplug(0)
	{
		// not implemented
	}

	/** Getter:  */
	bool is_updated() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "is_updated")) == 1;
	}

	/** Setter:  */
	void is_updated(bool value) {
		PyObject_SetAttrString(pyobjref, "is_updated", Py_BuildValue("i", value));
	}

	/**
	 * Add a new text to the main database
	 * @param New name for the datablock
	 * @return New text datablock
	 */
	Text create(const std::string name);

	/**
	 * Remove a text from the current blendfile
	 * @param Text to remove
	 */
	void remove(Text text);

	/**
	 * Add a new text to the main database from a file
	 * @param path for the datablock
	 * @param Make text file internal after loading
	 * @return New text datablock
	 */
	Text load(const std::string filepath, bool internal = false);

	/**
	 * Function: tag
	 * @param Param 'value'
	 */
	void tag(bool value)
	{
		// not implemented
	}

};

/**************** Main Speakers ****************/

/**
 * Collection of speakers
 */
class BlendDataSpeakers : public pyUniplug {
public:
	BlendDataSpeakers(PyObject* pyobj) : pyUniplug(pyobj) {}

	BlendDataSpeakers() : pyUniplug(0)
	{
		// not implemented
	}

	/** Getter:  */
	bool is_updated() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "is_updated")) == 1;
	}

	/** Setter:  */
	void is_updated(bool value) {
		PyObject_SetAttrString(pyobjref, "is_updated", Py_BuildValue("i", value));
	}

	/**
	 * Add a new speaker to the main database
	 * @param New name for the datablock
	 * @return New speaker datablock
	 */
	Speaker create(const std::string name);

	/**
	 * Remove a speaker from the current blendfile
	 * @param Speaker to remove
	 */
	void remove(Speaker speaker);

	/**
	 * Function: tag
	 * @param Param 'value'
	 */
	void tag(bool value)
	{
		// not implemented
	}

};

/**************** Main Sounds ****************/

/**
 * Collection of sounds
 */
class BlendDataSounds : public pyUniplug {
public:
	BlendDataSounds(PyObject* pyobj) : pyUniplug(pyobj) {}

	BlendDataSounds() : pyUniplug(0)
	{
		// not implemented
	}

	/** Getter:  */
	bool is_updated() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "is_updated")) == 1;
	}

	/** Setter:  */
	void is_updated(bool value) {
		PyObject_SetAttrString(pyobjref, "is_updated", Py_BuildValue("i", value));
	}

	/**
	 * Add a new sound to the main database from a file
	 * @param path for the datablock
	 * @return New text datablock
	 */
	Sound load(const std::string filepath);

	/**
	 * Remove a sound from the current blendfile
	 * @param Sound to remove
	 */
	void remove(Sound sound);

	/**
	 * Function: tag
	 * @param Param 'value'
	 */
	void tag(bool value)
	{
		// not implemented
	}

};

/**************** Main Armatures ****************/

/**
 * Collection of armatures
 */
class BlendDataArmatures : public pyUniplug {
public:
	BlendDataArmatures(PyObject* pyobj) : pyUniplug(pyobj) {}

	BlendDataArmatures() : pyUniplug(0)
	{
		// not implemented
	}

	/** Getter:  */
	bool is_updated() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "is_updated")) == 1;
	}

	/** Setter:  */
	void is_updated(bool value) {
		PyObject_SetAttrString(pyobjref, "is_updated", Py_BuildValue("i", value));
	}

	/**
	 * Add a new armature to the main database
	 * @param New name for the datablock
	 * @return New armature datablock
	 */
	Armature create(const std::string name);

	/**
	 * Remove a armature from the current blendfile
	 * @param Armature to remove
	 */
	void remove(Armature armature);

	/**
	 * Function: tag
	 * @param Param 'value'
	 */
	void tag(bool value)
	{
		// not implemented
	}

};

/**************** Main Actions ****************/

/**
 * Collection of actions
 */
class BlendDataActions : public pyUniplug {
public:
	BlendDataActions(PyObject* pyobj) : pyUniplug(pyobj) {}

	BlendDataActions() : pyUniplug(0)
	{
		// not implemented
	}

	/** Getter:  */
	bool is_updated() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "is_updated")) == 1;
	}

	/** Setter:  */
	void is_updated(bool value) {
		PyObject_SetAttrString(pyobjref, "is_updated", Py_BuildValue("i", value));
	}

	/**
	 * Add a new action to the main database
	 * @param New name for the datablock
	 * @return New action datablock
	 */
	Action create(const std::string name);

	/**
	 * Remove a action from the current blendfile
	 * @param Action to remove
	 */
	void remove(Action action);

	/**
	 * Function: tag
	 * @param Param 'value'
	 */
	void tag(bool value)
	{
		// not implemented
	}

};

/**************** Main Particle Settings ****************/

/**
 * Collection of particle settings
 */
class BlendDataParticles : public pyUniplug {
public:
	BlendDataParticles(PyObject* pyobj) : pyUniplug(pyobj) {}

	BlendDataParticles() : pyUniplug(0)
	{
		// not implemented
	}

	/** Getter:  */
	bool is_updated() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "is_updated")) == 1;
	}

	/** Setter:  */
	void is_updated(bool value) {
		PyObject_SetAttrString(pyobjref, "is_updated", Py_BuildValue("i", value));
	}

	/**
	 * Add a new particle settings instance to the main database
	 * @param New name for the datablock
	 * @return New particle settings datablock
	 */
	ParticleSettings create(const std::string name);

	/**
	 * Remove a particle settings instance from the current blendfile
	 * @param Particle Settings to remove
	 */
	void remove(ParticleSettings particle);

	/**
	 * Function: tag
	 * @param Param 'value'
	 */
	void tag(bool value)
	{
		// not implemented
	}

};

/**************** Main Palettes ****************/

/**
 * Collection of palettes
 */
class BlendDataPalettes : public pyUniplug {
public:
	BlendDataPalettes(PyObject* pyobj) : pyUniplug(pyobj) {}

	BlendDataPalettes() : pyUniplug(0)
	{
		// not implemented
	}

	/** Getter:  */
	bool is_updated() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "is_updated")) == 1;
	}

	/** Setter:  */
	void is_updated(bool value) {
		PyObject_SetAttrString(pyobjref, "is_updated", Py_BuildValue("i", value));
	}

	/**
	 * Add a new palette to the main database
	 * @param New name for the datablock
	 * @return New palette datablock
	 */
	Palette create(const std::string name);

	/**
	 * Remove a palette from the current blendfile
	 * @param Palette to remove
	 */
	void remove(Palette palette);

	/**
	 * Function: tag
	 * @param Param 'value'
	 */
	void tag(bool value)
	{
		// not implemented
	}

};

/**************** Main Grease Pencils ****************/

/**
 * Collection of grease pencils
 */
class BlendDataGreasePencils : public pyUniplug {
public:
	BlendDataGreasePencils(PyObject* pyobj) : pyUniplug(pyobj) {}

	BlendDataGreasePencils() : pyUniplug(0)
	{
		// not implemented
	}

	/** Getter:  */
	bool is_updated() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "is_updated")) == 1;
	}

	/** Setter:  */
	void is_updated(bool value) {
		PyObject_SetAttrString(pyobjref, "is_updated", Py_BuildValue("i", value));
	}

	/**
	 * Function: tag
	 * @param Param 'value'
	 */
	void tag(bool value)
	{
		// not implemented
	}

	/**
	 * Function: create
	 * @param New name for the datablock
	 * @return New grease pencil datablock
	 */
	GreasePencil create(const std::string name);

	/**
	 * Remove a grease pencil instance from the current blendfile
	 * @param Grease Pencil to remove
	 */
	void remove(GreasePencil grease_pencil);

};

/**************** Main Movie Clips ****************/

/**
 * Collection of movie clips
 */
class BlendDataMovieClips : public pyUniplug {
public:
	BlendDataMovieClips(PyObject* pyobj) : pyUniplug(pyobj) {}

	BlendDataMovieClips() : pyUniplug(0)
	{
		// not implemented
	}

	/**
	 * Function: tag
	 * @param Param 'value'
	 */
	void tag(bool value)
	{
		// not implemented
	}

	/**
	 * Remove a movie clip from the current blendfile.
	 * @param Movie clip to remove
	 */
	void remove(MovieClip clip);

	/**
	 * Add a new movie clip to the main database from a file
	 * @param path for the datablock
	 * @return New movie clip datablock
	 */
	MovieClip load(const std::string filepath);

};

/**************** Main Masks ****************/

/**
 * Collection of masks
 */
class BlendDataMasks : public pyUniplug {
public:
	BlendDataMasks(PyObject* pyobj) : pyUniplug(pyobj) {}

	BlendDataMasks() : pyUniplug(0)
	{
		// not implemented
	}

	/**
	 * Function: tag
	 * @param Param 'value'
	 */
	void tag(bool value)
	{
		// not implemented
	}

	/**
	 * Add a new mask with a given name to the main database
	 * @param Name of new mask datablock
	 * @return New mask datablock
	 */
	Mask create(const std::string name = NULL);

	/**
	 * Remove a masks from the current blendfile.
	 * @param Mask to remove
	 */
	void remove(Mask mask);

};

/**************** Main Line Styles ****************/

/**
 * Collection of line styles
 */
class BlendDataLineStyles : public pyUniplug {
public:
	BlendDataLineStyles(PyObject* pyobj) : pyUniplug(pyobj) {}

	BlendDataLineStyles() : pyUniplug(0)
	{
		// not implemented
	}

	/** Getter:  */
	bool is_updated() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "is_updated")) == 1;
	}

	/** Setter:  */
	void is_updated(bool value) {
		PyObject_SetAttrString(pyobjref, "is_updated", Py_BuildValue("i", value));
	}

	/**
	 * Function: tag
	 * @param Param 'value'
	 */
	void tag(bool value)
	{
		// not implemented
	}

	/**
	 * Add a new line style instance to the main database
	 * @param New name for the datablock
	 * @return New line style datablock
	 */
	FreestyleLineStyle create(const std::string name);

	/**
	 * Remove a line style instance from the current blendfile
	 * @param Line style to remove
	 */
	void remove(FreestyleLineStyle linestyle);

};

/**************** Texture Slots ****************/

/**
 * Collection of texture slots
 */
class MaterialTextureSlots : public pyUniplug {
public:
	MaterialTextureSlots(PyObject* pyobj) : pyUniplug(pyobj) {}

	MaterialTextureSlots() : pyUniplug(0)
	{
		// not implemented
	}

	/**
	 * Function: add
	 * @return The newly initialized mtex
	 */
	MaterialTextureSlot add();

	/**
	 * Function: create
	 * @param Slot index to initialize
	 * @return The newly initialized mtex
	 */
	MaterialTextureSlot create(int index);

	/**
	 * Function: clear
	 * @param Slot index to clear
	 */
	void clear(int index)
	{
		// not implemented
	}

};

/**************** Mesh Vertices ****************/

/**
 * Collection of mesh vertices
 */
class MeshVertices : public pyUniplug {
public:
	MeshVertices(PyObject* pyobj) : pyUniplug(pyobj) {}

	MeshVertices() : pyUniplug(0)
	{
		// not implemented
	}

	/**
	 * Function: add
	 * @param Number of vertices to add
	 */
	void add(int count = 0)
	{
		// not implemented
	}

};

/**************** Mesh Edges ****************/

/**
 * Collection of mesh edges
 */
class MeshEdges : public pyUniplug {
public:
	MeshEdges(PyObject* pyobj) : pyUniplug(pyobj) {}

	MeshEdges() : pyUniplug(0)
	{
		// not implemented
	}

	/**
	 * Function: add
	 * @param Number of edges to add
	 */
	void add(int count = 0)
	{
		// not implemented
	}

};

/**************** Mesh Faces ****************/

/**
 * Collection of mesh faces
 */
class MeshTessFaces : public pyUniplug {
public:
	MeshTessFaces(PyObject* pyobj) : pyUniplug(pyobj) {}

	MeshTessFaces() : pyUniplug(0)
	{
		// not implemented
	}

	/** Getter: The active face for this mesh */
	int active() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "active"));
	}

	/** Setter: The active face for this mesh */
	void active(int value) {
		PyObject_SetAttrString(pyobjref, "active", Py_BuildValue("i", value));
	}

	/**
	 * Function: add
	 * @param Number of faces to add
	 */
	void add(int count = 0)
	{
		// not implemented
	}

};

/**************** Mesh Loops ****************/

/**
 * Collection of mesh loops
 */
class MeshLoops : public pyUniplug {
public:
	MeshLoops(PyObject* pyobj) : pyUniplug(pyobj) {}

	MeshLoops() : pyUniplug(0)
	{
		// not implemented
	}

	/**
	 * Function: add
	 * @param Number of loops to add
	 */
	void add(int count = 0)
	{
		// not implemented
	}

};

/**************** Mesh Polygons ****************/

/**
 * Collection of mesh polygons
 */
class MeshPolygons : public pyUniplug {
public:
	MeshPolygons(PyObject* pyobj) : pyUniplug(pyobj) {}

	MeshPolygons() : pyUniplug(0)
	{
		// not implemented
	}

	/** Getter: The active polygon for this mesh */
	int active() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "active"));
	}

	/** Setter: The active polygon for this mesh */
	void active(int value) {
		PyObject_SetAttrString(pyobjref, "active", Py_BuildValue("i", value));
	}

	/**
	 * Function: add
	 * @param Number of polygons to add
	 */
	void add(int count = 0)
	{
		// not implemented
	}

};

/**************** UV Loop Layers ****************/

/**
 * Collection of uv loop layers
 */
class UVLoopLayers : public pyUniplug {
public:
	UVLoopLayers(PyObject* pyobj) : pyUniplug(pyobj) {}

	UVLoopLayers() : pyUniplug(0)
	{
		// not implemented
	}

	/** Getter: Active UV loop layer */
	MeshUVLoopLayer active();

	/** Getter: Active UV loop layer index */
	int active_index() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "active_index"));
	}

	/** Setter: Active UV loop layer index */
	void active_index(int value) {
		PyObject_SetAttrString(pyobjref, "active_index", Py_BuildValue("i", value));
	}

};

/**************** UV Maps ****************/

/**
 * Collection of UV maps for tessellated faces
 */
class TessfaceUVTextures : public pyUniplug {
public:
	TessfaceUVTextures(PyObject* pyobj) : pyUniplug(pyobj) {}

	TessfaceUVTextures() : pyUniplug(0)
	{
		// not implemented
	}

	/** Getter: Active UV Map */
	MeshTextureFaceLayer active();

	/** Getter: Active UV Map index */
	int active_index() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "active_index"));
	}

	/** Setter: Active UV Map index */
	void active_index(int value) {
		PyObject_SetAttrString(pyobjref, "active_index", Py_BuildValue("i", value));
	}

	/**
	 * Add a UV tessface-texture layer to Mesh (only for meshes with no polygons)
	 * @param UV map name
	 * @return The newly created layer
	 */
	MeshTextureFaceLayer create(const std::string name = "UVMap");

};

/**************** UV Maps ****************/

/**
 * Collection of UV maps
 */
class UVTextures : public pyUniplug {
public:
	UVTextures(PyObject* pyobj) : pyUniplug(pyobj) {}

	UVTextures() : pyUniplug(0)
	{
		// not implemented
	}

	/** Getter: Active UV Map */
	MeshTexturePolyLayer active();

	/** Getter: Active UV Map index */
	int active_index() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "active_index"));
	}

	/** Setter: Active UV Map index */
	void active_index(int value) {
		PyObject_SetAttrString(pyobjref, "active_index", Py_BuildValue("i", value));
	}

	/**
	 * Add a UV map layer to Mesh
	 * @param UV map name
	 * @return The newly created layer
	 */
	MeshTexturePolyLayer create(const std::string name = "UVMap");

	/**
	 * Remove a vertex color layer
	 * @param The layer to remove
	 */
	void remove(MeshTexturePolyLayer layer);

};

/**************** Vertex Colors ****************/

/**
 * Collection of vertex colors
 */
class VertexColors : public pyUniplug {
public:
	VertexColors(PyObject* pyobj) : pyUniplug(pyobj) {}

	VertexColors() : pyUniplug(0)
	{
		// not implemented
	}

	/** Getter: Active vertex color layer */
	MeshColorLayer active();

	/** Getter: Active vertex color index */
	int active_index() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "active_index"));
	}

	/** Setter: Active vertex color index */
	void active_index(int value) {
		PyObject_SetAttrString(pyobjref, "active_index", Py_BuildValue("i", value));
	}

	/**
	 * Add a vertex color layer to Mesh
	 * @param Vertex color name
	 * @return The newly created layer
	 */
	MeshColorLayer create(const std::string name = "Col");

};

/**************** Loop Colors ****************/

/**
 * Collection of vertex colors
 */
class LoopColors : public pyUniplug {
public:
	LoopColors(PyObject* pyobj) : pyUniplug(pyobj) {}

	LoopColors() : pyUniplug(0)
	{
		// not implemented
	}

	/** Getter: Active vertex color layer */
	MeshLoopColorLayer active();

	/** Getter: Active vertex color index */
	int active_index() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "active_index"));
	}

	/** Setter: Active vertex color index */
	void active_index(int value) {
		PyObject_SetAttrString(pyobjref, "active_index", Py_BuildValue("i", value));
	}

	/**
	 * Add a vertex color layer to Mesh
	 * @param Vertex color name
	 * @return The newly created layer
	 */
	MeshLoopColorLayer create(const std::string name = "Col");

	/**
	 * Remove a vertex color layer
	 * @param The layer to remove
	 */
	void remove(MeshLoopColorLayer layer);

};

/**************** Vertex Float Properties ****************/

/**
 * Collection of float properties
 */
class VertexFloatProperties : public pyUniplug {
public:
	VertexFloatProperties(PyObject* pyobj) : pyUniplug(pyobj) {}

	VertexFloatProperties() : pyUniplug(0)
	{
		// not implemented
	}

	/**
	 * Add a float property layer to Mesh
	 * @param Float property name
	 * @return The newly created layer
	 */
	MeshVertexFloatPropertyLayer create(const std::string name = "Float Prop");

};

/**************** Vertex Int Properties ****************/

/**
 * Collection of int properties
 */
class VertexIntProperties : public pyUniplug {
public:
	VertexIntProperties(PyObject* pyobj) : pyUniplug(pyobj) {}

	VertexIntProperties() : pyUniplug(0)
	{
		// not implemented
	}

	/**
	 * Add a integer property layer to Mesh
	 * @param Int property name
	 * @return The newly created layer
	 */
	MeshVertexIntPropertyLayer create(const std::string name = "Int Prop");

};

/**************** Vertex String Properties ****************/

/**
 * Collection of string properties
 */
class VertexStringProperties : public pyUniplug {
public:
	VertexStringProperties(PyObject* pyobj) : pyUniplug(pyobj) {}

	VertexStringProperties() : pyUniplug(0)
	{
		// not implemented
	}

	/**
	 * Add a string property layer to Mesh
	 * @param String property name
	 * @return The newly created layer
	 */
	MeshVertexStringPropertyLayer create(const std::string name = "String Prop");

};

/**************** Polygon Float Properties ****************/

/**
 * Collection of float properties
 */
class PolygonFloatProperties : public pyUniplug {
public:
	PolygonFloatProperties(PyObject* pyobj) : pyUniplug(pyobj) {}

	PolygonFloatProperties() : pyUniplug(0)
	{
		// not implemented
	}

	/**
	 * Add a float property layer to Mesh
	 * @param Float property name
	 * @return The newly created layer
	 */
	MeshPolygonFloatPropertyLayer create(const std::string name = "Float Prop");

};

/**************** Polygon Int Properties ****************/

/**
 * Collection of int properties
 */
class PolygonIntProperties : public pyUniplug {
public:
	PolygonIntProperties(PyObject* pyobj) : pyUniplug(pyobj) {}

	PolygonIntProperties() : pyUniplug(0)
	{
		// not implemented
	}

	/**
	 * Add a integer property layer to Mesh
	 * @param Int property name
	 * @return The newly created layer
	 */
	MeshPolygonIntPropertyLayer create(const std::string name = "Int Prop");

};

/**************** Polygon String Properties ****************/

/**
 * Collection of string properties
 */
class PolygonStringProperties : public pyUniplug {
public:
	PolygonStringProperties(PyObject* pyobj) : pyUniplug(pyobj) {}

	PolygonStringProperties() : pyUniplug(0)
	{
		// not implemented
	}

	/**
	 * Add a string property layer to Mesh
	 * @param String property name
	 * @return The newly created layer
	 */
	MeshPolygonStringPropertyLayer create(const std::string name = "String Prop");

};

/**************** Meta Elements ****************/

/**
 * Collection of metaball elements
 */
class MetaBallElements : public pyUniplug {
public:
	MetaBallElements(PyObject* pyobj) : pyUniplug(pyobj) {}

	MetaBallElements() : pyUniplug(0)
	{
		// not implemented
	}

	/** Getter: Last selected element */
	MetaElement active();

	/**
	 * Enum: metaelem_type_items
	 */
	enum metaelem_type_items {
		metaelem_type_items_BALL = 0,	
		metaelem_type_items_CAPSULE = 4,	
		metaelem_type_items_PLANE = 5,	
		metaelem_type_items_ELLIPSOID = 6,	
		metaelem_type_items_CUBE = 7	
	};

	/**
	 * Add a new element to the metaball
	 * @param type for the new meta-element
	 * @return The newly created meta-element
	 */
	MetaElement create(metaelem_type_items type = metaelem_type_items_BALL);

	/**
	 * Remove an element from the metaball
	 * @param The element to remove
	 */
	void remove(MetaElement element);

	/**
	 * Remove all elements from the metaball
	 */
	void clear()
	{
		// not implemented
	}

};

/**************** Nla Strips ****************/

/**
 * Collection of Nla Strips
 */
class NlaStrips : public pyUniplug {
public:
	NlaStrips(PyObject* pyobj) : pyUniplug(pyobj) {}

	NlaStrips() : pyUniplug(0)
	{
		// not implemented
	}

	/**
	 * Add a new Action-Clip strip to the track
	 * @param Name for the NLA Strips
	 * @param Start frame for this strip
	 * @param Action to assign to this strip
	 * @return New NLA Strip
	 */
	NlaStrip create(const std::string name, int start, Action action);

	/**
	 * Remove a NLA Strip
	 * @param NLA Strip to remove
	 */
	void remove(NlaStrip strip);

};

/**************** Node Inputs ****************/

/**
 * Collection of Node Sockets
 */
class NodeInputs : public pyUniplug {
public:
	NodeInputs(PyObject* pyobj) : pyUniplug(pyobj) {}

	NodeInputs() : pyUniplug(0)
	{
		// not implemented
	}

	/**
	 * Add a socket to this node
	 * @param Data type
	 * @param Param 'name'
	 * @param Unique socket identifier
	 * @return New socket
	 */
	NodeSocket create(const std::string type, const std::string name, const std::string identifier = NULL);

	/**
	 * Remove a socket from this node
	 * @param The socket to remove
	 */
	void remove(NodeSocket socket);

	/**
	 * Remove all sockets from this node
	 */
	void clear()
	{
		// not implemented
	}

	/**
	 * Move a socket to another position
	 * @param Index of the socket to move
	 * @param Target index for the socket
	 */
	void move(int from_index, int to_index)
	{
		// not implemented
	}

};

/**************** Node Outputs ****************/

/**
 * Collection of Node Sockets
 */
class NodeOutputs : public pyUniplug {
public:
	NodeOutputs(PyObject* pyobj) : pyUniplug(pyobj) {}

	NodeOutputs() : pyUniplug(0)
	{
		// not implemented
	}

	/**
	 * Add a socket to this node
	 * @param Data type
	 * @param Param 'name'
	 * @param Unique socket identifier
	 * @return New socket
	 */
	NodeSocket create(const std::string type, const std::string name, const std::string identifier = NULL);

	/**
	 * Remove a socket from this node
	 * @param The socket to remove
	 */
	void remove(NodeSocket socket);

	/**
	 * Remove all sockets from this node
	 */
	void clear()
	{
		// not implemented
	}

	/**
	 * Move a socket to another position
	 * @param Index of the socket to move
	 * @param Target index for the socket
	 */
	void move(int from_index, int to_index)
	{
		// not implemented
	}

};

/**************** Nodes ****************/

/**
 * Collection of Nodes
 */
class Nodes : public pyUniplug {
public:
	Nodes(PyObject* pyobj) : pyUniplug(pyobj) {}

	Nodes() : pyUniplug(0)
	{
		// not implemented
	}

	/** Getter: Active node in this tree */
	Node active();

	/**
	 * Add a node to this node tree
	 * @param Type of node to add (Warning: should be same as node.bl_idname, not node.type!)
	 * @return New node
	 */
	Node create(const std::string type);

	/**
	 * Remove a node from this node tree
	 * @param The node to remove
	 */
	void remove(Node node);

	/**
	 * Remove all nodes from this node tree
	 */
	void clear()
	{
		// not implemented
	}

};

/**************** Node Links ****************/

/**
 * Collection of Node Links
 */
class NodeLinks : public pyUniplug {
public:
	NodeLinks(PyObject* pyobj) : pyUniplug(pyobj) {}

	NodeLinks() : pyUniplug(0)
	{
		// not implemented
	}

	/**
	 * Add a node link to this node tree
	 * @param The input socket
	 * @param The output socket
	 * @param Remove existing links if connection limit is exceeded
	 * @return New node link
	 */
	NodeLink create(NodeSocket input, NodeSocket output, bool verify_limits = true);

	/**
	 * remove a node link from the node tree
	 * @param The node link to remove
	 */
	void remove(NodeLink link);

	/**
	 * remove all node links from the node tree
	 */
	void clear()
	{
		// not implemented
	}

};

/**************** Node Tree Inputs ****************/

/**
 * Collection of Node Tree Sockets
 */
class NodeTreeInputs : public pyUniplug {
public:
	NodeTreeInputs(PyObject* pyobj) : pyUniplug(pyobj) {}

	NodeTreeInputs() : pyUniplug(0)
	{
		// not implemented
	}

	/**
	 * Add a socket to this node tree
	 * @param Data type
	 * @param Param 'name'
	 * @return New socket
	 */
	NodeSocketInterface create(const std::string type, const std::string name);

	/**
	 * Remove a socket from this node tree
	 * @param The socket to remove
	 */
	void remove(NodeSocketInterface socket);

	/**
	 * Remove all sockets from this node tree
	 */
	void clear()
	{
		// not implemented
	}

	/**
	 * Move a socket to another position
	 * @param Index of the socket to move
	 * @param Target index for the socket
	 */
	void move(int from_index, int to_index)
	{
		// not implemented
	}

};

/**************** Node Tree Outputs ****************/

/**
 * Collection of Node Tree Sockets
 */
class NodeTreeOutputs : public pyUniplug {
public:
	NodeTreeOutputs(PyObject* pyobj) : pyUniplug(pyobj) {}

	NodeTreeOutputs() : pyUniplug(0)
	{
		// not implemented
	}

	/**
	 * Add a socket to this node tree
	 * @param Data type
	 * @param Param 'name'
	 * @return New socket
	 */
	NodeSocketInterface create(const std::string type, const std::string name);

	/**
	 * Remove a socket from this node tree
	 * @param The socket to remove
	 */
	void remove(NodeSocketInterface socket);

	/**
	 * Remove all sockets from this node tree
	 */
	void clear()
	{
		// not implemented
	}

	/**
	 * Move a socket to another position
	 * @param Index of the socket to move
	 * @param Target index for the socket
	 */
	void move(int from_index, int to_index)
	{
		// not implemented
	}

};

/**************** File Output Slots ****************/

/**
 * Collection of File Output node slots
 */
class CompositorNodeOutputFileFileSlots : public pyUniplug {
public:
	CompositorNodeOutputFileFileSlots(PyObject* pyobj) : pyUniplug(pyobj) {}

	CompositorNodeOutputFileFileSlots() : pyUniplug(0)
	{
		// not implemented
	}

	/**
	 * Add a file slot to this node
	 * @param Param 'name'
	 * @return New socket
	 */
	NodeSocket create(const std::string name);

	/**
	 * Remove a file slot from this node
	 * @param The socket to remove
	 */
	void remove(NodeSocket socket);

	/**
	 * Remove all file slots from this node
	 */
	void clear()
	{
		// not implemented
	}

	/**
	 * Move a file slot to another position
	 * @param Index of the socket to move
	 * @param Target index for the socket
	 */
	void move(int from_index, int to_index)
	{
		// not implemented
	}

};

/**************** File Output Slots ****************/

/**
 * Collection of File Output node slots
 */
class CompositorNodeOutputFileLayerSlots : public pyUniplug {
public:
	CompositorNodeOutputFileLayerSlots(PyObject* pyobj) : pyUniplug(pyobj) {}

	CompositorNodeOutputFileLayerSlots() : pyUniplug(0)
	{
		// not implemented
	}

	/**
	 * Add a file slot to this node
	 * @param Param 'name'
	 * @return New socket
	 */
	NodeSocket create(const std::string name);

	/**
	 * Remove a file slot from this node
	 * @param The socket to remove
	 */
	void remove(NodeSocket socket);

	/**
	 * Remove all file slots from this node
	 */
	void clear()
	{
		// not implemented
	}

	/**
	 * Move a file slot to another position
	 * @param Index of the socket to move
	 * @param Target index for the socket
	 */
	void move(int from_index, int to_index)
	{
		// not implemented
	}

};

/**************** Object Modifiers ****************/

/**
 * Collection of object modifiers
 */
class ObjectModifiers : public pyUniplug {
public:
	ObjectModifiers(PyObject* pyobj) : pyUniplug(pyobj) {}

	ObjectModifiers() : pyUniplug(0)
	{
		// not implemented
	}

	/**
	 * Enum: modifier_type_items
	 */
	enum modifier_type_items {
		// Modify //
		modifier_type_items_DATA_TRANSFER = 49,	
		modifier_type_items_MESH_CACHE = 46,	
		modifier_type_items_NORMAL_EDIT = 50,	
		modifier_type_items_UV_PROJECT = 15,	
		modifier_type_items_UV_WARP = 45,	
		modifier_type_items_VERTEX_WEIGHT_EDIT = 36,	
		modifier_type_items_VERTEX_WEIGHT_MIX = 37,	
		modifier_type_items_VERTEX_WEIGHT_PROXIMITY = 38,	
		// Generate //
		modifier_type_items_ARRAY = 12,	
		modifier_type_items_BEVEL = 24,	
		modifier_type_items_BOOLEAN = 11,	
		modifier_type_items_BUILD = 4,	
		modifier_type_items_DECIMATE = 6,	
		modifier_type_items_EDGE_SPLIT = 13,	
		modifier_type_items_MASK = 27,	
		modifier_type_items_MIRROR = 5,	
		modifier_type_items_MULTIRES = 29,	
		modifier_type_items_REMESH = 41,	
		modifier_type_items_SCREW = 34,	
		modifier_type_items_SKIN = 42,	
		modifier_type_items_SOLIDIFY = 33,	
		modifier_type_items_SUBSURF = 1,	
		modifier_type_items_TRIANGULATE = 44,	
		modifier_type_items_WIREFRAME = 48,	/**< Generate a wireframe on the edges of a mesh */
		// Deform //
		modifier_type_items_ARMATURE = 8,	
		modifier_type_items_CAST = 17,	
		modifier_type_items_CORRECTIVE_SMOOTH = 51,	
		modifier_type_items_CURVE = 3,	
		modifier_type_items_DISPLACE = 14,	
		modifier_type_items_HOOK = 9,	
		modifier_type_items_LAPLACIANSMOOTH = 43,	
		modifier_type_items_LAPLACIANDEFORM = 47,	
		modifier_type_items_LATTICE = 2,	
		modifier_type_items_MESH_DEFORM = 18,	
		modifier_type_items_SHRINKWRAP = 25,	
		modifier_type_items_SIMPLE_DEFORM = 28,	
		modifier_type_items_SMOOTH = 16,	
		modifier_type_items_WARP = 35,	
		modifier_type_items_WAVE = 7,	
		// Simulate //
		modifier_type_items_CLOTH = 22,	
		modifier_type_items_COLLISION = 23,	
		modifier_type_items_DYNAMIC_PAINT = 40,	
		modifier_type_items_EXPLODE = 21,	
		modifier_type_items_FLUID_SIMULATION = 26,	
		modifier_type_items_OCEAN = 39,	
		modifier_type_items_PARTICLE_INSTANCE = 20,	
		modifier_type_items_PARTICLE_SYSTEM = 19,	
		modifier_type_items_SMOKE = 31,	
		modifier_type_items_SOFT_BODY = 10,	
		modifier_type_items_SURFACE = 30	
	};

	/**
	 * Add a new modifier
	 * @param New name for the modifier
	 * @param Modifier type to add
	 * @return Newly created modifier
	 */
	Modifier create(const std::string name, modifier_type_items type);

	/**
	 * Remove an existing modifier from the object
	 * @param Modifier to remove
	 */
	void remove(Modifier modifier);

	/**
	 * Remove all modifiers from the object
	 */
	void clear()
	{
		// not implemented
	}

};

/**************** Object Constraints ****************/

/**
 * Collection of object constraints
 */
class ObjectConstraints : public pyUniplug {
public:
	ObjectConstraints(PyObject* pyobj) : pyUniplug(pyobj) {}

	ObjectConstraints() : pyUniplug(0)
	{
		// not implemented
	}

	/** Getter: Active Object constraint */
	Constraint active();

	/**
	 * Enum: constraint_type_items
	 */
	enum constraint_type_items {
		// Motion Tracking //
		constraint_type_items_CAMERA_SOLVER = 27,	
		constraint_type_items_FOLLOW_TRACK = 26,	
		constraint_type_items_OBJECT_SOLVER = 28,	
		// Transform //
		constraint_type_items_COPY_LOCATION = 9,	/**< Copy the location of a target (with an optional offset), so that they move together */
		constraint_type_items_COPY_ROTATION = 8,	/**< Copy the rotation of a target (with an optional offset), so that they rotate together */
		constraint_type_items_COPY_SCALE = 10,	/**< Copy the scale factors of a target (with an optional offset), so that they are scaled by the same amount */
		constraint_type_items_COPY_TRANSFORMS = 23,	/**< Copy all the transformations of a target, so that they move together */
		constraint_type_items_LIMIT_DISTANCE = 14,	/**< Restrict movements to within a certain distance of a target (at the time of constraint evaluation only) */
		constraint_type_items_LIMIT_LOCATION = 6,	/**< Restrict movement along each axis within given ranges */
		constraint_type_items_LIMIT_ROTATION = 5,	/**< Restrict rotation along each axis within given ranges */
		constraint_type_items_LIMIT_SCALE = 7,	/**< Restrict scaling along each axis with given ranges */
		constraint_type_items_MAINTAIN_VOLUME = 24,	/**< Compensate for scaling one axis by applying suitable scaling to the other two axes */
		constraint_type_items_TRANSFORM = 19,	/**< Use one transform property from target to control another (or same) property on owner */
		// Tracking //
		constraint_type_items_CLAMP_TO = 18,	/**< Restrict movements to lie along a curve by remapping location along curve's longest axis */
		constraint_type_items_DAMPED_TRACK = 21,	/**< Point towards a target by performing the smallest rotation necessary */
		constraint_type_items_IK = 3,	/**< Control a chain of bones by specifying the endpoint target (Bones only) */
		constraint_type_items_LOCKED_TRACK = 13,	/**< Rotate around the specified ('locked') axis to point towards a target */
		constraint_type_items_SPLINE_IK = 22,	/**< Align chain of bones along a curve (Bones only) */
		constraint_type_items_STRETCH_TO = 15,	/**< Stretch along Y-Axis to point towards a target */
		constraint_type_items_TRACK_TO = 2,	/**< Legacy tracking constraint prone to twisting artifacts */
		// Relationship //
		constraint_type_items_ACTION = 12,	/**< Use transform property of target to look up pose for owner from an Action */
		constraint_type_items_CHILD_OF = 1,	/**< Make target the 'detachable' parent of owner */
		constraint_type_items_FLOOR = 16,	/**< Use position (and optionally rotation) of target to define a 'wall' or 'floor' that the owner can not cross */
		constraint_type_items_FOLLOW_PATH = 4,	/**< Use to animate an object/bone following a path */
		constraint_type_items_PIVOT = 25,	/**< Change pivot point for transforms (buggy) */
		constraint_type_items_RIGID_BODY_JOINT = 17,	/**< Use to define a Rigid Body Constraint (for Game Engine use only) */
		constraint_type_items_SHRINKWRAP = 20	/**< Restrict movements to surface of target mesh */
	};

	/**
	 * Add a new constraint to this object
	 * @param Constraint type to add
	 * @return New constraint
	 */
	Constraint create(constraint_type_items type);

	/**
	 * Remove a constraint from this object
	 * @param Removed constraint
	 */
	void remove(Constraint constraint);

	/**
	 * Remove all constraint from this object
	 */
	void clear()
	{
		// not implemented
	}

};

/**************** Vertex Groups ****************/

/**
 * Collection of vertex groups
 */
class VertexGroups : public pyUniplug {
public:
	VertexGroups(PyObject* pyobj) : pyUniplug(pyobj) {}

	VertexGroups() : pyUniplug(0)
	{
		// not implemented
	}

	/** Getter: Vertex groups of the object */
	VertexGroup active();

	/** Getter: Active index in vertex group array */
	int active_index() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "active_index"));
	}

	/** Setter: Active index in vertex group array */
	void active_index(int value) {
		PyObject_SetAttrString(pyobjref, "active_index", Py_BuildValue("i", value));
	}

	/**
	 * Add vertex group to object
	 * @param Vertex group name
	 * @return New vertex group
	 */
	VertexGroup create(const std::string name = "Group");

	/**
	 * Delete vertex group from object
	 * @param Vertex group to remove
	 */
	void remove(VertexGroup group);

	/**
	 * Delete all vertex groups from object
	 */
	void clear()
	{
		// not implemented
	}

};

/**************** Particle Systems ****************/

/**
 * Collection of particle systems
 */
class ParticleSystems : public pyUniplug {
public:
	ParticleSystems(PyObject* pyobj) : pyUniplug(pyobj) {}

	ParticleSystems() : pyUniplug(0)
	{
		// not implemented
	}

	/** Getter: Active particle system being displayed */
	ParticleSystem active();

	/** Getter: Index of active particle system slot */
	int active_index() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "active_index"));
	}

	/** Setter: Index of active particle system slot */
	void active_index(int value) {
		PyObject_SetAttrString(pyobjref, "active_index", Py_BuildValue("i", value));
	}

};

/**************** Point Caches ****************/

/**
 * Collection of point caches
 */
class PointCaches : public pyUniplug {
public:
	PointCaches(PyObject* pyobj) : pyUniplug(pyobj) {}

	PointCaches() : pyUniplug(0)
	{
		// not implemented
	}

	/** Getter:  */
	int active_index() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "active_index"));
	}

	/** Setter:  */
	void active_index(int value) {
		PyObject_SetAttrString(pyobjref, "active_index", Py_BuildValue("i", value));
	}

};

/**************** Palette Splines ****************/

/**
 * Collection of palette colors
 */
class PaletteColors : public pyUniplug {
public:
	PaletteColors(PyObject* pyobj) : pyUniplug(pyobj) {}

	PaletteColors() : pyUniplug(0)
	{
		// not implemented
	}

	/** Getter:  */
	PaletteColor active();

	/**
	 * Add a new color to the palette
	 * @return The newly created color
	 */
	PaletteColor create();

	/**
	 * Remove a color from the palette
	 * @param The color to remove
	 */
	void remove(PaletteColor color);

	/**
	 * Remove all colors from the palette
	 */
	void clear()
	{
		// not implemented
	}

};

/**************** Texture Slots ****************/

/**
 * Collection of texture slots
 */
class ParticleSettingsTextureSlots : public pyUniplug {
public:
	ParticleSettingsTextureSlots(PyObject* pyobj) : pyUniplug(pyobj) {}

	ParticleSettingsTextureSlots() : pyUniplug(0)
	{
		// not implemented
	}

	/**
	 * Function: add
	 * @return The newly initialized mtex
	 */
	ParticleSettingsTextureSlot add();

	/**
	 * Function: create
	 * @param Slot index to initialize
	 * @return The newly initialized mtex
	 */
	ParticleSettingsTextureSlot create(int index);

	/**
	 * Function: clear
	 * @param Slot index to clear
	 */
	void clear(int index)
	{
		// not implemented
	}

};

/**************** Bone Groups ****************/

/**
 * Collection of bone groups
 */
class BoneGroups : public pyUniplug {
public:
	BoneGroups(PyObject* pyobj) : pyUniplug(pyobj) {}

	BoneGroups() : pyUniplug(0)
	{
		// not implemented
	}

	/** Getter: Active bone group for this pose */
	BoneGroup active();

	/** Getter: Active index in bone groups array */
	int active_index() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "active_index"));
	}

	/** Setter: Active index in bone groups array */
	void active_index(int value) {
		PyObject_SetAttrString(pyobjref, "active_index", Py_BuildValue("i", value));
	}

	/**
	 * Add a new bone group to the object
	 * @param Name of the new group
	 * @return New bone group
	 */
	BoneGroup create(const std::string name = "Group");

	/**
	 * Remove a bone group from this object
	 * @param Removed bone group
	 */
	void remove(BoneGroup group);

};

/**************** PoseBone Constraints ****************/

/**
 * Collection of pose bone constraints
 */
class PoseBoneConstraints : public pyUniplug {
public:
	PoseBoneConstraints(PyObject* pyobj) : pyUniplug(pyobj) {}

	PoseBoneConstraints() : pyUniplug(0)
	{
		// not implemented
	}

	/** Getter: Active PoseChannel constraint */
	Constraint active();

	/**
	 * Enum: constraint_type_items
	 */
	enum constraint_type_items {
		// Motion Tracking //
		constraint_type_items_CAMERA_SOLVER = 27,	
		constraint_type_items_FOLLOW_TRACK = 26,	
		constraint_type_items_OBJECT_SOLVER = 28,	
		// Transform //
		constraint_type_items_COPY_LOCATION = 9,	/**< Copy the location of a target (with an optional offset), so that they move together */
		constraint_type_items_COPY_ROTATION = 8,	/**< Copy the rotation of a target (with an optional offset), so that they rotate together */
		constraint_type_items_COPY_SCALE = 10,	/**< Copy the scale factors of a target (with an optional offset), so that they are scaled by the same amount */
		constraint_type_items_COPY_TRANSFORMS = 23,	/**< Copy all the transformations of a target, so that they move together */
		constraint_type_items_LIMIT_DISTANCE = 14,	/**< Restrict movements to within a certain distance of a target (at the time of constraint evaluation only) */
		constraint_type_items_LIMIT_LOCATION = 6,	/**< Restrict movement along each axis within given ranges */
		constraint_type_items_LIMIT_ROTATION = 5,	/**< Restrict rotation along each axis within given ranges */
		constraint_type_items_LIMIT_SCALE = 7,	/**< Restrict scaling along each axis with given ranges */
		constraint_type_items_MAINTAIN_VOLUME = 24,	/**< Compensate for scaling one axis by applying suitable scaling to the other two axes */
		constraint_type_items_TRANSFORM = 19,	/**< Use one transform property from target to control another (or same) property on owner */
		// Tracking //
		constraint_type_items_CLAMP_TO = 18,	/**< Restrict movements to lie along a curve by remapping location along curve's longest axis */
		constraint_type_items_DAMPED_TRACK = 21,	/**< Point towards a target by performing the smallest rotation necessary */
		constraint_type_items_IK = 3,	/**< Control a chain of bones by specifying the endpoint target (Bones only) */
		constraint_type_items_LOCKED_TRACK = 13,	/**< Rotate around the specified ('locked') axis to point towards a target */
		constraint_type_items_SPLINE_IK = 22,	/**< Align chain of bones along a curve (Bones only) */
		constraint_type_items_STRETCH_TO = 15,	/**< Stretch along Y-Axis to point towards a target */
		constraint_type_items_TRACK_TO = 2,	/**< Legacy tracking constraint prone to twisting artifacts */
		// Relationship //
		constraint_type_items_ACTION = 12,	/**< Use transform property of target to look up pose for owner from an Action */
		constraint_type_items_CHILD_OF = 1,	/**< Make target the 'detachable' parent of owner */
		constraint_type_items_FLOOR = 16,	/**< Use position (and optionally rotation) of target to define a 'wall' or 'floor' that the owner can not cross */
		constraint_type_items_FOLLOW_PATH = 4,	/**< Use to animate an object/bone following a path */
		constraint_type_items_PIVOT = 25,	/**< Change pivot point for transforms (buggy) */
		constraint_type_items_RIGID_BODY_JOINT = 17,	/**< Use to define a Rigid Body Constraint (for Game Engine use only) */
		constraint_type_items_SHRINKWRAP = 20	/**< Restrict movements to surface of target mesh */
	};

	/**
	 * Add a constraint to this object
	 * @return New constraint
	 * @param Constraint type to add
	 */
	Constraint create(constraint_type_items type);

	/**
	 * Remove a constraint from this object
	 * @param Removed constraint
	 */
	void remove(Constraint constraint);

};

/**************** Render Passes ****************/

/**
 * Collection of render passes
 */
class RenderPasses : public pyUniplug {
public:
	RenderPasses(PyObject* pyobj) : pyUniplug(pyobj) {}

	RenderPasses() : pyUniplug(0)
	{
		// not implemented
	}

	/**
	 * Enum: render_pass_type_items
	 */
	enum render_pass_type_items {
		render_pass_type_items_COMBINED = 1,	
		render_pass_type_items_Z = 2,	
		render_pass_type_items_COLOR = 4,	
		render_pass_type_items_DIFFUSE = 8,	
		render_pass_type_items_SPECULAR = 16,	
		render_pass_type_items_SHADOW = 32,	
		render_pass_type_items_AO = 64,	
		render_pass_type_items_REFLECTION = 128,	
		render_pass_type_items_NORMAL = 256,	
		render_pass_type_items_VECTOR = 512,	
		render_pass_type_items_REFRACTION = 1024,	
		render_pass_type_items_OBJECT_INDEX = 2048,	
		render_pass_type_items_UV = 4096,	
		render_pass_type_items_MIST = 16384,	
		render_pass_type_items_EMIT = 65536,	
		render_pass_type_items_ENVIRONMENT = 131072,	
		render_pass_type_items_MATERIAL_INDEX = 262144,	
		render_pass_type_items_DIFFUSE_DIRECT = 524288,	
		render_pass_type_items_DIFFUSE_INDIRECT = 1048576,	
		render_pass_type_items_DIFFUSE_COLOR = 2097152,	
		render_pass_type_items_GLOSSY_DIRECT = 4194304,	
		render_pass_type_items_GLOSSY_INDIRECT = 8388608,	
		render_pass_type_items_GLOSSY_COLOR = 16777216,	
		render_pass_type_items_TRANSMISSION_DIRECT = 33554432,	
		render_pass_type_items_TRANSMISSION_INDIRECT = 67108864,	
		render_pass_type_items_TRANSMISSION_COLOR = 134217728,	
		render_pass_type_items_SUBSURFACE_DIRECT = 268435456,	
		render_pass_type_items_SUBSURFACE_INDIRECT = 536870912,	
		render_pass_type_items_SUBSURFACE_COLOR = 1073741824	
	};

	/**
	 * Get the render pass for a given type and view
	 * @param Param 'pass_type'
	 * @param Render view to get pass from
	 * @return The matching render pass
	 */
	RenderPass find_by_type(render_pass_type_items pass_type, const std::string view);

};

/**************** Scene Bases ****************/

/**
 * Collection of scene bases
 */
class SceneBases : public pyUniplug {
public:
	SceneBases(PyObject* pyobj) : pyUniplug(pyobj) {}

	SceneBases() : pyUniplug(0)
	{
		// not implemented
	}

	/** Getter: Active object base in the scene */
	ObjectBase active();

};

/**************** Scene Objects ****************/

/**
 * Collection of scene objects
 */
class SceneObjects : public pyUniplug {
public:
	SceneObjects(PyObject* pyobj) : pyUniplug(pyobj) {}

	SceneObjects() : pyUniplug(0)
	{
		// not implemented
	}

	/** Getter: Active object for this scene */
	Object active();

	/**
	 * Link object to scene, run scene.update() after
	 * @param Object to add to scene
	 * @return The newly created base
	 */
	ObjectBase link(Object object_value);

	/**
	 * Unlink object from scene
	 * @param Object to remove from scene
	 */
	void unlink(Object object_value);

};

/**************** Keying Sets ****************/

/**
 * Scene keying sets
 */
class KeyingSets : public pyUniplug {
public:
	KeyingSets(PyObject* pyobj) : pyUniplug(pyobj) {}

	KeyingSets() : pyUniplug(0)
	{
		// not implemented
	}

	/** Getter: Active Keying Set used to insert/delete keyframes */
	KeyingSet active();

	/** Getter: Current Keying Set index (negative for 'builtin' and positive for 'absolute') */
	int active_index() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "active_index"));
	}

	/** Setter: Current Keying Set index (negative for 'builtin' and positive for 'absolute') */
	void active_index(int value) {
		PyObject_SetAttrString(pyobjref, "active_index", Py_BuildValue("i", value));
	}

	/**
	 * Add a new Keying Set to Scene
	 * @param Internal identifier of Keying Set
	 * @param User visible name of Keying Set
	 * @return Newly created Keying Set
	 */
	KeyingSet create(const std::string idname = "KeyingSet", const std::string name = "KeyingSet");

};

/**************** Keying Sets All ****************/

/**
 * All available keying sets
 */
class KeyingSetsAll : public pyUniplug {
public:
	KeyingSetsAll(PyObject* pyobj) : pyUniplug(pyobj) {}

	KeyingSetsAll() : pyUniplug(0)
	{
		// not implemented
	}

	/** Getter: Active Keying Set used to insert/delete keyframes */
	KeyingSet active();

	/** Getter: Current Keying Set index (negative for 'builtin' and positive for 'absolute') */
	int active_index() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "active_index"));
	}

	/** Setter: Current Keying Set index (negative for 'builtin' and positive for 'absolute') */
	void active_index(int value) {
		PyObject_SetAttrString(pyobjref, "active_index", Py_BuildValue("i", value));
	}

};

/**************** Timeline Markers ****************/

/**
 * Collection of timeline markers
 */
class TimelineMarkers : public pyUniplug {
public:
	TimelineMarkers(PyObject* pyobj) : pyUniplug(pyobj) {}

	TimelineMarkers() : pyUniplug(0)
	{
		// not implemented
	}

	/**
	 * Add a keyframe to the curve
	 * @param New name for the marker (not unique)
	 * @param The frame for the new marker
	 * @return Newly created timeline marker
	 */
	TimelineMarker create(const std::string name, int frame = 1);

	/**
	 * Remove a timeline marker
	 * @param Timeline marker to remove
	 */
	void remove(TimelineMarker marker);

	/**
	 * Remove all timeline markers
	 */
	void clear()
	{
		// not implemented
	}

};

/**************** Render Layers ****************/

/**
 * Collection of render layers
 */
class RenderLayers : public pyUniplug {
public:
	RenderLayers(PyObject* pyobj) : pyUniplug(pyobj) {}

	RenderLayers() : pyUniplug(0)
	{
		// not implemented
	}

	/** Getter: Active index in render layer array */
	int active_index() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "active_index"));
	}

	/** Setter: Active index in render layer array */
	void active_index(int value) {
		PyObject_SetAttrString(pyobjref, "active_index", Py_BuildValue("i", value));
	}

	/** Getter: Active Render Layer */
	SceneRenderLayer active();

	/**
	 * Add a render layer to scene
	 * @param New name for the render layer (not unique)
	 * @return Newly created render layer
	 */
	SceneRenderLayer create(const std::string name);

	/**
	 * Remove a render layer
	 * @param Render layer to remove
	 */
	void remove(SceneRenderLayer layer);

};

/**************** Render Views ****************/

/**
 * Collection of render views
 */
class RenderViews : public pyUniplug {
public:
	RenderViews(PyObject* pyobj) : pyUniplug(pyobj) {}

	RenderViews() : pyUniplug(0)
	{
		// not implemented
	}

	/** Getter: Active index in render view array */
	int active_index() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "active_index"));
	}

	/** Setter: Active index in render view array */
	void active_index(int value) {
		PyObject_SetAttrString(pyobjref, "active_index", Py_BuildValue("i", value));
	}

	/** Getter: Active Render View */
	SceneRenderView active();

	/**
	 * Add a render view to scene
	 * @param New name for the marker (not unique)
	 * @return Newly created render view
	 */
	SceneRenderView create(const std::string name);

	/**
	 * Remove a render view
	 * @param Render view to remove
	 */
	void remove(SceneRenderView view);

};

/**************** Style Modules ****************/

/**
 * A list of style modules (to be applied from top to bottom)
 */
class FreestyleModules : public pyUniplug {
public:
	FreestyleModules(PyObject* pyobj) : pyUniplug(pyobj) {}

	FreestyleModules() : pyUniplug(0)
	{
		// not implemented
	}

	/**
	 * Add a style module to scene render layer Freestyle settings
	 * @return Newly created style module
	 */
	FreestyleModuleSettings create();

	/**
	 * Remove a style module from scene render layer Freestyle settings
	 * @param Style module to remove
	 */
	void remove(FreestyleModuleSettings module);

};

/**************** Line Sets ****************/

/**
 * Line sets for associating lines and style parameters
 */
class Linesets : public pyUniplug {
public:
	Linesets(PyObject* pyobj) : pyUniplug(pyobj) {}

	Linesets() : pyUniplug(0)
	{
		// not implemented
	}

	/** Getter: Active line set being displayed */
	FreestyleLineSet active();

	/** Getter: Index of active line set slot */
	int active_index() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "active_index"));
	}

	/** Setter: Index of active line set slot */
	void active_index(int value) {
		PyObject_SetAttrString(pyobjref, "active_index", Py_BuildValue("i", value));
	}

	/**
	 * Add a line set to scene render layer Freestyle settings
	 * @param New name for the line set (not unique)
	 * @return Newly created line set
	 */
	FreestyleLineSet create(const std::string name);

	/**
	 * Remove a line set from scene render layer Freestyle settings
	 * @param Line set to remove
	 */
	void remove(FreestyleLineSet lineset);

};

/**************** Area Spaces ****************/

/**
 * Collection of spaces
 */
class AreaSpaces : public pyUniplug {
public:
	AreaSpaces(PyObject* pyobj) : pyUniplug(pyobj) {}

	AreaSpaces() : pyUniplug(0)
	{
		// not implemented
	}

	/** Getter: Space currently being displayed in this area */
	Space active();

};

/**************** Strip Modifiers ****************/

/**
 * Collection of strip modifiers
 */
class SequenceModifiers : public pyUniplug {
public:
	SequenceModifiers(PyObject* pyobj) : pyUniplug(pyobj) {}

	SequenceModifiers() : pyUniplug(0)
	{
		// not implemented
	}

	/**
	 * Enum: sequence_modifier_type_items
	 */
	enum sequence_modifier_type_items {
		sequence_modifier_type_items_COLOR_BALANCE = 1,	
		sequence_modifier_type_items_CURVES = 2,	
		sequence_modifier_type_items_HUE_CORRECT = 3,	
		sequence_modifier_type_items_BRIGHT_CONTRAST = 4,	
		sequence_modifier_type_items_MASK = 5	
	};

	/**
	 * Add a new modifier
	 * @param New name for the modifier
	 * @param Modifier type to add
	 * @return Newly created modifier
	 */
	SequenceModifier create(const std::string name, sequence_modifier_type_items type);

	/**
	 * Remove an existing modifier from the sequence
	 * @param Modifier to remove
	 */
	void remove(SequenceModifier modifier);

	/**
	 * Remove all modifiers from the sequence
	 */
	void clear()
	{
		// not implemented
	}

};

/**************** Sequences ****************/

/**
 * Collection of Sequences
 */
class Sequences : public pyUniplug {
public:
	Sequences(PyObject* pyobj) : pyUniplug(pyobj) {}

	Sequences() : pyUniplug(0)
	{
		// not implemented
	}

	/**
	 * Add a new movie clip sequence
	 * @param Name for the new sequence
	 * @param Movie clip to add
	 * @param The channel for the new sequence
	 * @param The start frame for the new sequence
	 * @return New Sequence
	 */
	Sequence new_clip(const std::string name, MovieClip clip, int channel, int frame_start);

	/**
	 * Add a new mask sequence
	 * @param Name for the new sequence
	 * @param Mask to add
	 * @param The channel for the new sequence
	 * @param The start frame for the new sequence
	 * @return New Sequence
	 */
	Sequence new_mask(const std::string name, Mask mask, int channel, int frame_start);

	/**
	 * Add a new scene sequence
	 * @param Name for the new sequence
	 * @param Scene to add
	 * @param The channel for the new sequence
	 * @param The start frame for the new sequence
	 * @return New Sequence
	 */
	Sequence new_scene(const std::string name, Scene scene, int channel, int frame_start);

	/**
	 * Add a new image sequence
	 * @param Name for the new sequence
	 * @param Filepath to image
	 * @param The channel for the new sequence
	 * @param The start frame for the new sequence
	 * @return New Sequence
	 */
	Sequence new_image(const std::string name, const std::string filepath, int channel, int frame_start);

	/**
	 * Add a new movie sequence
	 * @param Name for the new sequence
	 * @param Filepath to movie
	 * @param The channel for the new sequence
	 * @param The start frame for the new sequence
	 * @return New Sequence
	 */
	Sequence new_movie(const std::string name, const std::string filepath, int channel, int frame_start);

	/**
	 * Add a new sound sequence
	 * @param Name for the new sequence
	 * @param Filepath to movie
	 * @param The channel for the new sequence
	 * @param The start frame for the new sequence
	 * @return New Sequence
	 */
	Sequence new_sound(const std::string name, const std::string filepath, int channel, int frame_start);

	/**
	 * Enum: seq_effect_items
	 */
	enum seq_effect_items {
		seq_effect_items_CROSS = 8,	
		seq_effect_items_ADD = 9,	
		seq_effect_items_SUBTRACT = 10,	
		seq_effect_items_ALPHA_OVER = 11,	
		seq_effect_items_ALPHA_UNDER = 12,	
		seq_effect_items_GAMMA_CROSS = 13,	
		seq_effect_items_MULTIPLY = 14,	
		seq_effect_items_OVER_DROP = 15,	
		seq_effect_items_WIPE = 25,	
		seq_effect_items_GLOW = 26,	
		seq_effect_items_TRANSFORM = 27,	
		seq_effect_items_COLOR = 28,	
		seq_effect_items_SPEED = 29,	
		seq_effect_items_MULTICAM = 30,	
		seq_effect_items_ADJUSTMENT = 31,	
		seq_effect_items_GAUSSIAN_BLUR = 40	
	};

	/**
	 * Add a new effect sequence
	 * @param Name for the new sequence
	 * @param type for the new sequence
	 * @param The channel for the new sequence
	 * @param The start frame for the new sequence
	 * @param The end frame for the new sequence
	 * @param Sequence 1 for effect
	 * @param Sequence 2 for effect
	 * @param Sequence 3 for effect
	 * @return New Sequence
	 */
	Sequence new_effect(const std::string name, seq_effect_items type, int channel, int frame_start, int frame_end, Sequence seq1, Sequence seq2, Sequence seq3);

	/**
	 * Remove a Sequence
	 * @param Sequence to remove
	 */
	void remove(Sequence sequence);

};

/**************** SequenceElements ****************/

/**
 * Collection of SequenceElement
 */
class SequenceElements : public pyUniplug {
public:
	SequenceElements(PyObject* pyobj) : pyUniplug(pyobj) {}

	SequenceElements() : pyUniplug(0)
	{
		// not implemented
	}

	/**
	 * Push an image from ImageSequence.directory
	 * @param Filepath to image
	 * @return New SequenceElement
	 */
	SequenceElement append(const std::string filename);

	/**
	 * Pop an image off the collection
	 * @param Index of image to remove
	 */
	void pop(int index)
	{
		// not implemented
	}

};

/**************** Background Images ****************/

/**
 * Collection of background images
 */
class BackgroundImages : public pyUniplug {
public:
	BackgroundImages(PyObject* pyobj) : pyUniplug(pyobj) {}

	BackgroundImages() : pyUniplug(0)
	{
		// not implemented
	}

	/**
	 * Add new background image
	 * @return Image displayed as viewport background
	 */
	BackgroundImage create();

	/**
	 * Remove background image
	 * @param Image displayed as viewport background
	 */
	void remove(BackgroundImage image);

	/**
	 * Remove all background images
	 */
	void clear()
	{
		// not implemented
	}

};

/**************** Path ****************/

/**
 * Get the node tree path as a string
 */
class SpaceNodeEditorPath : public pyUniplug {
public:
	SpaceNodeEditorPath(PyObject* pyobj) : pyUniplug(pyobj) {}

	SpaceNodeEditorPath() : pyUniplug(0)
	{
		// not implemented
	}

	/** Getter:  */
	std::string to_string() { /* not implemented */ throw NULL; }
	/** Setter:  */
	void to_string(const std::string& value) { /* not implemented */ }

	/**
	 * Reset the node tree path
	 */
	void clear()
	{
		// not implemented
	}

	/**
	 * Set the root node tree
	 * @param Param 'node_tree'
	 */
	void start(NodeTree node_tree);

	/**
	 * Append a node group tree to the path
	 * @param Node tree to append to the node editor path
	 * @param Group node linking to this node tree
	 */
	void append(NodeTree node_tree, Node node);

	/**
	 * Remove the last node tree from the path
	 */
	void pop()
	{
		// not implemented
	}

};

/**************** User Add-ons ****************/

/**
 * Collection of add-ons
 */
class Addons : public pyUniplug {
public:
	Addons(PyObject* pyobj) : pyUniplug(pyobj) {}

	Addons() : pyUniplug(0)
	{
		// not implemented
	}

	/**
	 * Add a new add-on
	 * @return Addon datablock
	 */
	Addon create();

	/**
	 * Remove add-on
	 * @param Addon to remove
	 */
	void remove(Addon addon);

};

/**************** Paths Compare ****************/

/**
 * Collection of paths
 */
class PathCompareCollection : public pyUniplug {
public:
	PathCompareCollection(PyObject* pyobj) : pyUniplug(pyobj) {}

	PathCompareCollection() : pyUniplug(0)
	{
		// not implemented
	}

	/**
	 * Add a new path
	 * @return 
	 */
	PathCompare create();

	/**
	 * Remove path
	 * @param Param 'pathcmp'
	 */
	void remove(PathCompare pathcmp);

};

/**************** KeyConfigs ****************/

/**
 * Collection of KeyConfigs
 */
class KeyConfigurations : public pyUniplug {
public:
	KeyConfigurations(PyObject* pyobj) : pyUniplug(pyobj) {}

	KeyConfigurations() : pyUniplug(0)
	{
		// not implemented
	}

	/** Getter: Active key configuration (preset) */
	KeyConfig active();

	/** Getter: Default builtin key configuration */
	KeyConfig default_value();

	/** Getter: Key configuration that can be extended by addons, and is added to the active configuration when handling events */
	KeyConfig addon();

	/** Getter: Final key configuration that combines keymaps from the active and addon configurations, and can be edited by the user */
	KeyConfig user();

	/**
	 * Function: create
	 * @param Param 'name'
	 * @return Added key configuration
	 */
	KeyConfig create(const std::string name);

	/**
	 * Function: remove
	 * @param Removed key configuration
	 */
	void remove(KeyConfig keyconfig);

};

/**************** Key Maps ****************/

/**
 * Collection of keymaps
 */
class KeyMaps : public pyUniplug {
public:
	KeyMaps(PyObject* pyobj) : pyUniplug(pyobj) {}

	KeyMaps() : pyUniplug(0)
	{
		// not implemented
	}

	/**
	 * Enum: space_type_items
	 */
	enum space_type_items {
		space_type_items_EMPTY = 0,	
		space_type_items_VIEW_3D = 1,	/**< 3D viewport */
		// -------- //
		space_type_items_TIMELINE = 15,	/**< Timeline and playback controls */
		space_type_items_GRAPH_EDITOR = 2,	/**< Edit drivers and keyframe interpolation */
		space_type_items_DOPESHEET_EDITOR = 12,	/**< Adjust timing of keyframes */
		space_type_items_NLA_EDITOR = 13,	/**< Combine and layer Actions */
		// -------- //
		space_type_items_IMAGE_EDITOR = 6,	/**< View and edit images and UV Maps */
		space_type_items_SEQUENCE_EDITOR = 8,	/**< Video editing tools */
		space_type_items_CLIP_EDITOR = 20,	/**< Motion tracking tools */
		space_type_items_TEXT_EDITOR = 9,	/**< Edit scripts and in-file documentation */
		space_type_items_NODE_EDITOR = 16,	/**< Editor for node-based shading and compositing tools */
		space_type_items_LOGIC_EDITOR = 17,	/**< Game logic editing */
		// -------- //
		space_type_items_PROPERTIES = 4,	/**< Edit properties of active object and related datablocks */
		space_type_items_OUTLINER = 3,	/**< Overview of scene graph and all available datablocks */
		space_type_items_USER_PREFERENCES = 19,	/**< Edit persistent configuration settings */
		space_type_items_INFO = 7,	/**< Main menu bar and list of error messages (drag down to expand and display) */
		// -------- //
		space_type_items_FILE_BROWSER = 5,	/**< Browse for files and assets */
		// -------- //
		space_type_items_CONSOLE = 18	/**< Interactive programmatic console for advanced editing and script development */
	};

	/**
	 * Enum: region_type_items
	 */
	enum region_type_items {
		region_type_items_WINDOW = 0,	
		region_type_items_HEADER = 1,	
		region_type_items_CHANNELS = 2,	
		region_type_items_TEMPORARY = 3,	
		region_type_items_UI = 4,	
		region_type_items_TOOLS = 5,	
		region_type_items_TOOL_PROPS = 6,	
		region_type_items_PREVIEW = 7	
	};

	/**
	 * Function: create
	 * @param Param 'name'
	 * @param Param 'space_type'
	 * @param Param 'region_type'
	 * @param Param 'modal'
	 * @return Added key map
	 */
	KeyMap create(const std::string name, space_type_items space_type = space_type_items_EMPTY, region_type_items region_type = region_type_items_WINDOW, bool modal = false);

	/**
	 * Function: remove
	 * @param Removed key map
	 */
	void remove(KeyMap keymap);

	/**
	 * Function: find
	 * @param Param 'name'
	 * @param Param 'space_type'
	 * @param Param 'region_type'
	 * @return Corresponding key map
	 */
	KeyMap find(const std::string name, space_type_items space_type = space_type_items_EMPTY, region_type_items region_type = region_type_items_WINDOW);

	/**
	 * Function: find_modal
	 * @param Param 'name'
	 * @return Corresponding key map
	 */
	KeyMap find_modal(const std::string name);

};

/**************** KeyMap Items ****************/

/**
 * Collection of keymap items
 */
class KeyMapItems : public pyUniplug {
public:
	KeyMapItems(PyObject* pyobj) : pyUniplug(pyobj) {}

	KeyMapItems() : pyUniplug(0)
	{
		// not implemented
	}

	/**
	 * Enum: event_type_items
	 */
	enum event_type_items {
		event_type_items_NONE = 0,	
		event_type_items_LEFTMOUSE = 1,	
		event_type_items_MIDDLEMOUSE = 2,	
		event_type_items_RIGHTMOUSE = 3,	
		event_type_items_BUTTON4MOUSE = 7,	
		event_type_items_BUTTON5MOUSE = 8,	
		event_type_items_BUTTON6MOUSE = 18,	
		event_type_items_BUTTON7MOUSE = 19,	
		event_type_items_ACTIONMOUSE = 5,	
		event_type_items_SELECTMOUSE = 6,	
		// -------- //
		event_type_items_MOUSEMOVE = 4,	
		event_type_items_INBETWEEN_MOUSEMOVE = 17,	
		event_type_items_TRACKPADPAN = 14,	
		event_type_items_TRACKPADZOOM = 15,	
		event_type_items_MOUSEROTATE = 16,	
		// -------- //
		event_type_items_WHEELUPMOUSE = 10,	
		event_type_items_WHEELDOWNMOUSE = 11,	
		event_type_items_WHEELINMOUSE = 12,	
		event_type_items_WHEELOUTMOUSE = 13,	
		// -------- //
		event_type_items_EVT_TWEAK_L = 20482,	
		event_type_items_EVT_TWEAK_M = 20483,	
		event_type_items_EVT_TWEAK_R = 20484,	
		event_type_items_EVT_TWEAK_A = 20485,	
		event_type_items_EVT_TWEAK_S = 20486,	
		// -------- //
		event_type_items_A = 97,	
		event_type_items_B = 98,	
		event_type_items_C = 99,	
		event_type_items_D = 100,	
		event_type_items_E = 101,	
		event_type_items_F = 102,	
		event_type_items_G = 103,	
		event_type_items_H = 104,	
		event_type_items_I = 105,	
		event_type_items_J = 106,	
		event_type_items_K = 107,	
		event_type_items_L = 108,	
		event_type_items_M = 109,	
		event_type_items_N = 110,	
		event_type_items_O = 111,	
		event_type_items_P = 112,	
		event_type_items_Q = 113,	
		event_type_items_R = 114,	
		event_type_items_S = 115,	
		event_type_items_T = 116,	
		event_type_items_U = 117,	
		event_type_items_V = 118,	
		event_type_items_W = 119,	
		event_type_items_X = 120,	
		event_type_items_Y = 121,	
		event_type_items_Z = 122,	
		// -------- //
		event_type_items_ZERO = 48,	
		event_type_items_ONE = 49,	
		event_type_items_TWO = 50,	
		event_type_items_THREE = 51,	
		event_type_items_FOUR = 52,	
		event_type_items_FIVE = 53,	
		event_type_items_SIX = 54,	
		event_type_items_SEVEN = 55,	
		event_type_items_EIGHT = 56,	
		event_type_items_NINE = 57,	
		// -------- //
		event_type_items_LEFT_CTRL = 212,	
		event_type_items_LEFT_ALT = 213,	
		event_type_items_LEFT_SHIFT = 217,	
		event_type_items_RIGHT_ALT = 214,	
		event_type_items_RIGHT_CTRL = 215,	
		event_type_items_RIGHT_SHIFT = 216,	
		// -------- //
		event_type_items_OSKEY = 172,	
		event_type_items_GRLESS = 173,	
		event_type_items_ESC = 218,	
		event_type_items_TAB = 219,	
		event_type_items_RET = 220,	
		event_type_items_SPACE = 221,	
		event_type_items_LINE_FEED = 222,	
		event_type_items_BACK_SPACE = 223,	
		event_type_items_DEL = 224,	
		event_type_items_SEMI_COLON = 225,	
		event_type_items_PERIOD = 226,	
		event_type_items_COMMA = 227,	
		event_type_items_QUOTE = 228,	
		event_type_items_ACCENT_GRAVE = 229,	
		event_type_items_MINUS = 230,	
		event_type_items_SLASH = 232,	
		event_type_items_BACK_SLASH = 233,	
		event_type_items_EQUAL = 234,	
		event_type_items_LEFT_BRACKET = 235,	
		event_type_items_RIGHT_BRACKET = 236,	
		event_type_items_LEFT_ARROW = 137,	
		event_type_items_DOWN_ARROW = 138,	
		event_type_items_RIGHT_ARROW = 139,	
		event_type_items_UP_ARROW = 140,	
		event_type_items_NUMPAD_2 = 152,	
		event_type_items_NUMPAD_4 = 154,	
		event_type_items_NUMPAD_6 = 156,	
		event_type_items_NUMPAD_8 = 158,	
		event_type_items_NUMPAD_1 = 151,	
		event_type_items_NUMPAD_3 = 153,	
		event_type_items_NUMPAD_5 = 155,	
		event_type_items_NUMPAD_7 = 157,	
		event_type_items_NUMPAD_9 = 159,	
		event_type_items_NUMPAD_PERIOD = 199,	
		event_type_items_NUMPAD_SLASH = 161,	
		event_type_items_NUMPAD_ASTERIX = 160,	
		event_type_items_NUMPAD_0 = 150,	
		event_type_items_NUMPAD_MINUS = 162,	
		event_type_items_NUMPAD_ENTER = 163,	
		event_type_items_NUMPAD_PLUS = 164,	
		event_type_items_F1 = 300,	
		event_type_items_F2 = 301,	
		event_type_items_F3 = 302,	
		event_type_items_F4 = 303,	
		event_type_items_F5 = 304,	
		event_type_items_F6 = 305,	
		event_type_items_F7 = 306,	
		event_type_items_F8 = 307,	
		event_type_items_F9 = 308,	
		event_type_items_F10 = 309,	
		event_type_items_F11 = 310,	
		event_type_items_F12 = 311,	
		event_type_items_F13 = 312,	
		event_type_items_F14 = 313,	
		event_type_items_F15 = 314,	
		event_type_items_F16 = 315,	
		event_type_items_F17 = 316,	
		event_type_items_F18 = 317,	
		event_type_items_F19 = 318,	
		event_type_items_PAUSE = 165,	
		event_type_items_INSERT = 166,	
		event_type_items_HOME = 167,	
		event_type_items_PAGE_UP = 168,	
		event_type_items_PAGE_DOWN = 169,	
		event_type_items_END = 170,	
		// -------- //
		event_type_items_MEDIA_PLAY = 174,	
		event_type_items_MEDIA_STOP = 175,	
		event_type_items_MEDIA_FIRST = 176,	
		event_type_items_MEDIA_LAST = 177,	
		// -------- //
		event_type_items_TEXTINPUT = -2,	
		// -------- //
		event_type_items_WINDOW_DEACTIVATE = 260,	
		event_type_items_TIMER = 272,	
		event_type_items_TIMER0 = 273,	
		event_type_items_TIMER1 = 274,	
		event_type_items_TIMER2 = 275,	
		event_type_items_TIMER_JOBS = 276,	
		event_type_items_TIMER_AUTOSAVE = 277,	
		event_type_items_TIMER_REPORT = 278,	
		event_type_items_TIMERREGION = 279,	
		// -------- //
		event_type_items_NDOF_MOTION = 400,	
		event_type_items_NDOF_BUTTON_MENU = 401,	
		event_type_items_NDOF_BUTTON_FIT = 402,	
		event_type_items_NDOF_BUTTON_TOP = 403,	
		event_type_items_NDOF_BUTTON_BOTTOM = 404,	
		event_type_items_NDOF_BUTTON_LEFT = 405,	
		event_type_items_NDOF_BUTTON_RIGHT = 406,	
		event_type_items_NDOF_BUTTON_FRONT = 407,	
		event_type_items_NDOF_BUTTON_BACK = 408,	
		event_type_items_NDOF_BUTTON_ISO1 = 409,	
		event_type_items_NDOF_BUTTON_ISO2 = 410,	
		event_type_items_NDOF_BUTTON_ROLL_CW = 411,	
		event_type_items_NDOF_BUTTON_ROLL_CCW = 412,	
		event_type_items_NDOF_BUTTON_SPIN_CW = 413,	
		event_type_items_NDOF_BUTTON_SPIN_CCW = 414,	
		event_type_items_NDOF_BUTTON_TILT_CW = 415,	
		event_type_items_NDOF_BUTTON_TILT_CCW = 416,	
		event_type_items_NDOF_BUTTON_ROTATE = 417,	
		event_type_items_NDOF_BUTTON_PANZOOM = 418,	
		event_type_items_NDOF_BUTTON_DOMINANT = 419,	
		event_type_items_NDOF_BUTTON_PLUS = 420,	
		event_type_items_NDOF_BUTTON_MINUS = 421,	
		event_type_items_NDOF_BUTTON_ESC = 422,	
		event_type_items_NDOF_BUTTON_ALT = 423,	
		event_type_items_NDOF_BUTTON_SHIFT = 424,	
		event_type_items_NDOF_BUTTON_CTRL = 425,	
		event_type_items_NDOF_BUTTON_1 = 426,	
		event_type_items_NDOF_BUTTON_2 = 427,	
		event_type_items_NDOF_BUTTON_3 = 428,	
		event_type_items_NDOF_BUTTON_4 = 429,	
		event_type_items_NDOF_BUTTON_5 = 430,	
		event_type_items_NDOF_BUTTON_6 = 431,	
		event_type_items_NDOF_BUTTON_7 = 432,	
		event_type_items_NDOF_BUTTON_8 = 433,	
		event_type_items_NDOF_BUTTON_9 = 434,	
		event_type_items_NDOF_BUTTON_10 = 435,	
		event_type_items_NDOF_BUTTON_A = 436,	
		event_type_items_NDOF_BUTTON_B = 437,	
		event_type_items_NDOF_BUTTON_C = 438	
	};

	/**
	 * Enum: event_value_items
	 */
	enum event_value_items {
		event_value_items_ANY = -1,	
		event_value_items_NOTHING = 0,	
		event_value_items_PRESS = 1,	
		event_value_items_RELEASE = 2,	
		event_value_items_CLICK = 3,	
		event_value_items_DOUBLE_CLICK = 4,	
		event_value_items_NORTH = 1,	
		event_value_items_NORTH_EAST = 2,	
		event_value_items_EAST = 3,	
		event_value_items_SOUTH_EAST = 4,	
		event_value_items_SOUTH = 5,	
		event_value_items_SOUTH_WEST = 6,	
		event_value_items_WEST = 7,	
		event_value_items_NORTH_WEST = 8	
	};

	/**
	 * Function: create
	 * @param Param 'idname'
	 * @param Param 'type'
	 * @param Param 'value'
	 * @param Param 'any'
	 * @param Param 'shift'
	 * @param Param 'ctrl'
	 * @param Param 'alt'
	 * @param Param 'oskey'
	 * @param Param 'key_modifier'
	 * @param Force item to be added at start (not end) of key map so that it doesn't get blocked by an existing key map item
	 * @return Added key map item
	 */
	KeyMapItem create(const std::string idname, event_type_items type, event_value_items value, bool any = false, bool shift = false, bool ctrl = false, bool alt = false, bool oskey = false, event_type_items key_modifier = event_type_items_NONE, bool head = false);

	/**
	 * Function: new_modal
	 * @param Param 'propvalue'
	 * @param Param 'type'
	 * @param Param 'value'
	 * @param Param 'any'
	 * @param Param 'shift'
	 * @param Param 'ctrl'
	 * @param Param 'alt'
	 * @param Param 'oskey'
	 * @param Param 'key_modifier'
	 * @return Added key map item
	 */
	KeyMapItem new_modal(const std::string propvalue, event_type_items type, event_value_items value, bool any = false, bool shift = false, bool ctrl = false, bool alt = false, bool oskey = false, event_type_items key_modifier = event_type_items_NONE);

	/**
	 * Function: remove
	 * @param Param 'item'
	 */
	void remove(KeyMapItem item);

	/**
	 * Function: from_id
	 * @param ID of the item
	 * @return 
	 */
	KeyMapItem from_id(int id);

};

/**************** Texture Slots ****************/

/**
 * Collection of texture slots
 */
class WorldTextureSlots : public pyUniplug {
public:
	WorldTextureSlots(PyObject* pyobj) : pyUniplug(pyobj) {}

	WorldTextureSlots() : pyUniplug(0)
	{
		// not implemented
	}

	/**
	 * Function: add
	 * @return The newly initialized mtex
	 */
	WorldTextureSlot add();

	/**
	 * Function: create
	 * @param Slot index to initialize
	 * @return The newly initialized mtex
	 */
	WorldTextureSlot create(int index);

	/**
	 * Function: clear
	 * @param Slot index to clear
	 */
	void clear(int index)
	{
		// not implemented
	}

};

/**************** Movie Tracking Markers ****************/

/**
 * Collection of markers for movie tracking track
 */
class MovieTrackingMarkers : public pyUniplug {
public:
	MovieTrackingMarkers(PyObject* pyobj) : pyUniplug(pyobj) {}

	MovieTrackingMarkers() : pyUniplug(0)
	{
		// not implemented
	}

	/**
	 * Get marker for specified frame
	 * @param Frame number to find marker for
	 * @param Get marker at exact frame number rather than get estimated marker
	 * @return Marker for specified frame
	 */
	MovieTrackingMarker find_frame(int frame, bool exact = true);

	/**
	 * Insert a new marker at the specified frame
	 * @param Frame number to insert marker to
	 * @param Place new marker at the given frame using specified in normalized space coordinates
	 * @return Newly created marker
	 */
	MovieTrackingMarker insert_frame(int frame, float co[2]);

	/**
	 * Delete marker at specified frame
	 * @param Frame number to delete marker from
	 */
	void delete_frame(int frame)
	{
		// not implemented
	}

};

/**************** Movie Tracking Plane Markers ****************/

/**
 * Collection of markers for movie tracking plane track
 */
class MovieTrackingPlaneMarkers : public pyUniplug {
public:
	MovieTrackingPlaneMarkers(PyObject* pyobj) : pyUniplug(pyobj) {}

	MovieTrackingPlaneMarkers() : pyUniplug(0)
	{
		// not implemented
	}

	/**
	 * Get plane marker for specified frame
	 * @param Frame number to find marker for
	 * @param Get plane marker at exact frame number rather than get estimated marker
	 * @return Plane marker for specified frame
	 */
	MovieTrackingPlaneMarker find_frame(int frame, bool exact = true);

	/**
	 * Insert a new plane marker at the specified frame
	 * @param Frame number to insert marker to
	 * @return Newly created plane marker
	 */
	MovieTrackingPlaneMarker insert_frame(int frame);

	/**
	 * Delete plane marker at specified frame
	 * @param Frame number to delete plane marker from
	 */
	void delete_frame(int frame)
	{
		// not implemented
	}

};

/**************** Movie Tracks ****************/

/**
 * Collection of movie tracking tracks
 */
class MovieTrackingTracks : public pyUniplug {
public:
	MovieTrackingTracks(PyObject* pyobj) : pyUniplug(pyobj) {}

	MovieTrackingTracks() : pyUniplug(0)
	{
		// not implemented
	}

	/** Getter: Active track in this tracking data object */
	MovieTrackingTrack active();

	/**
	 * Create new motion track in this movie clip
	 * @param Name of new track
	 * @param Frame number to add track on
	 * @return Newly created track
	 */
	MovieTrackingTrack create(const std::string name = NULL, int frame = 1);

};

/**************** Movie Plane Tracks ****************/

/**
 * Collection of movie tracking plane tracks
 */
class MovieTrackingPlaneTracks : public pyUniplug {
public:
	MovieTrackingPlaneTracks(PyObject* pyobj) : pyUniplug(pyobj) {}

	MovieTrackingPlaneTracks() : pyUniplug(0)
	{
		// not implemented
	}

	/** Getter: Active plane track in this tracking data object */
	MovieTrackingPlaneTrack active();

};

/**************** Movie Tracks ****************/

/**
 * Collection of movie tracking tracks
 */
class MovieTrackingObjectTracks : public pyUniplug {
public:
	MovieTrackingObjectTracks(PyObject* pyobj) : pyUniplug(pyobj) {}

	MovieTrackingObjectTracks() : pyUniplug(0)
	{
		// not implemented
	}

	/** Getter: Active track in this tracking data object */
	MovieTrackingTrack active();

	/**
	 * create new motion track in this movie clip
	 * @param Name of new track
	 * @param Frame number to add tracks on
	 * @return Newly created track
	 */
	MovieTrackingTrack create(const std::string name = NULL, int frame = 1);

};

/**************** Plane Tracks ****************/

/**
 * Collection of tracking plane tracks
 */
class MovieTrackingObjectPlaneTracks : public pyUniplug {
public:
	MovieTrackingObjectPlaneTracks(PyObject* pyobj) : pyUniplug(pyobj) {}

	MovieTrackingObjectPlaneTracks() : pyUniplug(0)
	{
		// not implemented
	}

	/** Getter: Active track in this tracking data object */
	MovieTrackingTrack active();

};

/**************** Reconstructed Cameras ****************/

/**
 * Collection of solved cameras
 */
class MovieTrackingReconstructedCameras : public pyUniplug {
public:
	MovieTrackingReconstructedCameras(PyObject* pyobj) : pyUniplug(pyobj) {}

	MovieTrackingReconstructedCameras() : pyUniplug(0)
	{
		// not implemented
	}

	/**
	 * Find a reconstructed camera for a give frame number
	 * @param Frame number to find camera for
	 * @return Camera for a given frame
	 */
	MovieReconstructedCamera find_frame(int frame = 1);

	/**
	 * Return interpolated camera matrix for a given frame
	 * @param Frame number to find camera for
	 * @return Interpolated camera matrix for a given frame
	 */
	std::array<float, 16> matrix_from_frame(int frame = 1)
	{
		// not implemented
		throw NULL;
	}

};

/**************** Movie Objects ****************/

/**
 * Collection of movie trackingobjects
 */
class MovieTrackingObjects : public pyUniplug {
public:
	MovieTrackingObjects(PyObject* pyobj) : pyUniplug(pyobj) {}

	MovieTrackingObjects() : pyUniplug(0)
	{
		// not implemented
	}

	/** Getter: Active object in this tracking data object */
	MovieTrackingObject active();

	/**
	 * Add tracking object to this movie clip
	 * @param Name of new object
	 * @return New motion tracking object
	 */
	MovieTrackingObject create(const std::string name);

	/**
	 * Remove tracking object from this movie clip
	 * @param Motion tracking object to be removed
	 */
	void remove(MovieTrackingObject object_value);

};

/**************** Mask Splines ****************/

/**
 * Collection of masking splines
 */
class MaskSplines : public pyUniplug {
public:
	MaskSplines(PyObject* pyobj) : pyUniplug(pyobj) {}

	MaskSplines() : pyUniplug(0)
	{
		// not implemented
	}

	/** Getter: Active spline of masking layer */
	MaskSpline active();

	/** Getter: Active spline of masking layer */
	MaskSplinePoint active_point();

	/**
	 * Add a new spline to the layer
	 * @return The newly created spline
	 */
	MaskSpline create();

	/**
	 * Remove a spline from a layer
	 * @param The spline to remove
	 */
	void remove(MaskSpline spline);

};

/**************** Mask Spline Points ****************/

/**
 * Collection of masking spline points
 */
class MaskSplinePoints : public pyUniplug {
public:
	MaskSplinePoints(PyObject* pyobj) : pyUniplug(pyobj) {}

	MaskSplinePoints() : pyUniplug(0)
	{
		// not implemented
	}

	/**
	 * Add a number of point to this spline
	 * @param Number of points to add to the spline
	 */
	void add(int count = 1)
	{
		// not implemented
	}

	/**
	 * Remove a point from a spline
	 * @param The point to remove
	 */
	void remove(MaskSplinePoint point);

};

/**************** Mask Layers ****************/

/**
 * Collection of layers used by mask
 */
class MaskLayers : public pyUniplug {
public:
	MaskLayers(PyObject* pyobj) : pyUniplug(pyobj) {}

	MaskLayers() : pyUniplug(0)
	{
		// not implemented
	}

	/** Getter: Active layer in this mask */
	MaskLayer active();

	/**
	 * Add layer to this mask
	 * @param Name of new layer
	 * @return New mask layer
	 */
	MaskLayer create(const std::string name = NULL);

	/**
	 * Remove layer from this mask
	 * @param Shape to be removed
	 */
	void remove(MaskLayer layer);

	/**
	 * Remove all mask layers
	 */
	void clear()
	{
		// not implemented
	}

};

/**************** Action ****************/

/**
 * A collection of F-Curves for animation
 */
class Action : public ID {
public:
	Action(PyObject* pyobj) : ID(pyobj) {}

	Action() : ID(0)
	{
		// not implemented
	}

	/** Getter: The individual F-Curves that make up the action */
	std::map<std::string, FCurve> fcurves();
	/** Setter: The individual F-Curves that make up the action */
	void fcurves(std::map<std::string, FCurve> value);

	/** Getter: Convenient groupings of F-Curves */
	std::map<std::string, ActionGroup> groups();
	/** Setter: Convenient groupings of F-Curves */
	void groups(std::map<std::string, ActionGroup> value);

	/** Getter: Markers specific to this action, for labeling poses */
	std::map<std::string, TimelineMarker> pose_markers();
	/** Setter: Markers specific to this action, for labeling poses */
	void pose_markers(std::map<std::string, TimelineMarker> value);

	/** Getter: The final frame range of all F-Curves within this action */
	std::array<float, 2> frame_range() {
		// TODO: MISSING DEREF! USE #DEFINE!
		PyObject *seqval = PyObject_GetAttrString(pyobjref, "frame_range");
		std::array<float, 2> resarr;
		for (int i = 0; i < 2; i++)
			resarr[i] = (float)PyFloat_AsDouble(PySequence_GetItem(seqval, i));
		return resarr;
	}

	/** Setter: The final frame range of all F-Curves within this action */
	void frame_range(float values[2]) { /* not implemented */ }

	enum id_root_enum {
		id_root_ACTION = 17217,
		id_root_ARMATURE = 21057,
		id_root_BRUSH = 21058,
		id_root_CAMERA = 16707,
		id_root_CURVE = 21827,
		id_root_FONT = 18006,
		id_root_GREASEPENCIL = 17479,
		id_root_GROUP = 21063,
		id_root_IMAGE = 19785,
		id_root_KEY = 17739,
		id_root_LAMP = 16716,
		id_root_LIBRARY = 18764,
		id_root_LINESTYLE = 21324,
		id_root_LATTICE = 21580,
		id_root_MASK = 21325,
		id_root_MATERIAL = 16717,
		id_root_META = 16973,
		id_root_MESH = 17741,
		id_root_MOVIECLIP = 17229,
		id_root_NODETREE = 21582,
		id_root_OBJECT = 16975,
		id_root_PAINTCURVE = 17232,
		id_root_PALETTE = 19536,
		id_root_PARTICLE = 16720,
		id_root_SCENE = 17235,
		id_root_SCREEN = 21075,
		id_root_SOUND = 20307,
		id_root_SPEAKER = 19283,
		id_root_TEXT = 22612,
		id_root_TEXTURE = 17748,
		id_root_WINDOWMANAGER = 19799,
		id_root_WORLD = 20311,
	};

	/** Getter: Type of ID block that action can be used on - DO NOT CHANGE UNLESS YOU KNOW WHAT YOU ARE DOING */
	id_root_enum id_root() { /* not implemented */ throw NULL; }
	/** Setter: Type of ID block that action can be used on - DO NOT CHANGE UNLESS YOU KNOW WHAT YOU ARE DOING */
	void id_root(id_root_enum value) { /* not implemented */ }

};

/**************** Action Group ****************/

/**
 * Groups of F-Curves
 */
class ActionGroup : public pyUniplug {
public:
	ActionGroup(PyObject* pyobj) : pyUniplug(pyobj) {}

	ActionGroup() : pyUniplug(0)
	{
		// not implemented
	}

	/** Getter:  */
	std::string name() { /* not implemented */ throw NULL; }
	/** Setter:  */
	void name(const std::string& value) { /* not implemented */ }

	/** Getter: F-Curves in this group */
	std::map<std::string, FCurve> channels();
	/** Setter: F-Curves in this group */
	void channels(std::map<std::string, FCurve> value);

	/** Getter: Action group is selected */
	bool select() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "select")) == 1;
	}

	/** Setter: Action group is selected */
	void select(bool value) {
		PyObject_SetAttrString(pyobjref, "select", Py_BuildValue("i", value));
	}

	/** Getter: Action group is locked */
	bool lock_value() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "lock")) == 1;
	}

	/** Setter: Action group is locked */
	void lock_value(bool value) {
		PyObject_SetAttrString(pyobjref, "lock", Py_BuildValue("i", value));
	}

	/** Getter: Action group is expanded */
	bool show_expanded() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "show_expanded")) == 1;
	}

	/** Setter: Action group is expanded */
	void show_expanded(bool value) {
		PyObject_SetAttrString(pyobjref, "show_expanded", Py_BuildValue("i", value));
	}

	enum color_set_enum {
		color_set_DEFAULT = 0,
		color_set_THEME01 = 1,
		color_set_THEME02 = 2,
		color_set_THEME03 = 3,
		color_set_THEME04 = 4,
		color_set_THEME05 = 5,
		color_set_THEME06 = 6,
		color_set_THEME07 = 7,
		color_set_THEME08 = 8,
		color_set_THEME09 = 9,
		color_set_THEME10 = 10,
		color_set_THEME11 = 11,
		color_set_THEME12 = 12,
		color_set_THEME13 = 13,
		color_set_THEME14 = 14,
		color_set_THEME15 = 15,
		color_set_THEME16 = 16,
		color_set_THEME17 = 17,
		color_set_THEME18 = 18,
		color_set_THEME19 = 19,
		color_set_THEME20 = 20,
		color_set_CUSTOM = -1,
	};

	/** Getter: Custom color set to use */
	color_set_enum color_set() { /* not implemented */ throw NULL; }
	/** Setter: Custom color set to use */
	void color_set(color_set_enum value) { /* not implemented */ }

	/** Getter: Color set is user-defined instead of a fixed theme color set */
	bool is_custom_color_set() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "is_custom_color_set")) == 1;
	}

	/** Setter: Color set is user-defined instead of a fixed theme color set */
	void is_custom_color_set(bool value) {
		PyObject_SetAttrString(pyobjref, "is_custom_color_set", Py_BuildValue("i", value));
	}

	/** Getter: Copy of the colors associated with the group's color set */
	ThemeBoneColorSet colors();

};

/**************** Dope Sheet ****************/

/**
 * Settings for filtering the channels shown in animation editors
 */
class DopeSheet : public pyUniplug {
public:
	DopeSheet(PyObject* pyobj) : pyUniplug(pyobj) {}

	DopeSheet() : pyUniplug(0)
	{
		// not implemented
	}

	/** Getter: ID-Block representing source data, usually ID_SCE (i.e. Scene) */
	ID source() {
		/* not implemented */ throw NULL;
	}

	/** Getter: Show options for whether channels related to certain types of data are included */
	bool show_datablock_filters() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "show_datablock_filters")) == 1;
	}

	/** Setter: Show options for whether channels related to certain types of data are included */
	void show_datablock_filters(bool value) {
		PyObject_SetAttrString(pyobjref, "show_datablock_filters", Py_BuildValue("i", value));
	}

	/** Getter: Only include channels relating to selected objects and data */
	bool show_only_selected() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "show_only_selected")) == 1;
	}

	/** Setter: Only include channels relating to selected objects and data */
	void show_only_selected(bool value) {
		PyObject_SetAttrString(pyobjref, "show_only_selected", Py_BuildValue("i", value));
	}

	/** Getter: Include channels from objects/bone that are not visible */
	bool show_hidden() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "show_hidden")) == 1;
	}

	/** Setter: Include channels from objects/bone that are not visible */
	void show_hidden(bool value) {
		PyObject_SetAttrString(pyobjref, "show_hidden", Py_BuildValue("i", value));
	}

	/** Getter: Only include F-Curves and drivers that are disabled or have errors */
	bool show_only_errors() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "show_only_errors")) == 1;
	}

	/** Setter: Only include F-Curves and drivers that are disabled or have errors */
	void show_only_errors(bool value) {
		PyObject_SetAttrString(pyobjref, "show_only_errors", Py_BuildValue("i", value));
	}

	/** Getter: Only include channels from objects in the specified group */
	bool show_only_group_objects() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "show_only_group_objects")) == 1;
	}

	/** Setter: Only include channels from objects in the specified group */
	void show_only_group_objects(bool value) {
		PyObject_SetAttrString(pyobjref, "show_only_group_objects", Py_BuildValue("i", value));
	}

	/** Getter: Group that included object should be a member of */
	Group filter_group();

	/** Getter: Only include F-Curves with names containing search text */
	bool show_only_matching_fcurves() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "show_only_matching_fcurves")) == 1;
	}

	/** Setter: Only include F-Curves with names containing search text */
	void show_only_matching_fcurves(bool value) {
		PyObject_SetAttrString(pyobjref, "show_only_matching_fcurves", Py_BuildValue("i", value));
	}

	/** Getter: F-Curve live filtering string */
	std::string filter_fcurve_name() { /* not implemented */ throw NULL; }
	/** Setter: F-Curve live filtering string */
	void filter_fcurve_name(const std::string& value) { /* not implemented */ }

	/** Getter: Only include channels with names containing search text */
	bool use_filter_text() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_filter_text")) == 1;
	}

	/** Setter: Only include channels with names containing search text */
	void use_filter_text(bool value) {
		PyObject_SetAttrString(pyobjref, "use_filter_text", Py_BuildValue("i", value));
	}

	/** Getter: Live filtering string */
	std::string filter_text() { /* not implemented */ throw NULL; }
	/** Setter: Live filtering string */
	void filter_text(const std::string& value) { /* not implemented */ }

	/** Getter: Include animation data blocks with no NLA data (NLA editor only) */
	bool show_missing_nla() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "show_missing_nla")) == 1;
	}

	/** Setter: Include animation data blocks with no NLA data (NLA editor only) */
	void show_missing_nla(bool value) {
		PyObject_SetAttrString(pyobjref, "show_missing_nla", Py_BuildValue("i", value));
	}

	/** Getter: Display an additional 'summary' line (Dope Sheet editors only) */
	bool show_summary() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "show_summary")) == 1;
	}

	/** Setter: Display an additional 'summary' line (Dope Sheet editors only) */
	void show_summary(bool value) {
		PyObject_SetAttrString(pyobjref, "show_summary", Py_BuildValue("i", value));
	}

	/** Getter: Collapse summary when shown, so all other channels get hidden (Dope Sheet editors only) */
	bool show_expanded_summary() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "show_expanded_summary")) == 1;
	}

	/** Setter: Collapse summary when shown, so all other channels get hidden (Dope Sheet editors only) */
	void show_expanded_summary(bool value) {
		PyObject_SetAttrString(pyobjref, "show_expanded_summary", Py_BuildValue("i", value));
	}

	/** Getter: Include visualization of object-level animation data (mostly transforms) */
	bool show_transforms() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "show_transforms")) == 1;
	}

	/** Setter: Include visualization of object-level animation data (mostly transforms) */
	void show_transforms(bool value) {
		PyObject_SetAttrString(pyobjref, "show_transforms", Py_BuildValue("i", value));
	}

	/** Getter: Include visualization of shape key related animation data */
	bool show_shapekeys() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "show_shapekeys")) == 1;
	}

	/** Setter: Include visualization of shape key related animation data */
	void show_shapekeys(bool value) {
		PyObject_SetAttrString(pyobjref, "show_shapekeys", Py_BuildValue("i", value));
	}

	/** Getter: Include visualization of animation data related to datablocks linked to modifiers */
	bool show_modifiers() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "show_modifiers")) == 1;
	}

	/** Setter: Include visualization of animation data related to datablocks linked to modifiers */
	void show_modifiers(bool value) {
		PyObject_SetAttrString(pyobjref, "show_modifiers", Py_BuildValue("i", value));
	}

	/** Getter: Include visualization of mesh related animation data */
	bool show_meshes() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "show_meshes")) == 1;
	}

	/** Setter: Include visualization of mesh related animation data */
	void show_meshes(bool value) {
		PyObject_SetAttrString(pyobjref, "show_meshes", Py_BuildValue("i", value));
	}

	/** Getter: Include visualization of lattice related animation data */
	bool show_lattices() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "show_lattices")) == 1;
	}

	/** Setter: Include visualization of lattice related animation data */
	void show_lattices(bool value) {
		PyObject_SetAttrString(pyobjref, "show_lattices", Py_BuildValue("i", value));
	}

	/** Getter: Include visualization of camera related animation data */
	bool show_cameras() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "show_cameras")) == 1;
	}

	/** Setter: Include visualization of camera related animation data */
	void show_cameras(bool value) {
		PyObject_SetAttrString(pyobjref, "show_cameras", Py_BuildValue("i", value));
	}

	/** Getter: Include visualization of material related animation data */
	bool show_materials() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "show_materials")) == 1;
	}

	/** Setter: Include visualization of material related animation data */
	void show_materials(bool value) {
		PyObject_SetAttrString(pyobjref, "show_materials", Py_BuildValue("i", value));
	}

	/** Getter: Include visualization of lamp related animation data */
	bool show_lamps() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "show_lamps")) == 1;
	}

	/** Setter: Include visualization of lamp related animation data */
	void show_lamps(bool value) {
		PyObject_SetAttrString(pyobjref, "show_lamps", Py_BuildValue("i", value));
	}

	/** Getter: Include visualization of Line Style related Animation data */
	bool show_linestyles() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "show_linestyles")) == 1;
	}

	/** Setter: Include visualization of Line Style related Animation data */
	void show_linestyles(bool value) {
		PyObject_SetAttrString(pyobjref, "show_linestyles", Py_BuildValue("i", value));
	}

	/** Getter: Include visualization of texture related animation data */
	bool show_textures() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "show_textures")) == 1;
	}

	/** Setter: Include visualization of texture related animation data */
	void show_textures(bool value) {
		PyObject_SetAttrString(pyobjref, "show_textures", Py_BuildValue("i", value));
	}

	/** Getter: Include visualization of curve related animation data */
	bool show_curves() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "show_curves")) == 1;
	}

	/** Setter: Include visualization of curve related animation data */
	void show_curves(bool value) {
		PyObject_SetAttrString(pyobjref, "show_curves", Py_BuildValue("i", value));
	}

	/** Getter: Include visualization of world related animation data */
	bool show_worlds() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "show_worlds")) == 1;
	}

	/** Setter: Include visualization of world related animation data */
	void show_worlds(bool value) {
		PyObject_SetAttrString(pyobjref, "show_worlds", Py_BuildValue("i", value));
	}

	/** Getter: Include visualization of scene related animation data */
	bool show_scenes() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "show_scenes")) == 1;
	}

	/** Setter: Include visualization of scene related animation data */
	void show_scenes(bool value) {
		PyObject_SetAttrString(pyobjref, "show_scenes", Py_BuildValue("i", value));
	}

	/** Getter: Include visualization of particle related animation data */
	bool show_particles() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "show_particles")) == 1;
	}

	/** Setter: Include visualization of particle related animation data */
	void show_particles(bool value) {
		PyObject_SetAttrString(pyobjref, "show_particles", Py_BuildValue("i", value));
	}

	/** Getter: Include visualization of metaball related animation data */
	bool show_metaballs() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "show_metaballs")) == 1;
	}

	/** Setter: Include visualization of metaball related animation data */
	void show_metaballs(bool value) {
		PyObject_SetAttrString(pyobjref, "show_metaballs", Py_BuildValue("i", value));
	}

	/** Getter: Include visualization of armature related animation data */
	bool show_armatures() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "show_armatures")) == 1;
	}

	/** Setter: Include visualization of armature related animation data */
	void show_armatures(bool value) {
		PyObject_SetAttrString(pyobjref, "show_armatures", Py_BuildValue("i", value));
	}

	/** Getter: Include visualization of node related animation data */
	bool show_nodes() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "show_nodes")) == 1;
	}

	/** Setter: Include visualization of node related animation data */
	void show_nodes(bool value) {
		PyObject_SetAttrString(pyobjref, "show_nodes", Py_BuildValue("i", value));
	}

	/** Getter: Include visualization of speaker related animation data */
	bool show_speakers() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "show_speakers")) == 1;
	}

	/** Setter: Include visualization of speaker related animation data */
	void show_speakers(bool value) {
		PyObject_SetAttrString(pyobjref, "show_speakers", Py_BuildValue("i", value));
	}

	/** Getter: Include visualization of Grease Pencil related animation data and frames */
	bool show_gpencil() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "show_gpencil")) == 1;
	}

	/** Setter: Include visualization of Grease Pencil related animation data and frames */
	void show_gpencil(bool value) {
		PyObject_SetAttrString(pyobjref, "show_gpencil", Py_BuildValue("i", value));
	}

};

/**************** Animation Data ****************/

/**
 * Animation data for datablock
 */
class AnimData : public pyUniplug {
public:
	AnimData(PyObject* pyobj) : pyUniplug(pyobj) {}

	AnimData() : pyUniplug(0)
	{
		// not implemented
	}

	/** Getter: NLA Tracks (i.e. Animation Layers) */
	std::map<std::string, NlaTrack> nla_tracks();
	/** Setter: NLA Tracks (i.e. Animation Layers) */
	void nla_tracks(std::map<std::string, NlaTrack> value);

	/** Getter: Active Action for this datablock */
	Action action() {
		/* not implemented */ throw NULL;
	}

	enum action_extrapolation_enum {
		action_extrapolation_NOTHING = 2,
		action_extrapolation_HOLD = 0,
		action_extrapolation_HOLD_FORWARD = 1,
	};

	/** Getter: Action to take for gaps past the Active Action's range (when evaluating with NLA) */
	action_extrapolation_enum action_extrapolation() { /* not implemented */ throw NULL; }
	/** Setter: Action to take for gaps past the Active Action's range (when evaluating with NLA) */
	void action_extrapolation(action_extrapolation_enum value) { /* not implemented */ }

	enum action_blend_type_enum {
		action_blend_type_REPLACE = 0,
		action_blend_type_ADD = 1,
		action_blend_type_SUBTRACT = 2,
		action_blend_type_MULTIPLY = 3,
	};

	/** Getter: Method used for combining Active Action's result with result of NLA stack */
	action_blend_type_enum action_blend_type() { /* not implemented */ throw NULL; }
	/** Setter: Method used for combining Active Action's result with result of NLA stack */
	void action_blend_type(action_blend_type_enum value) { /* not implemented */ }

	/** Getter: Amount the Active Action contributes to the result of the NLA stack */
	float action_influence() { /* not implemented */ throw NULL; }
	/** Setter: Amount the Active Action contributes to the result of the NLA stack */
	void action_influence(float value) {
		PyObject_SetAttrString(pyobjref, "action_influence", Py_BuildValue("f", value));
	}

	/** Getter: The Drivers/Expressions for this datablock */
	std::map<std::string, FCurve> drivers();
	/** Setter: The Drivers/Expressions for this datablock */
	void drivers(std::map<std::string, FCurve> value);

	/** Getter: NLA stack is evaluated when evaluating this block */
	bool use_nla() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_nla")) == 1;
	}

	/** Setter: NLA stack is evaluated when evaluating this block */
	void use_nla(bool value) {
		PyObject_SetAttrString(pyobjref, "use_nla", Py_BuildValue("i", value));
	}

};

/**************** Keying Set ****************/

/**
 * Settings that should be keyframed together
 */
class KeyingSet : public pyUniplug {
public:
	KeyingSet(PyObject* pyobj) : pyUniplug(pyobj) {}

	KeyingSet() : pyUniplug(0)
	{
		// not implemented
	}

	/** Getter: If this is set, the Keying Set gets a custom ID, otherwise it takes the name of the class used to define the Keying Set (for example, if the class name is "BUILTIN_KSI_location", and bl_idname is not set by the script, then bl_idname = "BUILTIN_KSI_location") */
	std::string bl_idname() { /* not implemented */ throw NULL; }
	/** Setter: If this is set, the Keying Set gets a custom ID, otherwise it takes the name of the class used to define the Keying Set (for example, if the class name is "BUILTIN_KSI_location", and bl_idname is not set by the script, then bl_idname = "BUILTIN_KSI_location") */
	void bl_idname(const std::string& value) { /* not implemented */ }

	/** Getter:  */
	std::string bl_label() { /* not implemented */ throw NULL; }
	/** Setter:  */
	void bl_label(const std::string& value) { /* not implemented */ }

	/** Getter: A short description of the keying set */
	std::string bl_description() { /* not implemented */ throw NULL; }
	/** Setter: A short description of the keying set */
	void bl_description(const std::string& value) { /* not implemented */ }

	/** Getter: Callback function defines for built-in Keying Sets */
	KeyingSetInfo type_info();

	/** Getter: Keying Set Paths to define settings that get keyframed together */
	std::map<std::string, KeyingSetPath> paths();
	/** Setter: Keying Set Paths to define settings that get keyframed together */
	void paths(std::map<std::string, KeyingSetPath> value);

	/** Getter: Keying Set defines specific paths/settings to be keyframed (i.e. is not reliant on context info) */
	bool is_path_absolute() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "is_path_absolute")) == 1;
	}

	/** Setter: Keying Set defines specific paths/settings to be keyframed (i.e. is not reliant on context info) */
	void is_path_absolute(bool value) {
		PyObject_SetAttrString(pyobjref, "is_path_absolute", Py_BuildValue("i", value));
	}

	/** Getter: Override default setting to only insert keyframes where they're needed in the relevant F-Curves */
	bool use_insertkey_override_needed() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_insertkey_override_needed")) == 1;
	}

	/** Setter: Override default setting to only insert keyframes where they're needed in the relevant F-Curves */
	void use_insertkey_override_needed(bool value) {
		PyObject_SetAttrString(pyobjref, "use_insertkey_override_needed", Py_BuildValue("i", value));
	}

	/** Getter: Override default setting to insert keyframes based on 'visual transforms' */
	bool use_insertkey_override_visual() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_insertkey_override_visual")) == 1;
	}

	/** Setter: Override default setting to insert keyframes based on 'visual transforms' */
	void use_insertkey_override_visual(bool value) {
		PyObject_SetAttrString(pyobjref, "use_insertkey_override_visual", Py_BuildValue("i", value));
	}

	/** Getter: Override default setting to set color for newly added transformation F-Curves (Location, Rotation, Scale) to be based on the transform axis */
	bool use_insertkey_override_xyz_to_rgb() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_insertkey_override_xyz_to_rgb")) == 1;
	}

	/** Setter: Override default setting to set color for newly added transformation F-Curves (Location, Rotation, Scale) to be based on the transform axis */
	void use_insertkey_override_xyz_to_rgb(bool value) {
		PyObject_SetAttrString(pyobjref, "use_insertkey_override_xyz_to_rgb", Py_BuildValue("i", value));
	}

	/** Getter: Only insert keyframes where they're needed in the relevant F-Curves */
	bool use_insertkey_needed() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_insertkey_needed")) == 1;
	}

	/** Setter: Only insert keyframes where they're needed in the relevant F-Curves */
	void use_insertkey_needed(bool value) {
		PyObject_SetAttrString(pyobjref, "use_insertkey_needed", Py_BuildValue("i", value));
	}

	/** Getter: Insert keyframes based on 'visual transforms' */
	bool use_insertkey_visual() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_insertkey_visual")) == 1;
	}

	/** Setter: Insert keyframes based on 'visual transforms' */
	void use_insertkey_visual(bool value) {
		PyObject_SetAttrString(pyobjref, "use_insertkey_visual", Py_BuildValue("i", value));
	}

	/** Getter: Color for newly added transformation F-Curves (Location, Rotation, Scale) is based on the transform axis */
	bool use_insertkey_xyz_to_rgb() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_insertkey_xyz_to_rgb")) == 1;
	}

	/** Setter: Color for newly added transformation F-Curves (Location, Rotation, Scale) is based on the transform axis */
	void use_insertkey_xyz_to_rgb(bool value) {
		PyObject_SetAttrString(pyobjref, "use_insertkey_xyz_to_rgb", Py_BuildValue("i", value));
	}

	/**
	 * Refresh Keying Set to ensure that it is valid for the current context (call before each use of one)
	 */
	void refresh()
	{
		// not implemented
	}

};

/**************** Keying Set Path ****************/

/**
 * Path to a setting for use in a Keying Set
 */
class KeyingSetPath : public pyUniplug {
public:
	KeyingSetPath(PyObject* pyobj) : pyUniplug(pyobj) {}

	KeyingSetPath() : pyUniplug(0)
	{
		// not implemented
	}

	/** Getter: ID-Block that keyframes for Keying Set should be added to (for Absolute Keying Sets only) */
	ID id() {
		/* not implemented */ throw NULL;
	}

	enum id_type_enum {
		id_type_ACTION = 17217,
		id_type_ARMATURE = 21057,
		id_type_BRUSH = 21058,
		id_type_CAMERA = 16707,
		id_type_CURVE = 21827,
		id_type_FONT = 18006,
		id_type_GREASEPENCIL = 17479,
		id_type_GROUP = 21063,
		id_type_IMAGE = 19785,
		id_type_KEY = 17739,
		id_type_LAMP = 16716,
		id_type_LIBRARY = 18764,
		id_type_LINESTYLE = 21324,
		id_type_LATTICE = 21580,
		id_type_MASK = 21325,
		id_type_MATERIAL = 16717,
		id_type_META = 16973,
		id_type_MESH = 17741,
		id_type_MOVIECLIP = 17229,
		id_type_NODETREE = 21582,
		id_type_OBJECT = 16975,
		id_type_PAINTCURVE = 17232,
		id_type_PALETTE = 19536,
		id_type_PARTICLE = 16720,
		id_type_SCENE = 17235,
		id_type_SCREEN = 21075,
		id_type_SOUND = 20307,
		id_type_SPEAKER = 19283,
		id_type_TEXT = 22612,
		id_type_TEXTURE = 17748,
		id_type_WINDOWMANAGER = 19799,
		id_type_WORLD = 20311,
	};

	/** Getter: Type of ID-block that can be used */
	id_type_enum id_type() { /* not implemented */ throw NULL; }
	/** Setter: Type of ID-block that can be used */
	void id_type(id_type_enum value) { /* not implemented */ }

	/** Getter: Name of Action Group to assign setting(s) for this path to */
	std::string group() { /* not implemented */ throw NULL; }
	/** Setter: Name of Action Group to assign setting(s) for this path to */
	void group(const std::string& value) { /* not implemented */ }

	enum group_method_enum {
		group_method_NAMED = 0,
		group_method_NONE = 1,
		group_method_KEYINGSET = 2,
	};

	/** Getter: Method used to define which Group-name to use */
	group_method_enum group_method() { /* not implemented */ throw NULL; }
	/** Setter: Method used to define which Group-name to use */
	void group_method(group_method_enum value) { /* not implemented */ }

	/** Getter: Path to property setting */
	std::string data_path() { /* not implemented */ throw NULL; }
	/** Setter: Path to property setting */
	void data_path(const std::string& value) { /* not implemented */ }

	/** Getter: Index to the specific setting if applicable */
	int array_index() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "array_index"));
	}

	/** Setter: Index to the specific setting if applicable */
	void array_index(int value) {
		PyObject_SetAttrString(pyobjref, "array_index", Py_BuildValue("i", value));
	}

	/** Getter: When an 'array/vector' type is chosen (Location, Rotation, Color, etc.), entire array is to be used */
	bool use_entire_array() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_entire_array")) == 1;
	}

	/** Setter: When an 'array/vector' type is chosen (Location, Rotation, Color, etc.), entire array is to be used */
	void use_entire_array(bool value) {
		PyObject_SetAttrString(pyobjref, "use_entire_array", Py_BuildValue("i", value));
	}

	/** Getter: Override default setting to only insert keyframes where they're needed in the relevant F-Curves */
	bool use_insertkey_override_needed() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_insertkey_override_needed")) == 1;
	}

	/** Setter: Override default setting to only insert keyframes where they're needed in the relevant F-Curves */
	void use_insertkey_override_needed(bool value) {
		PyObject_SetAttrString(pyobjref, "use_insertkey_override_needed", Py_BuildValue("i", value));
	}

	/** Getter: Override default setting to insert keyframes based on 'visual transforms' */
	bool use_insertkey_override_visual() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_insertkey_override_visual")) == 1;
	}

	/** Setter: Override default setting to insert keyframes based on 'visual transforms' */
	void use_insertkey_override_visual(bool value) {
		PyObject_SetAttrString(pyobjref, "use_insertkey_override_visual", Py_BuildValue("i", value));
	}

	/** Getter: Override default setting to set color for newly added transformation F-Curves (Location, Rotation, Scale) to be based on the transform axis */
	bool use_insertkey_override_xyz_to_rgb() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_insertkey_override_xyz_to_rgb")) == 1;
	}

	/** Setter: Override default setting to set color for newly added transformation F-Curves (Location, Rotation, Scale) to be based on the transform axis */
	void use_insertkey_override_xyz_to_rgb(bool value) {
		PyObject_SetAttrString(pyobjref, "use_insertkey_override_xyz_to_rgb", Py_BuildValue("i", value));
	}

	/** Getter: Only insert keyframes where they're needed in the relevant F-Curves */
	bool use_insertkey_needed() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_insertkey_needed")) == 1;
	}

	/** Setter: Only insert keyframes where they're needed in the relevant F-Curves */
	void use_insertkey_needed(bool value) {
		PyObject_SetAttrString(pyobjref, "use_insertkey_needed", Py_BuildValue("i", value));
	}

	/** Getter: Insert keyframes based on 'visual transforms' */
	bool use_insertkey_visual() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_insertkey_visual")) == 1;
	}

	/** Setter: Insert keyframes based on 'visual transforms' */
	void use_insertkey_visual(bool value) {
		PyObject_SetAttrString(pyobjref, "use_insertkey_visual", Py_BuildValue("i", value));
	}

	/** Getter: Color for newly added transformation F-Curves (Location, Rotation, Scale) is based on the transform axis */
	bool use_insertkey_xyz_to_rgb() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_insertkey_xyz_to_rgb")) == 1;
	}

	/** Setter: Color for newly added transformation F-Curves (Location, Rotation, Scale) is based on the transform axis */
	void use_insertkey_xyz_to_rgb(bool value) {
		PyObject_SetAttrString(pyobjref, "use_insertkey_xyz_to_rgb", Py_BuildValue("i", value));
	}

};

/**************** Keying Set Info ****************/

/**
 * Callback function defines for builtin Keying Sets
 */
class KeyingSetInfo : public pyUniplug {
public:
	KeyingSetInfo(PyObject* pyobj) : pyUniplug(pyobj) {}

	KeyingSetInfo() : pyUniplug(0)
	{
		// not implemented
	}

	/** Getter: If this is set, the Keying Set gets a custom ID, otherwise it takes the name of the class used to define the Keying Set (for example, if the class name is "BUILTIN_KSI_location", and bl_idname is not set by the script, then bl_idname = "BUILTIN_KSI_location") */
	std::string bl_idname() { /* not implemented */ throw NULL; }
	/** Setter: If this is set, the Keying Set gets a custom ID, otherwise it takes the name of the class used to define the Keying Set (for example, if the class name is "BUILTIN_KSI_location", and bl_idname is not set by the script, then bl_idname = "BUILTIN_KSI_location") */
	void bl_idname(const std::string& value) { /* not implemented */ }

	/** Getter:  */
	std::string bl_label() { /* not implemented */ throw NULL; }
	/** Setter:  */
	void bl_label(const std::string& value) { /* not implemented */ }

	/** Getter: A short description of the keying set */
	std::string bl_description() { /* not implemented */ throw NULL; }
	/** Setter: A short description of the keying set */
	void bl_description(const std::string& value) { /* not implemented */ }

	enum bl_options_enum {
		bl_options_INSERTKEY_NEEDED = 1,
		bl_options_INSERTKEY_VISUAL = 2,
		bl_options_INSERTKEY_XYZ_TO_RGB = 32,
	};

	/** Getter: Keying Set options to use when inserting keyframes */
	bl_options_enum bl_options() { /* not implemented */ throw NULL; }
	/** Setter: Keying Set options to use when inserting keyframes */
	void bl_options(bl_options_enum value) { /* not implemented */ }

};

/**************** Animation Visualization ****************/

/**
 * Settings for the visualization of motion
 */
class AnimViz : public pyUniplug {
public:
	AnimViz(PyObject* pyobj) : pyUniplug(pyobj) {}

	AnimViz() : pyUniplug(0)
	{
		// not implemented
	}

	/** Getter: Onion Skinning (ghosting) settings for visualization */
	AnimVizOnionSkinning onion_skin_frames();

	/** Getter: Motion Path settings for visualization */
	AnimVizMotionPaths motion_path();

};

/**************** Onion Skinning Settings ****************/

/**
 * Onion Skinning settings for animation visualization
 */
class AnimVizOnionSkinning : public pyUniplug {
public:
	AnimVizOnionSkinning(PyObject* pyobj) : pyUniplug(pyobj) {}

	AnimVizOnionSkinning() : pyUniplug(0)
	{
		// not implemented
	}

	enum type_enum {
		type_NONE = 0,
		type_CURRENT_FRAME = 1,
		type_RANGE = 2,
		type_KEYS = 3,
	};

	/** Getter: Method used for determining what ghosts get drawn */
	type_enum type() { /* not implemented */ throw NULL; }
	/** Setter: Method used for determining what ghosts get drawn */
	void type(type_enum value) { /* not implemented */ }

	/** Getter: For Pose-Mode drawing, only draw ghosts for selected bones */
	bool show_only_selected() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "show_only_selected")) == 1;
	}

	/** Setter: For Pose-Mode drawing, only draw ghosts for selected bones */
	void show_only_selected(bool value) {
		PyObject_SetAttrString(pyobjref, "show_only_selected", Py_BuildValue("i", value));
	}

	/** Getter: Number of frames between ghosts shown (not for 'On Keyframes' Onion-skinning method) */
	int frame_step() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "frame_step"));
	}

	/** Setter: Number of frames between ghosts shown (not for 'On Keyframes' Onion-skinning method) */
	void frame_step(int value) {
		PyObject_SetAttrString(pyobjref, "frame_step", Py_BuildValue("i", value));
	}

	/** Getter: Starting frame of range of Ghosts to display (not for 'Around Current Frame' Onion-skinning method) */
	int frame_start() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "frame_start"));
	}

	/** Setter: Starting frame of range of Ghosts to display (not for 'Around Current Frame' Onion-skinning method) */
	void frame_start(int value) {
		PyObject_SetAttrString(pyobjref, "frame_start", Py_BuildValue("i", value));
	}

	/** Getter: End frame of range of Ghosts to display (not for 'Around Current Frame' Onion-skinning method) */
	int frame_end() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "frame_end"));
	}

	/** Setter: End frame of range of Ghosts to display (not for 'Around Current Frame' Onion-skinning method) */
	void frame_end(int value) {
		PyObject_SetAttrString(pyobjref, "frame_end", Py_BuildValue("i", value));
	}

	/** Getter: Number of frames to show before the current frame (only for 'Around Current Frame' Onion-skinning method) */
	int frame_before() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "frame_before"));
	}

	/** Setter: Number of frames to show before the current frame (only for 'Around Current Frame' Onion-skinning method) */
	void frame_before(int value) {
		PyObject_SetAttrString(pyobjref, "frame_before", Py_BuildValue("i", value));
	}

	/** Getter: Number of frames to show after the current frame (only for 'Around Current Frame' Onion-skinning method) */
	int frame_after() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "frame_after"));
	}

	/** Setter: Number of frames to show after the current frame (only for 'Around Current Frame' Onion-skinning method) */
	void frame_after(int value) {
		PyObject_SetAttrString(pyobjref, "frame_after", Py_BuildValue("i", value));
	}

};

/**************** Motion Path Settings ****************/

/**
 * Motion Path settings for animation visualization
 */
class AnimVizMotionPaths : public pyUniplug {
public:
	AnimVizMotionPaths(PyObject* pyobj) : pyUniplug(pyobj) {}

	AnimVizMotionPaths() : pyUniplug(0)
	{
		// not implemented
	}

	enum type_enum {
		type_CURRENT_FRAME = 1,
		type_RANGE = 0,
	};

	/** Getter: Type of range to show for Motion Paths */
	type_enum type() { /* not implemented */ throw NULL; }
	/** Setter: Type of range to show for Motion Paths */
	void type(type_enum value) { /* not implemented */ }

	enum bake_location_enum {
		bake_location_HEADS = 2,
		bake_location_TAILS = 0,
	};

	/** Getter: When calculating Bone Paths, use Head or Tips */
	bake_location_enum bake_location() { /* not implemented */ throw NULL; }
	/** Setter: When calculating Bone Paths, use Head or Tips */
	void bake_location(bake_location_enum value) { /* not implemented */ }

	/** Getter: Show frame numbers on Motion Paths */
	bool show_frame_numbers() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "show_frame_numbers")) == 1;
	}

	/** Setter: Show frame numbers on Motion Paths */
	void show_frame_numbers(bool value) {
		PyObject_SetAttrString(pyobjref, "show_frame_numbers", Py_BuildValue("i", value));
	}

	/** Getter: Emphasize position of keyframes on Motion Paths */
	bool show_keyframe_highlight() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "show_keyframe_highlight")) == 1;
	}

	/** Setter: Emphasize position of keyframes on Motion Paths */
	void show_keyframe_highlight(bool value) {
		PyObject_SetAttrString(pyobjref, "show_keyframe_highlight", Py_BuildValue("i", value));
	}

	/** Getter: Show frame numbers of Keyframes on Motion Paths */
	bool show_keyframe_numbers() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "show_keyframe_numbers")) == 1;
	}

	/** Setter: Show frame numbers of Keyframes on Motion Paths */
	void show_keyframe_numbers(bool value) {
		PyObject_SetAttrString(pyobjref, "show_keyframe_numbers", Py_BuildValue("i", value));
	}

	/** Getter: For bone motion paths, search whole Action for keyframes instead of in group with matching name only (is slower) */
	bool show_keyframe_action_all() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "show_keyframe_action_all")) == 1;
	}

	/** Setter: For bone motion paths, search whole Action for keyframes instead of in group with matching name only (is slower) */
	void show_keyframe_action_all(bool value) {
		PyObject_SetAttrString(pyobjref, "show_keyframe_action_all", Py_BuildValue("i", value));
	}

	/** Getter: Number of frames between paths shown (not for 'On Keyframes' Onion-skinning method) */
	int frame_step() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "frame_step"));
	}

	/** Setter: Number of frames between paths shown (not for 'On Keyframes' Onion-skinning method) */
	void frame_step(int value) {
		PyObject_SetAttrString(pyobjref, "frame_step", Py_BuildValue("i", value));
	}

	/** Getter: Starting frame of range of paths to display/calculate (not for 'Around Current Frame' Onion-skinning method) */
	int frame_start() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "frame_start"));
	}

	/** Setter: Starting frame of range of paths to display/calculate (not for 'Around Current Frame' Onion-skinning method) */
	void frame_start(int value) {
		PyObject_SetAttrString(pyobjref, "frame_start", Py_BuildValue("i", value));
	}

	/** Getter: End frame of range of paths to display/calculate (not for 'Around Current Frame' Onion-skinning method) */
	int frame_end() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "frame_end"));
	}

	/** Setter: End frame of range of paths to display/calculate (not for 'Around Current Frame' Onion-skinning method) */
	void frame_end(int value) {
		PyObject_SetAttrString(pyobjref, "frame_end", Py_BuildValue("i", value));
	}

	/** Getter: Number of frames to show before the current frame (only for 'Around Current Frame' Onion-skinning method) */
	int frame_before() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "frame_before"));
	}

	/** Setter: Number of frames to show before the current frame (only for 'Around Current Frame' Onion-skinning method) */
	void frame_before(int value) {
		PyObject_SetAttrString(pyobjref, "frame_before", Py_BuildValue("i", value));
	}

	/** Getter: Number of frames to show after the current frame (only for 'Around Current Frame' Onion-skinning method) */
	int frame_after() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "frame_after"));
	}

	/** Setter: Number of frames to show after the current frame (only for 'Around Current Frame' Onion-skinning method) */
	void frame_after(int value) {
		PyObject_SetAttrString(pyobjref, "frame_after", Py_BuildValue("i", value));
	}

};

/**************** Motion Path ****************/

/**
 * Cache of the worldspace positions of an element over a frame range
 */
class MotionPath : public pyUniplug {
public:
	MotionPath(PyObject* pyobj) : pyUniplug(pyobj) {}

	MotionPath() : pyUniplug(0)
	{
		// not implemented
	}

	/** Getter: Cached positions per frame */
	std::map<std::string, MotionPathVert> points();
	/** Setter: Cached positions per frame */
	void points(std::map<std::string, MotionPathVert> value);

	/** Getter: Starting frame of the stored range */
	int frame_start() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "frame_start"));
	}

	/** Setter: Starting frame of the stored range */
	void frame_start(int value) {
		PyObject_SetAttrString(pyobjref, "frame_start", Py_BuildValue("i", value));
	}

	/** Getter: End frame of the stored range */
	int frame_end() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "frame_end"));
	}

	/** Setter: End frame of the stored range */
	void frame_end(int value) {
		PyObject_SetAttrString(pyobjref, "frame_end", Py_BuildValue("i", value));
	}

	/** Getter: Number of frames cached */
	int length() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "length"));
	}

	/** Setter: Number of frames cached */
	void length(int value) {
		PyObject_SetAttrString(pyobjref, "length", Py_BuildValue("i", value));
	}

	/** Getter: For PoseBone paths, use the bone head location when calculating this path */
	bool use_bone_head() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_bone_head")) == 1;
	}

	/** Setter: For PoseBone paths, use the bone head location when calculating this path */
	void use_bone_head(bool value) {
		PyObject_SetAttrString(pyobjref, "use_bone_head", Py_BuildValue("i", value));
	}

	/** Getter: Path is being edited */
	bool is_modified() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "is_modified")) == 1;
	}

	/** Setter: Path is being edited */
	void is_modified(bool value) {
		PyObject_SetAttrString(pyobjref, "is_modified", Py_BuildValue("i", value));
	}

};

/**************** Motion Path Cache Point ****************/

/**
 * Cached location on path
 */
class MotionPathVert : public pyUniplug {
public:
	MotionPathVert(PyObject* pyobj) : pyUniplug(pyobj) {}

	MotionPathVert() : pyUniplug(0)
	{
		// not implemented
	}

	/** Getter:  */
	std::array<float, 3> co() {
		// TODO: MISSING DEREF! USE #DEFINE!
		PyObject *seqval = PyObject_GetAttrString(pyobjref, "co");
		std::array<float, 3> resarr;
		for (int i = 0; i < 3; i++)
			resarr[i] = (float)PyFloat_AsDouble(PySequence_GetItem(seqval, i));
		return resarr;
	}

	/** Setter:  */
	void co(float values[3]) { /* not implemented */ }

	/** Getter: Path point is selected for editing */
	bool select() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "select")) == 1;
	}

	/** Setter: Path point is selected for editing */
	void select(bool value) {
		PyObject_SetAttrString(pyobjref, "select", Py_BuildValue("i", value));
	}

};

/**************** Actuator ****************/

/**
 * Actuator to apply actions in the game engine
 */
class Actuator : public pyUniplug {
public:
	Actuator(PyObject* pyobj) : pyUniplug(pyobj) {}

	Actuator() : pyUniplug(0)
	{
		// not implemented
	}

	/** Getter:  */
	std::string name() { /* not implemented */ throw NULL; }
	/** Setter:  */
	void name(const std::string& value) { /* not implemented */ }

	enum type_enum {
		type_ACTION = 15,
		type_ARMATURE = 23,
		type_CAMERA = 3,
		type_CONSTRAINT = 9,
		type_EDIT_OBJECT = 10,
		type_FILTER_2D = 19,
		type_GAME = 17,
		type_MESSAGE = 14,
		type_MOTION = 0,
		type_MOUSE = 25,
		type_PARENT = 20,
		type_PROPERTY = 6,
		type_RANDOM = 13,
		type_SCENE = 11,
		type_SOUND = 5,
		type_STATE = 22,
		type_STEERING = 24,
		type_VISIBILITY = 18,
	};

	/** Getter:  */
	type_enum type() { /* not implemented */ throw NULL; }
	/** Setter:  */
	void type(type_enum value) { /* not implemented */ }

	/** Getter: Display when not linked to a visible states controller */
	bool pin() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "pin")) == 1;
	}

	/** Setter: Display when not linked to a visible states controller */
	void pin(bool value) {
		PyObject_SetAttrString(pyobjref, "pin", Py_BuildValue("i", value));
	}

	/** Getter: Set actuator expanded in the user interface */
	bool show_expanded() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "show_expanded")) == 1;
	}

	/** Setter: Set actuator expanded in the user interface */
	void show_expanded(bool value) {
		PyObject_SetAttrString(pyobjref, "show_expanded", Py_BuildValue("i", value));
	}

	/** Getter: Set the active state of the actuator */
	bool active() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "active")) == 1;
	}

	/** Setter: Set the active state of the actuator */
	void active(bool value) {
		PyObject_SetAttrString(pyobjref, "active", Py_BuildValue("i", value));
	}

	/**
	 * Link the actuator to a controller
	 * @param Controller to link to
	 */
	void link(Controller controller);

	/**
	 * Unlink the actuator from a controller
	 * @param Controller to unlink from
	 */
	void unlink(Controller controller);

};

/**************** Action Actuator ****************/

/**
 * Actuator to control the object movement
 */
class ActionActuator : public Actuator {
public:
	ActionActuator(PyObject* pyobj) : Actuator(pyobj) {}

	ActionActuator() : Actuator(0)
	{
		// not implemented
	}

	enum play_mode_enum {
		play_mode_PLAY = 0,
		play_mode_PINGPONG = 1,
		play_mode_FLIPPER = 2,
		play_mode_LOOPSTOP = 3,
		play_mode_LOOPEND = 4,
		play_mode_PROPERTY = 6,
	};

	/** Getter: Action playback type */
	play_mode_enum play_mode() { /* not implemented */ throw NULL; }
	/** Setter: Action playback type */
	void play_mode(play_mode_enum value) { /* not implemented */ }

	/** Getter:  */
	Action action() {
		/* not implemented */ throw NULL;
	}

	/** Getter: Restore last frame when switching on/off, otherwise play from the start each time */
	bool use_continue_last_frame() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_continue_last_frame")) == 1;
	}

	/** Setter: Restore last frame when switching on/off, otherwise play from the start each time */
	void use_continue_last_frame(bool value) {
		PyObject_SetAttrString(pyobjref, "use_continue_last_frame", Py_BuildValue("i", value));
	}

	/** Getter: Use this property to define the Action position */
	std::string property() { /* not implemented */ throw NULL; }
	/** Setter: Use this property to define the Action position */
	void property(const std::string& value) { /* not implemented */ }

	/** Getter:  */
	float frame_start() { /* not implemented */ throw NULL; }
	/** Setter:  */
	void frame_start(float value) {
		PyObject_SetAttrString(pyobjref, "frame_start", Py_BuildValue("f", value));
	}

	/** Getter:  */
	float frame_end() { /* not implemented */ throw NULL; }
	/** Setter:  */
	void frame_end(float value) {
		PyObject_SetAttrString(pyobjref, "frame_end", Py_BuildValue("f", value));
	}

	/** Getter: Number of frames of motion blending */
	int frame_blend_in() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "frame_blend_in"));
	}

	/** Setter: Number of frames of motion blending */
	void frame_blend_in(int value) {
		PyObject_SetAttrString(pyobjref, "frame_blend_in", Py_BuildValue("i", value));
	}

	/** Getter: Execution priority - lower numbers will override actions with higher numbers (with 2 or more actions at once, the overriding channels must be lower in the stack) */
	int priority() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "priority"));
	}

	/** Setter: Execution priority - lower numbers will override actions with higher numbers (with 2 or more actions at once, the overriding channels must be lower in the stack) */
	void priority(int value) {
		PyObject_SetAttrString(pyobjref, "priority", Py_BuildValue("i", value));
	}

	/** Getter: The animation layer to play the action on */
	int layer() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "layer"));
	}

	/** Setter: The animation layer to play the action on */
	void layer(int value) {
		PyObject_SetAttrString(pyobjref, "layer", Py_BuildValue("i", value));
	}

	/** Getter: How much of the previous layer to blend into this one */
	float layer_weight() { /* not implemented */ throw NULL; }
	/** Setter: How much of the previous layer to blend into this one */
	void layer_weight(float value) {
		PyObject_SetAttrString(pyobjref, "layer_weight", Py_BuildValue("f", value));
	}

	/** Getter: Assign the action's current frame number to this property */
	std::string frame_property() { /* not implemented */ throw NULL; }
	/** Setter: Assign the action's current frame number to this property */
	void frame_property(const std::string& value) { /* not implemented */ }

	/** Getter: Action is added to the current loc/rot/scale in global or local coordinate according to Local flag */
	bool use_additive() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_additive")) == 1;
	}

	/** Setter: Action is added to the current loc/rot/scale in global or local coordinate according to Local flag */
	void use_additive(bool value) {
		PyObject_SetAttrString(pyobjref, "use_additive", Py_BuildValue("i", value));
	}

	/** Getter: Apply Action as a global or local force depending on the local option (dynamic objects only) */
	bool use_force() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_force")) == 1;
	}

	/** Setter: Apply Action as a global or local force depending on the local option (dynamic objects only) */
	void use_force(bool value) {
		PyObject_SetAttrString(pyobjref, "use_force", Py_BuildValue("i", value));
	}

	/** Getter: Let the Action act in local coordinates, used in Force and Add mode */
	bool use_local() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_local")) == 1;
	}

	/** Setter: Let the Action act in local coordinates, used in Force and Add mode */
	void use_local(bool value) {
		PyObject_SetAttrString(pyobjref, "use_local", Py_BuildValue("i", value));
	}

	/** Getter: Update Action on all children Objects as well */
	bool apply_to_children() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "apply_to_children")) == 1;
	}

	/** Setter: Update Action on all children Objects as well */
	void apply_to_children(bool value) {
		PyObject_SetAttrString(pyobjref, "apply_to_children", Py_BuildValue("i", value));
	}

	enum blend_mode_enum {
		blend_mode_BLEND = 0,
		blend_mode_ADD = 1,
	};

	/** Getter: How this layer is blended with previous layers */
	blend_mode_enum blend_mode() { /* not implemented */ throw NULL; }
	/** Setter: How this layer is blended with previous layers */
	void blend_mode(blend_mode_enum value) { /* not implemented */ }

};

/**************** Motion Actuator ****************/

/**
 * Actuator to control the object movement
 */
class ObjectActuator : public Actuator {
public:
	ObjectActuator(PyObject* pyobj) : Actuator(pyobj) {}

	ObjectActuator() : Actuator(0)
	{
		// not implemented
	}

	enum mode_enum {
		mode_OBJECT_NORMAL = 0,
		mode_OBJECT_SERVO = 1,
		mode_OBJECT_CHARACTER = 2,
	};

	/** Getter: Specify the motion system */
	mode_enum mode() { /* not implemented */ throw NULL; }
	/** Setter: Specify the motion system */
	void mode(mode_enum value) { /* not implemented */ }

	/** Getter: Reference object for velocity calculation, leave empty for world reference */
	Object reference_object();

	/** Getter: Number of frames to reach the target velocity */
	int damping() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "damping"));
	}

	/** Setter: Number of frames to reach the target velocity */
	void damping(int value) {
		PyObject_SetAttrString(pyobjref, "damping", Py_BuildValue("i", value));
	}

	/** Getter: Typical value is 60x integral coefficient */
	float proportional_coefficient() { /* not implemented */ throw NULL; }
	/** Setter: Typical value is 60x integral coefficient */
	void proportional_coefficient(float value) {
		PyObject_SetAttrString(pyobjref, "proportional_coefficient", Py_BuildValue("f", value));
	}

	/** Getter: Low value (0.01) for slow response, high value (0.5) for fast response */
	float integral_coefficient() { /* not implemented */ throw NULL; }
	/** Setter: Low value (0.01) for slow response, high value (0.5) for fast response */
	void integral_coefficient(float value) {
		PyObject_SetAttrString(pyobjref, "integral_coefficient", Py_BuildValue("f", value));
	}

	/** Getter: Not required, high values can cause instability */
	float derivate_coefficient() { /* not implemented */ throw NULL; }
	/** Setter: Not required, high values can cause instability */
	void derivate_coefficient(float value) {
		PyObject_SetAttrString(pyobjref, "derivate_coefficient", Py_BuildValue("f", value));
	}

	/** Getter: Upper limit for X force */
	float force_max_x() { /* not implemented */ throw NULL; }
	/** Setter: Upper limit for X force */
	void force_max_x(float value) {
		PyObject_SetAttrString(pyobjref, "force_max_x", Py_BuildValue("f", value));
	}

	/** Getter: Lower limit for X force */
	float force_min_x() { /* not implemented */ throw NULL; }
	/** Setter: Lower limit for X force */
	void force_min_x(float value) {
		PyObject_SetAttrString(pyobjref, "force_min_x", Py_BuildValue("f", value));
	}

	/** Getter: Upper limit for Y force */
	float force_max_y() { /* not implemented */ throw NULL; }
	/** Setter: Upper limit for Y force */
	void force_max_y(float value) {
		PyObject_SetAttrString(pyobjref, "force_max_y", Py_BuildValue("f", value));
	}

	/** Getter: Lower limit for Y force */
	float force_min_y() { /* not implemented */ throw NULL; }
	/** Setter: Lower limit for Y force */
	void force_min_y(float value) {
		PyObject_SetAttrString(pyobjref, "force_min_y", Py_BuildValue("f", value));
	}

	/** Getter: Upper limit for Z force */
	float force_max_z() { /* not implemented */ throw NULL; }
	/** Setter: Upper limit for Z force */
	void force_max_z(float value) {
		PyObject_SetAttrString(pyobjref, "force_max_z", Py_BuildValue("f", value));
	}

	/** Getter: Lower limit for Z force */
	float force_min_z() { /* not implemented */ throw NULL; }
	/** Setter: Lower limit for Z force */
	void force_min_z(float value) {
		PyObject_SetAttrString(pyobjref, "force_min_z", Py_BuildValue("f", value));
	}

	/** Getter: Location */
	std::array<float, 3> offset_location() {
		// TODO: MISSING DEREF! USE #DEFINE!
		PyObject *seqval = PyObject_GetAttrString(pyobjref, "offset_location");
		std::array<float, 3> resarr;
		for (int i = 0; i < 3; i++)
			resarr[i] = (float)PyFloat_AsDouble(PySequence_GetItem(seqval, i));
		return resarr;
	}

	/** Setter: Location */
	void offset_location(float values[3]) { /* not implemented */ }

	/** Getter: Rotation */
	std::array<float, 3> offset_rotation() {
		// TODO: MISSING DEREF! USE #DEFINE!
		PyObject *seqval = PyObject_GetAttrString(pyobjref, "offset_rotation");
		std::array<float, 3> resarr;
		for (int i = 0; i < 3; i++)
			resarr[i] = (float)PyFloat_AsDouble(PySequence_GetItem(seqval, i));
		return resarr;
	}

	/** Setter: Rotation */
	void offset_rotation(float values[3]) { /* not implemented */ }

	/** Getter: Force */
	std::array<float, 3> force() {
		// TODO: MISSING DEREF! USE #DEFINE!
		PyObject *seqval = PyObject_GetAttrString(pyobjref, "force");
		std::array<float, 3> resarr;
		for (int i = 0; i < 3; i++)
			resarr[i] = (float)PyFloat_AsDouble(PySequence_GetItem(seqval, i));
		return resarr;
	}

	/** Setter: Force */
	void force(float values[3]) { /* not implemented */ }

	/** Getter: Torque */
	std::array<float, 3> torque() {
		// TODO: MISSING DEREF! USE #DEFINE!
		PyObject *seqval = PyObject_GetAttrString(pyobjref, "torque");
		std::array<float, 3> resarr;
		for (int i = 0; i < 3; i++)
			resarr[i] = (float)PyFloat_AsDouble(PySequence_GetItem(seqval, i));
		return resarr;
	}

	/** Setter: Torque */
	void torque(float values[3]) { /* not implemented */ }

	/** Getter: Linear velocity (in Servo mode it sets the target relative linear velocity, it will be achieved by automatic application of force - Null velocity is a valid target) */
	std::array<float, 3> linear_velocity() {
		// TODO: MISSING DEREF! USE #DEFINE!
		PyObject *seqval = PyObject_GetAttrString(pyobjref, "linear_velocity");
		std::array<float, 3> resarr;
		for (int i = 0; i < 3; i++)
			resarr[i] = (float)PyFloat_AsDouble(PySequence_GetItem(seqval, i));
		return resarr;
	}

	/** Setter: Linear velocity (in Servo mode it sets the target relative linear velocity, it will be achieved by automatic application of force - Null velocity is a valid target) */
	void linear_velocity(float values[3]) { /* not implemented */ }

	/** Getter: Angular velocity */
	std::array<float, 3> angular_velocity() {
		// TODO: MISSING DEREF! USE #DEFINE!
		PyObject *seqval = PyObject_GetAttrString(pyobjref, "angular_velocity");
		std::array<float, 3> resarr;
		for (int i = 0; i < 3; i++)
			resarr[i] = (float)PyFloat_AsDouble(PySequence_GetItem(seqval, i));
		return resarr;
	}

	/** Setter: Angular velocity */
	void angular_velocity(float values[3]) { /* not implemented */ }

	/** Getter: Location is defined in local coordinates */
	bool use_local_location() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_local_location")) == 1;
	}

	/** Setter: Location is defined in local coordinates */
	void use_local_location(bool value) {
		PyObject_SetAttrString(pyobjref, "use_local_location", Py_BuildValue("i", value));
	}

	/** Getter: Rotation is defined in local coordinates */
	bool use_local_rotation() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_local_rotation")) == 1;
	}

	/** Setter: Rotation is defined in local coordinates */
	void use_local_rotation(bool value) {
		PyObject_SetAttrString(pyobjref, "use_local_rotation", Py_BuildValue("i", value));
	}

	/** Getter: Force is defined in local coordinates */
	bool use_local_force() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_local_force")) == 1;
	}

	/** Setter: Force is defined in local coordinates */
	void use_local_force(bool value) {
		PyObject_SetAttrString(pyobjref, "use_local_force", Py_BuildValue("i", value));
	}

	/** Getter: Torque is defined in local coordinates */
	bool use_local_torque() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_local_torque")) == 1;
	}

	/** Setter: Torque is defined in local coordinates */
	void use_local_torque(bool value) {
		PyObject_SetAttrString(pyobjref, "use_local_torque", Py_BuildValue("i", value));
	}

	/** Getter: Velocity is defined in local coordinates */
	bool use_local_linear_velocity() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_local_linear_velocity")) == 1;
	}

	/** Setter: Velocity is defined in local coordinates */
	void use_local_linear_velocity(bool value) {
		PyObject_SetAttrString(pyobjref, "use_local_linear_velocity", Py_BuildValue("i", value));
	}

	/** Getter: Angular velocity is defined in local coordinates */
	bool use_local_angular_velocity() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_local_angular_velocity")) == 1;
	}

	/** Setter: Angular velocity is defined in local coordinates */
	void use_local_angular_velocity(bool value) {
		PyObject_SetAttrString(pyobjref, "use_local_angular_velocity", Py_BuildValue("i", value));
	}

	/** Getter: Toggles between ADD and SET linV */
	bool use_add_linear_velocity() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_add_linear_velocity")) == 1;
	}

	/** Setter: Toggles between ADD and SET linV */
	void use_add_linear_velocity(bool value) {
		PyObject_SetAttrString(pyobjref, "use_add_linear_velocity", Py_BuildValue("i", value));
	}

	/** Getter: Toggle between ADD and SET character location */
	bool use_add_character_location() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_add_character_location")) == 1;
	}

	/** Setter: Toggle between ADD and SET character location */
	void use_add_character_location(bool value) {
		PyObject_SetAttrString(pyobjref, "use_add_character_location", Py_BuildValue("i", value));
	}

	/** Getter: Set limit to force along the X axis */
	bool use_servo_limit_x() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_servo_limit_x")) == 1;
	}

	/** Setter: Set limit to force along the X axis */
	void use_servo_limit_x(bool value) {
		PyObject_SetAttrString(pyobjref, "use_servo_limit_x", Py_BuildValue("i", value));
	}

	/** Getter: Set limit to force along the Y axis */
	bool use_servo_limit_y() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_servo_limit_y")) == 1;
	}

	/** Setter: Set limit to force along the Y axis */
	void use_servo_limit_y(bool value) {
		PyObject_SetAttrString(pyobjref, "use_servo_limit_y", Py_BuildValue("i", value));
	}

	/** Getter: Set limit to force along the Z axis */
	bool use_servo_limit_z() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_servo_limit_z")) == 1;
	}

	/** Setter: Set limit to force along the Z axis */
	void use_servo_limit_z(bool value) {
		PyObject_SetAttrString(pyobjref, "use_servo_limit_z", Py_BuildValue("i", value));
	}

	/** Getter: Make the character jump using the settings in the physics properties */
	bool use_character_jump() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_character_jump")) == 1;
	}

	/** Setter: Make the character jump using the settings in the physics properties */
	void use_character_jump(bool value) {
		PyObject_SetAttrString(pyobjref, "use_character_jump", Py_BuildValue("i", value));
	}

};

/**************** Camera Actuator ****************/

/**
 * 
 */
class CameraActuator : public Actuator {
public:
	CameraActuator(PyObject* pyobj) : Actuator(pyobj) {}

	CameraActuator() : Actuator(0)
	{
		// not implemented
	}

	/** Getter: Look at this Object */
	Object object_value();

	/** Getter:  */
	float height() { /* not implemented */ throw NULL; }
	/** Setter:  */
	void height(float value) {
		PyObject_SetAttrString(pyobjref, "height", Py_BuildValue("f", value));
	}

	/** Getter:  */
	float min() { /* not implemented */ throw NULL; }
	/** Setter:  */
	void min(float value) {
		PyObject_SetAttrString(pyobjref, "min", Py_BuildValue("f", value));
	}

	/** Getter:  */
	float max() { /* not implemented */ throw NULL; }
	/** Setter:  */
	void max(float value) {
		PyObject_SetAttrString(pyobjref, "max", Py_BuildValue("f", value));
	}

	/** Getter: Strength of the constraint that drives the camera behind the target */
	float damping() { /* not implemented */ throw NULL; }
	/** Setter: Strength of the constraint that drives the camera behind the target */
	void damping(float value) {
		PyObject_SetAttrString(pyobjref, "damping", Py_BuildValue("f", value));
	}

	enum axis_enum {
		axis_POS_X = 0,
		axis_POS_Y = 1,
		axis_NEG_X = 3,
		axis_NEG_Y = 4,
	};

	/** Getter: Axis the Camera will try to get behind */
	axis_enum axis() { /* not implemented */ throw NULL; }
	/** Setter: Axis the Camera will try to get behind */
	void axis(axis_enum value) { /* not implemented */ }

};

/**************** Sound ****************/

/**
 * Sound file
 */
class SoundActuator : public Actuator {
public:
	SoundActuator(PyObject* pyobj) : Actuator(pyobj) {}

	SoundActuator() : Actuator(0)
	{
		// not implemented
	}

	/** Getter:  */
	Sound sound();

	enum mode_enum {
		mode_PLAYSTOP = 0,
		mode_PLAYEND = 1,
		mode_LOOPSTOP = 2,
		mode_LOOPEND = 3,
		mode_LOOPBIDIRECTIONAL = 4,
		mode_LOOPBIDIRECTIONALSTOP = 5,
	};

	/** Getter:  */
	mode_enum mode() { /* not implemented */ throw NULL; }
	/** Setter:  */
	void mode(mode_enum value) { /* not implemented */ }

	/** Getter: Initial volume of the sound */
	float volume() { /* not implemented */ throw NULL; }
	/** Setter: Initial volume of the sound */
	void volume(float value) {
		PyObject_SetAttrString(pyobjref, "volume", Py_BuildValue("f", value));
	}

	/** Getter: Pitch of the sound */
	float pitch() { /* not implemented */ throw NULL; }
	/** Setter: Pitch of the sound */
	void pitch(float value) {
		PyObject_SetAttrString(pyobjref, "pitch", Py_BuildValue("f", value));
	}

	/** Getter: The minimum gain of the sound, no matter how far it is away */
	float gain_3d_min() { /* not implemented */ throw NULL; }
	/** Setter: The minimum gain of the sound, no matter how far it is away */
	void gain_3d_min(float value) {
		PyObject_SetAttrString(pyobjref, "gain_3d_min", Py_BuildValue("f", value));
	}

	/** Getter: The maximum gain of the sound, no matter how near it is */
	float gain_3d_max() { /* not implemented */ throw NULL; }
	/** Setter: The maximum gain of the sound, no matter how near it is */
	void gain_3d_max(float value) {
		PyObject_SetAttrString(pyobjref, "gain_3d_max", Py_BuildValue("f", value));
	}

	/** Getter: The distance where the sound has a gain of 1.0 */
	float distance_3d_reference() { /* not implemented */ throw NULL; }
	/** Setter: The distance where the sound has a gain of 1.0 */
	void distance_3d_reference(float value) {
		PyObject_SetAttrString(pyobjref, "distance_3d_reference", Py_BuildValue("f", value));
	}

	/** Getter: The maximum distance at which you can hear the sound */
	float distance_3d_max() { /* not implemented */ throw NULL; }
	/** Setter: The maximum distance at which you can hear the sound */
	void distance_3d_max(float value) {
		PyObject_SetAttrString(pyobjref, "distance_3d_max", Py_BuildValue("f", value));
	}

	/** Getter: The influence factor on volume depending on distance */
	float rolloff_factor_3d() { /* not implemented */ throw NULL; }
	/** Setter: The influence factor on volume depending on distance */
	void rolloff_factor_3d(float value) {
		PyObject_SetAttrString(pyobjref, "rolloff_factor_3d", Py_BuildValue("f", value));
	}

	/** Getter: The gain outside the outer cone (the gain in the outer cone will be interpolated between this value and the normal gain in the inner cone) */
	float cone_outer_gain_3d() { /* not implemented */ throw NULL; }
	/** Setter: The gain outside the outer cone (the gain in the outer cone will be interpolated between this value and the normal gain in the inner cone) */
	void cone_outer_gain_3d(float value) {
		PyObject_SetAttrString(pyobjref, "cone_outer_gain_3d", Py_BuildValue("f", value));
	}

	/** Getter: The angle of the outer cone */
	float cone_outer_angle_3d() { /* not implemented */ throw NULL; }
	/** Setter: The angle of the outer cone */
	void cone_outer_angle_3d(float value) {
		PyObject_SetAttrString(pyobjref, "cone_outer_angle_3d", Py_BuildValue("f", value));
	}

	/** Getter: The angle of the inner cone */
	float cone_inner_angle_3d() { /* not implemented */ throw NULL; }
	/** Setter: The angle of the inner cone */
	void cone_inner_angle_3d(float value) {
		PyObject_SetAttrString(pyobjref, "cone_inner_angle_3d", Py_BuildValue("f", value));
	}

	/** Getter: Enable/Disable 3D Sound */
	bool use_sound_3d() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_sound_3d")) == 1;
	}

	/** Setter: Enable/Disable 3D Sound */
	void use_sound_3d(bool value) {
		PyObject_SetAttrString(pyobjref, "use_sound_3d", Py_BuildValue("i", value));
	}

};

/**************** Property Actuator ****************/

/**
 * Actuator to handle properties
 */
class PropertyActuator : public Actuator {
public:
	PropertyActuator(PyObject* pyobj) : Actuator(pyobj) {}

	PropertyActuator() : Actuator(0)
	{
		// not implemented
	}

	enum mode_enum {
		mode_ASSIGN = 0,
		mode_ADD = 1,
		mode_COPY = 2,
		mode_TOGGLE = 3,
		mode_LEVEL = 4,
	};

	/** Getter:  */
	mode_enum mode() { /* not implemented */ throw NULL; }
	/** Setter:  */
	void mode(mode_enum value) { /* not implemented */ }

	/** Getter: The name of the property */
	std::string property() { /* not implemented */ throw NULL; }
	/** Setter: The name of the property */
	void property(const std::string& value) { /* not implemented */ }

	/** Getter: The name of the property or the value to use (use "" around strings) */
	std::string value() { /* not implemented */ throw NULL; }
	/** Setter: The name of the property or the value to use (use "" around strings) */
	void value(const std::string& value) { /* not implemented */ }

	/** Getter: Copy from this Object */
	Object object_value();

	/** Getter: Copy this property */
	std::string object_property() { /* not implemented */ throw NULL; }
	/** Setter: Copy this property */
	void object_property(const std::string& value) { /* not implemented */ }

};

/**************** Constraint Actuator ****************/

/**
 * Actuator to handle Constraints
 */
class ConstraintActuator : public Actuator {
public:
	ConstraintActuator(PyObject* pyobj) : Actuator(pyobj) {}

	ConstraintActuator() : Actuator(0)
	{
		// not implemented
	}

	enum mode_enum {
		mode_LOC = 0,
		mode_DIST = 1,
		mode_ORI = 2,
		mode_FH = 3,
	};

	/** Getter: The type of the constraint */
	mode_enum mode() { /* not implemented */ throw NULL; }
	/** Setter: The type of the constraint */
	void mode(mode_enum value) { /* not implemented */ }

	enum limit_enum {
		limit_NONE = 0,
		limit_LOCX = 1,
		limit_LOCY = 2,
		limit_LOCZ = 4,
	};

	/** Getter:  */
	limit_enum limit() { /* not implemented */ throw NULL; }
	/** Setter:  */
	void limit(limit_enum value) { /* not implemented */ }

	enum direction_enum {
		direction_NONE = 0,
		direction_DIRPX = 1,
		direction_DIRPY = 2,
		direction_DIRPZ = 4,
		direction_DIRNX = 8,
		direction_DIRNY = 16,
		direction_DIRNZ = 32,
	};

	/** Getter: Direction of the ray */
	direction_enum direction() { /* not implemented */ throw NULL; }
	/** Setter: Direction of the ray */
	void direction(direction_enum value) { /* not implemented */ }

	enum direction_axis_enum {
		direction_axis_NONE = 0,
		direction_axis_DIRPX = 1,
		direction_axis_DIRPY = 2,
		direction_axis_DIRPZ = 4,
		direction_axis_DIRNX = 8,
		direction_axis_DIRNY = 16,
		direction_axis_DIRNZ = 32,
	};

	/** Getter: Select the axis to be aligned along the reference direction */
	direction_axis_enum direction_axis() { /* not implemented */ throw NULL; }
	/** Setter: Select the axis to be aligned along the reference direction */
	void direction_axis(direction_axis_enum value) { /* not implemented */ }

	/** Getter:  */
	float limit_min() { /* not implemented */ throw NULL; }
	/** Setter:  */
	void limit_min(float value) {
		PyObject_SetAttrString(pyobjref, "limit_min", Py_BuildValue("f", value));
	}

	/** Getter:  */
	float limit_max() { /* not implemented */ throw NULL; }
	/** Setter:  */
	void limit_max(float value) {
		PyObject_SetAttrString(pyobjref, "limit_max", Py_BuildValue("f", value));
	}

	/** Getter: Damping factor: time constant (in frame) of low pass filter */
	int damping() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "damping"));
	}

	/** Setter: Damping factor: time constant (in frame) of low pass filter */
	void damping(int value) {
		PyObject_SetAttrString(pyobjref, "damping", Py_BuildValue("i", value));
	}

	/** Getter: Maximum length of ray */
	float range() { /* not implemented */ throw NULL; }
	/** Setter: Maximum length of ray */
	void range(float value) {
		PyObject_SetAttrString(pyobjref, "range", Py_BuildValue("f", value));
	}

	/** Getter: Keep this distance to target */
	float distance() { /* not implemented */ throw NULL; }
	/** Setter: Keep this distance to target */
	void distance(float value) {
		PyObject_SetAttrString(pyobjref, "distance", Py_BuildValue("f", value));
	}

	/** Getter: Ray detects only Objects with this material */
	std::string material() { /* not implemented */ throw NULL; }
	/** Setter: Ray detects only Objects with this material */
	void material(const std::string& value) { /* not implemented */ }

	/** Getter: Ray detects only Objects with this property */
	std::string property() { /* not implemented */ throw NULL; }
	/** Setter: Ray detects only Objects with this property */
	void property(const std::string& value) { /* not implemented */ }

	/** Getter: Maximum activation time in frame, 0 for unlimited */
	int time() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "time"));
	}

	/** Setter: Maximum activation time in frame, 0 for unlimited */
	void time(int value) {
		PyObject_SetAttrString(pyobjref, "time", Py_BuildValue("i", value));
	}

	/** Getter: Use a different damping for orientation */
	int damping_rotation() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "damping_rotation"));
	}

	/** Setter: Use a different damping for orientation */
	void damping_rotation(int value) {
		PyObject_SetAttrString(pyobjref, "damping_rotation", Py_BuildValue("i", value));
	}

	enum direction_axis_pos_enum {
		direction_axis_pos_NONE = 0,
		direction_axis_pos_DIRPX = 1,
		direction_axis_pos_DIRPY = 2,
		direction_axis_pos_DIRPZ = 4,
	};

	/** Getter: Select the axis to be aligned along the reference direction */
	direction_axis_pos_enum direction_axis_pos() { /* not implemented */ throw NULL; }
	/** Setter: Select the axis to be aligned along the reference direction */
	void direction_axis_pos(direction_axis_pos_enum value) { /* not implemented */ }

	/** Getter: Reference Direction */
	std::array<float, 3> rotation_max() {
		// TODO: MISSING DEREF! USE #DEFINE!
		PyObject *seqval = PyObject_GetAttrString(pyobjref, "rotation_max");
		std::array<float, 3> resarr;
		for (int i = 0; i < 3; i++)
			resarr[i] = (float)PyFloat_AsDouble(PySequence_GetItem(seqval, i));
		return resarr;
	}

	/** Setter: Reference Direction */
	void rotation_max(float values[3]) { /* not implemented */ }

	/** Getter: Minimum angle to maintain with target direction (no correction is done if angle with target direction is between min and max) */
	float angle_min() { /* not implemented */ throw NULL; }
	/** Setter: Minimum angle to maintain with target direction (no correction is done if angle with target direction is between min and max) */
	void angle_min(float value) {
		PyObject_SetAttrString(pyobjref, "angle_min", Py_BuildValue("f", value));
	}

	/** Getter: Maximum angle allowed with target direction (no correction is done if angle with target direction is between min and max) */
	float angle_max() { /* not implemented */ throw NULL; }
	/** Setter: Maximum angle allowed with target direction (no correction is done if angle with target direction is between min and max) */
	void angle_max(float value) {
		PyObject_SetAttrString(pyobjref, "angle_max", Py_BuildValue("f", value));
	}

	/** Getter: Height of the force field area */
	float fh_height() { /* not implemented */ throw NULL; }
	/** Setter: Height of the force field area */
	void fh_height(float value) {
		PyObject_SetAttrString(pyobjref, "fh_height", Py_BuildValue("f", value));
	}

	/** Getter: Spring force within the force field area */
	float fh_force() { /* not implemented */ throw NULL; }
	/** Setter: Spring force within the force field area */
	void fh_force(float value) {
		PyObject_SetAttrString(pyobjref, "fh_force", Py_BuildValue("f", value));
	}

	/** Getter: Damping factor of the force field spring */
	float fh_damping() { /* not implemented */ throw NULL; }
	/** Setter: Damping factor of the force field spring */
	void fh_damping(float value) {
		PyObject_SetAttrString(pyobjref, "fh_damping", Py_BuildValue("f", value));
	}

	/** Getter: Force distance of object to point of impact of ray */
	bool use_force_distance() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_force_distance")) == 1;
	}

	/** Setter: Force distance of object to point of impact of ray */
	void use_force_distance(bool value) {
		PyObject_SetAttrString(pyobjref, "use_force_distance", Py_BuildValue("i", value));
	}

	/** Getter: Set ray along object's axis or global axis */
	bool use_local() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_local")) == 1;
	}

	/** Setter: Set ray along object's axis or global axis */
	void use_local(bool value) {
		PyObject_SetAttrString(pyobjref, "use_local", Py_BuildValue("i", value));
	}

	/** Getter: Set object axis along (local axis) or parallel (global axis) to the normal at hit position */
	bool use_normal() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_normal")) == 1;
	}

	/** Setter: Set object axis along (local axis) or parallel (global axis) to the normal at hit position */
	void use_normal(bool value) {
		PyObject_SetAttrString(pyobjref, "use_normal", Py_BuildValue("i", value));
	}

	/** Getter: Persistent actuator: stays active even if ray does not reach target */
	bool use_persistent() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_persistent")) == 1;
	}

	/** Setter: Persistent actuator: stays active even if ray does not reach target */
	void use_persistent(bool value) {
		PyObject_SetAttrString(pyobjref, "use_persistent", Py_BuildValue("i", value));
	}

	/** Getter: Detect material instead of property */
	bool use_material_detect() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_material_detect")) == 1;
	}

	/** Setter: Detect material instead of property */
	void use_material_detect(bool value) {
		PyObject_SetAttrString(pyobjref, "use_material_detect", Py_BuildValue("i", value));
	}

	/** Getter: Keep object axis parallel to normal */
	bool use_fh_paralel_axis() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_fh_paralel_axis")) == 1;
	}

	/** Setter: Keep object axis parallel to normal */
	void use_fh_paralel_axis(bool value) {
		PyObject_SetAttrString(pyobjref, "use_fh_paralel_axis", Py_BuildValue("i", value));
	}

	/** Getter: Add a horizontal spring force on slopes */
	bool use_fh_normal() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_fh_normal")) == 1;
	}

	/** Setter: Add a horizontal spring force on slopes */
	void use_fh_normal(bool value) {
		PyObject_SetAttrString(pyobjref, "use_fh_normal", Py_BuildValue("i", value));
	}

};

/**************** Edit Object Actuator ****************/

/**
 * Actuator used to edit objects
 */
class EditObjectActuator : public Actuator {
public:
	EditObjectActuator(PyObject* pyobj) : Actuator(pyobj) {}

	EditObjectActuator() : Actuator(0)
	{
		// not implemented
	}

	enum mode_enum {
		mode_ADDOBJECT = 0,
		mode_ENDOBJECT = 1,
		mode_REPLACEMESH = 2,
		mode_TRACKTO = 3,
		mode_DYNAMICS = 4,
	};

	/** Getter: The mode of the actuator */
	mode_enum mode() { /* not implemented */ throw NULL; }
	/** Setter: The mode of the actuator */
	void mode(mode_enum value) { /* not implemented */ }

	enum dynamic_operation_enum {
		dynamic_operation_RESTOREDYN = 0,
		dynamic_operation_SUSPENDDYN = 1,
		dynamic_operation_ENABLERIGIDBODY = 2,
		dynamic_operation_DISABLERIGIDBODY = 3,
		dynamic_operation_SETMASS = 4,
	};

	/** Getter:  */
	dynamic_operation_enum dynamic_operation() { /* not implemented */ throw NULL; }
	/** Setter:  */
	void dynamic_operation(dynamic_operation_enum value) { /* not implemented */ }

	enum up_axis_enum {
		up_axis_UPAXISX = 0,
		up_axis_UPAXISY = 1,
		up_axis_UPAXISZ = 2,
	};

	/** Getter: The axis that points upward */
	up_axis_enum up_axis() { /* not implemented */ throw NULL; }
	/** Setter: The axis that points upward */
	void up_axis(up_axis_enum value) { /* not implemented */ }

	enum track_axis_enum {
		track_axis_TRACKAXISX = 0,
		track_axis_TRACKAXISY = 1,
		track_axis_TRACKAXISZ = 2,
		track_axis_TRACKAXISNEGX = 3,
		track_axis_TRACKAXISNEGY = 4,
		track_axis_TRACKAXISNEGZ = 5,
	};

	/** Getter: The axis that points to the target object */
	track_axis_enum track_axis() { /* not implemented */ throw NULL; }
	/** Setter: The axis that points to the target object */
	void track_axis(track_axis_enum value) { /* not implemented */ }

	/** Getter: Add this Object and all its children (can't be on a visible layer) */
	Object object_value();

	/** Getter: Track to this Object */
	Object track_object();

	/** Getter: Replace the existing, when left blank 'Phys' will remake the existing physics mesh */
	Mesh mesh();

	/** Getter: Duration the new Object lives or the track takes */
	int time() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "time"));
	}

	/** Setter: Duration the new Object lives or the track takes */
	void time(int value) {
		PyObject_SetAttrString(pyobjref, "time", Py_BuildValue("i", value));
	}

	/** Getter: The mass of the object */
	float mass() { /* not implemented */ throw NULL; }
	/** Setter: The mass of the object */
	void mass(float value) {
		PyObject_SetAttrString(pyobjref, "mass", Py_BuildValue("f", value));
	}

	/** Getter: Velocity upon creation */
	std::array<float, 3> linear_velocity() {
		// TODO: MISSING DEREF! USE #DEFINE!
		PyObject *seqval = PyObject_GetAttrString(pyobjref, "linear_velocity");
		std::array<float, 3> resarr;
		for (int i = 0; i < 3; i++)
			resarr[i] = (float)PyFloat_AsDouble(PySequence_GetItem(seqval, i));
		return resarr;
	}

	/** Setter: Velocity upon creation */
	void linear_velocity(float values[3]) { /* not implemented */ }

	/** Getter: Angular velocity upon creation */
	std::array<float, 3> angular_velocity() {
		// TODO: MISSING DEREF! USE #DEFINE!
		PyObject *seqval = PyObject_GetAttrString(pyobjref, "angular_velocity");
		std::array<float, 3> resarr;
		for (int i = 0; i < 3; i++)
			resarr[i] = (float)PyFloat_AsDouble(PySequence_GetItem(seqval, i));
		return resarr;
	}

	/** Setter: Angular velocity upon creation */
	void angular_velocity(float values[3]) { /* not implemented */ }

	/** Getter: Apply the transformation locally */
	bool use_local_linear_velocity() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_local_linear_velocity")) == 1;
	}

	/** Setter: Apply the transformation locally */
	void use_local_linear_velocity(bool value) {
		PyObject_SetAttrString(pyobjref, "use_local_linear_velocity", Py_BuildValue("i", value));
	}

	/** Getter: Apply the rotation locally */
	bool use_local_angular_velocity() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_local_angular_velocity")) == 1;
	}

	/** Setter: Apply the rotation locally */
	void use_local_angular_velocity(bool value) {
		PyObject_SetAttrString(pyobjref, "use_local_angular_velocity", Py_BuildValue("i", value));
	}

	/** Getter: Replace the display mesh */
	bool use_replace_display_mesh() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_replace_display_mesh")) == 1;
	}

	/** Setter: Replace the display mesh */
	void use_replace_display_mesh(bool value) {
		PyObject_SetAttrString(pyobjref, "use_replace_display_mesh", Py_BuildValue("i", value));
	}

	/** Getter: Replace the physics mesh (triangle bounds only - compound shapes not supported) */
	bool use_replace_physics_mesh() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_replace_physics_mesh")) == 1;
	}

	/** Setter: Replace the physics mesh (triangle bounds only - compound shapes not supported) */
	void use_replace_physics_mesh(bool value) {
		PyObject_SetAttrString(pyobjref, "use_replace_physics_mesh", Py_BuildValue("i", value));
	}

	/** Getter: Enable 3D tracking */
	bool use_3d_tracking() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_3d_tracking")) == 1;
	}

	/** Setter: Enable 3D tracking */
	void use_3d_tracking(bool value) {
		PyObject_SetAttrString(pyobjref, "use_3d_tracking", Py_BuildValue("i", value));
	}

};

/**************** Scene Actuator ****************/

/**
 * 
 */
class SceneActuator : public Actuator {
public:
	SceneActuator(PyObject* pyobj) : Actuator(pyobj) {}

	SceneActuator() : Actuator(0)
	{
		// not implemented
	}

	enum mode_enum {
		mode_RESTART = 0,
		mode_SET = 1,
		mode_CAMERA = 2,
		mode_ADDFRONT = 3,
		mode_ADDBACK = 4,
		mode_REMOVE = 5,
		mode_SUSPEND = 6,
		mode_RESUME = 7,
	};

	/** Getter:  */
	mode_enum mode() { /* not implemented */ throw NULL; }
	/** Setter:  */
	void mode(mode_enum value) { /* not implemented */ }

	/** Getter: Set this Camera (leave empty to refer to self object) */
	Object camera();

	/** Getter: Scene to be added/removed/paused/resumed */
	Scene scene();

};

/**************** Random Actuator ****************/

/**
 * 
 */
class RandomActuator : public Actuator {
public:
	RandomActuator(PyObject* pyobj) : Actuator(pyobj) {}

	RandomActuator() : Actuator(0)
	{
		// not implemented
	}

	/** Getter: Initial seed of the random generator, use Python for more freedom (choose 0 for not random) */
	int seed() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "seed"));
	}

	/** Setter: Initial seed of the random generator, use Python for more freedom (choose 0 for not random) */
	void seed(int value) {
		PyObject_SetAttrString(pyobjref, "seed", Py_BuildValue("i", value));
	}

	/** Getter: Assign the random value to this property */
	std::string property() { /* not implemented */ throw NULL; }
	/** Setter: Assign the random value to this property */
	void property(const std::string& value) { /* not implemented */ }

	enum distribution_enum {
		distribution_BOOL_CONSTANT = 0,
		distribution_BOOL_UNIFORM = 1,
		distribution_BOOL_BERNOUILLI = 2,
		distribution_INT_CONSTANT = 3,
		distribution_INT_UNIFORM = 4,
		distribution_INT_POISSON = 5,
		distribution_FLOAT_CONSTANT = 6,
		distribution_FLOAT_UNIFORM = 7,
		distribution_FLOAT_NORMAL = 8,
		distribution_FLOAT_NEGATIVE_EXPONENTIAL = 9,
	};

	/** Getter: Choose the type of distribution */
	distribution_enum distribution() { /* not implemented */ throw NULL; }
	/** Setter: Choose the type of distribution */
	void distribution(distribution_enum value) { /* not implemented */ }

	/** Getter: Always false or always true */
	bool use_always_true() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_always_true")) == 1;
	}

	/** Setter: Always false or always true */
	void use_always_true(bool value) {
		PyObject_SetAttrString(pyobjref, "use_always_true", Py_BuildValue("i", value));
	}

	/** Getter: Pick a number between 0 and 1, success if it's below this value */
	float chance() { /* not implemented */ throw NULL; }
	/** Setter: Pick a number between 0 and 1, success if it's below this value */
	void chance(float value) {
		PyObject_SetAttrString(pyobjref, "chance", Py_BuildValue("f", value));
	}

	/** Getter: Always return this number */
	int int_value() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "int_value"));
	}

	/** Setter: Always return this number */
	void int_value(int value) {
		PyObject_SetAttrString(pyobjref, "int_value", Py_BuildValue("i", value));
	}

	/** Getter: Choose a number from a range: lower boundary of the range */
	int int_min() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "int_min"));
	}

	/** Setter: Choose a number from a range: lower boundary of the range */
	void int_min(int value) {
		PyObject_SetAttrString(pyobjref, "int_min", Py_BuildValue("i", value));
	}

	/** Getter: Choose a number from a range: upper boundary of the range */
	int int_max() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "int_max"));
	}

	/** Setter: Choose a number from a range: upper boundary of the range */
	void int_max(int value) {
		PyObject_SetAttrString(pyobjref, "int_max", Py_BuildValue("i", value));
	}

	/** Getter: Expected mean value of the distribution */
	float int_mean() { /* not implemented */ throw NULL; }
	/** Setter: Expected mean value of the distribution */
	void int_mean(float value) {
		PyObject_SetAttrString(pyobjref, "int_mean", Py_BuildValue("f", value));
	}

	/** Getter: Always return this number */
	float float_value() { /* not implemented */ throw NULL; }
	/** Setter: Always return this number */
	void float_value(float value) {
		PyObject_SetAttrString(pyobjref, "float_value", Py_BuildValue("f", value));
	}

	/** Getter: Choose a number from a range: lower boundary of the range */
	float float_min() { /* not implemented */ throw NULL; }
	/** Setter: Choose a number from a range: lower boundary of the range */
	void float_min(float value) {
		PyObject_SetAttrString(pyobjref, "float_min", Py_BuildValue("f", value));
	}

	/** Getter: Choose a number from a range: upper boundary of the range */
	float float_max() { /* not implemented */ throw NULL; }
	/** Setter: Choose a number from a range: upper boundary of the range */
	void float_max(float value) {
		PyObject_SetAttrString(pyobjref, "float_max", Py_BuildValue("f", value));
	}

	/** Getter: A normal distribution: mean of the distribution */
	float float_mean() { /* not implemented */ throw NULL; }
	/** Setter: A normal distribution: mean of the distribution */
	void float_mean(float value) {
		PyObject_SetAttrString(pyobjref, "float_mean", Py_BuildValue("f", value));
	}

	/** Getter: A normal distribution: standard deviation of the distribution */
	float standard_derivation() { /* not implemented */ throw NULL; }
	/** Setter: A normal distribution: standard deviation of the distribution */
	void standard_derivation(float value) {
		PyObject_SetAttrString(pyobjref, "standard_derivation", Py_BuildValue("f", value));
	}

	/** Getter: Negative exponential dropoff */
	float half_life_time() { /* not implemented */ throw NULL; }
	/** Setter: Negative exponential dropoff */
	void half_life_time(float value) {
		PyObject_SetAttrString(pyobjref, "half_life_time", Py_BuildValue("f", value));
	}

};

/**************** Message Actuator ****************/

/**
 * 
 */
class MessageActuator : public Actuator {
public:
	MessageActuator(PyObject* pyobj) : Actuator(pyobj) {}

	MessageActuator() : Actuator(0)
	{
		// not implemented
	}

	/** Getter: Optional, send message to objects with this name only, or empty to broadcast */
	std::string to_property() { /* not implemented */ throw NULL; }
	/** Setter: Optional, send message to objects with this name only, or empty to broadcast */
	void to_property(const std::string& value) { /* not implemented */ }

	/** Getter: Optional, message subject (this is what can be filtered on) */
	std::string subject() { /* not implemented */ throw NULL; }
	/** Setter: Optional, message subject (this is what can be filtered on) */
	void subject(const std::string& value) { /* not implemented */ }

	enum body_type_enum {
		body_type_TEXT = 0,
		body_type_PROPERTY = 1,
	};

	/** Getter: Toggle message type: either Text or a PropertyName */
	body_type_enum body_type() { /* not implemented */ throw NULL; }
	/** Setter: Toggle message type: either Text or a PropertyName */
	void body_type(body_type_enum value) { /* not implemented */ }

	/** Getter: Optional, message body Text */
	std::string body_message() { /* not implemented */ throw NULL; }
	/** Setter: Optional, message body Text */
	void body_message(const std::string& value) { /* not implemented */ }

	/** Getter: The message body will be set by the Property Value */
	std::string body_property() { /* not implemented */ throw NULL; }
	/** Setter: The message body will be set by the Property Value */
	void body_property(const std::string& value) { /* not implemented */ }

};

/**************** Game Actuator ****************/

/**
 * 
 */
class GameActuator : public Actuator {
public:
	GameActuator(PyObject* pyobj) : Actuator(pyobj) {}

	GameActuator() : Actuator(0)
	{
		// not implemented
	}

	enum mode_enum {
		mode_START = 0,
		mode_RESTART = 2,
		mode_QUIT = 3,
		mode_SAVECFG = 4,
		mode_LOADCFG = 5,
	};

	/** Getter:  */
	mode_enum mode() { /* not implemented */ throw NULL; }
	/** Setter:  */
	void mode(mode_enum value) { /* not implemented */ }

	/** Getter: Load this blend file, use the "//" prefix for a path relative to the current blend file */
	std::string filename() { /* not implemented */ throw NULL; }
	/** Setter: Load this blend file, use the "//" prefix for a path relative to the current blend file */
	void filename(const std::string& value) { /* not implemented */ }

};

/**************** Visibility Actuator ****************/

/**
 * Actuator to set visibility and occlusion of the object
 */
class VisibilityActuator : public Actuator {
public:
	VisibilityActuator(PyObject* pyobj) : Actuator(pyobj) {}

	VisibilityActuator() : Actuator(0)
	{
		// not implemented
	}

	/** Getter: Set the objects visible (initialized from the object render restriction toggle in physics button) */
	bool use_visible() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_visible")) == 1;
	}

	/** Setter: Set the objects visible (initialized from the object render restriction toggle in physics button) */
	void use_visible(bool value) {
		PyObject_SetAttrString(pyobjref, "use_visible", Py_BuildValue("i", value));
	}

	/** Getter: Set the object to occlude objects behind it (initialized from the object type in physics button) */
	bool use_occlusion() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_occlusion")) == 1;
	}

	/** Setter: Set the object to occlude objects behind it (initialized from the object type in physics button) */
	void use_occlusion(bool value) {
		PyObject_SetAttrString(pyobjref, "use_occlusion", Py_BuildValue("i", value));
	}

	/** Getter: Set all the children of this object to the same visibility/occlusion recursively */
	bool apply_to_children() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "apply_to_children")) == 1;
	}

	/** Setter: Set all the children of this object to the same visibility/occlusion recursively */
	void apply_to_children(bool value) {
		PyObject_SetAttrString(pyobjref, "apply_to_children", Py_BuildValue("i", value));
	}

};

/**************** Filter 2D Actuator ****************/

/**
 * Actuator to apply screen graphic effects
 */
class Filter2DActuator : public Actuator {
public:
	Filter2DActuator(PyObject* pyobj) : Actuator(pyobj) {}

	Filter2DActuator() : Actuator(0)
	{
		// not implemented
	}

	enum mode_enum {
		mode_ENABLE = -2,
		mode_DISABLE = -1,
		mode_REMOVE = 0,
		mode_MOTIONBLUR = 1,
		mode_BLUR = 2,
		mode_SHARPEN = 3,
		mode_DILATION = 4,
		mode_EROSION = 5,
		mode_LAPLACIAN = 6,
		mode_SOBEL = 7,
		mode_PREWITT = 8,
		mode_GRAYSCALE = 9,
		mode_SEPIA = 10,
		mode_INVERT = 11,
		mode_CUSTOMFILTER = 12,
	};

	/** Getter:  */
	mode_enum mode() { /* not implemented */ throw NULL; }
	/** Setter:  */
	void mode(mode_enum value) { /* not implemented */ }

	/** Getter:  */
	Text glsl_shader();

	/** Getter: Set filter order */
	int filter_pass() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "filter_pass"));
	}

	/** Setter: Set filter order */
	void filter_pass(int value) {
		PyObject_SetAttrString(pyobjref, "filter_pass", Py_BuildValue("i", value));
	}

	/** Getter: Motion blur factor */
	float motion_blur_factor() { /* not implemented */ throw NULL; }
	/** Setter: Motion blur factor */
	void motion_blur_factor(float value) {
		PyObject_SetAttrString(pyobjref, "motion_blur_factor", Py_BuildValue("f", value));
	}

	/** Getter: Enable/Disable Motion Blur */
	bool use_motion_blur() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_motion_blur")) == 1;
	}

	/** Setter: Enable/Disable Motion Blur */
	void use_motion_blur(bool value) {
		PyObject_SetAttrString(pyobjref, "use_motion_blur", Py_BuildValue("i", value));
	}

};

/**************** Parent Actuator ****************/

/**
 * 
 */
class ParentActuator : public Actuator {
public:
	ParentActuator(PyObject* pyobj) : Actuator(pyobj) {}

	ParentActuator() : Actuator(0)
	{
		// not implemented
	}

	enum mode_enum {
		mode_SETPARENT = 0,
		mode_REMOVEPARENT = 1,
	};

	/** Getter:  */
	mode_enum mode() { /* not implemented */ throw NULL; }
	/** Setter:  */
	void mode(mode_enum value) { /* not implemented */ }

	/** Getter: Set this object as parent */
	Object object_value();

	/** Getter: Add this object shape to the parent shape (only if the parent shape is already compound) */
	bool use_compound() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_compound")) == 1;
	}

	/** Setter: Add this object shape to the parent shape (only if the parent shape is already compound) */
	void use_compound(bool value) {
		PyObject_SetAttrString(pyobjref, "use_compound", Py_BuildValue("i", value));
	}

	/** Getter: Make this object ghost while parented */
	bool use_ghost() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_ghost")) == 1;
	}

	/** Setter: Make this object ghost while parented */
	void use_ghost(bool value) {
		PyObject_SetAttrString(pyobjref, "use_ghost", Py_BuildValue("i", value));
	}

};

/**************** State Actuator ****************/

/**
 * Actuator to handle states
 */
class StateActuator : public Actuator {
public:
	StateActuator(PyObject* pyobj) : Actuator(pyobj) {}

	StateActuator() : Actuator(0)
	{
		// not implemented
	}

	enum operation_enum {
		operation_SET = 0,
		operation_ADD = 1,
		operation_REMOVE = 2,
		operation_CHANGE = 3,
	};

	/** Getter: Select the bit operation on object state mask */
	operation_enum operation() { /* not implemented */ throw NULL; }
	/** Setter: Select the bit operation on object state mask */
	void operation(operation_enum value) { /* not implemented */ }

	/** Getter:  */
	std::array<bool, 30> states() {
		// TODO: MISSING DEREF! USE #DEFINE!
		PyObject *seqval = PyObject_GetAttrString(pyobjref, "states");
		std::array<bool, 30> resarr;
		for (int i = 0; i < 30; i++)
			resarr[i] = PyLong_AsLong(PySequence_GetItem(seqval, i)) == 1;
		return resarr;
	}

	/** Setter:  */
	void states(bool values[30]) { /* not implemented */ }

};

/**************** Armature Actuator ****************/

/**
 * 
 */
class ArmatureActuator : public Actuator {
public:
	ArmatureActuator(PyObject* pyobj) : Actuator(pyobj) {}

	ArmatureActuator() : Actuator(0)
	{
		// not implemented
	}

	enum mode_enum {
		mode_RUN = 0,
		mode_ENABLE = 1,
		mode_DISABLE = 2,
		mode_SETTARGET = 3,
		mode_SETWEIGHT = 4,
		mode_SETINFLUENCE = 5,
	};

	/** Getter:  */
	mode_enum mode() { /* not implemented */ throw NULL; }
	/** Setter:  */
	void mode(mode_enum value) { /* not implemented */ }

	/** Getter: Bone on which the constraint is defined */
	std::string bone() { /* not implemented */ throw NULL; }
	/** Setter: Bone on which the constraint is defined */
	void bone(const std::string& value) { /* not implemented */ }

	/** Getter: Name of the constraint to control */
	std::string constraint() { /* not implemented */ throw NULL; }
	/** Setter: Name of the constraint to control */
	void constraint(const std::string& value) { /* not implemented */ }

	/** Getter: Set this object as the target of the constraint */
	Object target();

	/** Getter: Set this object as the secondary target of the constraint (only IK polar target at the moment) */
	Object secondary_target();

	/** Getter: Weight of this constraint */
	float weight() { /* not implemented */ throw NULL; }
	/** Setter: Weight of this constraint */
	void weight(float value) {
		PyObject_SetAttrString(pyobjref, "weight", Py_BuildValue("f", value));
	}

	/** Getter: Influence of this constraint */
	float influence() { /* not implemented */ throw NULL; }
	/** Setter: Influence of this constraint */
	void influence(float value) {
		PyObject_SetAttrString(pyobjref, "influence", Py_BuildValue("f", value));
	}

};

/**************** Steering Actuator ****************/

/**
 * 
 */
class SteeringActuator : public Actuator {
public:
	SteeringActuator(PyObject* pyobj) : Actuator(pyobj) {}

	SteeringActuator() : Actuator(0)
	{
		// not implemented
	}

	enum mode_enum {
		mode_SEEK = 0,
		mode_FLEE = 1,
		mode_PATHFOLLOWING = 2,
	};

	/** Getter:  */
	mode_enum mode() { /* not implemented */ throw NULL; }
	/** Setter:  */
	void mode(mode_enum value) { /* not implemented */ }

	/** Getter: Velocity magnitude */
	float velocity() { /* not implemented */ throw NULL; }
	/** Setter: Velocity magnitude */
	void velocity(float value) {
		PyObject_SetAttrString(pyobjref, "velocity", Py_BuildValue("f", value));
	}

	/** Getter: Max acceleration */
	float acceleration() { /* not implemented */ throw NULL; }
	/** Setter: Max acceleration */
	void acceleration(float value) {
		PyObject_SetAttrString(pyobjref, "acceleration", Py_BuildValue("f", value));
	}

	/** Getter: Max turn speed */
	float turn_speed() { /* not implemented */ throw NULL; }
	/** Setter: Max turn speed */
	void turn_speed(float value) {
		PyObject_SetAttrString(pyobjref, "turn_speed", Py_BuildValue("f", value));
	}

	/** Getter: Relax distance */
	float distance() { /* not implemented */ throw NULL; }
	/** Setter: Relax distance */
	void distance(float value) {
		PyObject_SetAttrString(pyobjref, "distance", Py_BuildValue("f", value));
	}

	/** Getter: Target object */
	Object target();

	/** Getter: Terminate when target is reached */
	bool self_terminated() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "self_terminated")) == 1;
	}

	/** Setter: Terminate when target is reached */
	void self_terminated(bool value) {
		PyObject_SetAttrString(pyobjref, "self_terminated", Py_BuildValue("i", value));
	}

	/** Getter: Enable debug visualization for 'Path following' */
	bool show_visualization() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "show_visualization")) == 1;
	}

	/** Setter: Enable debug visualization for 'Path following' */
	void show_visualization(bool value) {
		PyObject_SetAttrString(pyobjref, "show_visualization", Py_BuildValue("i", value));
	}

	/** Getter: Path update period */
	int update_period() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "update_period"));
	}

	/** Setter: Path update period */
	void update_period(int value) {
		PyObject_SetAttrString(pyobjref, "update_period", Py_BuildValue("i", value));
	}

	/** Getter: Navigation mesh */
	Object navmesh();

	/** Getter: Enable automatic facing */
	bool facing() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "facing")) == 1;
	}

	/** Setter: Enable automatic facing */
	void facing(bool value) {
		PyObject_SetAttrString(pyobjref, "facing", Py_BuildValue("i", value));
	}

	enum facing_axis_enum {
		facing_axis_X = 1,
		facing_axis_Y = 2,
		facing_axis_Z = 3,
		facing_axis_NEG_X = 4,
		facing_axis_NEG_Y = 5,
		facing_axis_NEG_Z = 6,
	};

	/** Getter: Axis for automatic facing */
	facing_axis_enum facing_axis() { /* not implemented */ throw NULL; }
	/** Setter: Axis for automatic facing */
	void facing_axis(facing_axis_enum value) { /* not implemented */ }

	/** Getter: Use normal of the navmesh to set "UP" vector */
	bool normal_up() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "normal_up")) == 1;
	}

	/** Setter: Use normal of the navmesh to set "UP" vector */
	void normal_up(bool value) {
		PyObject_SetAttrString(pyobjref, "normal_up", Py_BuildValue("i", value));
	}

	/** Getter: Disable simulation of linear motion along Z axis */
	bool lock_z_velocity() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "lock_z_velocity")) == 1;
	}

	/** Setter: Disable simulation of linear motion along Z axis */
	void lock_z_velocity(bool value) {
		PyObject_SetAttrString(pyobjref, "lock_z_velocity", Py_BuildValue("i", value));
	}

};

/**************** Mouse Actuator ****************/

/**
 * 
 */
class MouseActuator : public Actuator {
public:
	MouseActuator(PyObject* pyobj) : Actuator(pyobj) {}

	MouseActuator() : Actuator(0)
	{
		// not implemented
	}

	enum mode_enum {
		mode_VISIBILITY = 0,
		mode_LOOK = 1,
	};

	/** Getter:  */
	mode_enum mode() { /* not implemented */ throw NULL; }
	/** Setter:  */
	void mode(mode_enum value) { /* not implemented */ }

	/** Getter: Make mouse cursor visible */
	bool visible() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "visible")) == 1;
	}

	/** Setter: Make mouse cursor visible */
	void visible(bool value) {
		PyObject_SetAttrString(pyobjref, "visible", Py_BuildValue("i", value));
	}

	/** Getter: Calculate mouse movement on the X axis */
	bool use_axis_x() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_axis_x")) == 1;
	}

	/** Setter: Calculate mouse movement on the X axis */
	void use_axis_x(bool value) {
		PyObject_SetAttrString(pyobjref, "use_axis_x", Py_BuildValue("i", value));
	}

	/** Getter: Calculate mouse movement on the Y axis */
	bool use_axis_y() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_axis_y")) == 1;
	}

	/** Setter: Calculate mouse movement on the Y axis */
	void use_axis_y(bool value) {
		PyObject_SetAttrString(pyobjref, "use_axis_y", Py_BuildValue("i", value));
	}

	/** Getter: Reset the cursor's X position to the center of the screen space after calculating */
	bool reset_x() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "reset_x")) == 1;
	}

	/** Setter: Reset the cursor's X position to the center of the screen space after calculating */
	void reset_x(bool value) {
		PyObject_SetAttrString(pyobjref, "reset_x", Py_BuildValue("i", value));
	}

	/** Getter: Reset the cursor's Y position to the center of the screen space after calculating */
	bool reset_y() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "reset_y")) == 1;
	}

	/** Setter: Reset the cursor's Y position to the center of the screen space after calculating */
	void reset_y(bool value) {
		PyObject_SetAttrString(pyobjref, "reset_y", Py_BuildValue("i", value));
	}

	/** Getter: Apply rotation locally */
	bool local_x() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "local_x")) == 1;
	}

	/** Setter: Apply rotation locally */
	void local_x(bool value) {
		PyObject_SetAttrString(pyobjref, "local_x", Py_BuildValue("i", value));
	}

	/** Getter: Apply rotation locally */
	bool local_y() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "local_y")) == 1;
	}

	/** Setter: Apply rotation locally */
	void local_y(bool value) {
		PyObject_SetAttrString(pyobjref, "local_y", Py_BuildValue("i", value));
	}

	/** Getter: Amount of X motion before mouse movement will register */
	float threshold_x() { /* not implemented */ throw NULL; }
	/** Setter: Amount of X motion before mouse movement will register */
	void threshold_x(float value) {
		PyObject_SetAttrString(pyobjref, "threshold_x", Py_BuildValue("f", value));
	}

	/** Getter: Amount of Y motion before mouse movement will register */
	float threshold_y() { /* not implemented */ throw NULL; }
	/** Setter: Amount of Y motion before mouse movement will register */
	void threshold_y(float value) {
		PyObject_SetAttrString(pyobjref, "threshold_y", Py_BuildValue("f", value));
	}

	enum object_axis_x_enum {
		object_axis_x_OBJECT_AXIS_X = 0,
		object_axis_x_OBJECT_AXIS_Y = 1,
		object_axis_x_OBJECT_AXIS_Z = 2,
	};

	/** Getter: Local object axis mouse movement in the X direction will apply to */
	object_axis_x_enum object_axis_x() { /* not implemented */ throw NULL; }
	/** Setter: Local object axis mouse movement in the X direction will apply to */
	void object_axis_x(object_axis_x_enum value) { /* not implemented */ }

	enum object_axis_y_enum {
		object_axis_y_OBJECT_AXIS_X = 0,
		object_axis_y_OBJECT_AXIS_Y = 1,
		object_axis_y_OBJECT_AXIS_Z = 2,
	};

	/** Getter: Local object axis mouse movement in the Y direction will apply to */
	object_axis_y_enum object_axis_y() { /* not implemented */ throw NULL; }
	/** Setter: Local object axis mouse movement in the Y direction will apply to */
	void object_axis_y(object_axis_y_enum value) { /* not implemented */ }

	/** Getter: Sensitivity of the X axis */
	float sensitivity_x() { /* not implemented */ throw NULL; }
	/** Setter: Sensitivity of the X axis */
	void sensitivity_x(float value) {
		PyObject_SetAttrString(pyobjref, "sensitivity_x", Py_BuildValue("f", value));
	}

	/** Getter: Sensitivity of the Y axis */
	float sensitivity_y() { /* not implemented */ throw NULL; }
	/** Setter: Sensitivity of the Y axis */
	void sensitivity_y(float value) {
		PyObject_SetAttrString(pyobjref, "sensitivity_y", Py_BuildValue("f", value));
	}

	/** Getter: Maximum negative rotation allowed by X mouse movement (0 for infinite) */
	float min_x() { /* not implemented */ throw NULL; }
	/** Setter: Maximum negative rotation allowed by X mouse movement (0 for infinite) */
	void min_x(float value) {
		PyObject_SetAttrString(pyobjref, "min_x", Py_BuildValue("f", value));
	}

	/** Getter: Maximum positive rotation allowed by X mouse movement (0 for infinite) */
	float max_x() { /* not implemented */ throw NULL; }
	/** Setter: Maximum positive rotation allowed by X mouse movement (0 for infinite) */
	void max_x(float value) {
		PyObject_SetAttrString(pyobjref, "max_x", Py_BuildValue("f", value));
	}

	/** Getter: Maximum negative rotation allowed by Y mouse movement (0 for infinite) */
	float min_y() { /* not implemented */ throw NULL; }
	/** Setter: Maximum negative rotation allowed by Y mouse movement (0 for infinite) */
	void min_y(float value) {
		PyObject_SetAttrString(pyobjref, "min_y", Py_BuildValue("f", value));
	}

	/** Getter: Maximum positive rotation allowed by Y mouse movement (0 for infinite) */
	float max_y() { /* not implemented */ throw NULL; }
	/** Setter: Maximum positive rotation allowed by Y mouse movement (0 for infinite) */
	void max_y(float value) {
		PyObject_SetAttrString(pyobjref, "max_y", Py_BuildValue("f", value));
	}

};

/**************** Armature ****************/

/**
 * Armature datablock containing a hierarchy of bones, usually used for rigging characters
 */
class Armature : public ID {
public:
	Armature(PyObject* pyobj) : ID(pyobj) {}

	Armature() : ID(0)
	{
		// not implemented
	}

	/** Getter: Animation data for this datablock */
	AnimData animation_data() {
		/* not implemented */ throw NULL;
	}

	/** Getter:  */
	std::map<std::string, Bone> bones();
	/** Setter:  */
	void bones(std::map<std::string, Bone> value);

	/** Getter:  */
	std::map<std::string, EditBone> edit_bones();
	/** Setter:  */
	void edit_bones(std::map<std::string, EditBone> value);

	enum pose_position_enum {
		pose_position_POSE = 0,
		pose_position_REST = 1,
	};

	/** Getter: Show armature in binding pose or final posed state */
	pose_position_enum pose_position() { /* not implemented */ throw NULL; }
	/** Setter: Show armature in binding pose or final posed state */
	void pose_position(pose_position_enum value) { /* not implemented */ }

	enum draw_type_enum {
		draw_type_OCTAHEDRAL = 0,
		draw_type_STICK = 1,
		draw_type_BBONE = 2,
		draw_type_ENVELOPE = 3,
		draw_type_WIRE = 4,
	};

	/** Getter:  */
	draw_type_enum draw_type() { /* not implemented */ throw NULL; }
	/** Setter:  */
	void draw_type(draw_type_enum value) { /* not implemented */ }

	enum deform_method_enum {
		deform_method_BLENDER = 0,
		deform_method_BGE_CPU = 1,
	};

	/** Getter: Vertex Deformer Method (Game Engine only) */
	deform_method_enum deform_method() { /* not implemented */ throw NULL; }
	/** Setter: Vertex Deformer Method (Game Engine only) */
	void deform_method(deform_method_enum value) { /* not implemented */ }

	enum ghost_type_enum {
		ghost_type_CURRENT_FRAME = 0,
		ghost_type_RANGE = 1,
		ghost_type_KEYS = 2,
	};

	/** Getter: Method of Onion-skinning for active Action */
	ghost_type_enum ghost_type() { /* not implemented */ throw NULL; }
	/** Setter: Method of Onion-skinning for active Action */
	void ghost_type(ghost_type_enum value) { /* not implemented */ }

	/** Getter: Armature layer visibility */
	std::array<bool, 32> layers() {
		// TODO: MISSING DEREF! USE #DEFINE!
		PyObject *seqval = PyObject_GetAttrString(pyobjref, "layers");
		std::array<bool, 32> resarr;
		for (int i = 0; i < 32; i++)
			resarr[i] = PyLong_AsLong(PySequence_GetItem(seqval, i)) == 1;
		return resarr;
	}

	/** Setter: Armature layer visibility */
	void layers(bool values[32]) { /* not implemented */ }

	/** Getter: Protected layers in Proxy Instances are restored to Proxy settings on file reload and undo */
	std::array<bool, 32> layers_protected() {
		// TODO: MISSING DEREF! USE #DEFINE!
		PyObject *seqval = PyObject_GetAttrString(pyobjref, "layers_protected");
		std::array<bool, 32> resarr;
		for (int i = 0; i < 32; i++)
			resarr[i] = PyLong_AsLong(PySequence_GetItem(seqval, i)) == 1;
		return resarr;
	}

	/** Setter: Protected layers in Proxy Instances are restored to Proxy settings on file reload and undo */
	void layers_protected(bool values[32]) { /* not implemented */ }

	/** Getter: Draw bone axes */
	bool show_axes() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "show_axes")) == 1;
	}

	/** Setter: Draw bone axes */
	void show_axes(bool value) {
		PyObject_SetAttrString(pyobjref, "show_axes", Py_BuildValue("i", value));
	}

	/** Getter: Draw bone names */
	bool show_names() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "show_names")) == 1;
	}

	/** Setter: Draw bone names */
	void show_names(bool value) {
		PyObject_SetAttrString(pyobjref, "show_names", Py_BuildValue("i", value));
	}

	/** Getter: Don't deform children when manipulating bones in Pose Mode */
	bool use_deform_delay() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_deform_delay")) == 1;
	}

	/** Setter: Don't deform children when manipulating bones in Pose Mode */
	void use_deform_delay(bool value) {
		PyObject_SetAttrString(pyobjref, "use_deform_delay", Py_BuildValue("i", value));
	}

	/** Getter: Apply changes to matching bone on opposite side of X-Axis */
	bool use_mirror_x() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_mirror_x")) == 1;
	}

	/** Setter: Apply changes to matching bone on opposite side of X-Axis */
	void use_mirror_x(bool value) {
		PyObject_SetAttrString(pyobjref, "use_mirror_x", Py_BuildValue("i", value));
	}

	/** Getter: Add temporary IK constraints while grabbing bones in Pose Mode */
	bool use_auto_ik() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_auto_ik")) == 1;
	}

	/** Setter: Add temporary IK constraints while grabbing bones in Pose Mode */
	void use_auto_ik(bool value) {
		PyObject_SetAttrString(pyobjref, "use_auto_ik", Py_BuildValue("i", value));
	}

	/** Getter: Draw bones with their custom shapes */
	bool show_bone_custom_shapes() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "show_bone_custom_shapes")) == 1;
	}

	/** Setter: Draw bones with their custom shapes */
	void show_bone_custom_shapes(bool value) {
		PyObject_SetAttrString(pyobjref, "show_bone_custom_shapes", Py_BuildValue("i", value));
	}

	/** Getter: Draw bone group colors */
	bool show_group_colors() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "show_group_colors")) == 1;
	}

	/** Setter: Draw bone group colors */
	void show_group_colors(bool value) {
		PyObject_SetAttrString(pyobjref, "show_group_colors", Py_BuildValue("i", value));
	}

	/** Getter:  */
	bool show_only_ghost_selected() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "show_only_ghost_selected")) == 1;
	}

	/** Setter:  */
	void show_only_ghost_selected(bool value) {
		PyObject_SetAttrString(pyobjref, "show_only_ghost_selected", Py_BuildValue("i", value));
	}

	/** Getter: Number of frame steps on either side of current frame to show as ghosts (only for 'Around Current Frame' Onion-skinning method) */
	int ghost_step() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "ghost_step"));
	}

	/** Setter: Number of frame steps on either side of current frame to show as ghosts (only for 'Around Current Frame' Onion-skinning method) */
	void ghost_step(int value) {
		PyObject_SetAttrString(pyobjref, "ghost_step", Py_BuildValue("i", value));
	}

	/** Getter: Frame step for Ghosts (not for 'On Keyframes' Onion-skinning method) */
	int ghost_size() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "ghost_size"));
	}

	/** Setter: Frame step for Ghosts (not for 'On Keyframes' Onion-skinning method) */
	void ghost_size(int value) {
		PyObject_SetAttrString(pyobjref, "ghost_size", Py_BuildValue("i", value));
	}

	/** Getter: Starting frame of range of Ghosts to display (not for 'Around Current Frame' Onion-skinning method) */
	int ghost_frame_start() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "ghost_frame_start"));
	}

	/** Setter: Starting frame of range of Ghosts to display (not for 'Around Current Frame' Onion-skinning method) */
	void ghost_frame_start(int value) {
		PyObject_SetAttrString(pyobjref, "ghost_frame_start", Py_BuildValue("i", value));
	}

	/** Getter: End frame of range of Ghosts to display (not for 'Around Current Frame' Onion-skinning method) */
	int ghost_frame_end() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "ghost_frame_end"));
	}

	/** Setter: End frame of range of Ghosts to display (not for 'Around Current Frame' Onion-skinning method) */
	void ghost_frame_end(int value) {
		PyObject_SetAttrString(pyobjref, "ghost_frame_end", Py_BuildValue("i", value));
	}

	/** Getter: True when used in editmode */
	bool is_editmode() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "is_editmode")) == 1;
	}

	/** Setter: True when used in editmode */
	void is_editmode(bool value) {
		PyObject_SetAttrString(pyobjref, "is_editmode", Py_BuildValue("i", value));
	}

	/**
	 * Transform armature bones by a matrix
	 * @param Matrix
	 */
	void transform(float matrix[16])
	{
		// not implemented
	}

};

/**************** Bone ****************/

/**
 * Bone in an Armature datablock
 */
class Bone : public pyUniplug {
public:
	Bone(PyObject* pyobj) : pyUniplug(pyobj) {}

	Bone() : pyUniplug(0)
	{
		// not implemented
	}

	/** Getter: Parent bone (in same Armature) */
	Bone parent() {
		/* not implemented */ throw NULL;
	}

	/** Getter: Bones which are children of this bone */
	std::map<std::string, Bone> children() {
		// TODO: MISSING DEREF! USE #DEFINE!
		PyObject *seqval = PyObject_GetAttrString(pyobjref, "children");
		PyObject *seqkeys = PyObject_CallMethod(seqval, "keys", NULL);
		std::map<std::string, Bone> resmap;
		for (int i = 0; i < PySequence_Length(seqval); i++) {
			PyObject *keyobj = PySequence_GetItem(seqkeys, i);
			std::string key = PyBytes_AsString(PyUnicode_AsASCIIString(keyobj));
			Bone value = Bone(PySequence_GetItem(seqval, i));
			resmap.insert(std::pair<std::string,Bone>(key, value));
		}
		return resmap;
	}

	/** Setter: Bones which are children of this bone */
	void children(std::map<std::string, Bone> value) { /* not implemented */ }

	/** Getter:  */
	std::string name() { /* not implemented */ throw NULL; }
	/** Setter:  */
	void name(const std::string& value) { /* not implemented */ }

	/** Getter: Layers bone exists in */
	std::array<bool, 32> layers() {
		// TODO: MISSING DEREF! USE #DEFINE!
		PyObject *seqval = PyObject_GetAttrString(pyobjref, "layers");
		std::array<bool, 32> resarr;
		for (int i = 0; i < 32; i++)
			resarr[i] = PyLong_AsLong(PySequence_GetItem(seqval, i)) == 1;
		return resarr;
	}

	/** Setter: Layers bone exists in */
	void layers(bool values[32]) { /* not implemented */ }

	/** Getter: When bone has a parent, bone's head is stuck to the parent's tail */
	bool use_connect() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_connect")) == 1;
	}

	/** Setter: When bone has a parent, bone's head is stuck to the parent's tail */
	void use_connect(bool value) {
		PyObject_SetAttrString(pyobjref, "use_connect", Py_BuildValue("i", value));
	}

	/** Getter: Bone inherits rotation or scale from parent bone */
	bool use_inherit_rotation() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_inherit_rotation")) == 1;
	}

	/** Setter: Bone inherits rotation or scale from parent bone */
	void use_inherit_rotation(bool value) {
		PyObject_SetAttrString(pyobjref, "use_inherit_rotation", Py_BuildValue("i", value));
	}

	/** Getter: When deforming bone, multiply effects of Vertex Group weights with Envelope influence */
	bool use_envelope_multiply() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_envelope_multiply")) == 1;
	}

	/** Setter: When deforming bone, multiply effects of Vertex Group weights with Envelope influence */
	void use_envelope_multiply(bool value) {
		PyObject_SetAttrString(pyobjref, "use_envelope_multiply", Py_BuildValue("i", value));
	}

	/** Getter: Enable Bone to deform geometry */
	bool use_deform() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_deform")) == 1;
	}

	/** Setter: Enable Bone to deform geometry */
	void use_deform(bool value) {
		PyObject_SetAttrString(pyobjref, "use_deform", Py_BuildValue("i", value));
	}

	/** Getter: Bone inherits scaling from parent bone */
	bool use_inherit_scale() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_inherit_scale")) == 1;
	}

	/** Setter: Bone inherits scaling from parent bone */
	void use_inherit_scale(bool value) {
		PyObject_SetAttrString(pyobjref, "use_inherit_scale", Py_BuildValue("i", value));
	}

	/** Getter: Bone location is set in local space */
	bool use_local_location() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_local_location")) == 1;
	}

	/** Setter: Bone location is set in local space */
	void use_local_location(bool value) {
		PyObject_SetAttrString(pyobjref, "use_local_location", Py_BuildValue("i", value));
	}

	/** Getter: Object children will use relative transform, like deform */
	bool use_relative_parent() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_relative_parent")) == 1;
	}

	/** Setter: Object children will use relative transform, like deform */
	void use_relative_parent(bool value) {
		PyObject_SetAttrString(pyobjref, "use_relative_parent", Py_BuildValue("i", value));
	}

	/** Getter: Bone is always drawn as Wireframe regardless of viewport draw mode (useful for non-obstructive custom bone shapes) */
	bool show_wire() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "show_wire")) == 1;
	}

	/** Setter: Bone is always drawn as Wireframe regardless of viewport draw mode (useful for non-obstructive custom bone shapes) */
	void show_wire(bool value) {
		PyObject_SetAttrString(pyobjref, "show_wire", Py_BuildValue("i", value));
	}

	/** Getter: When bone doesn't have a parent, it receives cyclic offset effects (Deprecated) */
	bool use_cyclic_offset() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_cyclic_offset")) == 1;
	}

	/** Setter: When bone doesn't have a parent, it receives cyclic offset effects (Deprecated) */
	void use_cyclic_offset(bool value) {
		PyObject_SetAttrString(pyobjref, "use_cyclic_offset", Py_BuildValue("i", value));
	}

	/** Getter: Bone is able to be selected */
	bool hide_select() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "hide_select")) == 1;
	}

	/** Setter: Bone is able to be selected */
	void hide_select(bool value) {
		PyObject_SetAttrString(pyobjref, "hide_select", Py_BuildValue("i", value));
	}

	/** Getter: Bone deformation distance (for Envelope deform only) */
	float envelope_distance() { /* not implemented */ throw NULL; }
	/** Setter: Bone deformation distance (for Envelope deform only) */
	void envelope_distance(float value) {
		PyObject_SetAttrString(pyobjref, "envelope_distance", Py_BuildValue("f", value));
	}

	/** Getter: Bone deformation weight (for Envelope deform only) */
	float envelope_weight() { /* not implemented */ throw NULL; }
	/** Setter: Bone deformation weight (for Envelope deform only) */
	void envelope_weight(float value) {
		PyObject_SetAttrString(pyobjref, "envelope_weight", Py_BuildValue("f", value));
	}

	/** Getter: Radius of head of bone (for Envelope deform only) */
	float head_radius() { /* not implemented */ throw NULL; }
	/** Setter: Radius of head of bone (for Envelope deform only) */
	void head_radius(float value) {
		PyObject_SetAttrString(pyobjref, "head_radius", Py_BuildValue("f", value));
	}

	/** Getter: Radius of tail of bone (for Envelope deform only) */
	float tail_radius() { /* not implemented */ throw NULL; }
	/** Setter: Radius of tail of bone (for Envelope deform only) */
	void tail_radius(float value) {
		PyObject_SetAttrString(pyobjref, "tail_radius", Py_BuildValue("f", value));
	}

	/** Getter: Number of subdivisions of bone (for B-Bones only) */
	int bbone_segments() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "bbone_segments"));
	}

	/** Setter: Number of subdivisions of bone (for B-Bones only) */
	void bbone_segments(int value) {
		PyObject_SetAttrString(pyobjref, "bbone_segments", Py_BuildValue("i", value));
	}

	/** Getter: Length of first Bezier Handle (for B-Bones only) */
	float bbone_in() { /* not implemented */ throw NULL; }
	/** Setter: Length of first Bezier Handle (for B-Bones only) */
	void bbone_in(float value) {
		PyObject_SetAttrString(pyobjref, "bbone_in", Py_BuildValue("f", value));
	}

	/** Getter: Length of second Bezier Handle (for B-Bones only) */
	float bbone_out() { /* not implemented */ throw NULL; }
	/** Setter: Length of second Bezier Handle (for B-Bones only) */
	void bbone_out(float value) {
		PyObject_SetAttrString(pyobjref, "bbone_out", Py_BuildValue("f", value));
	}

	/** Getter: B-Bone X size */
	float bbone_x() { /* not implemented */ throw NULL; }
	/** Setter: B-Bone X size */
	void bbone_x(float value) {
		PyObject_SetAttrString(pyobjref, "bbone_x", Py_BuildValue("f", value));
	}

	/** Getter: B-Bone Z size */
	float bbone_z() { /* not implemented */ throw NULL; }
	/** Setter: B-Bone Z size */
	void bbone_z(float value) {
		PyObject_SetAttrString(pyobjref, "bbone_z", Py_BuildValue("f", value));
	}

	/** Getter: Bone is not visible when it is not in Edit Mode (i.e. in Object or Pose Modes) */
	bool hide() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "hide")) == 1;
	}

	/** Setter: Bone is not visible when it is not in Edit Mode (i.e. in Object or Pose Modes) */
	void hide(bool value) {
		PyObject_SetAttrString(pyobjref, "hide", Py_BuildValue("i", value));
	}

	/** Getter:  */
	bool select() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "select")) == 1;
	}

	/** Setter:  */
	void select(bool value) {
		PyObject_SetAttrString(pyobjref, "select", Py_BuildValue("i", value));
	}

	/** Getter:  */
	bool select_head() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "select_head")) == 1;
	}

	/** Setter:  */
	void select_head(bool value) {
		PyObject_SetAttrString(pyobjref, "select_head", Py_BuildValue("i", value));
	}

	/** Getter:  */
	bool select_tail() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "select_tail")) == 1;
	}

	/** Setter:  */
	void select_tail(bool value) {
		PyObject_SetAttrString(pyobjref, "select_tail", Py_BuildValue("i", value));
	}

	/** Getter: 3x3 bone matrix */
	std::array<float, 9> matrix() {
		// TODO: MISSING DEREF! USE #DEFINE!
		PyObject *seqval = PyObject_GetAttrString(pyobjref, "matrix");
		std::array<float, 9> resarr;
		for (int i = 0; i < 9; i++)
			resarr[i] = (float)PyFloat_AsDouble(PySequence_GetItem(seqval, i));
		return resarr;
	}

	/** Setter: 3x3 bone matrix */
	void matrix(float values[9]) { /* not implemented */ }

	/** Getter: 4x4 bone matrix relative to armature */
	std::array<float, 16> matrix_local() {
		// TODO: MISSING DEREF! USE #DEFINE!
		PyObject *seqval = PyObject_GetAttrString(pyobjref, "matrix_local");
		std::array<float, 16> resarr;
		for (int i = 0; i < 16; i++)
			resarr[i] = (float)PyFloat_AsDouble(PySequence_GetItem(seqval, i));
		return resarr;
	}

	/** Setter: 4x4 bone matrix relative to armature */
	void matrix_local(float values[16]) { /* not implemented */ }

	/** Getter: Location of tail end of the bone */
	std::array<float, 3> tail() {
		// TODO: MISSING DEREF! USE #DEFINE!
		PyObject *seqval = PyObject_GetAttrString(pyobjref, "tail");
		std::array<float, 3> resarr;
		for (int i = 0; i < 3; i++)
			resarr[i] = (float)PyFloat_AsDouble(PySequence_GetItem(seqval, i));
		return resarr;
	}

	/** Setter: Location of tail end of the bone */
	void tail(float values[3]) { /* not implemented */ }

	/** Getter: Location of tail end of the bone relative to armature */
	std::array<float, 3> tail_local() {
		// TODO: MISSING DEREF! USE #DEFINE!
		PyObject *seqval = PyObject_GetAttrString(pyobjref, "tail_local");
		std::array<float, 3> resarr;
		for (int i = 0; i < 3; i++)
			resarr[i] = (float)PyFloat_AsDouble(PySequence_GetItem(seqval, i));
		return resarr;
	}

	/** Setter: Location of tail end of the bone relative to armature */
	void tail_local(float values[3]) { /* not implemented */ }

	/** Getter: Location of head end of the bone relative to its parent */
	std::array<float, 3> head() {
		// TODO: MISSING DEREF! USE #DEFINE!
		PyObject *seqval = PyObject_GetAttrString(pyobjref, "head");
		std::array<float, 3> resarr;
		for (int i = 0; i < 3; i++)
			resarr[i] = (float)PyFloat_AsDouble(PySequence_GetItem(seqval, i));
		return resarr;
	}

	/** Setter: Location of head end of the bone relative to its parent */
	void head(float values[3]) { /* not implemented */ }

	/** Getter: Location of head end of the bone relative to armature */
	std::array<float, 3> head_local() {
		// TODO: MISSING DEREF! USE #DEFINE!
		PyObject *seqval = PyObject_GetAttrString(pyobjref, "head_local");
		std::array<float, 3> resarr;
		for (int i = 0; i < 3; i++)
			resarr[i] = (float)PyFloat_AsDouble(PySequence_GetItem(seqval, i));
		return resarr;
	}

	/** Setter: Location of head end of the bone relative to armature */
	void head_local(float values[3]) { /* not implemented */ }

	/**
	 * Calculate bone envelope at given point
	 * @param Position in 3d space to evaluate
	 * @return Envelope factor
	 */
	float evaluate_envelope(float point[3])
	{
		// not implemented
		throw NULL;
	}

};

/**************** Edit Bone ****************/

/**
 * Editmode bone in an Armature datablock
 */
class EditBone : public pyUniplug {
public:
	EditBone(PyObject* pyobj) : pyUniplug(pyobj) {}

	EditBone() : pyUniplug(0)
	{
		// not implemented
	}

	/** Getter: Parent edit bone (in same Armature) */
	EditBone parent() {
		/* not implemented */ throw NULL;
	}

	/** Getter: Bone rotation around head-tail axis */
	float roll() { /* not implemented */ throw NULL; }
	/** Setter: Bone rotation around head-tail axis */
	void roll(float value) {
		PyObject_SetAttrString(pyobjref, "roll", Py_BuildValue("f", value));
	}

	/** Getter: Location of head end of the bone */
	std::array<float, 3> head() {
		// TODO: MISSING DEREF! USE #DEFINE!
		PyObject *seqval = PyObject_GetAttrString(pyobjref, "head");
		std::array<float, 3> resarr;
		for (int i = 0; i < 3; i++)
			resarr[i] = (float)PyFloat_AsDouble(PySequence_GetItem(seqval, i));
		return resarr;
	}

	/** Setter: Location of head end of the bone */
	void head(float values[3]) { /* not implemented */ }

	/** Getter: Location of tail end of the bone */
	std::array<float, 3> tail() {
		// TODO: MISSING DEREF! USE #DEFINE!
		PyObject *seqval = PyObject_GetAttrString(pyobjref, "tail");
		std::array<float, 3> resarr;
		for (int i = 0; i < 3; i++)
			resarr[i] = (float)PyFloat_AsDouble(PySequence_GetItem(seqval, i));
		return resarr;
	}

	/** Setter: Location of tail end of the bone */
	void tail(float values[3]) { /* not implemented */ }

	/** Getter:  */
	std::string name() { /* not implemented */ throw NULL; }
	/** Setter:  */
	void name(const std::string& value) { /* not implemented */ }

	/** Getter: Layers bone exists in */
	std::array<bool, 32> layers() {
		// TODO: MISSING DEREF! USE #DEFINE!
		PyObject *seqval = PyObject_GetAttrString(pyobjref, "layers");
		std::array<bool, 32> resarr;
		for (int i = 0; i < 32; i++)
			resarr[i] = PyLong_AsLong(PySequence_GetItem(seqval, i)) == 1;
		return resarr;
	}

	/** Setter: Layers bone exists in */
	void layers(bool values[32]) { /* not implemented */ }

	/** Getter: When bone has a parent, bone's head is stuck to the parent's tail */
	bool use_connect() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_connect")) == 1;
	}

	/** Setter: When bone has a parent, bone's head is stuck to the parent's tail */
	void use_connect(bool value) {
		PyObject_SetAttrString(pyobjref, "use_connect", Py_BuildValue("i", value));
	}

	/** Getter: Bone inherits rotation or scale from parent bone */
	bool use_inherit_rotation() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_inherit_rotation")) == 1;
	}

	/** Setter: Bone inherits rotation or scale from parent bone */
	void use_inherit_rotation(bool value) {
		PyObject_SetAttrString(pyobjref, "use_inherit_rotation", Py_BuildValue("i", value));
	}

	/** Getter: When deforming bone, multiply effects of Vertex Group weights with Envelope influence */
	bool use_envelope_multiply() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_envelope_multiply")) == 1;
	}

	/** Setter: When deforming bone, multiply effects of Vertex Group weights with Envelope influence */
	void use_envelope_multiply(bool value) {
		PyObject_SetAttrString(pyobjref, "use_envelope_multiply", Py_BuildValue("i", value));
	}

	/** Getter: Enable Bone to deform geometry */
	bool use_deform() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_deform")) == 1;
	}

	/** Setter: Enable Bone to deform geometry */
	void use_deform(bool value) {
		PyObject_SetAttrString(pyobjref, "use_deform", Py_BuildValue("i", value));
	}

	/** Getter: Bone inherits scaling from parent bone */
	bool use_inherit_scale() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_inherit_scale")) == 1;
	}

	/** Setter: Bone inherits scaling from parent bone */
	void use_inherit_scale(bool value) {
		PyObject_SetAttrString(pyobjref, "use_inherit_scale", Py_BuildValue("i", value));
	}

	/** Getter: Bone location is set in local space */
	bool use_local_location() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_local_location")) == 1;
	}

	/** Setter: Bone location is set in local space */
	void use_local_location(bool value) {
		PyObject_SetAttrString(pyobjref, "use_local_location", Py_BuildValue("i", value));
	}

	/** Getter: Object children will use relative transform, like deform */
	bool use_relative_parent() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_relative_parent")) == 1;
	}

	/** Setter: Object children will use relative transform, like deform */
	void use_relative_parent(bool value) {
		PyObject_SetAttrString(pyobjref, "use_relative_parent", Py_BuildValue("i", value));
	}

	/** Getter: Bone is always drawn as Wireframe regardless of viewport draw mode (useful for non-obstructive custom bone shapes) */
	bool show_wire() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "show_wire")) == 1;
	}

	/** Setter: Bone is always drawn as Wireframe regardless of viewport draw mode (useful for non-obstructive custom bone shapes) */
	void show_wire(bool value) {
		PyObject_SetAttrString(pyobjref, "show_wire", Py_BuildValue("i", value));
	}

	/** Getter: When bone doesn't have a parent, it receives cyclic offset effects (Deprecated) */
	bool use_cyclic_offset() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_cyclic_offset")) == 1;
	}

	/** Setter: When bone doesn't have a parent, it receives cyclic offset effects (Deprecated) */
	void use_cyclic_offset(bool value) {
		PyObject_SetAttrString(pyobjref, "use_cyclic_offset", Py_BuildValue("i", value));
	}

	/** Getter: Bone is able to be selected */
	bool hide_select() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "hide_select")) == 1;
	}

	/** Setter: Bone is able to be selected */
	void hide_select(bool value) {
		PyObject_SetAttrString(pyobjref, "hide_select", Py_BuildValue("i", value));
	}

	/** Getter: Bone deformation distance (for Envelope deform only) */
	float envelope_distance() { /* not implemented */ throw NULL; }
	/** Setter: Bone deformation distance (for Envelope deform only) */
	void envelope_distance(float value) {
		PyObject_SetAttrString(pyobjref, "envelope_distance", Py_BuildValue("f", value));
	}

	/** Getter: Bone deformation weight (for Envelope deform only) */
	float envelope_weight() { /* not implemented */ throw NULL; }
	/** Setter: Bone deformation weight (for Envelope deform only) */
	void envelope_weight(float value) {
		PyObject_SetAttrString(pyobjref, "envelope_weight", Py_BuildValue("f", value));
	}

	/** Getter: Radius of head of bone (for Envelope deform only) */
	float head_radius() { /* not implemented */ throw NULL; }
	/** Setter: Radius of head of bone (for Envelope deform only) */
	void head_radius(float value) {
		PyObject_SetAttrString(pyobjref, "head_radius", Py_BuildValue("f", value));
	}

	/** Getter: Radius of tail of bone (for Envelope deform only) */
	float tail_radius() { /* not implemented */ throw NULL; }
	/** Setter: Radius of tail of bone (for Envelope deform only) */
	void tail_radius(float value) {
		PyObject_SetAttrString(pyobjref, "tail_radius", Py_BuildValue("f", value));
	}

	/** Getter: Number of subdivisions of bone (for B-Bones only) */
	int bbone_segments() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "bbone_segments"));
	}

	/** Setter: Number of subdivisions of bone (for B-Bones only) */
	void bbone_segments(int value) {
		PyObject_SetAttrString(pyobjref, "bbone_segments", Py_BuildValue("i", value));
	}

	/** Getter: Length of first Bezier Handle (for B-Bones only) */
	float bbone_in() { /* not implemented */ throw NULL; }
	/** Setter: Length of first Bezier Handle (for B-Bones only) */
	void bbone_in(float value) {
		PyObject_SetAttrString(pyobjref, "bbone_in", Py_BuildValue("f", value));
	}

	/** Getter: Length of second Bezier Handle (for B-Bones only) */
	float bbone_out() { /* not implemented */ throw NULL; }
	/** Setter: Length of second Bezier Handle (for B-Bones only) */
	void bbone_out(float value) {
		PyObject_SetAttrString(pyobjref, "bbone_out", Py_BuildValue("f", value));
	}

	/** Getter: B-Bone X size */
	float bbone_x() { /* not implemented */ throw NULL; }
	/** Setter: B-Bone X size */
	void bbone_x(float value) {
		PyObject_SetAttrString(pyobjref, "bbone_x", Py_BuildValue("f", value));
	}

	/** Getter: B-Bone Z size */
	float bbone_z() { /* not implemented */ throw NULL; }
	/** Setter: B-Bone Z size */
	void bbone_z(float value) {
		PyObject_SetAttrString(pyobjref, "bbone_z", Py_BuildValue("f", value));
	}

	/** Getter: Bone is not visible when in Edit Mode */
	bool hide() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "hide")) == 1;
	}

	/** Setter: Bone is not visible when in Edit Mode */
	void hide(bool value) {
		PyObject_SetAttrString(pyobjref, "hide", Py_BuildValue("i", value));
	}

	/** Getter: Bone is not able to be transformed when in Edit Mode */
	bool lock_value() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "lock")) == 1;
	}

	/** Setter: Bone is not able to be transformed when in Edit Mode */
	void lock_value(bool value) {
		PyObject_SetAttrString(pyobjref, "lock", Py_BuildValue("i", value));
	}

	/** Getter:  */
	bool select() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "select")) == 1;
	}

	/** Setter:  */
	void select(bool value) {
		PyObject_SetAttrString(pyobjref, "select", Py_BuildValue("i", value));
	}

	/** Getter:  */
	bool select_head() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "select_head")) == 1;
	}

	/** Setter:  */
	void select_head(bool value) {
		PyObject_SetAttrString(pyobjref, "select_head", Py_BuildValue("i", value));
	}

	/** Getter:  */
	bool select_tail() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "select_tail")) == 1;
	}

	/** Setter:  */
	void select_tail(bool value) {
		PyObject_SetAttrString(pyobjref, "select_tail", Py_BuildValue("i", value));
	}

	/** Getter: Matrix combining loc/rot of the bone (head position, direction and roll), in armature space (WARNING: does not include/support bone's length/size) */
	std::array<float, 16> matrix() {
		// TODO: MISSING DEREF! USE #DEFINE!
		PyObject *seqval = PyObject_GetAttrString(pyobjref, "matrix");
		std::array<float, 16> resarr;
		for (int i = 0; i < 16; i++)
			resarr[i] = (float)PyFloat_AsDouble(PySequence_GetItem(seqval, i));
		return resarr;
	}

	/** Setter: Matrix combining loc/rot of the bone (head position, direction and roll), in armature space (WARNING: does not include/support bone's length/size) */
	void matrix(float values[16]) { /* not implemented */ }

	/**
	 * Align the bone to a localspace roll so the Z axis points in the direction of the vector given
	 * @param Param 'vector'
	 */
	void align_roll(float vector[3])
	{
		// not implemented
	}

};

/**************** Boid Rule ****************/

/**
 * 
 */
class BoidRule : public pyUniplug {
public:
	BoidRule(PyObject* pyobj) : pyUniplug(pyobj) {}

	BoidRule() : pyUniplug(0)
	{
		// not implemented
	}

	/** Getter: Boid rule name */
	std::string name() { /* not implemented */ throw NULL; }
	/** Setter: Boid rule name */
	void name(const std::string& value) { /* not implemented */ }

	enum type_enum {
		type_GOAL = 1,
		type_AVOID = 2,
		type_AVOID_COLLISION = 3,
		type_SEPARATE = 4,
		type_FLOCK = 5,
		type_FOLLOW_LEADER = 6,
		type_AVERAGE_SPEED = 7,
		type_FIGHT = 8,
	};

	/** Getter:  */
	type_enum type() { /* not implemented */ throw NULL; }
	/** Setter:  */
	void type(type_enum value) { /* not implemented */ }

	/** Getter: Use rule when boid is flying */
	bool use_in_air() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_in_air")) == 1;
	}

	/** Setter: Use rule when boid is flying */
	void use_in_air(bool value) {
		PyObject_SetAttrString(pyobjref, "use_in_air", Py_BuildValue("i", value));
	}

	/** Getter: Use rule when boid is on land */
	bool use_on_land() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_on_land")) == 1;
	}

	/** Setter: Use rule when boid is on land */
	void use_on_land(bool value) {
		PyObject_SetAttrString(pyobjref, "use_on_land", Py_BuildValue("i", value));
	}

};

/**************** Goal ****************/

/**
 * 
 */
class BoidRuleGoal : public BoidRule {
public:
	BoidRuleGoal(PyObject* pyobj) : BoidRule(pyobj) {}

	BoidRuleGoal() : BoidRule(0)
	{
		// not implemented
	}

	/** Getter: Goal object */
	Object object_value();

	/** Getter: Predict target movement */
	bool use_predict() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_predict")) == 1;
	}

	/** Setter: Predict target movement */
	void use_predict(bool value) {
		PyObject_SetAttrString(pyobjref, "use_predict", Py_BuildValue("i", value));
	}

};

/**************** Avoid ****************/

/**
 * 
 */
class BoidRuleAvoid : public BoidRule {
public:
	BoidRuleAvoid(PyObject* pyobj) : BoidRule(pyobj) {}

	BoidRuleAvoid() : BoidRule(0)
	{
		// not implemented
	}

	/** Getter: Object to avoid */
	Object object_value();

	/** Getter: Predict target movement */
	bool use_predict() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_predict")) == 1;
	}

	/** Setter: Predict target movement */
	void use_predict(bool value) {
		PyObject_SetAttrString(pyobjref, "use_predict", Py_BuildValue("i", value));
	}

	/** Getter: Avoid object if danger from it is above this threshold */
	float fear_factor() { /* not implemented */ throw NULL; }
	/** Setter: Avoid object if danger from it is above this threshold */
	void fear_factor(float value) {
		PyObject_SetAttrString(pyobjref, "fear_factor", Py_BuildValue("f", value));
	}

};

/**************** Avoid Collision ****************/

/**
 * 
 */
class BoidRuleAvoidCollision : public BoidRule {
public:
	BoidRuleAvoidCollision(PyObject* pyobj) : BoidRule(pyobj) {}

	BoidRuleAvoidCollision() : BoidRule(0)
	{
		// not implemented
	}

	/** Getter: Avoid collision with other boids */
	bool use_avoid() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_avoid")) == 1;
	}

	/** Setter: Avoid collision with other boids */
	void use_avoid(bool value) {
		PyObject_SetAttrString(pyobjref, "use_avoid", Py_BuildValue("i", value));
	}

	/** Getter: Avoid collision with deflector objects */
	bool use_avoid_collision() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_avoid_collision")) == 1;
	}

	/** Setter: Avoid collision with deflector objects */
	void use_avoid_collision(bool value) {
		PyObject_SetAttrString(pyobjref, "use_avoid_collision", Py_BuildValue("i", value));
	}

	/** Getter: Time to look ahead in seconds */
	float look_ahead() { /* not implemented */ throw NULL; }
	/** Setter: Time to look ahead in seconds */
	void look_ahead(float value) {
		PyObject_SetAttrString(pyobjref, "look_ahead", Py_BuildValue("f", value));
	}

};

/**************** Follow Leader ****************/

/**
 * 
 */
class BoidRuleFollowLeader : public BoidRule {
public:
	BoidRuleFollowLeader(PyObject* pyobj) : BoidRule(pyobj) {}

	BoidRuleFollowLeader() : BoidRule(0)
	{
		// not implemented
	}

	/** Getter: Follow this object instead of a boid */
	Object object_value();

	/** Getter: Distance behind leader to follow */
	float distance() { /* not implemented */ throw NULL; }
	/** Setter: Distance behind leader to follow */
	void distance(float value) {
		PyObject_SetAttrString(pyobjref, "distance", Py_BuildValue("f", value));
	}

	/** Getter: How many boids in a line */
	int queue_count() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "queue_count"));
	}

	/** Setter: How many boids in a line */
	void queue_count(int value) {
		PyObject_SetAttrString(pyobjref, "queue_count", Py_BuildValue("i", value));
	}

	/** Getter: Follow leader in a line */
	bool use_line() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_line")) == 1;
	}

	/** Setter: Follow leader in a line */
	void use_line(bool value) {
		PyObject_SetAttrString(pyobjref, "use_line", Py_BuildValue("i", value));
	}

};

/**************** Average Speed ****************/

/**
 * 
 */
class BoidRuleAverageSpeed : public BoidRule {
public:
	BoidRuleAverageSpeed(PyObject* pyobj) : BoidRule(pyobj) {}

	BoidRuleAverageSpeed() : BoidRule(0)
	{
		// not implemented
	}

	/** Getter: How fast velocity's direction is randomized */
	float wander() { /* not implemented */ throw NULL; }
	/** Setter: How fast velocity's direction is randomized */
	void wander(float value) {
		PyObject_SetAttrString(pyobjref, "wander", Py_BuildValue("f", value));
	}

	/** Getter: How much velocity's z-component is kept constant */
	float level() { /* not implemented */ throw NULL; }
	/** Setter: How much velocity's z-component is kept constant */
	void level(float value) {
		PyObject_SetAttrString(pyobjref, "level", Py_BuildValue("f", value));
	}

	/** Getter: Percentage of maximum speed */
	float speed() { /* not implemented */ throw NULL; }
	/** Setter: Percentage of maximum speed */
	void speed(float value) {
		PyObject_SetAttrString(pyobjref, "speed", Py_BuildValue("f", value));
	}

};

/**************** Fight ****************/

/**
 * 
 */
class BoidRuleFight : public BoidRule {
public:
	BoidRuleFight(PyObject* pyobj) : BoidRule(pyobj) {}

	BoidRuleFight() : BoidRule(0)
	{
		// not implemented
	}

	/** Getter: Attack boids at max this distance */
	float distance() { /* not implemented */ throw NULL; }
	/** Setter: Attack boids at max this distance */
	void distance(float value) {
		PyObject_SetAttrString(pyobjref, "distance", Py_BuildValue("f", value));
	}

	/** Getter: Flee to this distance */
	float flee_distance() { /* not implemented */ throw NULL; }
	/** Setter: Flee to this distance */
	void flee_distance(float value) {
		PyObject_SetAttrString(pyobjref, "flee_distance", Py_BuildValue("f", value));
	}

};

/**************** Boid State ****************/

/**
 * Boid state for boid physics
 */
class BoidState : public pyUniplug {
public:
	BoidState(PyObject* pyobj) : pyUniplug(pyobj) {}

	BoidState() : pyUniplug(0)
	{
		// not implemented
	}

	/** Getter: Boid state name */
	std::string name() { /* not implemented */ throw NULL; }
	/** Setter: Boid state name */
	void name(const std::string& value) { /* not implemented */ }

	enum ruleset_type_enum {
		ruleset_type_FUZZY = 0,
		ruleset_type_RANDOM = 1,
		ruleset_type_AVERAGE = 2,
	};

	/** Getter: How the rules in the list are evaluated */
	ruleset_type_enum ruleset_type() { /* not implemented */ throw NULL; }
	/** Setter: How the rules in the list are evaluated */
	void ruleset_type(ruleset_type_enum value) { /* not implemented */ }

	/** Getter:  */
	std::map<std::string, BoidRule> rules() {
		// TODO: MISSING DEREF! USE #DEFINE!
		PyObject *seqval = PyObject_GetAttrString(pyobjref, "rules");
		PyObject *seqkeys = PyObject_CallMethod(seqval, "keys", NULL);
		std::map<std::string, BoidRule> resmap;
		for (int i = 0; i < PySequence_Length(seqval); i++) {
			PyObject *keyobj = PySequence_GetItem(seqkeys, i);
			std::string key = PyBytes_AsString(PyUnicode_AsASCIIString(keyobj));
			BoidRule value = BoidRule(PySequence_GetItem(seqval, i));
			resmap.insert(std::pair<std::string,BoidRule>(key, value));
		}
		return resmap;
	}

	/** Setter:  */
	void rules(std::map<std::string, BoidRule> value) { /* not implemented */ }

	/** Getter:  */
	BoidRule active_boid_rule() {
		/* not implemented */ throw NULL;
	}

	/** Getter:  */
	int active_boid_rule_index() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "active_boid_rule_index"));
	}

	/** Setter:  */
	void active_boid_rule_index(int value) {
		PyObject_SetAttrString(pyobjref, "active_boid_rule_index", Py_BuildValue("i", value));
	}

	/** Getter:  */
	float rule_fuzzy() { /* not implemented */ throw NULL; }
	/** Setter:  */
	void rule_fuzzy(float value) {
		PyObject_SetAttrString(pyobjref, "rule_fuzzy", Py_BuildValue("f", value));
	}

	/** Getter:  */
	float volume() { /* not implemented */ throw NULL; }
	/** Setter:  */
	void volume(float value) {
		PyObject_SetAttrString(pyobjref, "volume", Py_BuildValue("f", value));
	}

	/** Getter:  */
	float falloff() { /* not implemented */ throw NULL; }
	/** Setter:  */
	void falloff(float value) {
		PyObject_SetAttrString(pyobjref, "falloff", Py_BuildValue("f", value));
	}

};

/**************** Boid Settings ****************/

/**
 * Settings for boid physics
 */
class BoidSettings : public pyUniplug {
public:
	BoidSettings(PyObject* pyobj) : pyUniplug(pyobj) {}

	BoidSettings() : pyUniplug(0)
	{
		// not implemented
	}

	/** Getter: How smoothly the boids land */
	float land_smooth() { /* not implemented */ throw NULL; }
	/** Setter: How smoothly the boids land */
	void land_smooth(float value) {
		PyObject_SetAttrString(pyobjref, "land_smooth", Py_BuildValue("f", value));
	}

	/** Getter: Amount of rotation around velocity vector on turns */
	float bank() { /* not implemented */ throw NULL; }
	/** Setter: Amount of rotation around velocity vector on turns */
	void bank(float value) {
		PyObject_SetAttrString(pyobjref, "bank", Py_BuildValue("f", value));
	}

	/** Getter: Amount of rotation around side vector */
	float pitch() { /* not implemented */ throw NULL; }
	/** Setter: Amount of rotation around side vector */
	void pitch(float value) {
		PyObject_SetAttrString(pyobjref, "pitch", Py_BuildValue("f", value));
	}

	/** Getter: Boid height relative to particle size */
	float height() { /* not implemented */ throw NULL; }
	/** Setter: Boid height relative to particle size */
	void height(float value) {
		PyObject_SetAttrString(pyobjref, "height", Py_BuildValue("f", value));
	}

	/** Getter:  */
	std::map<std::string, BoidState> states() {
		// TODO: MISSING DEREF! USE #DEFINE!
		PyObject *seqval = PyObject_GetAttrString(pyobjref, "states");
		PyObject *seqkeys = PyObject_CallMethod(seqval, "keys", NULL);
		std::map<std::string, BoidState> resmap;
		for (int i = 0; i < PySequence_Length(seqval); i++) {
			PyObject *keyobj = PySequence_GetItem(seqkeys, i);
			std::string key = PyBytes_AsString(PyUnicode_AsASCIIString(keyobj));
			BoidState value = BoidState(PySequence_GetItem(seqval, i));
			resmap.insert(std::pair<std::string,BoidState>(key, value));
		}
		return resmap;
	}

	/** Setter:  */
	void states(std::map<std::string, BoidState> value) { /* not implemented */ }

	/** Getter:  */
	BoidRule active_boid_state() {
		/* not implemented */ throw NULL;
	}

	/** Getter:  */
	int active_boid_state_index() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "active_boid_state_index"));
	}

	/** Setter:  */
	void active_boid_state_index(int value) {
		PyObject_SetAttrString(pyobjref, "active_boid_state_index", Py_BuildValue("i", value));
	}

	/** Getter: Initial boid health when born */
	float health() { /* not implemented */ throw NULL; }
	/** Setter: Initial boid health when born */
	void health(float value) {
		PyObject_SetAttrString(pyobjref, "health", Py_BuildValue("f", value));
	}

	/** Getter: Maximum caused damage on attack per second */
	float strength() { /* not implemented */ throw NULL; }
	/** Setter: Maximum caused damage on attack per second */
	void strength(float value) {
		PyObject_SetAttrString(pyobjref, "strength", Py_BuildValue("f", value));
	}

	/** Getter: Boid will fight this times stronger enemy */
	float aggression() { /* not implemented */ throw NULL; }
	/** Setter: Boid will fight this times stronger enemy */
	void aggression(float value) {
		PyObject_SetAttrString(pyobjref, "aggression", Py_BuildValue("f", value));
	}

	/** Getter: Accuracy of attack */
	float accuracy() { /* not implemented */ throw NULL; }
	/** Setter: Accuracy of attack */
	void accuracy(float value) {
		PyObject_SetAttrString(pyobjref, "accuracy", Py_BuildValue("f", value));
	}

	/** Getter: Maximum distance from which a boid can attack */
	float range() { /* not implemented */ throw NULL; }
	/** Setter: Maximum distance from which a boid can attack */
	void range(float value) {
		PyObject_SetAttrString(pyobjref, "range", Py_BuildValue("f", value));
	}

	/** Getter: Minimum speed in air (relative to maximum speed) */
	float air_speed_min() { /* not implemented */ throw NULL; }
	/** Setter: Minimum speed in air (relative to maximum speed) */
	void air_speed_min(float value) {
		PyObject_SetAttrString(pyobjref, "air_speed_min", Py_BuildValue("f", value));
	}

	/** Getter: Maximum speed in air */
	float air_speed_max() { /* not implemented */ throw NULL; }
	/** Setter: Maximum speed in air */
	void air_speed_max(float value) {
		PyObject_SetAttrString(pyobjref, "air_speed_max", Py_BuildValue("f", value));
	}

	/** Getter: Maximum acceleration in air (relative to maximum speed) */
	float air_acc_max() { /* not implemented */ throw NULL; }
	/** Setter: Maximum acceleration in air (relative to maximum speed) */
	void air_acc_max(float value) {
		PyObject_SetAttrString(pyobjref, "air_acc_max", Py_BuildValue("f", value));
	}

	/** Getter: Maximum angular velocity in air (relative to 180 degrees) */
	float air_ave_max() { /* not implemented */ throw NULL; }
	/** Setter: Maximum angular velocity in air (relative to 180 degrees) */
	void air_ave_max(float value) {
		PyObject_SetAttrString(pyobjref, "air_ave_max", Py_BuildValue("f", value));
	}

	/** Getter: Radius of boids personal space in air (% of particle size) */
	float air_personal_space() { /* not implemented */ throw NULL; }
	/** Setter: Radius of boids personal space in air (% of particle size) */
	void air_personal_space(float value) {
		PyObject_SetAttrString(pyobjref, "air_personal_space", Py_BuildValue("f", value));
	}

	/** Getter: Maximum speed for jumping */
	float land_jump_speed() { /* not implemented */ throw NULL; }
	/** Setter: Maximum speed for jumping */
	void land_jump_speed(float value) {
		PyObject_SetAttrString(pyobjref, "land_jump_speed", Py_BuildValue("f", value));
	}

	/** Getter: Maximum speed on land */
	float land_speed_max() { /* not implemented */ throw NULL; }
	/** Setter: Maximum speed on land */
	void land_speed_max(float value) {
		PyObject_SetAttrString(pyobjref, "land_speed_max", Py_BuildValue("f", value));
	}

	/** Getter: Maximum acceleration on land (relative to maximum speed) */
	float land_acc_max() { /* not implemented */ throw NULL; }
	/** Setter: Maximum acceleration on land (relative to maximum speed) */
	void land_acc_max(float value) {
		PyObject_SetAttrString(pyobjref, "land_acc_max", Py_BuildValue("f", value));
	}

	/** Getter: Maximum angular velocity on land (relative to 180 degrees) */
	float land_ave_max() { /* not implemented */ throw NULL; }
	/** Setter: Maximum angular velocity on land (relative to 180 degrees) */
	void land_ave_max(float value) {
		PyObject_SetAttrString(pyobjref, "land_ave_max", Py_BuildValue("f", value));
	}

	/** Getter: Radius of boids personal space on land (% of particle size) */
	float land_personal_space() { /* not implemented */ throw NULL; }
	/** Setter: Radius of boids personal space on land (% of particle size) */
	void land_personal_space(float value) {
		PyObject_SetAttrString(pyobjref, "land_personal_space", Py_BuildValue("f", value));
	}

	/** Getter: How strong a force must be to start effecting a boid on land */
	float land_stick_force() { /* not implemented */ throw NULL; }
	/** Setter: How strong a force must be to start effecting a boid on land */
	void land_stick_force(float value) {
		PyObject_SetAttrString(pyobjref, "land_stick_force", Py_BuildValue("f", value));
	}

	/** Getter: Allow boids to move in air */
	bool use_flight() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_flight")) == 1;
	}

	/** Setter: Allow boids to move in air */
	void use_flight(bool value) {
		PyObject_SetAttrString(pyobjref, "use_flight", Py_BuildValue("i", value));
	}

	/** Getter: Allow boids to move on land */
	bool use_land() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_land")) == 1;
	}

	/** Setter: Allow boids to move on land */
	void use_land(bool value) {
		PyObject_SetAttrString(pyobjref, "use_land", Py_BuildValue("i", value));
	}

	/** Getter: Allow boids to climb goal objects */
	bool use_climb() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_climb")) == 1;
	}

	/** Setter: Allow boids to climb goal objects */
	void use_climb(bool value) {
		PyObject_SetAttrString(pyobjref, "use_climb", Py_BuildValue("i", value));
	}

};

/**************** Brush ****************/

/**
 * Brush datablock for storing brush settings for painting and sculpting
 */
class Brush : public ID {
public:
	Brush(PyObject* pyobj) : ID(pyobj) {}

	Brush() : ID(0)
	{
		// not implemented
	}

	enum blend_enum {
		blend_MIX = 0,
		blend_ADD = 1,
		blend_SUB = 2,
		blend_MUL = 3,
		blend_LIGHTEN = 4,
		blend_DARKEN = 5,
		blend_ERASE_ALPHA = 6,
		blend_ADD_ALPHA = 7,
		blend_OVERLAY = 8,
		blend_HARDLIGHT = 9,
		blend_COLORBURN = 10,
		blend_LINEARBURN = 11,
		blend_COLORDODGE = 12,
		blend_SCREEN = 13,
		blend_SOFTLIGHT = 14,
		blend_PINLIGHT = 15,
		blend_VIVIDLIGHT = 16,
		blend_LINEARLIGHT = 17,
		blend_DIFFERENCE = 18,
		blend_EXCLUSION = 19,
		blend_HUE = 20,
		blend_SATURATION = 21,
		blend_LUMINOSITY = 22,
		blend_COLOR = 23,
	};

	/** Getter: Brush blending mode */
	blend_enum blend() { /* not implemented */ throw NULL; }
	/** Setter: Brush blending mode */
	void blend(blend_enum value) { /* not implemented */ }

	enum sculpt_tool_enum {
		sculpt_tool_BLOB = 17,
		sculpt_tool_CLAY = 8,
		sculpt_tool_CLAY_STRIPS = 18,
		sculpt_tool_CREASE = 16,
		sculpt_tool_DRAW = 1,
		sculpt_tool_FILL = 9,
		sculpt_tool_FLATTEN = 7,
		sculpt_tool_GRAB = 5,
		sculpt_tool_INFLATE = 4,
		sculpt_tool_LAYER = 6,
		sculpt_tool_MASK = 19,
		sculpt_tool_NUDGE = 11,
		sculpt_tool_PINCH = 3,
		sculpt_tool_ROTATE = 14,
		sculpt_tool_SCRAPE = 10,
		sculpt_tool_SIMPLIFY = 15,
		sculpt_tool_SMOOTH = 2,
		sculpt_tool_SNAKE_HOOK = 13,
		sculpt_tool_THUMB = 12,
	};

	/** Getter:  */
	sculpt_tool_enum sculpt_tool() { /* not implemented */ throw NULL; }
	/** Setter:  */
	void sculpt_tool(sculpt_tool_enum value) { /* not implemented */ }

	enum vertex_tool_enum {
		vertex_tool_MIX = 0,
		vertex_tool_ADD = 1,
		vertex_tool_SUB = 2,
		vertex_tool_MUL = 3,
		vertex_tool_BLUR = 4,
		vertex_tool_LIGHTEN = 5,
		vertex_tool_DARKEN = 6,
	};

	/** Getter: Brush blending mode */
	vertex_tool_enum vertex_tool() { /* not implemented */ throw NULL; }
	/** Setter: Brush blending mode */
	void vertex_tool(vertex_tool_enum value) { /* not implemented */ }

	enum image_tool_enum {
		image_tool_DRAW = 0,
		image_tool_SOFTEN = 1,
		image_tool_SMEAR = 2,
		image_tool_CLONE = 3,
		image_tool_FILL = 4,
		image_tool_MASK = 5,
	};

	/** Getter:  */
	image_tool_enum image_tool() { /* not implemented */ throw NULL; }
	/** Setter:  */
	void image_tool(image_tool_enum value) { /* not implemented */ }

	enum direction_enum {
		direction_ADD = 0,
		direction_SUBTRACT = 512,
	};

	/** Getter:  */
	direction_enum direction() { /* not implemented */ throw NULL; }
	/** Setter:  */
	void direction(direction_enum value) { /* not implemented */ }

	enum stroke_method_enum {
		stroke_method_DOTS = 0,
		stroke_method_DRAG_DOT = 8388608,
		stroke_method_SPACE = 1024,
		stroke_method_AIRBRUSH = 1,
		stroke_method_ANCHORED = 256,
		stroke_method_LINE = 536870912,
		stroke_method_CURVE = -2147483648,
	};

	/** Getter:  */
	stroke_method_enum stroke_method() { /* not implemented */ throw NULL; }
	/** Setter:  */
	void stroke_method(stroke_method_enum value) { /* not implemented */ }

	enum sculpt_plane_enum {
		sculpt_plane_AREA = 0,
		sculpt_plane_VIEW = 1,
		sculpt_plane_X = 2,
		sculpt_plane_Y = 3,
		sculpt_plane_Z = 4,
	};

	/** Getter:  */
	sculpt_plane_enum sculpt_plane() { /* not implemented */ throw NULL; }
	/** Setter:  */
	void sculpt_plane(sculpt_plane_enum value) { /* not implemented */ }

	enum mask_tool_enum {
		mask_tool_DRAW = 0,
		mask_tool_SMOOTH = 1,
	};

	/** Getter:  */
	mask_tool_enum mask_tool() { /* not implemented */ throw NULL; }
	/** Setter:  */
	void mask_tool(mask_tool_enum value) { /* not implemented */ }

	/** Getter: Radius of the brush in pixels */
	int size() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "size"));
	}

	/** Setter: Radius of the brush in pixels */
	void size(int value) {
		PyObject_SetAttrString(pyobjref, "size", Py_BuildValue("i", value));
	}

	/** Getter: Radius of brush in Blender units */
	float unprojected_radius() { /* not implemented */ throw NULL; }
	/** Setter: Radius of brush in Blender units */
	void unprojected_radius(float value) {
		PyObject_SetAttrString(pyobjref, "unprojected_radius", Py_BuildValue("f", value));
	}

	/** Getter: Jitter the position of the brush while painting */
	float jitter() { /* not implemented */ throw NULL; }
	/** Setter: Jitter the position of the brush while painting */
	void jitter(float value) {
		PyObject_SetAttrString(pyobjref, "jitter", Py_BuildValue("f", value));
	}

	/** Getter: Jitter the position of the brush in pixels while painting */
	int jitter_absolute() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "jitter_absolute"));
	}

	/** Setter: Jitter the position of the brush in pixels while painting */
	void jitter_absolute(int value) {
		PyObject_SetAttrString(pyobjref, "jitter_absolute", Py_BuildValue("i", value));
	}

	/** Getter: Spacing between brush daubs as a percentage of brush diameter */
	int spacing() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "spacing"));
	}

	/** Setter: Spacing between brush daubs as a percentage of brush diameter */
	void spacing(int value) {
		PyObject_SetAttrString(pyobjref, "spacing", Py_BuildValue("i", value));
	}

	/** Getter: Spacing before brush gradient goes full circle */
	int grad_spacing() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "grad_spacing"));
	}

	/** Setter: Spacing before brush gradient goes full circle */
	void grad_spacing(int value) {
		PyObject_SetAttrString(pyobjref, "grad_spacing", Py_BuildValue("i", value));
	}

	/** Getter: Minimum distance from last point before stroke continues */
	int smooth_stroke_radius() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "smooth_stroke_radius"));
	}

	/** Setter: Minimum distance from last point before stroke continues */
	void smooth_stroke_radius(int value) {
		PyObject_SetAttrString(pyobjref, "smooth_stroke_radius", Py_BuildValue("i", value));
	}

	/** Getter: Higher values give a smoother stroke */
	float smooth_stroke_factor() { /* not implemented */ throw NULL; }
	/** Setter: Higher values give a smoother stroke */
	void smooth_stroke_factor(float value) {
		PyObject_SetAttrString(pyobjref, "smooth_stroke_factor", Py_BuildValue("f", value));
	}

	/** Getter: Interval between paints for Airbrush */
	float rate() { /* not implemented */ throw NULL; }
	/** Setter: Interval between paints for Airbrush */
	void rate(float value) {
		PyObject_SetAttrString(pyobjref, "rate", Py_BuildValue("f", value));
	}

	/** Getter:  */
	std::array<float, 3> color() {
		// TODO: MISSING DEREF! USE #DEFINE!
		PyObject *seqval = PyObject_GetAttrString(pyobjref, "color");
		std::array<float, 3> resarr;
		for (int i = 0; i < 3; i++)
			resarr[i] = (float)PyFloat_AsDouble(PySequence_GetItem(seqval, i));
		return resarr;
	}

	/** Setter:  */
	void color(float values[3]) { /* not implemented */ }

	/** Getter:  */
	std::array<float, 3> secondary_color() {
		// TODO: MISSING DEREF! USE #DEFINE!
		PyObject *seqval = PyObject_GetAttrString(pyobjref, "secondary_color");
		std::array<float, 3> resarr;
		for (int i = 0; i < 3; i++)
			resarr[i] = (float)PyFloat_AsDouble(PySequence_GetItem(seqval, i));
		return resarr;
	}

	/** Setter:  */
	void secondary_color(float values[3]) { /* not implemented */ }

	/** Getter: Vertex weight when brush is applied */
	float weight() { /* not implemented */ throw NULL; }
	/** Setter: Vertex weight when brush is applied */
	void weight(float value) {
		PyObject_SetAttrString(pyobjref, "weight", Py_BuildValue("f", value));
	}

	/** Getter: How powerful the effect of the brush is when applied */
	float strength() { /* not implemented */ throw NULL; }
	/** Setter: How powerful the effect of the brush is when applied */
	void strength(float value) {
		PyObject_SetAttrString(pyobjref, "strength", Py_BuildValue("f", value));
	}

	/** Getter: Adjust plane on which the brush acts towards or away from the object surface */
	float plane_offset() { /* not implemented */ throw NULL; }
	/** Setter: Adjust plane on which the brush acts towards or away from the object surface */
	void plane_offset(float value) {
		PyObject_SetAttrString(pyobjref, "plane_offset", Py_BuildValue("f", value));
	}

	/** Getter: If a vertex is further away from offset plane than this, then it is not affected */
	float plane_trim() { /* not implemented */ throw NULL; }
	/** Setter: If a vertex is further away from offset plane than this, then it is not affected */
	void plane_trim(float value) {
		PyObject_SetAttrString(pyobjref, "plane_trim", Py_BuildValue("f", value));
	}

	/** Getter: Affectable height of brush (layer height for layer tool, i.e.) */
	float height() { /* not implemented */ throw NULL; }
	/** Setter: Affectable height of brush (layer height for layer tool, i.e.) */
	void height(float value) {
		PyObject_SetAttrString(pyobjref, "height", Py_BuildValue("f", value));
	}

	/** Getter: Value added to texture samples */
	float texture_sample_bias() { /* not implemented */ throw NULL; }
	/** Setter: Value added to texture samples */
	void texture_sample_bias(float value) {
		PyObject_SetAttrString(pyobjref, "texture_sample_bias", Py_BuildValue("f", value));
	}

	/** Getter: How much grab will pull vertexes out of surface during a grab */
	float normal_weight() { /* not implemented */ throw NULL; }
	/** Setter: How much grab will pull vertexes out of surface during a grab */
	void normal_weight(float value) {
		PyObject_SetAttrString(pyobjref, "normal_weight", Py_BuildValue("f", value));
	}

	/** Getter: How much the crease brush pinches */
	float crease_pinch_factor() { /* not implemented */ throw NULL; }
	/** Setter: How much the crease brush pinches */
	void crease_pinch_factor(float value) {
		PyObject_SetAttrString(pyobjref, "crease_pinch_factor", Py_BuildValue("f", value));
	}

	/** Getter: Amount of smoothing to automatically apply to each stroke */
	float auto_smooth_factor() { /* not implemented */ throw NULL; }
	/** Setter: Amount of smoothing to automatically apply to each stroke */
	void auto_smooth_factor(float value) {
		PyObject_SetAttrString(pyobjref, "auto_smooth_factor", Py_BuildValue("f", value));
	}

	/** Getter: Position of stencil in viewport */
	std::array<float, 2> stencil_pos() {
		// TODO: MISSING DEREF! USE #DEFINE!
		PyObject *seqval = PyObject_GetAttrString(pyobjref, "stencil_pos");
		std::array<float, 2> resarr;
		for (int i = 0; i < 2; i++)
			resarr[i] = (float)PyFloat_AsDouble(PySequence_GetItem(seqval, i));
		return resarr;
	}

	/** Setter: Position of stencil in viewport */
	void stencil_pos(float values[2]) { /* not implemented */ }

	/** Getter: Dimensions of stencil in viewport */
	std::array<float, 2> stencil_dimension() {
		// TODO: MISSING DEREF! USE #DEFINE!
		PyObject *seqval = PyObject_GetAttrString(pyobjref, "stencil_dimension");
		std::array<float, 2> resarr;
		for (int i = 0; i < 2; i++)
			resarr[i] = (float)PyFloat_AsDouble(PySequence_GetItem(seqval, i));
		return resarr;
	}

	/** Setter: Dimensions of stencil in viewport */
	void stencil_dimension(float values[2]) { /* not implemented */ }

	/** Getter: Position of mask stencil in viewport */
	std::array<float, 2> mask_stencil_pos() {
		// TODO: MISSING DEREF! USE #DEFINE!
		PyObject *seqval = PyObject_GetAttrString(pyobjref, "mask_stencil_pos");
		std::array<float, 2> resarr;
		for (int i = 0; i < 2; i++)
			resarr[i] = (float)PyFloat_AsDouble(PySequence_GetItem(seqval, i));
		return resarr;
	}

	/** Setter: Position of mask stencil in viewport */
	void mask_stencil_pos(float values[2]) { /* not implemented */ }

	/** Getter: Dimensions of mask stencil in viewport */
	std::array<float, 2> mask_stencil_dimension() {
		// TODO: MISSING DEREF! USE #DEFINE!
		PyObject *seqval = PyObject_GetAttrString(pyobjref, "mask_stencil_dimension");
		std::array<float, 2> resarr;
		for (int i = 0; i < 2; i++)
			resarr[i] = (float)PyFloat_AsDouble(PySequence_GetItem(seqval, i));
		return resarr;
	}

	/** Setter: Dimensions of mask stencil in viewport */
	void mask_stencil_dimension(float values[2]) { /* not implemented */ }

	/** Getter: Threshold below which, no sharpening is done */
	float sharp_threshold() { /* not implemented */ throw NULL; }
	/** Setter: Threshold below which, no sharpening is done */
	void sharp_threshold(float value) {
		PyObject_SetAttrString(pyobjref, "sharp_threshold", Py_BuildValue("f", value));
	}

	/** Getter: Threshold above which filling is not propagated */
	float fill_threshold() { /* not implemented */ throw NULL; }
	/** Setter: Threshold above which filling is not propagated */
	void fill_threshold(float value) {
		PyObject_SetAttrString(pyobjref, "fill_threshold", Py_BuildValue("f", value));
	}

	/** Getter: Radius of kernel used for soften and sharpen in pixels */
	int blur_kernel_radius() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "blur_kernel_radius"));
	}

	/** Setter: Radius of kernel used for soften and sharpen in pixels */
	void blur_kernel_radius(int value) {
		PyObject_SetAttrString(pyobjref, "blur_kernel_radius", Py_BuildValue("i", value));
	}

	enum blur_mode_enum {
		blur_mode_BOX = 1,
		blur_mode_GAUSSIAN = 0,
	};

	/** Getter:  */
	blur_mode_enum blur_mode() { /* not implemented */ throw NULL; }
	/** Setter:  */
	void blur_mode(blur_mode_enum value) { /* not implemented */ }

	/** Getter: Keep applying paint effect while holding mouse (spray) */
	bool use_airbrush() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_airbrush")) == 1;
	}

	/** Setter: Keep applying paint effect while holding mouse (spray) */
	void use_airbrush(bool value) {
		PyObject_SetAttrString(pyobjref, "use_airbrush", Py_BuildValue("i", value));
	}

	/** Getter: When locked keep using normal of surface where stroke was initiated */
	bool use_original_normal() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_original_normal")) == 1;
	}

	/** Setter: When locked keep using normal of surface where stroke was initiated */
	void use_original_normal(bool value) {
		PyObject_SetAttrString(pyobjref, "use_original_normal", Py_BuildValue("i", value));
	}

	/** Getter: Enable torus wrapping while painting */
	bool use_wrap() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_wrap")) == 1;
	}

	/** Setter: Enable torus wrapping while painting */
	void use_wrap(bool value) {
		PyObject_SetAttrString(pyobjref, "use_wrap", Py_BuildValue("i", value));
	}

	/** Getter: Enable tablet pressure sensitivity for strength */
	bool use_pressure_strength() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_pressure_strength")) == 1;
	}

	/** Setter: Enable tablet pressure sensitivity for strength */
	void use_pressure_strength(bool value) {
		PyObject_SetAttrString(pyobjref, "use_pressure_strength", Py_BuildValue("i", value));
	}

	/** Getter: Enable tablet pressure sensitivity for offset */
	bool use_offset_pressure() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_offset_pressure")) == 1;
	}

	/** Setter: Enable tablet pressure sensitivity for offset */
	void use_offset_pressure(bool value) {
		PyObject_SetAttrString(pyobjref, "use_offset_pressure", Py_BuildValue("i", value));
	}

	/** Getter: Enable tablet pressure sensitivity for size */
	bool use_pressure_size() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_pressure_size")) == 1;
	}

	/** Setter: Enable tablet pressure sensitivity for size */
	void use_pressure_size(bool value) {
		PyObject_SetAttrString(pyobjref, "use_pressure_size", Py_BuildValue("i", value));
	}

	/** Getter: Use Gradient by utilizing a sampling method */
	bool use_gradient() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_gradient")) == 1;
	}

	/** Setter: Use Gradient by utilizing a sampling method */
	void use_gradient(bool value) {
		PyObject_SetAttrString(pyobjref, "use_gradient", Py_BuildValue("i", value));
	}

	/** Getter: Enable tablet pressure sensitivity for jitter */
	bool use_pressure_jitter() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_pressure_jitter")) == 1;
	}

	/** Setter: Enable tablet pressure sensitivity for jitter */
	void use_pressure_jitter(bool value) {
		PyObject_SetAttrString(pyobjref, "use_pressure_jitter", Py_BuildValue("i", value));
	}

	/** Getter: Enable tablet pressure sensitivity for spacing */
	bool use_pressure_spacing() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_pressure_spacing")) == 1;
	}

	/** Setter: Enable tablet pressure sensitivity for spacing */
	void use_pressure_spacing(bool value) {
		PyObject_SetAttrString(pyobjref, "use_pressure_spacing", Py_BuildValue("i", value));
	}

	enum use_pressure_masking_enum {
		use_pressure_masking_NONE = 0,
		use_pressure_masking_RAMP = 2,
		use_pressure_masking_CUTOFF = 4,
	};

	/** Getter: Pen pressure makes texture influence smaller */
	use_pressure_masking_enum use_pressure_masking() { /* not implemented */ throw NULL; }
	/** Setter: Pen pressure makes texture influence smaller */
	void use_pressure_masking(use_pressure_masking_enum value) { /* not implemented */ }

	/** Getter: Lighter pressure causes more smoothing to be applied */
	bool use_inverse_smooth_pressure() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_inverse_smooth_pressure")) == 1;
	}

	/** Setter: Lighter pressure causes more smoothing to be applied */
	void use_inverse_smooth_pressure(bool value) {
		PyObject_SetAttrString(pyobjref, "use_inverse_smooth_pressure", Py_BuildValue("i", value));
	}

	/** Getter: Jittering happens in screen space, not relative to brush size */
	bool use_relative_jitter() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_relative_jitter")) == 1;
	}

	/** Setter: Jittering happens in screen space, not relative to brush size */
	void use_relative_jitter(bool value) {
		PyObject_SetAttrString(pyobjref, "use_relative_jitter", Py_BuildValue("i", value));
	}

	/** Getter: Enable Plane Trim */
	bool use_plane_trim() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_plane_trim")) == 1;
	}

	/** Setter: Enable Plane Trim */
	void use_plane_trim(bool value) {
		PyObject_SetAttrString(pyobjref, "use_plane_trim", Py_BuildValue("i", value));
	}

	/** Getter: Brush only affects vertexes that face the viewer */
	bool use_frontface() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_frontface")) == 1;
	}

	/** Setter: Brush only affects vertexes that face the viewer */
	void use_frontface(bool value) {
		PyObject_SetAttrString(pyobjref, "use_frontface", Py_BuildValue("i", value));
	}

	/** Getter: Keep the brush anchored to the initial location */
	bool use_anchor() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_anchor")) == 1;
	}

	/** Setter: Keep the brush anchored to the initial location */
	void use_anchor(bool value) {
		PyObject_SetAttrString(pyobjref, "use_anchor", Py_BuildValue("i", value));
	}

	/** Getter: Limit brush application to the distance specified by spacing */
	bool use_space() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_space")) == 1;
	}

	/** Setter: Limit brush application to the distance specified by spacing */
	void use_space(bool value) {
		PyObject_SetAttrString(pyobjref, "use_space", Py_BuildValue("i", value));
	}

	/** Getter: Draw a line with dabs separated according to spacing */
	bool use_line() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_line")) == 1;
	}

	/** Setter: Draw a line with dabs separated according to spacing */
	void use_line(bool value) {
		PyObject_SetAttrString(pyobjref, "use_line", Py_BuildValue("i", value));
	}

	/** Getter: Define the stroke curve with a bezier curve. Dabs are separated according to spacing */
	bool use_curve() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_curve")) == 1;
	}

	/** Setter: Define the stroke curve with a bezier curve. Dabs are separated according to spacing */
	void use_curve(bool value) {
		PyObject_SetAttrString(pyobjref, "use_curve", Py_BuildValue("i", value));
	}

	/** Getter: Brush lags behind mouse and follows a smoother path */
	bool use_smooth_stroke() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_smooth_stroke")) == 1;
	}

	/** Setter: Brush lags behind mouse and follows a smoother path */
	void use_smooth_stroke(bool value) {
		PyObject_SetAttrString(pyobjref, "use_smooth_stroke", Py_BuildValue("i", value));
	}

	/** Getter: Sculpt on a persistent layer of the mesh */
	bool use_persistent() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_persistent")) == 1;
	}

	/** Setter: Sculpt on a persistent layer of the mesh */
	void use_persistent(bool value) {
		PyObject_SetAttrString(pyobjref, "use_persistent", Py_BuildValue("i", value));
	}

	/** Getter: Accumulate stroke daubs on top of each other */
	bool use_accumulate() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_accumulate")) == 1;
	}

	/** Setter: Accumulate stroke daubs on top of each other */
	void use_accumulate(bool value) {
		PyObject_SetAttrString(pyobjref, "use_accumulate", Py_BuildValue("i", value));
	}

	/** Getter: Automatically adjust strength to give consistent results for different spacings */
	bool use_space_attenuation() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_space_attenuation")) == 1;
	}

	/** Setter: Automatically adjust strength to give consistent results for different spacings */
	void use_space_attenuation(bool value) {
		PyObject_SetAttrString(pyobjref, "use_space_attenuation", Py_BuildValue("i", value));
	}

	/** Getter: Space daubs according to surface orientation instead of screen space */
	bool use_adaptive_space() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_adaptive_space")) == 1;
	}

	/** Setter: Space daubs according to surface orientation instead of screen space */
	void use_adaptive_space(bool value) {
		PyObject_SetAttrString(pyobjref, "use_adaptive_space", Py_BuildValue("i", value));
	}

	/** Getter: When locked brush stays same size relative to object; when unlocked brush size is given in pixels */
	bool use_locked_size() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_locked_size")) == 1;
	}

	/** Setter: When locked brush stays same size relative to object; when unlocked brush size is given in pixels */
	void use_locked_size(bool value) {
		PyObject_SetAttrString(pyobjref, "use_locked_size", Py_BuildValue("i", value));
	}

	/** Getter: Drag anchor brush from edge-to-edge */
	bool use_edge_to_edge() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_edge_to_edge")) == 1;
	}

	/** Setter: Drag anchor brush from edge-to-edge */
	void use_edge_to_edge(bool value) {
		PyObject_SetAttrString(pyobjref, "use_edge_to_edge", Py_BuildValue("i", value));
	}

	/** Getter: Allow a single dot to be carefully positioned */
	bool use_restore_mesh() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_restore_mesh")) == 1;
	}

	/** Setter: Allow a single dot to be carefully positioned */
	void use_restore_mesh(bool value) {
		PyObject_SetAttrString(pyobjref, "use_restore_mesh", Py_BuildValue("i", value));
	}

	/** Getter: When this is disabled, lock alpha while painting */
	bool use_alpha() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_alpha")) == 1;
	}

	/** Setter: When this is disabled, lock alpha while painting */
	void use_alpha(bool value) {
		PyObject_SetAttrString(pyobjref, "use_alpha", Py_BuildValue("i", value));
	}

	/** Getter: Editable falloff curve */
	CurveMapping curve();

	/** Getter: Active Paint Curve */
	PaintCurve paint_curve();

	/** Getter:  */
	ColorRamp gradient();

	enum gradient_stroke_mode_enum {
		gradient_stroke_mode_PRESSURE = 0,
		gradient_stroke_mode_SPACING_REPEAT = 1,
		gradient_stroke_mode_SPACING_CLAMP = 2,
	};

	/** Getter:  */
	gradient_stroke_mode_enum gradient_stroke_mode() { /* not implemented */ throw NULL; }
	/** Setter:  */
	void gradient_stroke_mode(gradient_stroke_mode_enum value) { /* not implemented */ }

	enum gradient_fill_mode_enum {
		gradient_fill_mode_LINEAR = 0,
		gradient_fill_mode_RADIAL = 1,
	};

	/** Getter:  */
	gradient_fill_mode_enum gradient_fill_mode() { /* not implemented */ throw NULL; }
	/** Setter:  */
	void gradient_fill_mode(gradient_fill_mode_enum value) { /* not implemented */ }

	/** Getter: Show texture in viewport */
	bool use_primary_overlay() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_primary_overlay")) == 1;
	}

	/** Setter: Show texture in viewport */
	void use_primary_overlay(bool value) {
		PyObject_SetAttrString(pyobjref, "use_primary_overlay", Py_BuildValue("i", value));
	}

	/** Getter: Show texture in viewport */
	bool use_secondary_overlay() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_secondary_overlay")) == 1;
	}

	/** Setter: Show texture in viewport */
	void use_secondary_overlay(bool value) {
		PyObject_SetAttrString(pyobjref, "use_secondary_overlay", Py_BuildValue("i", value));
	}

	/** Getter: Show cursor in viewport */
	bool use_cursor_overlay() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_cursor_overlay")) == 1;
	}

	/** Setter: Show cursor in viewport */
	void use_cursor_overlay(bool value) {
		PyObject_SetAttrString(pyobjref, "use_cursor_overlay", Py_BuildValue("i", value));
	}

	/** Getter: Don't show overlay during a stroke */
	bool use_cursor_overlay_override() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_cursor_overlay_override")) == 1;
	}

	/** Setter: Don't show overlay during a stroke */
	void use_cursor_overlay_override(bool value) {
		PyObject_SetAttrString(pyobjref, "use_cursor_overlay_override", Py_BuildValue("i", value));
	}

	/** Getter: Don't show overlay during a stroke */
	bool use_primary_overlay_override() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_primary_overlay_override")) == 1;
	}

	/** Setter: Don't show overlay during a stroke */
	void use_primary_overlay_override(bool value) {
		PyObject_SetAttrString(pyobjref, "use_primary_overlay_override", Py_BuildValue("i", value));
	}

	/** Getter: Don't show overlay during a stroke */
	bool use_secondary_overlay_override() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_secondary_overlay_override")) == 1;
	}

	/** Setter: Don't show overlay during a stroke */
	void use_secondary_overlay_override(bool value) {
		PyObject_SetAttrString(pyobjref, "use_secondary_overlay_override", Py_BuildValue("i", value));
	}

	/** Getter: Use this brush in sculpt mode */
	bool use_paint_sculpt() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_paint_sculpt")) == 1;
	}

	/** Setter: Use this brush in sculpt mode */
	void use_paint_sculpt(bool value) {
		PyObject_SetAttrString(pyobjref, "use_paint_sculpt", Py_BuildValue("i", value));
	}

	/** Getter: Use this brush in vertex paint mode */
	bool use_paint_vertex() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_paint_vertex")) == 1;
	}

	/** Setter: Use this brush in vertex paint mode */
	void use_paint_vertex(bool value) {
		PyObject_SetAttrString(pyobjref, "use_paint_vertex", Py_BuildValue("i", value));
	}

	/** Getter: Use this brush in weight paint mode */
	bool use_paint_weight() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_paint_weight")) == 1;
	}

	/** Setter: Use this brush in weight paint mode */
	void use_paint_weight(bool value) {
		PyObject_SetAttrString(pyobjref, "use_paint_weight", Py_BuildValue("i", value));
	}

	/** Getter: Use this brush in texture paint mode */
	bool use_paint_image() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_paint_image")) == 1;
	}

	/** Setter: Use this brush in texture paint mode */
	void use_paint_image(bool value) {
		PyObject_SetAttrString(pyobjref, "use_paint_image", Py_BuildValue("i", value));
	}

	/** Getter:  */
	BrushTextureSlot texture_slot();

	/** Getter:  */
	Texture texture() {
		/* not implemented */ throw NULL;
	}

	/** Getter:  */
	BrushTextureSlot mask_texture_slot();

	/** Getter:  */
	Texture mask_texture() {
		/* not implemented */ throw NULL;
	}

	/** Getter:  */
	int texture_overlay_alpha() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "texture_overlay_alpha"));
	}

	/** Setter:  */
	void texture_overlay_alpha(int value) {
		PyObject_SetAttrString(pyobjref, "texture_overlay_alpha", Py_BuildValue("i", value));
	}

	/** Getter:  */
	int mask_overlay_alpha() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "mask_overlay_alpha"));
	}

	/** Setter:  */
	void mask_overlay_alpha(int value) {
		PyObject_SetAttrString(pyobjref, "mask_overlay_alpha", Py_BuildValue("i", value));
	}

	/** Getter:  */
	int cursor_overlay_alpha() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "cursor_overlay_alpha"));
	}

	/** Setter:  */
	void cursor_overlay_alpha(int value) {
		PyObject_SetAttrString(pyobjref, "cursor_overlay_alpha", Py_BuildValue("i", value));
	}

	/** Getter: Color of cursor when adding */
	std::array<float, 3> cursor_color_add() {
		// TODO: MISSING DEREF! USE #DEFINE!
		PyObject *seqval = PyObject_GetAttrString(pyobjref, "cursor_color_add");
		std::array<float, 3> resarr;
		for (int i = 0; i < 3; i++)
			resarr[i] = (float)PyFloat_AsDouble(PySequence_GetItem(seqval, i));
		return resarr;
	}

	/** Setter: Color of cursor when adding */
	void cursor_color_add(float values[3]) { /* not implemented */ }

	/** Getter: Color of cursor when subtracting */
	std::array<float, 3> cursor_color_subtract() {
		// TODO: MISSING DEREF! USE #DEFINE!
		PyObject *seqval = PyObject_GetAttrString(pyobjref, "cursor_color_subtract");
		std::array<float, 3> resarr;
		for (int i = 0; i < 3; i++)
			resarr[i] = (float)PyFloat_AsDouble(PySequence_GetItem(seqval, i));
		return resarr;
	}

	/** Setter: Color of cursor when subtracting */
	void cursor_color_subtract(float values[3]) { /* not implemented */ }

	/** Getter: Set the brush icon from an image file */
	bool use_custom_icon() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_custom_icon")) == 1;
	}

	/** Setter: Set the brush icon from an image file */
	void use_custom_icon(bool value) {
		PyObject_SetAttrString(pyobjref, "use_custom_icon", Py_BuildValue("i", value));
	}

	/** Getter: File path to brush icon */
	std::string icon_filepath() { /* not implemented */ throw NULL; }
	/** Setter: File path to brush icon */
	void icon_filepath(const std::string& value) { /* not implemented */ }

	/** Getter: Image for clone tool */
	Image clone_image();

	/** Getter: Opacity of clone image display */
	float clone_alpha() { /* not implemented */ throw NULL; }
	/** Setter: Opacity of clone image display */
	void clone_alpha(float value) {
		PyObject_SetAttrString(pyobjref, "clone_alpha", Py_BuildValue("f", value));
	}

	/** Getter:  */
	std::array<float, 2> clone_offset() {
		// TODO: MISSING DEREF! USE #DEFINE!
		PyObject *seqval = PyObject_GetAttrString(pyobjref, "clone_offset");
		std::array<float, 2> resarr;
		for (int i = 0; i < 2; i++)
			resarr[i] = (float)PyFloat_AsDouble(PySequence_GetItem(seqval, i));
		return resarr;
	}

	/** Setter:  */
	void clone_offset(float values[2]) { /* not implemented */ }

	/** Getter: Brush's capabilities */
	BrushCapabilities brush_capabilities();

	/** Getter: Brush's capabilities in sculpt mode */
	SculptToolCapabilities sculpt_capabilities();

	/** Getter: Brush's capabilities in image paint mode */
	ImapaintToolCapabilities image_paint_capabilities();

};

/**************** Brush Capabilities ****************/

/**
 * Read-only indications of which brush operations are supported by the current brush
 */
class BrushCapabilities : public pyUniplug {
public:
	BrushCapabilities(PyObject* pyobj) : pyUniplug(pyobj) {}

	BrushCapabilities() : pyUniplug(0)
	{
		// not implemented
	}

	/** Getter: (null) */
	bool has_overlay() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "has_overlay")) == 1;
	}

	/** Setter: (null) */
	void has_overlay(bool value) {
		PyObject_SetAttrString(pyobjref, "has_overlay", Py_BuildValue("i", value));
	}

	/** Getter: (null) */
	bool has_random_texture_angle() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "has_random_texture_angle")) == 1;
	}

	/** Setter: (null) */
	void has_random_texture_angle(bool value) {
		PyObject_SetAttrString(pyobjref, "has_random_texture_angle", Py_BuildValue("i", value));
	}

	/** Getter: (null) */
	bool has_spacing() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "has_spacing")) == 1;
	}

	/** Setter: (null) */
	void has_spacing(bool value) {
		PyObject_SetAttrString(pyobjref, "has_spacing", Py_BuildValue("i", value));
	}

	/** Getter: (null) */
	bool has_smooth_stroke() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "has_smooth_stroke")) == 1;
	}

	/** Setter: (null) */
	void has_smooth_stroke(bool value) {
		PyObject_SetAttrString(pyobjref, "has_smooth_stroke", Py_BuildValue("i", value));
	}

};

/**************** Sculpt Capabilities ****************/

/**
 * Read-only indications of which brush operations are supported by the current sculpt tool
 */
class SculptToolCapabilities : public pyUniplug {
public:
	SculptToolCapabilities(PyObject* pyobj) : pyUniplug(pyobj) {}

	SculptToolCapabilities() : pyUniplug(0)
	{
		// not implemented
	}

	/** Getter: (null) */
	bool has_accumulate() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "has_accumulate")) == 1;
	}

	/** Setter: (null) */
	void has_accumulate(bool value) {
		PyObject_SetAttrString(pyobjref, "has_accumulate", Py_BuildValue("i", value));
	}

	/** Getter: (null) */
	bool has_auto_smooth() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "has_auto_smooth")) == 1;
	}

	/** Setter: (null) */
	void has_auto_smooth(bool value) {
		PyObject_SetAttrString(pyobjref, "has_auto_smooth", Py_BuildValue("i", value));
	}

	/** Getter: (null) */
	bool has_height() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "has_height")) == 1;
	}

	/** Setter: (null) */
	void has_height(bool value) {
		PyObject_SetAttrString(pyobjref, "has_height", Py_BuildValue("i", value));
	}

	/** Getter: (null) */
	bool has_jitter() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "has_jitter")) == 1;
	}

	/** Setter: (null) */
	void has_jitter(bool value) {
		PyObject_SetAttrString(pyobjref, "has_jitter", Py_BuildValue("i", value));
	}

	/** Getter: (null) */
	bool has_normal_weight() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "has_normal_weight")) == 1;
	}

	/** Setter: (null) */
	void has_normal_weight(bool value) {
		PyObject_SetAttrString(pyobjref, "has_normal_weight", Py_BuildValue("i", value));
	}

	/** Getter: (null) */
	bool has_persistence() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "has_persistence")) == 1;
	}

	/** Setter: (null) */
	void has_persistence(bool value) {
		PyObject_SetAttrString(pyobjref, "has_persistence", Py_BuildValue("i", value));
	}

	/** Getter: (null) */
	bool has_pinch_factor() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "has_pinch_factor")) == 1;
	}

	/** Setter: (null) */
	void has_pinch_factor(bool value) {
		PyObject_SetAttrString(pyobjref, "has_pinch_factor", Py_BuildValue("i", value));
	}

	/** Getter: (null) */
	bool has_plane_offset() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "has_plane_offset")) == 1;
	}

	/** Setter: (null) */
	void has_plane_offset(bool value) {
		PyObject_SetAttrString(pyobjref, "has_plane_offset", Py_BuildValue("i", value));
	}

	/** Getter: (null) */
	bool has_random_texture_angle() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "has_random_texture_angle")) == 1;
	}

	/** Setter: (null) */
	void has_random_texture_angle(bool value) {
		PyObject_SetAttrString(pyobjref, "has_random_texture_angle", Py_BuildValue("i", value));
	}

	/** Getter: (null) */
	bool has_sculpt_plane() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "has_sculpt_plane")) == 1;
	}

	/** Setter: (null) */
	void has_sculpt_plane(bool value) {
		PyObject_SetAttrString(pyobjref, "has_sculpt_plane", Py_BuildValue("i", value));
	}

	/** Getter: (null) */
	bool has_secondary_color() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "has_secondary_color")) == 1;
	}

	/** Setter: (null) */
	void has_secondary_color(bool value) {
		PyObject_SetAttrString(pyobjref, "has_secondary_color", Py_BuildValue("i", value));
	}

	/** Getter: (null) */
	bool has_smooth_stroke() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "has_smooth_stroke")) == 1;
	}

	/** Setter: (null) */
	void has_smooth_stroke(bool value) {
		PyObject_SetAttrString(pyobjref, "has_smooth_stroke", Py_BuildValue("i", value));
	}

	/** Getter: (null) */
	bool has_space_attenuation() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "has_space_attenuation")) == 1;
	}

	/** Setter: (null) */
	void has_space_attenuation(bool value) {
		PyObject_SetAttrString(pyobjref, "has_space_attenuation", Py_BuildValue("i", value));
	}

	/** Getter: (null) */
	bool has_strength_pressure() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "has_strength_pressure")) == 1;
	}

	/** Setter: (null) */
	void has_strength_pressure(bool value) {
		PyObject_SetAttrString(pyobjref, "has_strength_pressure", Py_BuildValue("i", value));
	}

	/** Getter: (null) */
	bool has_gravity() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "has_gravity")) == 1;
	}

	/** Setter: (null) */
	void has_gravity(bool value) {
		PyObject_SetAttrString(pyobjref, "has_gravity", Py_BuildValue("i", value));
	}

};

/**************** Image Paint Capabilities ****************/

/**
 * Read-only indications of which brush operations are supported by the current image paint brush
 */
class ImapaintToolCapabilities : public pyUniplug {
public:
	ImapaintToolCapabilities(PyObject* pyobj) : pyUniplug(pyobj) {}

	ImapaintToolCapabilities() : pyUniplug(0)
	{
		// not implemented
	}

	/** Getter: (null) */
	bool has_accumulate() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "has_accumulate")) == 1;
	}

	/** Setter: (null) */
	void has_accumulate(bool value) {
		PyObject_SetAttrString(pyobjref, "has_accumulate", Py_BuildValue("i", value));
	}

	/** Getter: (null) */
	bool has_space_attenuation() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "has_space_attenuation")) == 1;
	}

	/** Setter: (null) */
	void has_space_attenuation(bool value) {
		PyObject_SetAttrString(pyobjref, "has_space_attenuation", Py_BuildValue("i", value));
	}

	/** Getter: (null) */
	bool has_radius() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "has_radius")) == 1;
	}

	/** Setter: (null) */
	void has_radius(bool value) {
		PyObject_SetAttrString(pyobjref, "has_radius", Py_BuildValue("i", value));
	}

};

/**************** Brush Texture Slot ****************/

/**
 * Texture slot for textures in a Brush datablock
 */
class BrushTextureSlot : public TextureSlot {
public:
	BrushTextureSlot(PyObject* pyobj) : TextureSlot(pyobj) {}

	BrushTextureSlot() : TextureSlot(0)
	{
		// not implemented
	}

	/** Getter: Brush texture rotation */
	float angle() { /* not implemented */ throw NULL; }
	/** Setter: Brush texture rotation */
	void angle(float value) {
		PyObject_SetAttrString(pyobjref, "angle", Py_BuildValue("f", value));
	}

	enum map_mode_enum {
		map_mode_VIEW_PLANE = 0,
		map_mode_AREA_PLANE = 3,
		map_mode_TILED = 1,
		map_mode_3D = 2,
		map_mode_RANDOM = 4,
		map_mode_STENCIL = 5,
	};

	/** Getter:  */
	map_mode_enum map_mode() { /* not implemented */ throw NULL; }
	/** Setter:  */
	void map_mode(map_mode_enum value) { /* not implemented */ }

	enum tex_paint_map_mode_enum {
		tex_paint_map_mode_VIEW_PLANE = 0,
		tex_paint_map_mode_TILED = 1,
		tex_paint_map_mode_3D = 2,
		tex_paint_map_mode_RANDOM = 4,
		tex_paint_map_mode_STENCIL = 5,
	};

	/** Getter:  */
	tex_paint_map_mode_enum tex_paint_map_mode() { /* not implemented */ throw NULL; }
	/** Setter:  */
	void tex_paint_map_mode(tex_paint_map_mode_enum value) { /* not implemented */ }

	enum mask_map_mode_enum {
		mask_map_mode_VIEW_PLANE = 0,
		mask_map_mode_TILED = 1,
		mask_map_mode_RANDOM = 4,
		mask_map_mode_STENCIL = 5,
	};

	/** Getter:  */
	mask_map_mode_enum mask_map_mode() { /* not implemented */ throw NULL; }
	/** Setter:  */
	void mask_map_mode(mask_map_mode_enum value) { /* not implemented */ }

	/** Getter:  */
	bool use_rake() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_rake")) == 1;
	}

	/** Setter:  */
	void use_rake(bool value) {
		PyObject_SetAttrString(pyobjref, "use_rake", Py_BuildValue("i", value));
	}

	/** Getter:  */
	bool use_random() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_random")) == 1;
	}

	/** Setter:  */
	void use_random(bool value) {
		PyObject_SetAttrString(pyobjref, "use_random", Py_BuildValue("i", value));
	}

	/** Getter: Brush texture random angle */
	float random_angle() { /* not implemented */ throw NULL; }
	/** Setter: Brush texture random angle */
	void random_angle(float value) {
		PyObject_SetAttrString(pyobjref, "random_angle", Py_BuildValue("f", value));
	}

	/** Getter: (null) */
	bool has_texture_angle_source() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "has_texture_angle_source")) == 1;
	}

	/** Setter: (null) */
	void has_texture_angle_source(bool value) {
		PyObject_SetAttrString(pyobjref, "has_texture_angle_source", Py_BuildValue("i", value));
	}

	/** Getter: (null) */
	bool has_random_texture_angle() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "has_random_texture_angle")) == 1;
	}

	/** Setter: (null) */
	void has_random_texture_angle(bool value) {
		PyObject_SetAttrString(pyobjref, "has_random_texture_angle", Py_BuildValue("i", value));
	}

	/** Getter: (null) */
	bool has_texture_angle() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "has_texture_angle")) == 1;
	}

	/** Setter: (null) */
	void has_texture_angle(bool value) {
		PyObject_SetAttrString(pyobjref, "has_texture_angle", Py_BuildValue("i", value));
	}

};

/**************** Operator Stroke Element ****************/

/**
 * 
 */
class OperatorStrokeElement : public PropertyGroup {
public:
	OperatorStrokeElement(PyObject* pyobj) : PropertyGroup(pyobj) {}

	OperatorStrokeElement() : PropertyGroup(0)
	{
		// not implemented
	}

	/** Getter:  */
	std::array<float, 3> location() {
		// TODO: MISSING DEREF! USE #DEFINE!
		PyObject *seqval = PyObject_GetAttrString(pyobjref, "location");
		std::array<float, 3> resarr;
		for (int i = 0; i < 3; i++)
			resarr[i] = (float)PyFloat_AsDouble(PySequence_GetItem(seqval, i));
		return resarr;
	}

	/** Setter:  */
	void location(float values[3]) { /* not implemented */ }

	/** Getter:  */
	std::array<float, 2> mouse() {
		// TODO: MISSING DEREF! USE #DEFINE!
		PyObject *seqval = PyObject_GetAttrString(pyobjref, "mouse");
		std::array<float, 2> resarr;
		for (int i = 0; i < 2; i++)
			resarr[i] = (float)PyFloat_AsDouble(PySequence_GetItem(seqval, i));
		return resarr;
	}

	/** Setter:  */
	void mouse(float values[2]) { /* not implemented */ }

	/** Getter: Tablet pressure */
	float pressure() { /* not implemented */ throw NULL; }
	/** Setter: Tablet pressure */
	void pressure(float value) {
		PyObject_SetAttrString(pyobjref, "pressure", Py_BuildValue("f", value));
	}

	/** Getter: Brush Size in screen space */
	float size() { /* not implemented */ throw NULL; }
	/** Setter: Brush Size in screen space */
	void size(float value) {
		PyObject_SetAttrString(pyobjref, "size", Py_BuildValue("f", value));
	}

	/** Getter:  */
	bool pen_flip() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "pen_flip")) == 1;
	}

	/** Setter:  */
	void pen_flip(bool value) {
		PyObject_SetAttrString(pyobjref, "pen_flip", Py_BuildValue("i", value));
	}

	/** Getter:  */
	float time() { /* not implemented */ throw NULL; }
	/** Setter:  */
	void time(float value) {
		PyObject_SetAttrString(pyobjref, "time", Py_BuildValue("f", value));
	}

	/** Getter:  */
	bool is_start() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "is_start")) == 1;
	}

	/** Setter:  */
	void is_start(bool value) {
		PyObject_SetAttrString(pyobjref, "is_start", Py_BuildValue("i", value));
	}

};

/**************** Camera ****************/

/**
 * Camera datablock for storing camera settings
 */
class Camera : public ID {
public:
	Camera(PyObject* pyobj) : ID(pyobj) {}

	Camera() : ID(0)
	{
		// not implemented
	}

	enum type_enum {
		type_PERSP = 0,
		type_ORTHO = 1,
		type_PANO = 2,
	};

	/** Getter: Camera types */
	type_enum type() { /* not implemented */ throw NULL; }
	/** Setter: Camera types */
	void type(type_enum value) { /* not implemented */ }

	enum show_guide_enum {
		show_guide_CENTER = 1,
		show_guide_CENTER_DIAGONAL = 2,
		show_guide_THIRDS = 4,
		show_guide_GOLDEN = 8,
		show_guide_GOLDEN_TRIANGLE_A = 16,
		show_guide_GOLDEN_TRIANGLE_B = 32,
		show_guide_HARMONY_TRIANGLE_A = 64,
		show_guide_HARMONY_TRIANGLE_B = 128,
	};

	/** Getter: Draw overlay */
	show_guide_enum show_guide() { /* not implemented */ throw NULL; }
	/** Setter: Draw overlay */
	void show_guide(show_guide_enum value) { /* not implemented */ }

	enum sensor_fit_enum {
		sensor_fit_AUTO = 0,
		sensor_fit_HORIZONTAL = 1,
		sensor_fit_VERTICAL = 2,
	};

	/** Getter: Method to fit image and field of view angle inside the sensor */
	sensor_fit_enum sensor_fit() { /* not implemented */ throw NULL; }
	/** Setter: Method to fit image and field of view angle inside the sensor */
	void sensor_fit(sensor_fit_enum value) { /* not implemented */ }

	/** Getter: Opacity (alpha) of the darkened overlay in Camera view */
	float passepartout_alpha() { /* not implemented */ throw NULL; }
	/** Setter: Opacity (alpha) of the darkened overlay in Camera view */
	void passepartout_alpha(float value) {
		PyObject_SetAttrString(pyobjref, "passepartout_alpha", Py_BuildValue("f", value));
	}

	/** Getter: Camera lens horizontal field of view */
	float angle_x() { /* not implemented */ throw NULL; }
	/** Setter: Camera lens horizontal field of view */
	void angle_x(float value) {
		PyObject_SetAttrString(pyobjref, "angle_x", Py_BuildValue("f", value));
	}

	/** Getter: Camera lens vertical field of view */
	float angle_y() { /* not implemented */ throw NULL; }
	/** Setter: Camera lens vertical field of view */
	void angle_y(float value) {
		PyObject_SetAttrString(pyobjref, "angle_y", Py_BuildValue("f", value));
	}

	/** Getter: Camera lens field of view */
	float angle() { /* not implemented */ throw NULL; }
	/** Setter: Camera lens field of view */
	void angle(float value) {
		PyObject_SetAttrString(pyobjref, "angle", Py_BuildValue("f", value));
	}

	/** Getter: Camera near clipping distance */
	float clip_start() { /* not implemented */ throw NULL; }
	/** Setter: Camera near clipping distance */
	void clip_start(float value) {
		PyObject_SetAttrString(pyobjref, "clip_start", Py_BuildValue("f", value));
	}

	/** Getter: Camera far clipping distance */
	float clip_end() { /* not implemented */ throw NULL; }
	/** Setter: Camera far clipping distance */
	void clip_end(float value) {
		PyObject_SetAttrString(pyobjref, "clip_end", Py_BuildValue("f", value));
	}

	/** Getter: Perspective Camera lens value in millimeters */
	float lens() { /* not implemented */ throw NULL; }
	/** Setter: Perspective Camera lens value in millimeters */
	void lens(float value) {
		PyObject_SetAttrString(pyobjref, "lens", Py_BuildValue("f", value));
	}

	/** Getter: Horizontal size of the image sensor area in millimeters */
	float sensor_width() { /* not implemented */ throw NULL; }
	/** Setter: Horizontal size of the image sensor area in millimeters */
	void sensor_width(float value) {
		PyObject_SetAttrString(pyobjref, "sensor_width", Py_BuildValue("f", value));
	}

	/** Getter: Vertical size of the image sensor area in millimeters */
	float sensor_height() { /* not implemented */ throw NULL; }
	/** Setter: Vertical size of the image sensor area in millimeters */
	void sensor_height(float value) {
		PyObject_SetAttrString(pyobjref, "sensor_height", Py_BuildValue("f", value));
	}

	/** Getter: Orthographic Camera scale (similar to zoom) */
	float ortho_scale() { /* not implemented */ throw NULL; }
	/** Setter: Orthographic Camera scale (similar to zoom) */
	void ortho_scale(float value) {
		PyObject_SetAttrString(pyobjref, "ortho_scale", Py_BuildValue("f", value));
	}

	/** Getter: Apparent size of the Camera object in the 3D View */
	float draw_size() { /* not implemented */ throw NULL; }
	/** Setter: Apparent size of the Camera object in the 3D View */
	void draw_size(float value) {
		PyObject_SetAttrString(pyobjref, "draw_size", Py_BuildValue("f", value));
	}

	/** Getter: Perspective Camera horizontal shift */
	float shift_x() { /* not implemented */ throw NULL; }
	/** Setter: Perspective Camera horizontal shift */
	void shift_x(float value) {
		PyObject_SetAttrString(pyobjref, "shift_x", Py_BuildValue("f", value));
	}

	/** Getter: Perspective Camera vertical shift */
	float shift_y() { /* not implemented */ throw NULL; }
	/** Setter: Perspective Camera vertical shift */
	void shift_y(float value) {
		PyObject_SetAttrString(pyobjref, "shift_y", Py_BuildValue("f", value));
	}

	/** Getter: Distance to the focus point for depth of field */
	float dof_distance() { /* not implemented */ throw NULL; }
	/** Setter: Distance to the focus point for depth of field */
	void dof_distance(float value) {
		PyObject_SetAttrString(pyobjref, "dof_distance", Py_BuildValue("f", value));
	}

	/** Getter:  */
	CameraStereoData stereo();

	/** Getter: Draw the clipping range and focus point on the camera */
	bool show_limits() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "show_limits")) == 1;
	}

	/** Setter: Draw the clipping range and focus point on the camera */
	void show_limits(bool value) {
		PyObject_SetAttrString(pyobjref, "show_limits", Py_BuildValue("i", value));
	}

	/** Getter: Draw a line from the Camera to indicate the mist area */
	bool show_mist() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "show_mist")) == 1;
	}

	/** Setter: Draw a line from the Camera to indicate the mist area */
	void show_mist(bool value) {
		PyObject_SetAttrString(pyobjref, "show_mist", Py_BuildValue("i", value));
	}

	/** Getter: Show a darkened overlay outside the image area in Camera view */
	bool show_passepartout() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "show_passepartout")) == 1;
	}

	/** Setter: Show a darkened overlay outside the image area in Camera view */
	void show_passepartout(bool value) {
		PyObject_SetAttrString(pyobjref, "show_passepartout", Py_BuildValue("i", value));
	}

	/** Getter: Show TV title safe and action safe areas in Camera view */
	bool show_safe_areas() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "show_safe_areas")) == 1;
	}

	/** Setter: Show TV title safe and action safe areas in Camera view */
	void show_safe_areas(bool value) {
		PyObject_SetAttrString(pyobjref, "show_safe_areas", Py_BuildValue("i", value));
	}

	/** Getter: Show safe areas to fit content in a different aspect ratio */
	bool show_safe_center() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "show_safe_center")) == 1;
	}

	/** Setter: Show safe areas to fit content in a different aspect ratio */
	void show_safe_center(bool value) {
		PyObject_SetAttrString(pyobjref, "show_safe_center", Py_BuildValue("i", value));
	}

	/** Getter: Show the active Camera's name in Camera view */
	bool show_name() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "show_name")) == 1;
	}

	/** Setter: Show the active Camera's name in Camera view */
	void show_name(bool value) {
		PyObject_SetAttrString(pyobjref, "show_name", Py_BuildValue("i", value));
	}

	/** Getter: Show sensor size (film gate) in Camera view */
	bool show_sensor() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "show_sensor")) == 1;
	}

	/** Setter: Show sensor size (film gate) in Camera view */
	void show_sensor(bool value) {
		PyObject_SetAttrString(pyobjref, "show_sensor", Py_BuildValue("i", value));
	}

	enum lens_unit_enum {
		lens_unit_MILLIMETERS = 0,
		lens_unit_FOV = 32,
	};

	/** Getter: Unit to edit lens in for the user interface */
	lens_unit_enum lens_unit() { /* not implemented */ throw NULL; }
	/** Setter: Unit to edit lens in for the user interface */
	void lens_unit(lens_unit_enum value) { /* not implemented */ }

	/** Getter: Use this object to define the depth of field focal point */
	Object dof_object();

	/** Getter:  */
	GPUDOFSettings gpu_dof();

	/** Getter: Animation data for this datablock */
	AnimData animation_data() {
		/* not implemented */ throw NULL;
	}

	/**
	 * Container for the output of view_frame()
	 */
	struct view_frame_result {
		float result_1;
		float result_2;
		float result_3;
		float result_4;
	};

	/**
	 * Return 4 points for the cameras frame (before object transformation)
	 * @param Scene to use for aspect calculation, when omitted 1:1 aspect is used
	 * @return A view_frame_result struct containing the output of this function
	 */
	view_frame_result view_frame(Scene scene);

};

/**************** Stereo ****************/

/**
 * Stereoscopy settings for a Camera datablock
 */
class CameraStereoData : public pyUniplug {
public:
	CameraStereoData(PyObject* pyobj) : pyUniplug(pyobj) {}

	CameraStereoData() : pyUniplug(0)
	{
		// not implemented
	}

	enum convergence_mode_enum {
		convergence_mode_OFFAXIS = 0,
		convergence_mode_PARALLEL = 1,
		convergence_mode_TOE = 2,
	};

	/** Getter:  */
	convergence_mode_enum convergence_mode() { /* not implemented */ throw NULL; }
	/** Setter:  */
	void convergence_mode(convergence_mode_enum value) { /* not implemented */ }

	enum pivot_enum {
		pivot_LEFT = 0,
		pivot_RIGHT = 1,
		pivot_CENTER = 2,
	};

	/** Getter:  */
	pivot_enum pivot() { /* not implemented */ throw NULL; }
	/** Setter:  */
	void pivot(pivot_enum value) { /* not implemented */ }

	/** Getter: Set the distance between the eyes - the stereo plane distance / 30 should be fine */
	float interocular_distance() { /* not implemented */ throw NULL; }
	/** Setter: Set the distance between the eyes - the stereo plane distance / 30 should be fine */
	void interocular_distance(float value) {
		PyObject_SetAttrString(pyobjref, "interocular_distance", Py_BuildValue("f", value));
	}

	/** Getter: The converge point for the stereo cameras (often the distance between a projector and the projection screen) */
	float convergence_distance() { /* not implemented */ throw NULL; }
	/** Setter: The converge point for the stereo cameras (often the distance between a projector and the projection screen) */
	void convergence_distance(float value) {
		PyObject_SetAttrString(pyobjref, "convergence_distance", Py_BuildValue("f", value));
	}

	/** Getter: Preview convergence distance for the stereo effect in the viewport (it does not affect the render!) */
	float viewport_convergence() { /* not implemented */ throw NULL; }
	/** Setter: Preview convergence distance for the stereo effect in the viewport (it does not affect the render!) */
	void viewport_convergence(float value) {
		PyObject_SetAttrString(pyobjref, "viewport_convergence", Py_BuildValue("f", value));
	}

};

/**************** Solver Result ****************/

/**
 * Result of cloth solver iteration
 */
class ClothSolverResult : public pyUniplug {
public:
	ClothSolverResult(PyObject* pyobj) : pyUniplug(pyobj) {}

	ClothSolverResult() : pyUniplug(0)
	{
		// not implemented
	}

	enum status_enum {
		status_SUCCESS = 1,
		status_NUMERICAL_ISSUE = 2,
		status_NO_CONVERGENCE = 4,
		status_INVALID_INPUT = 8,
	};

	/** Getter: Status of the solver iteration */
	status_enum status() { /* not implemented */ throw NULL; }
	/** Setter: Status of the solver iteration */
	void status(status_enum value) { /* not implemented */ }

	/** Getter: Maximum error during substeps */
	float max_error() { /* not implemented */ throw NULL; }
	/** Setter: Maximum error during substeps */
	void max_error(float value) {
		PyObject_SetAttrString(pyobjref, "max_error", Py_BuildValue("f", value));
	}

	/** Getter: Minimum error during substeps */
	float min_error() { /* not implemented */ throw NULL; }
	/** Setter: Minimum error during substeps */
	void min_error(float value) {
		PyObject_SetAttrString(pyobjref, "min_error", Py_BuildValue("f", value));
	}

	/** Getter: Average error during substeps */
	float avg_error() { /* not implemented */ throw NULL; }
	/** Setter: Average error during substeps */
	void avg_error(float value) {
		PyObject_SetAttrString(pyobjref, "avg_error", Py_BuildValue("f", value));
	}

	/** Getter: Maximum iterations during substeps */
	int max_iterations() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "max_iterations"));
	}

	/** Setter: Maximum iterations during substeps */
	void max_iterations(int value) {
		PyObject_SetAttrString(pyobjref, "max_iterations", Py_BuildValue("i", value));
	}

	/** Getter: Minimum iterations during substeps */
	int min_iterations() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "min_iterations"));
	}

	/** Setter: Minimum iterations during substeps */
	void min_iterations(int value) {
		PyObject_SetAttrString(pyobjref, "min_iterations", Py_BuildValue("i", value));
	}

	/** Getter: Average iterations during substeps */
	float avg_iterations() { /* not implemented */ throw NULL; }
	/** Setter: Average iterations during substeps */
	void avg_iterations(float value) {
		PyObject_SetAttrString(pyobjref, "avg_iterations", Py_BuildValue("f", value));
	}

};

/**************** Cloth Settings ****************/

/**
 * Cloth simulation settings for an object
 */
class ClothSettings : public pyUniplug {
public:
	ClothSettings(PyObject* pyobj) : pyUniplug(pyobj) {}

	ClothSettings() : pyUniplug(0)
	{
		// not implemented
	}

	/** Getter: Goal minimum, vertex group weights are scaled to match this range */
	float goal_min() { /* not implemented */ throw NULL; }
	/** Setter: Goal minimum, vertex group weights are scaled to match this range */
	void goal_min(float value) {
		PyObject_SetAttrString(pyobjref, "goal_min", Py_BuildValue("f", value));
	}

	/** Getter: Goal maximum, vertex group weights are scaled to match this range */
	float goal_max() { /* not implemented */ throw NULL; }
	/** Setter: Goal maximum, vertex group weights are scaled to match this range */
	void goal_max(float value) {
		PyObject_SetAttrString(pyobjref, "goal_max", Py_BuildValue("f", value));
	}

	/** Getter: Default Goal (vertex target position) value, when no Vertex Group used */
	float goal_default() { /* not implemented */ throw NULL; }
	/** Setter: Default Goal (vertex target position) value, when no Vertex Group used */
	void goal_default(float value) {
		PyObject_SetAttrString(pyobjref, "goal_default", Py_BuildValue("f", value));
	}

	/** Getter: Goal (vertex target position) spring stiffness */
	float goal_spring() { /* not implemented */ throw NULL; }
	/** Setter: Goal (vertex target position) spring stiffness */
	void goal_spring(float value) {
		PyObject_SetAttrString(pyobjref, "goal_spring", Py_BuildValue("f", value));
	}

	/** Getter: Goal (vertex target position) friction */
	float goal_friction() { /* not implemented */ throw NULL; }
	/** Setter: Goal (vertex target position) friction */
	void goal_friction(float value) {
		PyObject_SetAttrString(pyobjref, "goal_friction", Py_BuildValue("f", value));
	}

	/** Getter:  */
	float internal_friction() { /* not implemented */ throw NULL; }
	/** Setter:  */
	void internal_friction(float value) {
		PyObject_SetAttrString(pyobjref, "internal_friction", Py_BuildValue("f", value));
	}

	/** Getter:  */
	float collider_friction() { /* not implemented */ throw NULL; }
	/** Setter:  */
	void collider_friction(float value) {
		PyObject_SetAttrString(pyobjref, "collider_friction", Py_BuildValue("f", value));
	}

	/** Getter: Maximum density of hair */
	float density_target() { /* not implemented */ throw NULL; }
	/** Setter: Maximum density of hair */
	void density_target(float value) {
		PyObject_SetAttrString(pyobjref, "density_target", Py_BuildValue("f", value));
	}

	/** Getter: Influence of target density on the simulation */
	float density_strength() { /* not implemented */ throw NULL; }
	/** Setter: Influence of target density on the simulation */
	void density_strength(float value) {
		PyObject_SetAttrString(pyobjref, "density_strength", Py_BuildValue("f", value));
	}

	/** Getter: Mass of cloth material */
	float mass() { /* not implemented */ throw NULL; }
	/** Setter: Mass of cloth material */
	void mass(float value) {
		PyObject_SetAttrString(pyobjref, "mass", Py_BuildValue("f", value));
	}

	/** Getter: Vertex Group for pinning of vertices */
	std::string vertex_group_mass() { /* not implemented */ throw NULL; }
	/** Setter: Vertex Group for pinning of vertices */
	void vertex_group_mass(const std::string& value) { /* not implemented */ }

	/** Getter: Gravity or external force vector */
	std::array<float, 3> gravity() {
		// TODO: MISSING DEREF! USE #DEFINE!
		PyObject *seqval = PyObject_GetAttrString(pyobjref, "gravity");
		std::array<float, 3> resarr;
		for (int i = 0; i < 3; i++)
			resarr[i] = (float)PyFloat_AsDouble(PySequence_GetItem(seqval, i));
		return resarr;
	}

	/** Setter: Gravity or external force vector */
	void gravity(float values[3]) { /* not implemented */ }

	/** Getter: Air has normally some thickness which slows falling things down */
	float air_damping() { /* not implemented */ throw NULL; }
	/** Setter: Air has normally some thickness which slows falling things down */
	void air_damping(float value) {
		PyObject_SetAttrString(pyobjref, "air_damping", Py_BuildValue("f", value));
	}

	/** Getter: Damp velocity to help cloth reach the resting position faster (1.0 = no damping, 0.0 = fully dampened) */
	float vel_damping() { /* not implemented */ throw NULL; }
	/** Setter: Damp velocity to help cloth reach the resting position faster (1.0 = no damping, 0.0 = fully dampened) */
	void vel_damping(float value) {
		PyObject_SetAttrString(pyobjref, "vel_damping", Py_BuildValue("f", value));
	}

	/** Getter: Enable pinning of cloth vertices to other objects/positions */
	bool use_pin_cloth() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_pin_cloth")) == 1;
	}

	/** Setter: Enable pinning of cloth vertices to other objects/positions */
	void use_pin_cloth(bool value) {
		PyObject_SetAttrString(pyobjref, "use_pin_cloth", Py_BuildValue("i", value));
	}

	/** Getter: Pin (vertex target position) spring stiffness */
	float pin_stiffness() { /* not implemented */ throw NULL; }
	/** Setter: Pin (vertex target position) spring stiffness */
	void pin_stiffness(float value) {
		PyObject_SetAttrString(pyobjref, "pin_stiffness", Py_BuildValue("f", value));
	}

	/** Getter: Quality of the simulation in steps per frame (higher is better quality but slower) */
	int quality() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "quality"));
	}

	/** Setter: Quality of the simulation in steps per frame (higher is better quality but slower) */
	void quality(int value) {
		PyObject_SetAttrString(pyobjref, "quality", Py_BuildValue("i", value));
	}

	/** Getter: Vertex Group for shrinking cloth */
	std::string vertex_group_shrink() { /* not implemented */ throw NULL; }
	/** Setter: Vertex Group for shrinking cloth */
	void vertex_group_shrink(const std::string& value) { /* not implemented */ }

	/** Getter: Min amount to shrink cloth by */
	float shrink_min() { /* not implemented */ throw NULL; }
	/** Setter: Min amount to shrink cloth by */
	void shrink_min(float value) {
		PyObject_SetAttrString(pyobjref, "shrink_min", Py_BuildValue("f", value));
	}

	/** Getter: Max amount to shrink cloth by */
	float shrink_max() { /* not implemented */ throw NULL; }
	/** Setter: Max amount to shrink cloth by */
	void shrink_max(float value) {
		PyObject_SetAttrString(pyobjref, "shrink_max", Py_BuildValue("f", value));
	}

	/** Getter: Size of the voxel grid cells for interaction effects */
	float voxel_cell_size() { /* not implemented */ throw NULL; }
	/** Setter: Size of the voxel grid cells for interaction effects */
	void voxel_cell_size(float value) {
		PyObject_SetAttrString(pyobjref, "voxel_cell_size", Py_BuildValue("f", value));
	}

	/** Getter: If enabled, stiffness can be scaled along a weight painted vertex group */
	bool use_stiffness_scale() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_stiffness_scale")) == 1;
	}

	/** Setter: If enabled, stiffness can be scaled along a weight painted vertex group */
	void use_stiffness_scale(bool value) {
		PyObject_SetAttrString(pyobjref, "use_stiffness_scale", Py_BuildValue("i", value));
	}

	/** Getter: Damping of cloth velocity (higher = more smooth, less jiggling) */
	float spring_damping() { /* not implemented */ throw NULL; }
	/** Setter: Damping of cloth velocity (higher = more smooth, less jiggling) */
	void spring_damping(float value) {
		PyObject_SetAttrString(pyobjref, "spring_damping", Py_BuildValue("f", value));
	}

	/** Getter: Overall stiffness of structure */
	float structural_stiffness() { /* not implemented */ throw NULL; }
	/** Setter: Overall stiffness of structure */
	void structural_stiffness(float value) {
		PyObject_SetAttrString(pyobjref, "structural_stiffness", Py_BuildValue("f", value));
	}

	/** Getter: Maximum structural stiffness value */
	float structural_stiffness_max() { /* not implemented */ throw NULL; }
	/** Setter: Maximum structural stiffness value */
	void structural_stiffness_max(float value) {
		PyObject_SetAttrString(pyobjref, "structural_stiffness_max", Py_BuildValue("f", value));
	}

	/** Getter: Maximum sewing force */
	float sewing_force_max() { /* not implemented */ throw NULL; }
	/** Setter: Maximum sewing force */
	void sewing_force_max(float value) {
		PyObject_SetAttrString(pyobjref, "sewing_force_max", Py_BuildValue("f", value));
	}

	/** Getter: Vertex group for fine control over structural stiffness */
	std::string vertex_group_structural_stiffness() { /* not implemented */ throw NULL; }
	/** Setter: Vertex group for fine control over structural stiffness */
	void vertex_group_structural_stiffness(const std::string& value) { /* not implemented */ }

	/** Getter: Wrinkle coefficient (higher = less smaller but more big wrinkles) */
	float bending_stiffness() { /* not implemented */ throw NULL; }
	/** Setter: Wrinkle coefficient (higher = less smaller but more big wrinkles) */
	void bending_stiffness(float value) {
		PyObject_SetAttrString(pyobjref, "bending_stiffness", Py_BuildValue("f", value));
	}

	/** Getter: Maximum bending stiffness value */
	float bending_stiffness_max() { /* not implemented */ throw NULL; }
	/** Setter: Maximum bending stiffness value */
	void bending_stiffness_max(float value) {
		PyObject_SetAttrString(pyobjref, "bending_stiffness_max", Py_BuildValue("f", value));
	}

	/** Getter: Damping of bending motion */
	float bending_damping() { /* not implemented */ throw NULL; }
	/** Setter: Damping of bending motion */
	void bending_damping(float value) {
		PyObject_SetAttrString(pyobjref, "bending_damping", Py_BuildValue("f", value));
	}

	/** Getter: Pulls loose edges together */
	bool use_sewing_springs() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_sewing_springs")) == 1;
	}

	/** Setter: Pulls loose edges together */
	void use_sewing_springs(bool value) {
		PyObject_SetAttrString(pyobjref, "use_sewing_springs", Py_BuildValue("i", value));
	}

	/** Getter: Vertex group for fine control over bending stiffness */
	std::string vertex_group_bending() { /* not implemented */ throw NULL; }
	/** Setter: Vertex group for fine control over bending stiffness */
	void vertex_group_bending(const std::string& value) { /* not implemented */ }

	/** Getter:  */
	EffectorWeights effector_weights();

	/** Getter: Shape key to use the rest spring lengths from */
	ShapeKey rest_shape_key();

};

/**************** Cloth Collision Settings ****************/

/**
 * Cloth simulation settings for self collision and collision with other objects
 */
class ClothCollisionSettings : public pyUniplug {
public:
	ClothCollisionSettings(PyObject* pyobj) : pyUniplug(pyobj) {}

	ClothCollisionSettings() : pyUniplug(0)
	{
		// not implemented
	}

	/** Getter: Enable collisions with other objects */
	bool use_collision() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_collision")) == 1;
	}

	/** Setter: Enable collisions with other objects */
	void use_collision(bool value) {
		PyObject_SetAttrString(pyobjref, "use_collision", Py_BuildValue("i", value));
	}

	/** Getter: Repulsion force to apply on cloth when close to colliding */
	float repel_force() { /* not implemented */ throw NULL; }
	/** Setter: Repulsion force to apply on cloth when close to colliding */
	void repel_force(float value) {
		PyObject_SetAttrString(pyobjref, "repel_force", Py_BuildValue("f", value));
	}

	/** Getter: Maximum distance to apply repulsion force, must be greater than minimum distance */
	float distance_repel() { /* not implemented */ throw NULL; }
	/** Setter: Maximum distance to apply repulsion force, must be greater than minimum distance */
	void distance_repel(float value) {
		PyObject_SetAttrString(pyobjref, "distance_repel", Py_BuildValue("f", value));
	}

	/** Getter: Minimum distance between collision objects before collision response takes in */
	float distance_min() { /* not implemented */ throw NULL; }
	/** Setter: Minimum distance between collision objects before collision response takes in */
	void distance_min(float value) {
		PyObject_SetAttrString(pyobjref, "distance_min", Py_BuildValue("f", value));
	}

	/** Getter: Friction force if a collision happened (higher = less movement) */
	float friction() { /* not implemented */ throw NULL; }
	/** Setter: Friction force if a collision happened (higher = less movement) */
	void friction(float value) {
		PyObject_SetAttrString(pyobjref, "friction", Py_BuildValue("f", value));
	}

	/** Getter: Amount of velocity lost on collision */
	float damping() { /* not implemented */ throw NULL; }
	/** Setter: Amount of velocity lost on collision */
	void damping(float value) {
		PyObject_SetAttrString(pyobjref, "damping", Py_BuildValue("f", value));
	}

	/** Getter: How many collision iterations should be done. (higher is better quality but slower) */
	int collision_quality() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "collision_quality"));
	}

	/** Setter: How many collision iterations should be done. (higher is better quality but slower) */
	void collision_quality(int value) {
		PyObject_SetAttrString(pyobjref, "collision_quality", Py_BuildValue("i", value));
	}

	/** Getter: Enable self collisions */
	bool use_self_collision() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_self_collision")) == 1;
	}

	/** Setter: Enable self collisions */
	void use_self_collision(bool value) {
		PyObject_SetAttrString(pyobjref, "use_self_collision", Py_BuildValue("i", value));
	}

	/** Getter: 0.5 means no distance at all, 1.0 is maximum distance */
	float self_distance_min() { /* not implemented */ throw NULL; }
	/** Setter: 0.5 means no distance at all, 1.0 is maximum distance */
	void self_distance_min(float value) {
		PyObject_SetAttrString(pyobjref, "self_distance_min", Py_BuildValue("f", value));
	}

	/** Getter: Friction/damping with self contact */
	float self_friction() { /* not implemented */ throw NULL; }
	/** Setter: Friction/damping with self contact */
	void self_friction(float value) {
		PyObject_SetAttrString(pyobjref, "self_friction", Py_BuildValue("f", value));
	}

	/** Getter: How many self collision iterations should be done (higher is better quality but slower) */
	int self_collision_quality() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "self_collision_quality"));
	}

	/** Setter: How many self collision iterations should be done (higher is better quality but slower) */
	void self_collision_quality(int value) {
		PyObject_SetAttrString(pyobjref, "self_collision_quality", Py_BuildValue("i", value));
	}

	/** Getter: Limit colliders to this Group */
	Group group();

	/** Getter: Vertex group to define vertices which are not used during self collisions */
	std::string vertex_group_self_collisions() { /* not implemented */ throw NULL; }
	/** Setter: Vertex group to define vertices which are not used during self collisions */
	void vertex_group_self_collisions(const std::string& value) { /* not implemented */ }

};

/**************** CurveMapPoint ****************/

/**
 * Point of a curve used for a curve mapping
 */
class CurveMapPoint : public pyUniplug {
public:
	CurveMapPoint(PyObject* pyobj) : pyUniplug(pyobj) {}

	CurveMapPoint() : pyUniplug(0)
	{
		// not implemented
	}

	/** Getter: X/Y coordinates of the curve point */
	std::array<float, 2> location() {
		// TODO: MISSING DEREF! USE #DEFINE!
		PyObject *seqval = PyObject_GetAttrString(pyobjref, "location");
		std::array<float, 2> resarr;
		for (int i = 0; i < 2; i++)
			resarr[i] = (float)PyFloat_AsDouble(PySequence_GetItem(seqval, i));
		return resarr;
	}

	/** Setter: X/Y coordinates of the curve point */
	void location(float values[2]) { /* not implemented */ }

	enum handle_type_enum {
		handle_type_AUTO = 0,
		handle_type_VECTOR = 2,
	};

	/** Getter: Curve interpolation at this point: Bezier or vector */
	handle_type_enum handle_type() { /* not implemented */ throw NULL; }
	/** Setter: Curve interpolation at this point: Bezier or vector */
	void handle_type(handle_type_enum value) { /* not implemented */ }

	/** Getter: Selection state of the curve point */
	bool select() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "select")) == 1;
	}

	/** Setter: Selection state of the curve point */
	void select(bool value) {
		PyObject_SetAttrString(pyobjref, "select", Py_BuildValue("i", value));
	}

};

/**************** CurveMap ****************/

/**
 * Curve in a curve mapping
 */
class CurveMap : public pyUniplug {
public:
	CurveMap(PyObject* pyobj) : pyUniplug(pyobj) {}

	CurveMap() : pyUniplug(0)
	{
		// not implemented
	}

	enum extend_enum {
		extend_HORIZONTAL = 0,
		extend_EXTRAPOLATED = 1,
	};

	/** Getter: Extrapolate the curve or extend it horizontally */
	extend_enum extend() { /* not implemented */ throw NULL; }
	/** Setter: Extrapolate the curve or extend it horizontally */
	void extend(extend_enum value) { /* not implemented */ }

	/** Getter:  */
	std::map<std::string, CurveMapPoint> points() {
		// TODO: MISSING DEREF! USE #DEFINE!
		PyObject *seqval = PyObject_GetAttrString(pyobjref, "points");
		PyObject *seqkeys = PyObject_CallMethod(seqval, "keys", NULL);
		std::map<std::string, CurveMapPoint> resmap;
		for (int i = 0; i < PySequence_Length(seqval); i++) {
			PyObject *keyobj = PySequence_GetItem(seqkeys, i);
			std::string key = PyBytes_AsString(PyUnicode_AsASCIIString(keyobj));
			CurveMapPoint value = CurveMapPoint(PySequence_GetItem(seqval, i));
			resmap.insert(std::pair<std::string,CurveMapPoint>(key, value));
		}
		return resmap;
	}

	/** Setter:  */
	void points(std::map<std::string, CurveMapPoint> value) { /* not implemented */ }

	/**
	 * Evaluate curve at given location
	 * @param Position to evaluate curve at
	 * @return Value of curve at given location
	 */
	float evaluate(float position)
	{
		// not implemented
		throw NULL;
	}

};

/**************** CurveMapping ****************/

/**
 * Curve mapping to map color, vector and scalar values to other values using a user defined curve
 */
class CurveMapping : public pyUniplug {
public:
	CurveMapping(PyObject* pyobj) : pyUniplug(pyobj) {}

	CurveMapping() : pyUniplug(0)
	{
		// not implemented
	}

	/** Getter: Force the curve view to fit a defined boundary */
	bool use_clip() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_clip")) == 1;
	}

	/** Setter: Force the curve view to fit a defined boundary */
	void use_clip(bool value) {
		PyObject_SetAttrString(pyobjref, "use_clip", Py_BuildValue("i", value));
	}

	/** Getter:  */
	float clip_min_x() { /* not implemented */ throw NULL; }
	/** Setter:  */
	void clip_min_x(float value) {
		PyObject_SetAttrString(pyobjref, "clip_min_x", Py_BuildValue("f", value));
	}

	/** Getter:  */
	float clip_min_y() { /* not implemented */ throw NULL; }
	/** Setter:  */
	void clip_min_y(float value) {
		PyObject_SetAttrString(pyobjref, "clip_min_y", Py_BuildValue("f", value));
	}

	/** Getter:  */
	float clip_max_x() { /* not implemented */ throw NULL; }
	/** Setter:  */
	void clip_max_x(float value) {
		PyObject_SetAttrString(pyobjref, "clip_max_x", Py_BuildValue("f", value));
	}

	/** Getter:  */
	float clip_max_y() { /* not implemented */ throw NULL; }
	/** Setter:  */
	void clip_max_y(float value) {
		PyObject_SetAttrString(pyobjref, "clip_max_y", Py_BuildValue("f", value));
	}

	/** Getter:  */
	std::map<std::string, CurveMap> curves() {
		// TODO: MISSING DEREF! USE #DEFINE!
		PyObject *seqval = PyObject_GetAttrString(pyobjref, "curves");
		PyObject *seqkeys = PyObject_CallMethod(seqval, "keys", NULL);
		std::map<std::string, CurveMap> resmap;
		for (int i = 0; i < PySequence_Length(seqval); i++) {
			PyObject *keyobj = PySequence_GetItem(seqkeys, i);
			std::string key = PyBytes_AsString(PyUnicode_AsASCIIString(keyobj));
			CurveMap value = CurveMap(PySequence_GetItem(seqval, i));
			resmap.insert(std::pair<std::string,CurveMap>(key, value));
		}
		return resmap;
	}

	/** Setter:  */
	void curves(std::map<std::string, CurveMap> value) { /* not implemented */ }

	/** Getter: For RGB curves, the color that black is mapped to */
	std::array<float, 3> black_level() {
		// TODO: MISSING DEREF! USE #DEFINE!
		PyObject *seqval = PyObject_GetAttrString(pyobjref, "black_level");
		std::array<float, 3> resarr;
		for (int i = 0; i < 3; i++)
			resarr[i] = (float)PyFloat_AsDouble(PySequence_GetItem(seqval, i));
		return resarr;
	}

	/** Setter: For RGB curves, the color that black is mapped to */
	void black_level(float values[3]) { /* not implemented */ }

	/** Getter: For RGB curves, the color that white is mapped to */
	std::array<float, 3> white_level() {
		// TODO: MISSING DEREF! USE #DEFINE!
		PyObject *seqval = PyObject_GetAttrString(pyobjref, "white_level");
		std::array<float, 3> resarr;
		for (int i = 0; i < 3; i++)
			resarr[i] = (float)PyFloat_AsDouble(PySequence_GetItem(seqval, i));
		return resarr;
	}

	/** Setter: For RGB curves, the color that white is mapped to */
	void white_level(float values[3]) { /* not implemented */ }

	/**
	 * Update curve mapping after making changes
	 */
	void update()
	{
		// not implemented
	}

	/**
	 * Initialize curve
	 */
	void initialize()
	{
		// not implemented
	}

};

/**************** Color Ramp Element ****************/

/**
 * Element defining a color at a position in the color ramp
 */
class ColorRampElement : public pyUniplug {
public:
	ColorRampElement(PyObject* pyobj) : pyUniplug(pyobj) {}

	ColorRampElement() : pyUniplug(0)
	{
		// not implemented
	}

	/** Getter: Set color of selected color stop */
	std::array<float, 4> color() {
		// TODO: MISSING DEREF! USE #DEFINE!
		PyObject *seqval = PyObject_GetAttrString(pyobjref, "color");
		std::array<float, 4> resarr;
		for (int i = 0; i < 4; i++)
			resarr[i] = (float)PyFloat_AsDouble(PySequence_GetItem(seqval, i));
		return resarr;
	}

	/** Setter: Set color of selected color stop */
	void color(float values[4]) { /* not implemented */ }

	/** Getter: Set alpha of selected color stop */
	float alpha() { /* not implemented */ throw NULL; }
	/** Setter: Set alpha of selected color stop */
	void alpha(float value) {
		PyObject_SetAttrString(pyobjref, "alpha", Py_BuildValue("f", value));
	}

	/** Getter: Set position of selected color stop */
	float position() { /* not implemented */ throw NULL; }
	/** Setter: Set position of selected color stop */
	void position(float value) {
		PyObject_SetAttrString(pyobjref, "position", Py_BuildValue("f", value));
	}

};

/**************** Color Ramp ****************/

/**
 * Color ramp mapping a scalar value to a color
 */
class ColorRamp : public pyUniplug {
public:
	ColorRamp(PyObject* pyobj) : pyUniplug(pyobj) {}

	ColorRamp() : pyUniplug(0)
	{
		// not implemented
	}

	/** Getter:  */
	std::map<std::string, ColorRampElement> elements() {
		// TODO: MISSING DEREF! USE #DEFINE!
		PyObject *seqval = PyObject_GetAttrString(pyobjref, "elements");
		PyObject *seqkeys = PyObject_CallMethod(seqval, "keys", NULL);
		std::map<std::string, ColorRampElement> resmap;
		for (int i = 0; i < PySequence_Length(seqval); i++) {
			PyObject *keyobj = PySequence_GetItem(seqkeys, i);
			std::string key = PyBytes_AsString(PyUnicode_AsASCIIString(keyobj));
			ColorRampElement value = ColorRampElement(PySequence_GetItem(seqval, i));
			resmap.insert(std::pair<std::string,ColorRampElement>(key, value));
		}
		return resmap;
	}

	/** Setter:  */
	void elements(std::map<std::string, ColorRampElement> value) { /* not implemented */ }

	enum interpolation_enum {
		interpolation_EASE = 1,
		interpolation_CARDINAL = 3,
		interpolation_LINEAR = 0,
		interpolation_B_SPLINE = 2,
		interpolation_CONSTANT = 4,
	};

	/** Getter: Set interpolation between color stops */
	interpolation_enum interpolation() { /* not implemented */ throw NULL; }
	/** Setter: Set interpolation between color stops */
	void interpolation(interpolation_enum value) { /* not implemented */ }

	enum hue_interpolation_enum {
		hue_interpolation_NEAR = 0,
		hue_interpolation_FAR = 1,
		hue_interpolation_CW = 2,
		hue_interpolation_CCW = 3,
	};

	/** Getter: Set color interpolation */
	hue_interpolation_enum hue_interpolation() { /* not implemented */ throw NULL; }
	/** Setter: Set color interpolation */
	void hue_interpolation(hue_interpolation_enum value) { /* not implemented */ }

	enum color_mode_enum {
		color_mode_RGB = 0,
		color_mode_HSV = 1,
		color_mode_HSL = 2,
	};

	/** Getter: Set color mode to use for interpolation */
	color_mode_enum color_mode() { /* not implemented */ throw NULL; }
	/** Setter: Set color mode to use for interpolation */
	void color_mode(color_mode_enum value) { /* not implemented */ }

	/**
	 * Evaluate ColorRamp
	 * @param Evaluate ColorRamp at position
	 * @return Color at given position
	 */
	std::array<float, 4> evaluate(float position)
	{
		// not implemented
		throw NULL;
	}

};

/**************** Histogram ****************/

/**
 * Statistical view of the levels of color in an image
 */
class Histogram : public pyUniplug {
public:
	Histogram(PyObject* pyobj) : pyUniplug(pyobj) {}

	Histogram() : pyUniplug(0)
	{
		// not implemented
	}

	enum mode_enum {
		mode_LUMA = 0,
		mode_RGB = 1,
		mode_R = 2,
		mode_G = 3,
		mode_B = 4,
		mode_A = 5,
	};

	/** Getter: Channels to display when drawing the histogram */
	mode_enum mode() { /* not implemented */ throw NULL; }
	/** Setter: Channels to display when drawing the histogram */
	void mode(mode_enum value) { /* not implemented */ }

	/** Getter: Display lines rather than filled shapes */
	bool show_line() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "show_line")) == 1;
	}

	/** Setter: Display lines rather than filled shapes */
	void show_line(bool value) {
		PyObject_SetAttrString(pyobjref, "show_line", Py_BuildValue("i", value));
	}

};

/**************** Scopes ****************/

/**
 * Scopes for statistical view of an image
 */
class Scopes : public pyUniplug {
public:
	Scopes(PyObject* pyobj) : pyUniplug(pyobj) {}

	Scopes() : pyUniplug(0)
	{
		// not implemented
	}

	/** Getter: Sample every pixel of the image */
	bool use_full_resolution() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_full_resolution")) == 1;
	}

	/** Setter: Sample every pixel of the image */
	void use_full_resolution(bool value) {
		PyObject_SetAttrString(pyobjref, "use_full_resolution", Py_BuildValue("i", value));
	}

	/** Getter: Proportion of original image source pixel lines to sample */
	float accuracy() { /* not implemented */ throw NULL; }
	/** Setter: Proportion of original image source pixel lines to sample */
	void accuracy(float value) {
		PyObject_SetAttrString(pyobjref, "accuracy", Py_BuildValue("f", value));
	}

	/** Getter: Histogram for viewing image statistics */
	Histogram histogram() {
		/* not implemented */ throw NULL;
	}

	enum waveform_mode_enum {
		waveform_mode_LUMA = 0,
		waveform_mode_RGB = 1,
		waveform_mode_YCBCR601 = 2,
		waveform_mode_YCBCR709 = 3,
		waveform_mode_YCBCRJPG = 4,
	};

	/** Getter:  */
	waveform_mode_enum waveform_mode() { /* not implemented */ throw NULL; }
	/** Setter:  */
	void waveform_mode(waveform_mode_enum value) { /* not implemented */ }

	/** Getter: Opacity of the points */
	float waveform_alpha() { /* not implemented */ throw NULL; }
	/** Setter: Opacity of the points */
	void waveform_alpha(float value) {
		PyObject_SetAttrString(pyobjref, "waveform_alpha", Py_BuildValue("f", value));
	}

	/** Getter: Opacity of the points */
	float vectorscope_alpha() { /* not implemented */ throw NULL; }
	/** Setter: Opacity of the points */
	void vectorscope_alpha(float value) {
		PyObject_SetAttrString(pyobjref, "vectorscope_alpha", Py_BuildValue("f", value));
	}

};

/**************** ColorManagedDisplaySettings ****************/

/**
 * Color management specific to display device
 */
class ColorManagedDisplaySettings : public pyUniplug {
public:
	ColorManagedDisplaySettings(PyObject* pyobj) : pyUniplug(pyobj) {}

	ColorManagedDisplaySettings() : pyUniplug(0)
	{
		// not implemented
	}

	enum display_device_enum {
		display_device_DEFAULT = 0,
	};

	/** Getter: Display device name */
	display_device_enum display_device() { /* not implemented */ throw NULL; }
	/** Setter: Display device name */
	void display_device(display_device_enum value) { /* not implemented */ }

};

/**************** ColorManagedViewSettings ****************/

/**
 * Color management settings used for displaying images on the display
 */
class ColorManagedViewSettings : public pyUniplug {
public:
	ColorManagedViewSettings(PyObject* pyobj) : pyUniplug(pyobj) {}

	ColorManagedViewSettings() : pyUniplug(0)
	{
		// not implemented
	}

	enum look_enum {
		look_NONE = 0,
	};

	/** Getter: Additional transform applied before view transform for an artistic needs */
	look_enum look() { /* not implemented */ throw NULL; }
	/** Setter: Additional transform applied before view transform for an artistic needs */
	void look(look_enum value) { /* not implemented */ }

	enum view_transform_enum {
		view_transform_NONE = 0,
	};

	/** Getter: View used when converting image to a display space */
	view_transform_enum view_transform() { /* not implemented */ throw NULL; }
	/** Setter: View used when converting image to a display space */
	void view_transform(view_transform_enum value) { /* not implemented */ }

	/** Getter: Exposure (stops) applied before display transform */
	float exposure() { /* not implemented */ throw NULL; }
	/** Setter: Exposure (stops) applied before display transform */
	void exposure(float value) {
		PyObject_SetAttrString(pyobjref, "exposure", Py_BuildValue("f", value));
	}

	/** Getter: Amount of gamma modification applied after display transform */
	float gamma() { /* not implemented */ throw NULL; }
	/** Setter: Amount of gamma modification applied after display transform */
	void gamma(float value) {
		PyObject_SetAttrString(pyobjref, "gamma", Py_BuildValue("f", value));
	}

	/** Getter: Color curve mapping applied before display transform */
	CurveMapping curve_mapping() {
		/* not implemented */ throw NULL;
	}

	/** Getter: Use RGB curved for pre-display transformation */
	bool use_curve_mapping() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_curve_mapping")) == 1;
	}

	/** Setter: Use RGB curved for pre-display transformation */
	void use_curve_mapping(bool value) {
		PyObject_SetAttrString(pyobjref, "use_curve_mapping", Py_BuildValue("i", value));
	}

};

/**************** ColorManagedInputColorspaceSettings ****************/

/**
 * Input color space settings
 */
class ColorManagedInputColorspaceSettings : public pyUniplug {
public:
	ColorManagedInputColorspaceSettings(PyObject* pyobj) : pyUniplug(pyobj) {}

	ColorManagedInputColorspaceSettings() : pyUniplug(0)
	{
		// not implemented
	}

	enum name_enum {
		name_NONE = 0,
	};

	/** Getter: Color space of the image or movie on disk */
	name_enum name() { /* not implemented */ throw NULL; }
	/** Setter: Color space of the image or movie on disk */
	void name(name_enum value) { /* not implemented */ }

};

/**************** ColorManagedSequencerColorspaceSettings ****************/

/**
 * Input color space settings
 */
class ColorManagedSequencerColorspaceSettings : public pyUniplug {
public:
	ColorManagedSequencerColorspaceSettings(PyObject* pyobj) : pyUniplug(pyobj) {}

	ColorManagedSequencerColorspaceSettings() : pyUniplug(0)
	{
		// not implemented
	}

	enum name_enum {
		name_NONE = 0,
	};

	/** Getter: Color space that the sequencer operates in */
	name_enum name() { /* not implemented */ throw NULL; }
	/** Setter: Color space that the sequencer operates in */
	void name(name_enum value) { /* not implemented */ }

};

/**************** Constraint ****************/

/**
 * Constraint modifying the transformation of objects and bones
 */
class Constraint : public pyUniplug {
public:
	Constraint(PyObject* pyobj) : pyUniplug(pyobj) {}

	Constraint() : pyUniplug(0)
	{
		// not implemented
	}

	/** Getter: Constraint name */
	std::string name() { /* not implemented */ throw NULL; }
	/** Setter: Constraint name */
	void name(const std::string& value) { /* not implemented */ }

	enum type_enum {
		type_CAMERA_SOLVER = 27,
		type_FOLLOW_TRACK = 26,
		type_OBJECT_SOLVER = 28,
		type_COPY_LOCATION = 9,
		type_COPY_ROTATION = 8,
		type_COPY_SCALE = 10,
		type_COPY_TRANSFORMS = 23,
		type_LIMIT_DISTANCE = 14,
		type_LIMIT_LOCATION = 6,
		type_LIMIT_ROTATION = 5,
		type_LIMIT_SCALE = 7,
		type_MAINTAIN_VOLUME = 24,
		type_TRANSFORM = 19,
		type_CLAMP_TO = 18,
		type_DAMPED_TRACK = 21,
		type_IK = 3,
		type_LOCKED_TRACK = 13,
		type_SPLINE_IK = 22,
		type_STRETCH_TO = 15,
		type_TRACK_TO = 2,
		type_ACTION = 12,
		type_CHILD_OF = 1,
		type_FLOOR = 16,
		type_FOLLOW_PATH = 4,
		type_PIVOT = 25,
		type_RIGID_BODY_JOINT = 17,
		type_SHRINKWRAP = 20,
	};

	/** Getter:  */
	type_enum type() { /* not implemented */ throw NULL; }
	/** Setter:  */
	void type(type_enum value) { /* not implemented */ }

	enum owner_space_enum {
		owner_space_WORLD = 0,
		owner_space_POSE = 2,
		owner_space_LOCAL_WITH_PARENT = 3,
		owner_space_LOCAL = 1,
	};

	/** Getter: Space that owner is evaluated in */
	owner_space_enum owner_space() { /* not implemented */ throw NULL; }
	/** Setter: Space that owner is evaluated in */
	void owner_space(owner_space_enum value) { /* not implemented */ }

	enum target_space_enum {
		target_space_WORLD = 0,
		target_space_POSE = 2,
		target_space_LOCAL_WITH_PARENT = 3,
		target_space_LOCAL = 1,
	};

	/** Getter: Space that target is evaluated in */
	target_space_enum target_space() { /* not implemented */ throw NULL; }
	/** Setter: Space that target is evaluated in */
	void target_space(target_space_enum value) { /* not implemented */ }

	/** Getter: Enable/Disable Constraint */
	bool mute() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "mute")) == 1;
	}

	/** Setter: Enable/Disable Constraint */
	void mute(bool value) {
		PyObject_SetAttrString(pyobjref, "mute", Py_BuildValue("i", value));
	}

	/** Getter: Constraint's panel is expanded in UI */
	bool show_expanded() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "show_expanded")) == 1;
	}

	/** Setter: Constraint's panel is expanded in UI */
	void show_expanded(bool value) {
		PyObject_SetAttrString(pyobjref, "show_expanded", Py_BuildValue("i", value));
	}

	/** Getter: Constraint has valid settings and can be evaluated */
	bool is_valid() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "is_valid")) == 1;
	}

	/** Setter: Constraint has valid settings and can be evaluated */
	void is_valid(bool value) {
		PyObject_SetAttrString(pyobjref, "is_valid", Py_BuildValue("i", value));
	}

	/** Getter: Constraint is the one being edited  */
	bool active() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "active")) == 1;
	}

	/** Setter: Constraint is the one being edited  */
	void active(bool value) {
		PyObject_SetAttrString(pyobjref, "active", Py_BuildValue("i", value));
	}

	/** Getter: Constraint was added in this proxy instance (i.e. did not belong to source Armature) */
	bool is_proxy_local() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "is_proxy_local")) == 1;
	}

	/** Setter: Constraint was added in this proxy instance (i.e. did not belong to source Armature) */
	void is_proxy_local(bool value) {
		PyObject_SetAttrString(pyobjref, "is_proxy_local", Py_BuildValue("i", value));
	}

	/** Getter: Amount of influence constraint will have on the final solution */
	float influence() { /* not implemented */ throw NULL; }
	/** Setter: Amount of influence constraint will have on the final solution */
	void influence(float value) {
		PyObject_SetAttrString(pyobjref, "influence", Py_BuildValue("f", value));
	}

	/** Getter: Amount of residual error in Blender space unit for constraints that work on position */
	float error_location() { /* not implemented */ throw NULL; }
	/** Setter: Amount of residual error in Blender space unit for constraints that work on position */
	void error_location(float value) {
		PyObject_SetAttrString(pyobjref, "error_location", Py_BuildValue("f", value));
	}

	/** Getter: Amount of residual error in radians for constraints that work on orientation */
	float error_rotation() { /* not implemented */ throw NULL; }
	/** Setter: Amount of residual error in radians for constraints that work on orientation */
	void error_rotation(float value) {
		PyObject_SetAttrString(pyobjref, "error_rotation", Py_BuildValue("f", value));
	}

};

/**************** Constraint Target ****************/

/**
 * Target object for multi-target constraints
 */
class ConstraintTarget : public pyUniplug {
public:
	ConstraintTarget(PyObject* pyobj) : pyUniplug(pyobj) {}

	ConstraintTarget() : pyUniplug(0)
	{
		// not implemented
	}

	/** Getter: Target Object */
	Object target();

	/** Getter:  */
	std::string subtarget() { /* not implemented */ throw NULL; }
	/** Setter:  */
	void subtarget(const std::string& value) { /* not implemented */ }

};

/**************** Child Of Constraint ****************/

/**
 * Create constraint-based parent-child relationship
 */
class ChildOfConstraint : public Constraint {
public:
	ChildOfConstraint(PyObject* pyobj) : Constraint(pyobj) {}

	ChildOfConstraint() : Constraint(0)
	{
		// not implemented
	}

	/** Getter: Target Object */
	Object target();

	/** Getter:  */
	std::string subtarget() { /* not implemented */ throw NULL; }
	/** Setter:  */
	void subtarget(const std::string& value) { /* not implemented */ }

	/** Getter: Use X Location of Parent */
	bool use_location_x() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_location_x")) == 1;
	}

	/** Setter: Use X Location of Parent */
	void use_location_x(bool value) {
		PyObject_SetAttrString(pyobjref, "use_location_x", Py_BuildValue("i", value));
	}

	/** Getter: Use Y Location of Parent */
	bool use_location_y() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_location_y")) == 1;
	}

	/** Setter: Use Y Location of Parent */
	void use_location_y(bool value) {
		PyObject_SetAttrString(pyobjref, "use_location_y", Py_BuildValue("i", value));
	}

	/** Getter: Use Z Location of Parent */
	bool use_location_z() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_location_z")) == 1;
	}

	/** Setter: Use Z Location of Parent */
	void use_location_z(bool value) {
		PyObject_SetAttrString(pyobjref, "use_location_z", Py_BuildValue("i", value));
	}

	/** Getter: Use X Rotation of Parent */
	bool use_rotation_x() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_rotation_x")) == 1;
	}

	/** Setter: Use X Rotation of Parent */
	void use_rotation_x(bool value) {
		PyObject_SetAttrString(pyobjref, "use_rotation_x", Py_BuildValue("i", value));
	}

	/** Getter: Use Y Rotation of Parent */
	bool use_rotation_y() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_rotation_y")) == 1;
	}

	/** Setter: Use Y Rotation of Parent */
	void use_rotation_y(bool value) {
		PyObject_SetAttrString(pyobjref, "use_rotation_y", Py_BuildValue("i", value));
	}

	/** Getter: Use Z Rotation of Parent */
	bool use_rotation_z() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_rotation_z")) == 1;
	}

	/** Setter: Use Z Rotation of Parent */
	void use_rotation_z(bool value) {
		PyObject_SetAttrString(pyobjref, "use_rotation_z", Py_BuildValue("i", value));
	}

	/** Getter: Use X Scale of Parent */
	bool use_scale_x() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_scale_x")) == 1;
	}

	/** Setter: Use X Scale of Parent */
	void use_scale_x(bool value) {
		PyObject_SetAttrString(pyobjref, "use_scale_x", Py_BuildValue("i", value));
	}

	/** Getter: Use Y Scale of Parent */
	bool use_scale_y() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_scale_y")) == 1;
	}

	/** Setter: Use Y Scale of Parent */
	void use_scale_y(bool value) {
		PyObject_SetAttrString(pyobjref, "use_scale_y", Py_BuildValue("i", value));
	}

	/** Getter: Use Z Scale of Parent */
	bool use_scale_z() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_scale_z")) == 1;
	}

	/** Setter: Use Z Scale of Parent */
	void use_scale_z(bool value) {
		PyObject_SetAttrString(pyobjref, "use_scale_z", Py_BuildValue("i", value));
	}

	/** Getter: Transformation matrix to apply before */
	std::array<float, 16> inverse_matrix() {
		// TODO: MISSING DEREF! USE #DEFINE!
		PyObject *seqval = PyObject_GetAttrString(pyobjref, "inverse_matrix");
		std::array<float, 16> resarr;
		for (int i = 0; i < 16; i++)
			resarr[i] = (float)PyFloat_AsDouble(PySequence_GetItem(seqval, i));
		return resarr;
	}

	/** Setter: Transformation matrix to apply before */
	void inverse_matrix(float values[16]) { /* not implemented */ }

};

/**************** Python Constraint ****************/

/**
 * Use Python script for constraint evaluation
 */
class PythonConstraint : public Constraint {
public:
	PythonConstraint(PyObject* pyobj) : Constraint(pyobj) {}

	PythonConstraint() : Constraint(0)
	{
		// not implemented
	}

	/** Getter: Target Objects */
	std::map<std::string, ConstraintTarget> targets() {
		// TODO: MISSING DEREF! USE #DEFINE!
		PyObject *seqval = PyObject_GetAttrString(pyobjref, "targets");
		PyObject *seqkeys = PyObject_CallMethod(seqval, "keys", NULL);
		std::map<std::string, ConstraintTarget> resmap;
		for (int i = 0; i < PySequence_Length(seqval); i++) {
			PyObject *keyobj = PySequence_GetItem(seqkeys, i);
			std::string key = PyBytes_AsString(PyUnicode_AsASCIIString(keyobj));
			ConstraintTarget value = ConstraintTarget(PySequence_GetItem(seqval, i));
			resmap.insert(std::pair<std::string,ConstraintTarget>(key, value));
		}
		return resmap;
	}

	/** Setter: Target Objects */
	void targets(std::map<std::string, ConstraintTarget> value) { /* not implemented */ }

	/** Getter: Usually only 1-3 are needed */
	int target_count() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "target_count"));
	}

	/** Setter: Usually only 1-3 are needed */
	void target_count(int value) {
		PyObject_SetAttrString(pyobjref, "target_count", Py_BuildValue("i", value));
	}

	/** Getter: The text object that contains the Python script */
	Text text();

	/** Getter: Use the targets indicated in the constraint panel */
	bool use_targets() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_targets")) == 1;
	}

	/** Setter: Use the targets indicated in the constraint panel */
	void use_targets(bool value) {
		PyObject_SetAttrString(pyobjref, "use_targets", Py_BuildValue("i", value));
	}

	/** Getter: The linked Python script has thrown an error */
	bool has_script_error() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "has_script_error")) == 1;
	}

	/** Setter: The linked Python script has thrown an error */
	void has_script_error(bool value) {
		PyObject_SetAttrString(pyobjref, "has_script_error", Py_BuildValue("i", value));
	}

};

/**************** Stretch To Constraint ****************/

/**
 * Stretch to meet the target object
 */
class StretchToConstraint : public Constraint {
public:
	StretchToConstraint(PyObject* pyobj) : Constraint(pyobj) {}

	StretchToConstraint() : Constraint(0)
	{
		// not implemented
	}

	/** Getter: Target along length of bone: Head=0, Tail=1 */
	float head_tail() { /* not implemented */ throw NULL; }
	/** Setter: Target along length of bone: Head=0, Tail=1 */
	void head_tail(float value) {
		PyObject_SetAttrString(pyobjref, "head_tail", Py_BuildValue("f", value));
	}

	/** Getter: Target Object */
	Object target();

	/** Getter:  */
	std::string subtarget() { /* not implemented */ throw NULL; }
	/** Setter:  */
	void subtarget(const std::string& value) { /* not implemented */ }

	enum volume_enum {
		volume_VOLUME_XZX = 0,
		volume_VOLUME_X = 1,
		volume_VOLUME_Z = 2,
		volume_NO_VOLUME = 3,
	};

	/** Getter: Maintain the object's volume as it stretches */
	volume_enum volume() { /* not implemented */ throw NULL; }
	/** Setter: Maintain the object's volume as it stretches */
	void volume(volume_enum value) { /* not implemented */ }

	enum keep_axis_enum {
		keep_axis_PLANE_X = 0,
		keep_axis_PLANE_Z = 2,
	};

	/** Getter: Axis to maintain during stretch */
	keep_axis_enum keep_axis() { /* not implemented */ throw NULL; }
	/** Setter: Axis to maintain during stretch */
	void keep_axis(keep_axis_enum value) { /* not implemented */ }

	/** Getter: Length at rest position */
	float rest_length() { /* not implemented */ throw NULL; }
	/** Setter: Length at rest position */
	void rest_length(float value) {
		PyObject_SetAttrString(pyobjref, "rest_length", Py_BuildValue("f", value));
	}

	/** Getter: Factor between volume variation and stretching */
	float bulge() { /* not implemented */ throw NULL; }
	/** Setter: Factor between volume variation and stretching */
	void bulge(float value) {
		PyObject_SetAttrString(pyobjref, "bulge", Py_BuildValue("f", value));
	}

	/** Getter: Use lower limit for volume variation */
	bool use_bulge_min() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_bulge_min")) == 1;
	}

	/** Setter: Use lower limit for volume variation */
	void use_bulge_min(bool value) {
		PyObject_SetAttrString(pyobjref, "use_bulge_min", Py_BuildValue("i", value));
	}

	/** Getter: Use upper limit for volume variation */
	bool use_bulge_max() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_bulge_max")) == 1;
	}

	/** Setter: Use upper limit for volume variation */
	void use_bulge_max(bool value) {
		PyObject_SetAttrString(pyobjref, "use_bulge_max", Py_BuildValue("i", value));
	}

	/** Getter: Minimum volume stretching factor */
	float bulge_min() { /* not implemented */ throw NULL; }
	/** Setter: Minimum volume stretching factor */
	void bulge_min(float value) {
		PyObject_SetAttrString(pyobjref, "bulge_min", Py_BuildValue("f", value));
	}

	/** Getter: Maximum volume stretching factor */
	float bulge_max() { /* not implemented */ throw NULL; }
	/** Setter: Maximum volume stretching factor */
	void bulge_max(float value) {
		PyObject_SetAttrString(pyobjref, "bulge_max", Py_BuildValue("f", value));
	}

	/** Getter: Strength of volume stretching clamping */
	float bulge_smooth() { /* not implemented */ throw NULL; }
	/** Setter: Strength of volume stretching clamping */
	void bulge_smooth(float value) {
		PyObject_SetAttrString(pyobjref, "bulge_smooth", Py_BuildValue("f", value));
	}

};

/**************** Follow Path Constraint ****************/

/**
 * Lock motion to the target path
 */
class FollowPathConstraint : public Constraint {
public:
	FollowPathConstraint(PyObject* pyobj) : Constraint(pyobj) {}

	FollowPathConstraint() : Constraint(0)
	{
		// not implemented
	}

	/** Getter: Target Object */
	Object target();

	/** Getter: Offset from the position corresponding to the time frame */
	float offset() { /* not implemented */ throw NULL; }
	/** Setter: Offset from the position corresponding to the time frame */
	void offset(float value) {
		PyObject_SetAttrString(pyobjref, "offset", Py_BuildValue("f", value));
	}

	/** Getter: Percentage value defining target position along length of curve */
	float offset_factor() { /* not implemented */ throw NULL; }
	/** Setter: Percentage value defining target position along length of curve */
	void offset_factor(float value) {
		PyObject_SetAttrString(pyobjref, "offset_factor", Py_BuildValue("f", value));
	}

	enum forward_axis_enum {
		forward_axis_FORWARD_X = 0,
		forward_axis_FORWARD_Y = 1,
		forward_axis_FORWARD_Z = 2,
		forward_axis_TRACK_NEGATIVE_X = 3,
		forward_axis_TRACK_NEGATIVE_Y = 4,
		forward_axis_TRACK_NEGATIVE_Z = 5,
	};

	/** Getter: Axis that points forward along the path */
	forward_axis_enum forward_axis() { /* not implemented */ throw NULL; }
	/** Setter: Axis that points forward along the path */
	void forward_axis(forward_axis_enum value) { /* not implemented */ }

	enum up_axis_enum {
		up_axis_UP_X = 0,
		up_axis_UP_Y = 1,
		up_axis_UP_Z = 2,
	};

	/** Getter: Axis that points upward */
	up_axis_enum up_axis() { /* not implemented */ throw NULL; }
	/** Setter: Axis that points upward */
	void up_axis(up_axis_enum value) { /* not implemented */ }

	/** Getter: Object will follow the heading and banking of the curve */
	bool use_curve_follow() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_curve_follow")) == 1;
	}

	/** Setter: Object will follow the heading and banking of the curve */
	void use_curve_follow(bool value) {
		PyObject_SetAttrString(pyobjref, "use_curve_follow", Py_BuildValue("i", value));
	}

	/** Getter: Object will stay locked to a single point somewhere along the length of the curve regardless of time */
	bool use_fixed_location() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_fixed_location")) == 1;
	}

	/** Setter: Object will stay locked to a single point somewhere along the length of the curve regardless of time */
	void use_fixed_location(bool value) {
		PyObject_SetAttrString(pyobjref, "use_fixed_location", Py_BuildValue("i", value));
	}

	/** Getter: Object is scaled by the curve radius */
	bool use_curve_radius() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_curve_radius")) == 1;
	}

	/** Setter: Object is scaled by the curve radius */
	void use_curve_radius(bool value) {
		PyObject_SetAttrString(pyobjref, "use_curve_radius", Py_BuildValue("i", value));
	}

};

/**************** Locked Track Constraint ****************/

/**
 * Point toward the target along the track axis, while locking the other axis
 */
class LockedTrackConstraint : public Constraint {
public:
	LockedTrackConstraint(PyObject* pyobj) : Constraint(pyobj) {}

	LockedTrackConstraint() : Constraint(0)
	{
		// not implemented
	}

	/** Getter: Target along length of bone: Head=0, Tail=1 */
	float head_tail() { /* not implemented */ throw NULL; }
	/** Setter: Target along length of bone: Head=0, Tail=1 */
	void head_tail(float value) {
		PyObject_SetAttrString(pyobjref, "head_tail", Py_BuildValue("f", value));
	}

	/** Getter: Target Object */
	Object target();

	/** Getter:  */
	std::string subtarget() { /* not implemented */ throw NULL; }
	/** Setter:  */
	void subtarget(const std::string& value) { /* not implemented */ }

	enum track_axis_enum {
		track_axis_TRACK_X = 0,
		track_axis_TRACK_Y = 1,
		track_axis_TRACK_Z = 2,
		track_axis_TRACK_NEGATIVE_X = 3,
		track_axis_TRACK_NEGATIVE_Y = 4,
		track_axis_TRACK_NEGATIVE_Z = 5,
	};

	/** Getter: Axis that points to the target object */
	track_axis_enum track_axis() { /* not implemented */ throw NULL; }
	/** Setter: Axis that points to the target object */
	void track_axis(track_axis_enum value) { /* not implemented */ }

	enum lock_axis_enum {
		lock_axis_LOCK_X = 0,
		lock_axis_LOCK_Y = 1,
		lock_axis_LOCK_Z = 2,
	};

	/** Getter: Axis that points upward */
	lock_axis_enum lock_axis() { /* not implemented */ throw NULL; }
	/** Setter: Axis that points upward */
	void lock_axis(lock_axis_enum value) { /* not implemented */ }

};

/**************** Action Constraint ****************/

/**
 * Map an action to the transform axes of a bone
 */
class ActionConstraint : public Constraint {
public:
	ActionConstraint(PyObject* pyobj) : Constraint(pyobj) {}

	ActionConstraint() : Constraint(0)
	{
		// not implemented
	}

	/** Getter: Target Object */
	Object target();

	/** Getter:  */
	std::string subtarget() { /* not implemented */ throw NULL; }
	/** Setter:  */
	void subtarget(const std::string& value) { /* not implemented */ }

	enum transform_channel_enum {
		transform_channel_LOCATION_X = 20,
		transform_channel_LOCATION_Y = 21,
		transform_channel_LOCATION_Z = 22,
		transform_channel_ROTATION_X = 0,
		transform_channel_ROTATION_Y = 1,
		transform_channel_ROTATION_Z = 2,
		transform_channel_SCALE_X = 10,
		transform_channel_SCALE_Y = 11,
		transform_channel_SCALE_Z = 12,
	};

	/** Getter: Transformation channel from the target that is used to key the Action */
	transform_channel_enum transform_channel() { /* not implemented */ throw NULL; }
	/** Setter: Transformation channel from the target that is used to key the Action */
	void transform_channel(transform_channel_enum value) { /* not implemented */ }

	/** Getter: The constraining action */
	Action action() {
		/* not implemented */ throw NULL;
	}

	/** Getter: Bones only: apply the object's transformation channels of the action to the constrained bone, instead of bone's channels */
	bool use_bone_object_action() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_bone_object_action")) == 1;
	}

	/** Setter: Bones only: apply the object's transformation channels of the action to the constrained bone, instead of bone's channels */
	void use_bone_object_action(bool value) {
		PyObject_SetAttrString(pyobjref, "use_bone_object_action", Py_BuildValue("i", value));
	}

	/** Getter: First frame of the Action to use */
	int frame_start() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "frame_start"));
	}

	/** Setter: First frame of the Action to use */
	void frame_start(int value) {
		PyObject_SetAttrString(pyobjref, "frame_start", Py_BuildValue("i", value));
	}

	/** Getter: Last frame of the Action to use */
	int frame_end() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "frame_end"));
	}

	/** Setter: Last frame of the Action to use */
	void frame_end(int value) {
		PyObject_SetAttrString(pyobjref, "frame_end", Py_BuildValue("i", value));
	}

	/** Getter: Maximum value for target channel range */
	float max() { /* not implemented */ throw NULL; }
	/** Setter: Maximum value for target channel range */
	void max(float value) {
		PyObject_SetAttrString(pyobjref, "max", Py_BuildValue("f", value));
	}

	/** Getter: Minimum value for target channel range */
	float min() { /* not implemented */ throw NULL; }
	/** Setter: Minimum value for target channel range */
	void min(float value) {
		PyObject_SetAttrString(pyobjref, "min", Py_BuildValue("f", value));
	}

};

/**************** Copy Scale Constraint ****************/

/**
 * Copy the scale of the target
 */
class CopyScaleConstraint : public Constraint {
public:
	CopyScaleConstraint(PyObject* pyobj) : Constraint(pyobj) {}

	CopyScaleConstraint() : Constraint(0)
	{
		// not implemented
	}

	/** Getter: Target Object */
	Object target();

	/** Getter:  */
	std::string subtarget() { /* not implemented */ throw NULL; }
	/** Setter:  */
	void subtarget(const std::string& value) { /* not implemented */ }

	/** Getter: Copy the target's X scale */
	bool use_x() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_x")) == 1;
	}

	/** Setter: Copy the target's X scale */
	void use_x(bool value) {
		PyObject_SetAttrString(pyobjref, "use_x", Py_BuildValue("i", value));
	}

	/** Getter: Copy the target's Y scale */
	bool use_y() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_y")) == 1;
	}

	/** Setter: Copy the target's Y scale */
	void use_y(bool value) {
		PyObject_SetAttrString(pyobjref, "use_y", Py_BuildValue("i", value));
	}

	/** Getter: Copy the target's Z scale */
	bool use_z() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_z")) == 1;
	}

	/** Setter: Copy the target's Z scale */
	void use_z(bool value) {
		PyObject_SetAttrString(pyobjref, "use_z", Py_BuildValue("i", value));
	}

	/** Getter: Add original scale into copied scale */
	bool use_offset() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_offset")) == 1;
	}

	/** Setter: Add original scale into copied scale */
	void use_offset(bool value) {
		PyObject_SetAttrString(pyobjref, "use_offset", Py_BuildValue("i", value));
	}

};

/**************** Maintain Volume Constraint ****************/

/**
 * Maintain a constant volume along a single scaling axis
 */
class MaintainVolumeConstraint : public Constraint {
public:
	MaintainVolumeConstraint(PyObject* pyobj) : Constraint(pyobj) {}

	MaintainVolumeConstraint() : Constraint(0)
	{
		// not implemented
	}

	enum free_axis_enum {
		free_axis_SAMEVOL_X = 0,
		free_axis_SAMEVOL_Y = 1,
		free_axis_SAMEVOL_Z = 2,
	};

	/** Getter: The free scaling axis of the object */
	free_axis_enum free_axis() { /* not implemented */ throw NULL; }
	/** Setter: The free scaling axis of the object */
	void free_axis(free_axis_enum value) { /* not implemented */ }

	/** Getter: Volume of the bone at rest */
	float volume() { /* not implemented */ throw NULL; }
	/** Setter: Volume of the bone at rest */
	void volume(float value) {
		PyObject_SetAttrString(pyobjref, "volume", Py_BuildValue("f", value));
	}

};

/**************** Copy Location Constraint ****************/

/**
 * Copy the location of the target
 */
class CopyLocationConstraint : public Constraint {
public:
	CopyLocationConstraint(PyObject* pyobj) : Constraint(pyobj) {}

	CopyLocationConstraint() : Constraint(0)
	{
		// not implemented
	}

	/** Getter: Target along length of bone: Head=0, Tail=1 */
	float head_tail() { /* not implemented */ throw NULL; }
	/** Setter: Target along length of bone: Head=0, Tail=1 */
	void head_tail(float value) {
		PyObject_SetAttrString(pyobjref, "head_tail", Py_BuildValue("f", value));
	}

	/** Getter: Target Object */
	Object target();

	/** Getter:  */
	std::string subtarget() { /* not implemented */ throw NULL; }
	/** Setter:  */
	void subtarget(const std::string& value) { /* not implemented */ }

	/** Getter: Copy the target's X location */
	bool use_x() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_x")) == 1;
	}

	/** Setter: Copy the target's X location */
	void use_x(bool value) {
		PyObject_SetAttrString(pyobjref, "use_x", Py_BuildValue("i", value));
	}

	/** Getter: Copy the target's Y location */
	bool use_y() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_y")) == 1;
	}

	/** Setter: Copy the target's Y location */
	void use_y(bool value) {
		PyObject_SetAttrString(pyobjref, "use_y", Py_BuildValue("i", value));
	}

	/** Getter: Copy the target's Z location */
	bool use_z() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_z")) == 1;
	}

	/** Setter: Copy the target's Z location */
	void use_z(bool value) {
		PyObject_SetAttrString(pyobjref, "use_z", Py_BuildValue("i", value));
	}

	/** Getter: Invert the X location */
	bool invert_x() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "invert_x")) == 1;
	}

	/** Setter: Invert the X location */
	void invert_x(bool value) {
		PyObject_SetAttrString(pyobjref, "invert_x", Py_BuildValue("i", value));
	}

	/** Getter: Invert the Y location */
	bool invert_y() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "invert_y")) == 1;
	}

	/** Setter: Invert the Y location */
	void invert_y(bool value) {
		PyObject_SetAttrString(pyobjref, "invert_y", Py_BuildValue("i", value));
	}

	/** Getter: Invert the Z location */
	bool invert_z() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "invert_z")) == 1;
	}

	/** Setter: Invert the Z location */
	void invert_z(bool value) {
		PyObject_SetAttrString(pyobjref, "invert_z", Py_BuildValue("i", value));
	}

	/** Getter: Add original location into copied location */
	bool use_offset() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_offset")) == 1;
	}

	/** Setter: Add original location into copied location */
	void use_offset(bool value) {
		PyObject_SetAttrString(pyobjref, "use_offset", Py_BuildValue("i", value));
	}

};

/**************** Copy Rotation Constraint ****************/

/**
 * Copy the rotation of the target
 */
class CopyRotationConstraint : public Constraint {
public:
	CopyRotationConstraint(PyObject* pyobj) : Constraint(pyobj) {}

	CopyRotationConstraint() : Constraint(0)
	{
		// not implemented
	}

	/** Getter: Target Object */
	Object target();

	/** Getter:  */
	std::string subtarget() { /* not implemented */ throw NULL; }
	/** Setter:  */
	void subtarget(const std::string& value) { /* not implemented */ }

	/** Getter: Copy the target's X rotation */
	bool use_x() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_x")) == 1;
	}

	/** Setter: Copy the target's X rotation */
	void use_x(bool value) {
		PyObject_SetAttrString(pyobjref, "use_x", Py_BuildValue("i", value));
	}

	/** Getter: Copy the target's Y rotation */
	bool use_y() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_y")) == 1;
	}

	/** Setter: Copy the target's Y rotation */
	void use_y(bool value) {
		PyObject_SetAttrString(pyobjref, "use_y", Py_BuildValue("i", value));
	}

	/** Getter: Copy the target's Z rotation */
	bool use_z() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_z")) == 1;
	}

	/** Setter: Copy the target's Z rotation */
	void use_z(bool value) {
		PyObject_SetAttrString(pyobjref, "use_z", Py_BuildValue("i", value));
	}

	/** Getter: Invert the X rotation */
	bool invert_x() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "invert_x")) == 1;
	}

	/** Setter: Invert the X rotation */
	void invert_x(bool value) {
		PyObject_SetAttrString(pyobjref, "invert_x", Py_BuildValue("i", value));
	}

	/** Getter: Invert the Y rotation */
	bool invert_y() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "invert_y")) == 1;
	}

	/** Setter: Invert the Y rotation */
	void invert_y(bool value) {
		PyObject_SetAttrString(pyobjref, "invert_y", Py_BuildValue("i", value));
	}

	/** Getter: Invert the Z rotation */
	bool invert_z() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "invert_z")) == 1;
	}

	/** Setter: Invert the Z rotation */
	void invert_z(bool value) {
		PyObject_SetAttrString(pyobjref, "invert_z", Py_BuildValue("i", value));
	}

	/** Getter: Add original rotation into copied rotation */
	bool use_offset() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_offset")) == 1;
	}

	/** Setter: Add original rotation into copied rotation */
	void use_offset(bool value) {
		PyObject_SetAttrString(pyobjref, "use_offset", Py_BuildValue("i", value));
	}

};

/**************** Copy Transforms Constraint ****************/

/**
 * Copy all the transforms of the target
 */
class CopyTransformsConstraint : public Constraint {
public:
	CopyTransformsConstraint(PyObject* pyobj) : Constraint(pyobj) {}

	CopyTransformsConstraint() : Constraint(0)
	{
		// not implemented
	}

	/** Getter: Target along length of bone: Head=0, Tail=1 */
	float head_tail() { /* not implemented */ throw NULL; }
	/** Setter: Target along length of bone: Head=0, Tail=1 */
	void head_tail(float value) {
		PyObject_SetAttrString(pyobjref, "head_tail", Py_BuildValue("f", value));
	}

	/** Getter: Target Object */
	Object target();

	/** Getter:  */
	std::string subtarget() { /* not implemented */ throw NULL; }
	/** Setter:  */
	void subtarget(const std::string& value) { /* not implemented */ }

};

/**************** Floor Constraint ****************/

/**
 * Use the target object for location limitation
 */
class FloorConstraint : public Constraint {
public:
	FloorConstraint(PyObject* pyobj) : Constraint(pyobj) {}

	FloorConstraint() : Constraint(0)
	{
		// not implemented
	}

	/** Getter: Target Object */
	Object target();

	/** Getter:  */
	std::string subtarget() { /* not implemented */ throw NULL; }
	/** Setter:  */
	void subtarget(const std::string& value) { /* not implemented */ }

	enum floor_location_enum {
		floor_location_FLOOR_X = 0,
		floor_location_FLOOR_Y = 1,
		floor_location_FLOOR_Z = 2,
		floor_location_FLOOR_NEGATIVE_X = 3,
		floor_location_FLOOR_NEGATIVE_Y = 4,
		floor_location_FLOOR_NEGATIVE_Z = 5,
	};

	/** Getter: Location of target that object will not pass through */
	floor_location_enum floor_location() { /* not implemented */ throw NULL; }
	/** Setter: Location of target that object will not pass through */
	void floor_location(floor_location_enum value) { /* not implemented */ }

	/** Getter: Immobilize object while constrained */
	bool use_sticky() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_sticky")) == 1;
	}

	/** Setter: Immobilize object while constrained */
	void use_sticky(bool value) {
		PyObject_SetAttrString(pyobjref, "use_sticky", Py_BuildValue("i", value));
	}

	/** Getter: Use the target's rotation to determine floor */
	bool use_rotation() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_rotation")) == 1;
	}

	/** Setter: Use the target's rotation to determine floor */
	void use_rotation(bool value) {
		PyObject_SetAttrString(pyobjref, "use_rotation", Py_BuildValue("i", value));
	}

	/** Getter: Offset of floor from object origin */
	float offset() { /* not implemented */ throw NULL; }
	/** Setter: Offset of floor from object origin */
	void offset(float value) {
		PyObject_SetAttrString(pyobjref, "offset", Py_BuildValue("f", value));
	}

};

/**************** Track To Constraint ****************/

/**
 * Aim the constrained object toward the target
 */
class TrackToConstraint : public Constraint {
public:
	TrackToConstraint(PyObject* pyobj) : Constraint(pyobj) {}

	TrackToConstraint() : Constraint(0)
	{
		// not implemented
	}

	/** Getter: Target along length of bone: Head=0, Tail=1 */
	float head_tail() { /* not implemented */ throw NULL; }
	/** Setter: Target along length of bone: Head=0, Tail=1 */
	void head_tail(float value) {
		PyObject_SetAttrString(pyobjref, "head_tail", Py_BuildValue("f", value));
	}

	/** Getter: Target Object */
	Object target();

	/** Getter:  */
	std::string subtarget() { /* not implemented */ throw NULL; }
	/** Setter:  */
	void subtarget(const std::string& value) { /* not implemented */ }

	enum track_axis_enum {
		track_axis_TRACK_X = 0,
		track_axis_TRACK_Y = 1,
		track_axis_TRACK_Z = 2,
		track_axis_TRACK_NEGATIVE_X = 3,
		track_axis_TRACK_NEGATIVE_Y = 4,
		track_axis_TRACK_NEGATIVE_Z = 5,
	};

	/** Getter: Axis that points to the target object */
	track_axis_enum track_axis() { /* not implemented */ throw NULL; }
	/** Setter: Axis that points to the target object */
	void track_axis(track_axis_enum value) { /* not implemented */ }

	enum up_axis_enum {
		up_axis_UP_X = 0,
		up_axis_UP_Y = 1,
		up_axis_UP_Z = 2,
	};

	/** Getter: Axis that points upward */
	up_axis_enum up_axis() { /* not implemented */ throw NULL; }
	/** Setter: Axis that points upward */
	void up_axis(up_axis_enum value) { /* not implemented */ }

	/** Getter: Target's Z axis, not World Z axis, will constraint the Up direction */
	bool use_target_z() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_target_z")) == 1;
	}

	/** Setter: Target's Z axis, not World Z axis, will constraint the Up direction */
	void use_target_z(bool value) {
		PyObject_SetAttrString(pyobjref, "use_target_z", Py_BuildValue("i", value));
	}

};

/**************** Kinematic Constraint ****************/

/**
 * Inverse Kinematics
 */
class KinematicConstraint : public Constraint {
public:
	KinematicConstraint(PyObject* pyobj) : Constraint(pyobj) {}

	KinematicConstraint() : Constraint(0)
	{
		// not implemented
	}

	/** Getter: Target Object */
	Object target();

	/** Getter:  */
	std::string subtarget() { /* not implemented */ throw NULL; }
	/** Setter:  */
	void subtarget(const std::string& value) { /* not implemented */ }

	/** Getter: Maximum number of solving iterations */
	int iterations() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "iterations"));
	}

	/** Setter: Maximum number of solving iterations */
	void iterations(int value) {
		PyObject_SetAttrString(pyobjref, "iterations", Py_BuildValue("i", value));
	}

	/** Getter: Object for pole rotation */
	Object pole_target();

	/** Getter:  */
	std::string pole_subtarget() { /* not implemented */ throw NULL; }
	/** Setter:  */
	void pole_subtarget(const std::string& value) { /* not implemented */ }

	/** Getter: Pole rotation offset */
	float pole_angle() { /* not implemented */ throw NULL; }
	/** Setter: Pole rotation offset */
	void pole_angle(float value) {
		PyObject_SetAttrString(pyobjref, "pole_angle", Py_BuildValue("f", value));
	}

	/** Getter: For Tree-IK: Weight of position control for this target */
	float weight() { /* not implemented */ throw NULL; }
	/** Setter: For Tree-IK: Weight of position control for this target */
	void weight(float value) {
		PyObject_SetAttrString(pyobjref, "weight", Py_BuildValue("f", value));
	}

	/** Getter: For Tree-IK: Weight of orientation control for this target */
	float orient_weight() { /* not implemented */ throw NULL; }
	/** Setter: For Tree-IK: Weight of orientation control for this target */
	void orient_weight(float value) {
		PyObject_SetAttrString(pyobjref, "orient_weight", Py_BuildValue("f", value));
	}

	/** Getter: How many bones are included in the IK effect - 0 uses all bones */
	int chain_count() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "chain_count"));
	}

	/** Setter: How many bones are included in the IK effect - 0 uses all bones */
	void chain_count(int value) {
		PyObject_SetAttrString(pyobjref, "chain_count", Py_BuildValue("i", value));
	}

	/** Getter: Include bone's tail as last element in chain */
	bool use_tail() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_tail")) == 1;
	}

	/** Setter: Include bone's tail as last element in chain */
	void use_tail(bool value) {
		PyObject_SetAttrString(pyobjref, "use_tail", Py_BuildValue("i", value));
	}

	enum reference_axis_enum {
		reference_axis_BONE = 0,
		reference_axis_TARGET = 16384,
	};

	/** Getter: Constraint axis Lock options relative to Bone or Target reference */
	reference_axis_enum reference_axis() { /* not implemented */ throw NULL; }
	/** Setter: Constraint axis Lock options relative to Bone or Target reference */
	void reference_axis(reference_axis_enum value) { /* not implemented */ }

	/** Getter: Chain follows position of target */
	bool use_location() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_location")) == 1;
	}

	/** Setter: Chain follows position of target */
	void use_location(bool value) {
		PyObject_SetAttrString(pyobjref, "use_location", Py_BuildValue("i", value));
	}

	/** Getter: Constraint position along X axis */
	bool lock_location_x() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "lock_location_x")) == 1;
	}

	/** Setter: Constraint position along X axis */
	void lock_location_x(bool value) {
		PyObject_SetAttrString(pyobjref, "lock_location_x", Py_BuildValue("i", value));
	}

	/** Getter: Constraint position along Y axis */
	bool lock_location_y() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "lock_location_y")) == 1;
	}

	/** Setter: Constraint position along Y axis */
	void lock_location_y(bool value) {
		PyObject_SetAttrString(pyobjref, "lock_location_y", Py_BuildValue("i", value));
	}

	/** Getter: Constraint position along Z axis */
	bool lock_location_z() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "lock_location_z")) == 1;
	}

	/** Setter: Constraint position along Z axis */
	void lock_location_z(bool value) {
		PyObject_SetAttrString(pyobjref, "lock_location_z", Py_BuildValue("i", value));
	}

	/** Getter: Chain follows rotation of target */
	bool use_rotation() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_rotation")) == 1;
	}

	/** Setter: Chain follows rotation of target */
	void use_rotation(bool value) {
		PyObject_SetAttrString(pyobjref, "use_rotation", Py_BuildValue("i", value));
	}

	/** Getter: Constraint rotation along X axis */
	bool lock_rotation_x() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "lock_rotation_x")) == 1;
	}

	/** Setter: Constraint rotation along X axis */
	void lock_rotation_x(bool value) {
		PyObject_SetAttrString(pyobjref, "lock_rotation_x", Py_BuildValue("i", value));
	}

	/** Getter: Constraint rotation along Y axis */
	bool lock_rotation_y() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "lock_rotation_y")) == 1;
	}

	/** Setter: Constraint rotation along Y axis */
	void lock_rotation_y(bool value) {
		PyObject_SetAttrString(pyobjref, "lock_rotation_y", Py_BuildValue("i", value));
	}

	/** Getter: Constraint rotation along Z axis */
	bool lock_rotation_z() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "lock_rotation_z")) == 1;
	}

	/** Setter: Constraint rotation along Z axis */
	void lock_rotation_z(bool value) {
		PyObject_SetAttrString(pyobjref, "lock_rotation_z", Py_BuildValue("i", value));
	}

	/** Getter: Enable IK Stretching */
	bool use_stretch() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_stretch")) == 1;
	}

	/** Setter: Enable IK Stretching */
	void use_stretch(bool value) {
		PyObject_SetAttrString(pyobjref, "use_stretch", Py_BuildValue("i", value));
	}

	enum ik_type_enum {
		ik_type_COPY_POSE = 0,
		ik_type_DISTANCE = 1,
	};

	/** Getter:  */
	ik_type_enum ik_type() { /* not implemented */ throw NULL; }
	/** Setter:  */
	void ik_type(ik_type_enum value) { /* not implemented */ }

	enum limit_mode_enum {
		limit_mode_LIMITDIST_INSIDE = 0,
		limit_mode_LIMITDIST_OUTSIDE = 1,
		limit_mode_LIMITDIST_ONSURFACE = 2,
	};

	/** Getter: Distances in relation to sphere of influence to allow */
	limit_mode_enum limit_mode() { /* not implemented */ throw NULL; }
	/** Setter: Distances in relation to sphere of influence to allow */
	void limit_mode(limit_mode_enum value) { /* not implemented */ }

	/** Getter: Radius of limiting sphere */
	float distance() { /* not implemented */ throw NULL; }
	/** Setter: Radius of limiting sphere */
	void distance(float value) {
		PyObject_SetAttrString(pyobjref, "distance", Py_BuildValue("f", value));
	}

};

/**************** Rigid Body Joint Constraint ****************/

/**
 * For use with the Game Engine
 */
class RigidBodyJointConstraint : public Constraint {
public:
	RigidBodyJointConstraint(PyObject* pyobj) : Constraint(pyobj) {}

	RigidBodyJointConstraint() : Constraint(0)
	{
		// not implemented
	}

	/** Getter: Target Object */
	Object target();

	/** Getter: Child object */
	Object child();

	enum pivot_type_enum {
		pivot_type_BALL = 1,
		pivot_type_HINGE = 2,
		pivot_type_CONE_TWIST = 4,
		pivot_type_GENERIC_6_DOF = 12,
	};

	/** Getter:  */
	pivot_type_enum pivot_type() { /* not implemented */ throw NULL; }
	/** Setter:  */
	void pivot_type(pivot_type_enum value) { /* not implemented */ }

	/** Getter: Offset pivot on X */
	float pivot_x() { /* not implemented */ throw NULL; }
	/** Setter: Offset pivot on X */
	void pivot_x(float value) {
		PyObject_SetAttrString(pyobjref, "pivot_x", Py_BuildValue("f", value));
	}

	/** Getter: Offset pivot on Y */
	float pivot_y() { /* not implemented */ throw NULL; }
	/** Setter: Offset pivot on Y */
	void pivot_y(float value) {
		PyObject_SetAttrString(pyobjref, "pivot_y", Py_BuildValue("f", value));
	}

	/** Getter: Offset pivot on Z */
	float pivot_z() { /* not implemented */ throw NULL; }
	/** Setter: Offset pivot on Z */
	void pivot_z(float value) {
		PyObject_SetAttrString(pyobjref, "pivot_z", Py_BuildValue("f", value));
	}

	/** Getter: Rotate pivot on X axis */
	float axis_x() { /* not implemented */ throw NULL; }
	/** Setter: Rotate pivot on X axis */
	void axis_x(float value) {
		PyObject_SetAttrString(pyobjref, "axis_x", Py_BuildValue("f", value));
	}

	/** Getter: Rotate pivot on Y axis */
	float axis_y() { /* not implemented */ throw NULL; }
	/** Setter: Rotate pivot on Y axis */
	void axis_y(float value) {
		PyObject_SetAttrString(pyobjref, "axis_y", Py_BuildValue("f", value));
	}

	/** Getter: Rotate pivot on Z axis */
	float axis_z() { /* not implemented */ throw NULL; }
	/** Setter: Rotate pivot on Z axis */
	void axis_z(float value) {
		PyObject_SetAttrString(pyobjref, "axis_z", Py_BuildValue("f", value));
	}

	/** Getter: Disable collision between linked bodies */
	bool use_linked_collision() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_linked_collision")) == 1;
	}

	/** Setter: Disable collision between linked bodies */
	void use_linked_collision(bool value) {
		PyObject_SetAttrString(pyobjref, "use_linked_collision", Py_BuildValue("i", value));
	}

	/** Getter: Display the pivot point and rotation in 3D view */
	bool show_pivot() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "show_pivot")) == 1;
	}

	/** Setter: Display the pivot point and rotation in 3D view */
	void show_pivot(bool value) {
		PyObject_SetAttrString(pyobjref, "show_pivot", Py_BuildValue("i", value));
	}

	/** Getter:  */
	float limit_min_x() { /* not implemented */ throw NULL; }
	/** Setter:  */
	void limit_min_x(float value) {
		PyObject_SetAttrString(pyobjref, "limit_min_x", Py_BuildValue("f", value));
	}

	/** Getter:  */
	float limit_min_y() { /* not implemented */ throw NULL; }
	/** Setter:  */
	void limit_min_y(float value) {
		PyObject_SetAttrString(pyobjref, "limit_min_y", Py_BuildValue("f", value));
	}

	/** Getter:  */
	float limit_min_z() { /* not implemented */ throw NULL; }
	/** Setter:  */
	void limit_min_z(float value) {
		PyObject_SetAttrString(pyobjref, "limit_min_z", Py_BuildValue("f", value));
	}

	/** Getter:  */
	float limit_max_x() { /* not implemented */ throw NULL; }
	/** Setter:  */
	void limit_max_x(float value) {
		PyObject_SetAttrString(pyobjref, "limit_max_x", Py_BuildValue("f", value));
	}

	/** Getter:  */
	float limit_max_y() { /* not implemented */ throw NULL; }
	/** Setter:  */
	void limit_max_y(float value) {
		PyObject_SetAttrString(pyobjref, "limit_max_y", Py_BuildValue("f", value));
	}

	/** Getter:  */
	float limit_max_z() { /* not implemented */ throw NULL; }
	/** Setter:  */
	void limit_max_z(float value) {
		PyObject_SetAttrString(pyobjref, "limit_max_z", Py_BuildValue("f", value));
	}

	/** Getter:  */
	float limit_angle_min_x() { /* not implemented */ throw NULL; }
	/** Setter:  */
	void limit_angle_min_x(float value) {
		PyObject_SetAttrString(pyobjref, "limit_angle_min_x", Py_BuildValue("f", value));
	}

	/** Getter:  */
	float limit_angle_min_y() { /* not implemented */ throw NULL; }
	/** Setter:  */
	void limit_angle_min_y(float value) {
		PyObject_SetAttrString(pyobjref, "limit_angle_min_y", Py_BuildValue("f", value));
	}

	/** Getter:  */
	float limit_angle_min_z() { /* not implemented */ throw NULL; }
	/** Setter:  */
	void limit_angle_min_z(float value) {
		PyObject_SetAttrString(pyobjref, "limit_angle_min_z", Py_BuildValue("f", value));
	}

	/** Getter:  */
	float limit_angle_max_x() { /* not implemented */ throw NULL; }
	/** Setter:  */
	void limit_angle_max_x(float value) {
		PyObject_SetAttrString(pyobjref, "limit_angle_max_x", Py_BuildValue("f", value));
	}

	/** Getter:  */
	float limit_angle_max_y() { /* not implemented */ throw NULL; }
	/** Setter:  */
	void limit_angle_max_y(float value) {
		PyObject_SetAttrString(pyobjref, "limit_angle_max_y", Py_BuildValue("f", value));
	}

	/** Getter:  */
	float limit_angle_max_z() { /* not implemented */ throw NULL; }
	/** Setter:  */
	void limit_angle_max_z(float value) {
		PyObject_SetAttrString(pyobjref, "limit_angle_max_z", Py_BuildValue("f", value));
	}

	/** Getter: Use minimum/maximum X limit */
	bool use_limit_x() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_limit_x")) == 1;
	}

	/** Setter: Use minimum/maximum X limit */
	void use_limit_x(bool value) {
		PyObject_SetAttrString(pyobjref, "use_limit_x", Py_BuildValue("i", value));
	}

	/** Getter: Use minimum/maximum y limit */
	bool use_limit_y() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_limit_y")) == 1;
	}

	/** Setter: Use minimum/maximum y limit */
	void use_limit_y(bool value) {
		PyObject_SetAttrString(pyobjref, "use_limit_y", Py_BuildValue("i", value));
	}

	/** Getter: Use minimum/maximum z limit */
	bool use_limit_z() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_limit_z")) == 1;
	}

	/** Setter: Use minimum/maximum z limit */
	void use_limit_z(bool value) {
		PyObject_SetAttrString(pyobjref, "use_limit_z", Py_BuildValue("i", value));
	}

	/** Getter: Use minimum/maximum X angular limit */
	bool use_angular_limit_x() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_angular_limit_x")) == 1;
	}

	/** Setter: Use minimum/maximum X angular limit */
	void use_angular_limit_x(bool value) {
		PyObject_SetAttrString(pyobjref, "use_angular_limit_x", Py_BuildValue("i", value));
	}

	/** Getter: Use minimum/maximum Y angular limit */
	bool use_angular_limit_y() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_angular_limit_y")) == 1;
	}

	/** Setter: Use minimum/maximum Y angular limit */
	void use_angular_limit_y(bool value) {
		PyObject_SetAttrString(pyobjref, "use_angular_limit_y", Py_BuildValue("i", value));
	}

	/** Getter: Use minimum/maximum Z angular limit */
	bool use_angular_limit_z() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_angular_limit_z")) == 1;
	}

	/** Setter: Use minimum/maximum Z angular limit */
	void use_angular_limit_z(bool value) {
		PyObject_SetAttrString(pyobjref, "use_angular_limit_z", Py_BuildValue("i", value));
	}

};

/**************** Clamp To Constraint ****************/

/**
 * Constrain an object's location to the nearest point along the target path
 */
class ClampToConstraint : public Constraint {
public:
	ClampToConstraint(PyObject* pyobj) : Constraint(pyobj) {}

	ClampToConstraint() : Constraint(0)
	{
		// not implemented
	}

	/** Getter: Target Object (Curves only) */
	Object target();

	enum main_axis_enum {
		main_axis_CLAMPTO_AUTO = 0,
		main_axis_CLAMPTO_X = 1,
		main_axis_CLAMPTO_Y = 2,
		main_axis_CLAMPTO_Z = 3,
	};

	/** Getter: Main axis of movement */
	main_axis_enum main_axis() { /* not implemented */ throw NULL; }
	/** Setter: Main axis of movement */
	void main_axis(main_axis_enum value) { /* not implemented */ }

	/** Getter: Treat curve as cyclic curve (no clamping to curve bounding box) */
	bool use_cyclic() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_cyclic")) == 1;
	}

	/** Setter: Treat curve as cyclic curve (no clamping to curve bounding box) */
	void use_cyclic(bool value) {
		PyObject_SetAttrString(pyobjref, "use_cyclic", Py_BuildValue("i", value));
	}

};

/**************** Limit Distance Constraint ****************/

/**
 * Limit the distance from target object
 */
class LimitDistanceConstraint : public Constraint {
public:
	LimitDistanceConstraint(PyObject* pyobj) : Constraint(pyobj) {}

	LimitDistanceConstraint() : Constraint(0)
	{
		// not implemented
	}

	/** Getter: Target along length of bone: Head=0, Tail=1 */
	float head_tail() { /* not implemented */ throw NULL; }
	/** Setter: Target along length of bone: Head=0, Tail=1 */
	void head_tail(float value) {
		PyObject_SetAttrString(pyobjref, "head_tail", Py_BuildValue("f", value));
	}

	/** Getter: Target Object */
	Object target();

	/** Getter:  */
	std::string subtarget() { /* not implemented */ throw NULL; }
	/** Setter:  */
	void subtarget(const std::string& value) { /* not implemented */ }

	/** Getter: Radius of limiting sphere */
	float distance() { /* not implemented */ throw NULL; }
	/** Setter: Radius of limiting sphere */
	void distance(float value) {
		PyObject_SetAttrString(pyobjref, "distance", Py_BuildValue("f", value));
	}

	enum limit_mode_enum {
		limit_mode_LIMITDIST_INSIDE = 0,
		limit_mode_LIMITDIST_OUTSIDE = 1,
		limit_mode_LIMITDIST_ONSURFACE = 2,
	};

	/** Getter: Distances in relation to sphere of influence to allow */
	limit_mode_enum limit_mode() { /* not implemented */ throw NULL; }
	/** Setter: Distances in relation to sphere of influence to allow */
	void limit_mode(limit_mode_enum value) { /* not implemented */ }

	/** Getter: Transforms are affected by this constraint as well */
	bool use_transform_limit() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_transform_limit")) == 1;
	}

	/** Setter: Transforms are affected by this constraint as well */
	void use_transform_limit(bool value) {
		PyObject_SetAttrString(pyobjref, "use_transform_limit", Py_BuildValue("i", value));
	}

};

/**************** Limit Size Constraint ****************/

/**
 * Limit the scaling of the constrained object
 */
class LimitScaleConstraint : public Constraint {
public:
	LimitScaleConstraint(PyObject* pyobj) : Constraint(pyobj) {}

	LimitScaleConstraint() : Constraint(0)
	{
		// not implemented
	}

	/** Getter: Use the minimum X value */
	bool use_min_x() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_min_x")) == 1;
	}

	/** Setter: Use the minimum X value */
	void use_min_x(bool value) {
		PyObject_SetAttrString(pyobjref, "use_min_x", Py_BuildValue("i", value));
	}

	/** Getter: Use the minimum Y value */
	bool use_min_y() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_min_y")) == 1;
	}

	/** Setter: Use the minimum Y value */
	void use_min_y(bool value) {
		PyObject_SetAttrString(pyobjref, "use_min_y", Py_BuildValue("i", value));
	}

	/** Getter: Use the minimum Z value */
	bool use_min_z() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_min_z")) == 1;
	}

	/** Setter: Use the minimum Z value */
	void use_min_z(bool value) {
		PyObject_SetAttrString(pyobjref, "use_min_z", Py_BuildValue("i", value));
	}

	/** Getter: Use the maximum X value */
	bool use_max_x() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_max_x")) == 1;
	}

	/** Setter: Use the maximum X value */
	void use_max_x(bool value) {
		PyObject_SetAttrString(pyobjref, "use_max_x", Py_BuildValue("i", value));
	}

	/** Getter: Use the maximum Y value */
	bool use_max_y() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_max_y")) == 1;
	}

	/** Setter: Use the maximum Y value */
	void use_max_y(bool value) {
		PyObject_SetAttrString(pyobjref, "use_max_y", Py_BuildValue("i", value));
	}

	/** Getter: Use the maximum Z value */
	bool use_max_z() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_max_z")) == 1;
	}

	/** Setter: Use the maximum Z value */
	void use_max_z(bool value) {
		PyObject_SetAttrString(pyobjref, "use_max_z", Py_BuildValue("i", value));
	}

	/** Getter: Lowest X value to allow */
	float min_x() { /* not implemented */ throw NULL; }
	/** Setter: Lowest X value to allow */
	void min_x(float value) {
		PyObject_SetAttrString(pyobjref, "min_x", Py_BuildValue("f", value));
	}

	/** Getter: Lowest Y value to allow */
	float min_y() { /* not implemented */ throw NULL; }
	/** Setter: Lowest Y value to allow */
	void min_y(float value) {
		PyObject_SetAttrString(pyobjref, "min_y", Py_BuildValue("f", value));
	}

	/** Getter: Lowest Z value to allow */
	float min_z() { /* not implemented */ throw NULL; }
	/** Setter: Lowest Z value to allow */
	void min_z(float value) {
		PyObject_SetAttrString(pyobjref, "min_z", Py_BuildValue("f", value));
	}

	/** Getter: Highest X value to allow */
	float max_x() { /* not implemented */ throw NULL; }
	/** Setter: Highest X value to allow */
	void max_x(float value) {
		PyObject_SetAttrString(pyobjref, "max_x", Py_BuildValue("f", value));
	}

	/** Getter: Highest Y value to allow */
	float max_y() { /* not implemented */ throw NULL; }
	/** Setter: Highest Y value to allow */
	void max_y(float value) {
		PyObject_SetAttrString(pyobjref, "max_y", Py_BuildValue("f", value));
	}

	/** Getter: Highest Z value to allow */
	float max_z() { /* not implemented */ throw NULL; }
	/** Setter: Highest Z value to allow */
	void max_z(float value) {
		PyObject_SetAttrString(pyobjref, "max_z", Py_BuildValue("f", value));
	}

	/** Getter: Transforms are affected by this constraint as well */
	bool use_transform_limit() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_transform_limit")) == 1;
	}

	/** Setter: Transforms are affected by this constraint as well */
	void use_transform_limit(bool value) {
		PyObject_SetAttrString(pyobjref, "use_transform_limit", Py_BuildValue("i", value));
	}

};

/**************** Limit Rotation Constraint ****************/

/**
 * Limit the rotation of the constrained object
 */
class LimitRotationConstraint : public Constraint {
public:
	LimitRotationConstraint(PyObject* pyobj) : Constraint(pyobj) {}

	LimitRotationConstraint() : Constraint(0)
	{
		// not implemented
	}

	/** Getter: Use the minimum X value */
	bool use_limit_x() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_limit_x")) == 1;
	}

	/** Setter: Use the minimum X value */
	void use_limit_x(bool value) {
		PyObject_SetAttrString(pyobjref, "use_limit_x", Py_BuildValue("i", value));
	}

	/** Getter: Use the minimum Y value */
	bool use_limit_y() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_limit_y")) == 1;
	}

	/** Setter: Use the minimum Y value */
	void use_limit_y(bool value) {
		PyObject_SetAttrString(pyobjref, "use_limit_y", Py_BuildValue("i", value));
	}

	/** Getter: Use the minimum Z value */
	bool use_limit_z() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_limit_z")) == 1;
	}

	/** Setter: Use the minimum Z value */
	void use_limit_z(bool value) {
		PyObject_SetAttrString(pyobjref, "use_limit_z", Py_BuildValue("i", value));
	}

	/** Getter: Lowest X value to allow */
	float min_x() { /* not implemented */ throw NULL; }
	/** Setter: Lowest X value to allow */
	void min_x(float value) {
		PyObject_SetAttrString(pyobjref, "min_x", Py_BuildValue("f", value));
	}

	/** Getter: Lowest Y value to allow */
	float min_y() { /* not implemented */ throw NULL; }
	/** Setter: Lowest Y value to allow */
	void min_y(float value) {
		PyObject_SetAttrString(pyobjref, "min_y", Py_BuildValue("f", value));
	}

	/** Getter: Lowest Z value to allow */
	float min_z() { /* not implemented */ throw NULL; }
	/** Setter: Lowest Z value to allow */
	void min_z(float value) {
		PyObject_SetAttrString(pyobjref, "min_z", Py_BuildValue("f", value));
	}

	/** Getter: Highest X value to allow */
	float max_x() { /* not implemented */ throw NULL; }
	/** Setter: Highest X value to allow */
	void max_x(float value) {
		PyObject_SetAttrString(pyobjref, "max_x", Py_BuildValue("f", value));
	}

	/** Getter: Highest Y value to allow */
	float max_y() { /* not implemented */ throw NULL; }
	/** Setter: Highest Y value to allow */
	void max_y(float value) {
		PyObject_SetAttrString(pyobjref, "max_y", Py_BuildValue("f", value));
	}

	/** Getter: Highest Z value to allow */
	float max_z() { /* not implemented */ throw NULL; }
	/** Setter: Highest Z value to allow */
	void max_z(float value) {
		PyObject_SetAttrString(pyobjref, "max_z", Py_BuildValue("f", value));
	}

	/** Getter: Transforms are affected by this constraint as well */
	bool use_transform_limit() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_transform_limit")) == 1;
	}

	/** Setter: Transforms are affected by this constraint as well */
	void use_transform_limit(bool value) {
		PyObject_SetAttrString(pyobjref, "use_transform_limit", Py_BuildValue("i", value));
	}

};

/**************** Limit Location Constraint ****************/

/**
 * Limit the location of the constrained object
 */
class LimitLocationConstraint : public Constraint {
public:
	LimitLocationConstraint(PyObject* pyobj) : Constraint(pyobj) {}

	LimitLocationConstraint() : Constraint(0)
	{
		// not implemented
	}

	/** Getter: Use the minimum X value */
	bool use_min_x() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_min_x")) == 1;
	}

	/** Setter: Use the minimum X value */
	void use_min_x(bool value) {
		PyObject_SetAttrString(pyobjref, "use_min_x", Py_BuildValue("i", value));
	}

	/** Getter: Use the minimum Y value */
	bool use_min_y() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_min_y")) == 1;
	}

	/** Setter: Use the minimum Y value */
	void use_min_y(bool value) {
		PyObject_SetAttrString(pyobjref, "use_min_y", Py_BuildValue("i", value));
	}

	/** Getter: Use the minimum Z value */
	bool use_min_z() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_min_z")) == 1;
	}

	/** Setter: Use the minimum Z value */
	void use_min_z(bool value) {
		PyObject_SetAttrString(pyobjref, "use_min_z", Py_BuildValue("i", value));
	}

	/** Getter: Use the maximum X value */
	bool use_max_x() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_max_x")) == 1;
	}

	/** Setter: Use the maximum X value */
	void use_max_x(bool value) {
		PyObject_SetAttrString(pyobjref, "use_max_x", Py_BuildValue("i", value));
	}

	/** Getter: Use the maximum Y value */
	bool use_max_y() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_max_y")) == 1;
	}

	/** Setter: Use the maximum Y value */
	void use_max_y(bool value) {
		PyObject_SetAttrString(pyobjref, "use_max_y", Py_BuildValue("i", value));
	}

	/** Getter: Use the maximum Z value */
	bool use_max_z() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_max_z")) == 1;
	}

	/** Setter: Use the maximum Z value */
	void use_max_z(bool value) {
		PyObject_SetAttrString(pyobjref, "use_max_z", Py_BuildValue("i", value));
	}

	/** Getter: Lowest X value to allow */
	float min_x() { /* not implemented */ throw NULL; }
	/** Setter: Lowest X value to allow */
	void min_x(float value) {
		PyObject_SetAttrString(pyobjref, "min_x", Py_BuildValue("f", value));
	}

	/** Getter: Lowest Y value to allow */
	float min_y() { /* not implemented */ throw NULL; }
	/** Setter: Lowest Y value to allow */
	void min_y(float value) {
		PyObject_SetAttrString(pyobjref, "min_y", Py_BuildValue("f", value));
	}

	/** Getter: Lowest Z value to allow */
	float min_z() { /* not implemented */ throw NULL; }
	/** Setter: Lowest Z value to allow */
	void min_z(float value) {
		PyObject_SetAttrString(pyobjref, "min_z", Py_BuildValue("f", value));
	}

	/** Getter: Highest X value to allow */
	float max_x() { /* not implemented */ throw NULL; }
	/** Setter: Highest X value to allow */
	void max_x(float value) {
		PyObject_SetAttrString(pyobjref, "max_x", Py_BuildValue("f", value));
	}

	/** Getter: Highest Y value to allow */
	float max_y() { /* not implemented */ throw NULL; }
	/** Setter: Highest Y value to allow */
	void max_y(float value) {
		PyObject_SetAttrString(pyobjref, "max_y", Py_BuildValue("f", value));
	}

	/** Getter: Highest Z value to allow */
	float max_z() { /* not implemented */ throw NULL; }
	/** Setter: Highest Z value to allow */
	void max_z(float value) {
		PyObject_SetAttrString(pyobjref, "max_z", Py_BuildValue("f", value));
	}

	/** Getter: Transforms are affected by this constraint as well */
	bool use_transform_limit() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_transform_limit")) == 1;
	}

	/** Setter: Transforms are affected by this constraint as well */
	void use_transform_limit(bool value) {
		PyObject_SetAttrString(pyobjref, "use_transform_limit", Py_BuildValue("i", value));
	}

};

/**************** Transformation Constraint ****************/

/**
 * Map transformations of the target to the object
 */
class TransformConstraint : public Constraint {
public:
	TransformConstraint(PyObject* pyobj) : Constraint(pyobj) {}

	TransformConstraint() : Constraint(0)
	{
		// not implemented
	}

	/** Getter: Target Object */
	Object target();

	/** Getter:  */
	std::string subtarget() { /* not implemented */ throw NULL; }
	/** Setter:  */
	void subtarget(const std::string& value) { /* not implemented */ }

	enum map_from_enum {
		map_from_LOCATION = 0,
		map_from_ROTATION = 1,
		map_from_SCALE = 2,
	};

	/** Getter: The transformation type to use from the target */
	map_from_enum map_from() { /* not implemented */ throw NULL; }
	/** Setter: The transformation type to use from the target */
	void map_from(map_from_enum value) { /* not implemented */ }

	enum map_to_enum {
		map_to_LOCATION = 0,
		map_to_ROTATION = 1,
		map_to_SCALE = 2,
	};

	/** Getter: The transformation type to affect of the constrained object */
	map_to_enum map_to() { /* not implemented */ throw NULL; }
	/** Setter: The transformation type to affect of the constrained object */
	void map_to(map_to_enum value) { /* not implemented */ }

	enum map_to_x_from_enum {
		map_to_x_from_X = 0,
		map_to_x_from_Y = 1,
		map_to_x_from_Z = 2,
	};

	/** Getter: The source axis constrained object's X axis uses */
	map_to_x_from_enum map_to_x_from() { /* not implemented */ throw NULL; }
	/** Setter: The source axis constrained object's X axis uses */
	void map_to_x_from(map_to_x_from_enum value) { /* not implemented */ }

	enum map_to_y_from_enum {
		map_to_y_from_X = 0,
		map_to_y_from_Y = 1,
		map_to_y_from_Z = 2,
	};

	/** Getter: The source axis constrained object's Y axis uses */
	map_to_y_from_enum map_to_y_from() { /* not implemented */ throw NULL; }
	/** Setter: The source axis constrained object's Y axis uses */
	void map_to_y_from(map_to_y_from_enum value) { /* not implemented */ }

	enum map_to_z_from_enum {
		map_to_z_from_X = 0,
		map_to_z_from_Y = 1,
		map_to_z_from_Z = 2,
	};

	/** Getter: The source axis constrained object's Z axis uses */
	map_to_z_from_enum map_to_z_from() { /* not implemented */ throw NULL; }
	/** Setter: The source axis constrained object's Z axis uses */
	void map_to_z_from(map_to_z_from_enum value) { /* not implemented */ }

	/** Getter: Extrapolate ranges */
	bool use_motion_extrapolate() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_motion_extrapolate")) == 1;
	}

	/** Setter: Extrapolate ranges */
	void use_motion_extrapolate(bool value) {
		PyObject_SetAttrString(pyobjref, "use_motion_extrapolate", Py_BuildValue("i", value));
	}

	/** Getter: Bottom range of X axis source motion */
	float from_min_x() { /* not implemented */ throw NULL; }
	/** Setter: Bottom range of X axis source motion */
	void from_min_x(float value) {
		PyObject_SetAttrString(pyobjref, "from_min_x", Py_BuildValue("f", value));
	}

	/** Getter: Bottom range of Y axis source motion */
	float from_min_y() { /* not implemented */ throw NULL; }
	/** Setter: Bottom range of Y axis source motion */
	void from_min_y(float value) {
		PyObject_SetAttrString(pyobjref, "from_min_y", Py_BuildValue("f", value));
	}

	/** Getter: Bottom range of Z axis source motion */
	float from_min_z() { /* not implemented */ throw NULL; }
	/** Setter: Bottom range of Z axis source motion */
	void from_min_z(float value) {
		PyObject_SetAttrString(pyobjref, "from_min_z", Py_BuildValue("f", value));
	}

	/** Getter: Top range of X axis source motion */
	float from_max_x() { /* not implemented */ throw NULL; }
	/** Setter: Top range of X axis source motion */
	void from_max_x(float value) {
		PyObject_SetAttrString(pyobjref, "from_max_x", Py_BuildValue("f", value));
	}

	/** Getter: Top range of Y axis source motion */
	float from_max_y() { /* not implemented */ throw NULL; }
	/** Setter: Top range of Y axis source motion */
	void from_max_y(float value) {
		PyObject_SetAttrString(pyobjref, "from_max_y", Py_BuildValue("f", value));
	}

	/** Getter: Top range of Z axis source motion */
	float from_max_z() { /* not implemented */ throw NULL; }
	/** Setter: Top range of Z axis source motion */
	void from_max_z(float value) {
		PyObject_SetAttrString(pyobjref, "from_max_z", Py_BuildValue("f", value));
	}

	/** Getter: Bottom range of X axis destination motion */
	float to_min_x() { /* not implemented */ throw NULL; }
	/** Setter: Bottom range of X axis destination motion */
	void to_min_x(float value) {
		PyObject_SetAttrString(pyobjref, "to_min_x", Py_BuildValue("f", value));
	}

	/** Getter: Bottom range of Y axis destination motion */
	float to_min_y() { /* not implemented */ throw NULL; }
	/** Setter: Bottom range of Y axis destination motion */
	void to_min_y(float value) {
		PyObject_SetAttrString(pyobjref, "to_min_y", Py_BuildValue("f", value));
	}

	/** Getter: Bottom range of Z axis destination motion */
	float to_min_z() { /* not implemented */ throw NULL; }
	/** Setter: Bottom range of Z axis destination motion */
	void to_min_z(float value) {
		PyObject_SetAttrString(pyobjref, "to_min_z", Py_BuildValue("f", value));
	}

	/** Getter: Top range of X axis destination motion */
	float to_max_x() { /* not implemented */ throw NULL; }
	/** Setter: Top range of X axis destination motion */
	void to_max_x(float value) {
		PyObject_SetAttrString(pyobjref, "to_max_x", Py_BuildValue("f", value));
	}

	/** Getter: Top range of Y axis destination motion */
	float to_max_y() { /* not implemented */ throw NULL; }
	/** Setter: Top range of Y axis destination motion */
	void to_max_y(float value) {
		PyObject_SetAttrString(pyobjref, "to_max_y", Py_BuildValue("f", value));
	}

	/** Getter: Top range of Z axis destination motion */
	float to_max_z() { /* not implemented */ throw NULL; }
	/** Setter: Top range of Z axis destination motion */
	void to_max_z(float value) {
		PyObject_SetAttrString(pyobjref, "to_max_z", Py_BuildValue("f", value));
	}

	/** Getter: Bottom range of X axis source motion */
	float from_min_x_rot() { /* not implemented */ throw NULL; }
	/** Setter: Bottom range of X axis source motion */
	void from_min_x_rot(float value) {
		PyObject_SetAttrString(pyobjref, "from_min_x_rot", Py_BuildValue("f", value));
	}

	/** Getter: Bottom range of Y axis source motion */
	float from_min_y_rot() { /* not implemented */ throw NULL; }
	/** Setter: Bottom range of Y axis source motion */
	void from_min_y_rot(float value) {
		PyObject_SetAttrString(pyobjref, "from_min_y_rot", Py_BuildValue("f", value));
	}

	/** Getter: Bottom range of Z axis source motion */
	float from_min_z_rot() { /* not implemented */ throw NULL; }
	/** Setter: Bottom range of Z axis source motion */
	void from_min_z_rot(float value) {
		PyObject_SetAttrString(pyobjref, "from_min_z_rot", Py_BuildValue("f", value));
	}

	/** Getter: Top range of X axis source motion */
	float from_max_x_rot() { /* not implemented */ throw NULL; }
	/** Setter: Top range of X axis source motion */
	void from_max_x_rot(float value) {
		PyObject_SetAttrString(pyobjref, "from_max_x_rot", Py_BuildValue("f", value));
	}

	/** Getter: Top range of Y axis source motion */
	float from_max_y_rot() { /* not implemented */ throw NULL; }
	/** Setter: Top range of Y axis source motion */
	void from_max_y_rot(float value) {
		PyObject_SetAttrString(pyobjref, "from_max_y_rot", Py_BuildValue("f", value));
	}

	/** Getter: Top range of Z axis source motion */
	float from_max_z_rot() { /* not implemented */ throw NULL; }
	/** Setter: Top range of Z axis source motion */
	void from_max_z_rot(float value) {
		PyObject_SetAttrString(pyobjref, "from_max_z_rot", Py_BuildValue("f", value));
	}

	/** Getter: Bottom range of X axis destination motion */
	float to_min_x_rot() { /* not implemented */ throw NULL; }
	/** Setter: Bottom range of X axis destination motion */
	void to_min_x_rot(float value) {
		PyObject_SetAttrString(pyobjref, "to_min_x_rot", Py_BuildValue("f", value));
	}

	/** Getter: Bottom range of Y axis destination motion */
	float to_min_y_rot() { /* not implemented */ throw NULL; }
	/** Setter: Bottom range of Y axis destination motion */
	void to_min_y_rot(float value) {
		PyObject_SetAttrString(pyobjref, "to_min_y_rot", Py_BuildValue("f", value));
	}

	/** Getter: Bottom range of Z axis destination motion */
	float to_min_z_rot() { /* not implemented */ throw NULL; }
	/** Setter: Bottom range of Z axis destination motion */
	void to_min_z_rot(float value) {
		PyObject_SetAttrString(pyobjref, "to_min_z_rot", Py_BuildValue("f", value));
	}

	/** Getter: Top range of X axis destination motion */
	float to_max_x_rot() { /* not implemented */ throw NULL; }
	/** Setter: Top range of X axis destination motion */
	void to_max_x_rot(float value) {
		PyObject_SetAttrString(pyobjref, "to_max_x_rot", Py_BuildValue("f", value));
	}

	/** Getter: Top range of Y axis destination motion */
	float to_max_y_rot() { /* not implemented */ throw NULL; }
	/** Setter: Top range of Y axis destination motion */
	void to_max_y_rot(float value) {
		PyObject_SetAttrString(pyobjref, "to_max_y_rot", Py_BuildValue("f", value));
	}

	/** Getter: Top range of Z axis destination motion */
	float to_max_z_rot() { /* not implemented */ throw NULL; }
	/** Setter: Top range of Z axis destination motion */
	void to_max_z_rot(float value) {
		PyObject_SetAttrString(pyobjref, "to_max_z_rot", Py_BuildValue("f", value));
	}

	/** Getter: Bottom range of X axis source motion */
	float from_min_x_scale() { /* not implemented */ throw NULL; }
	/** Setter: Bottom range of X axis source motion */
	void from_min_x_scale(float value) {
		PyObject_SetAttrString(pyobjref, "from_min_x_scale", Py_BuildValue("f", value));
	}

	/** Getter: Bottom range of Y axis source motion */
	float from_min_y_scale() { /* not implemented */ throw NULL; }
	/** Setter: Bottom range of Y axis source motion */
	void from_min_y_scale(float value) {
		PyObject_SetAttrString(pyobjref, "from_min_y_scale", Py_BuildValue("f", value));
	}

	/** Getter: Bottom range of Z axis source motion */
	float from_min_z_scale() { /* not implemented */ throw NULL; }
	/** Setter: Bottom range of Z axis source motion */
	void from_min_z_scale(float value) {
		PyObject_SetAttrString(pyobjref, "from_min_z_scale", Py_BuildValue("f", value));
	}

	/** Getter: Top range of X axis source motion */
	float from_max_x_scale() { /* not implemented */ throw NULL; }
	/** Setter: Top range of X axis source motion */
	void from_max_x_scale(float value) {
		PyObject_SetAttrString(pyobjref, "from_max_x_scale", Py_BuildValue("f", value));
	}

	/** Getter: Top range of Y axis source motion */
	float from_max_y_scale() { /* not implemented */ throw NULL; }
	/** Setter: Top range of Y axis source motion */
	void from_max_y_scale(float value) {
		PyObject_SetAttrString(pyobjref, "from_max_y_scale", Py_BuildValue("f", value));
	}

	/** Getter: Top range of Z axis source motion */
	float from_max_z_scale() { /* not implemented */ throw NULL; }
	/** Setter: Top range of Z axis source motion */
	void from_max_z_scale(float value) {
		PyObject_SetAttrString(pyobjref, "from_max_z_scale", Py_BuildValue("f", value));
	}

	/** Getter: Bottom range of X axis destination motion */
	float to_min_x_scale() { /* not implemented */ throw NULL; }
	/** Setter: Bottom range of X axis destination motion */
	void to_min_x_scale(float value) {
		PyObject_SetAttrString(pyobjref, "to_min_x_scale", Py_BuildValue("f", value));
	}

	/** Getter: Bottom range of Y axis destination motion */
	float to_min_y_scale() { /* not implemented */ throw NULL; }
	/** Setter: Bottom range of Y axis destination motion */
	void to_min_y_scale(float value) {
		PyObject_SetAttrString(pyobjref, "to_min_y_scale", Py_BuildValue("f", value));
	}

	/** Getter: Bottom range of Z axis destination motion */
	float to_min_z_scale() { /* not implemented */ throw NULL; }
	/** Setter: Bottom range of Z axis destination motion */
	void to_min_z_scale(float value) {
		PyObject_SetAttrString(pyobjref, "to_min_z_scale", Py_BuildValue("f", value));
	}

	/** Getter: Top range of X axis destination motion */
	float to_max_x_scale() { /* not implemented */ throw NULL; }
	/** Setter: Top range of X axis destination motion */
	void to_max_x_scale(float value) {
		PyObject_SetAttrString(pyobjref, "to_max_x_scale", Py_BuildValue("f", value));
	}

	/** Getter: Top range of Y axis destination motion */
	float to_max_y_scale() { /* not implemented */ throw NULL; }
	/** Setter: Top range of Y axis destination motion */
	void to_max_y_scale(float value) {
		PyObject_SetAttrString(pyobjref, "to_max_y_scale", Py_BuildValue("f", value));
	}

	/** Getter: Top range of Z axis destination motion */
	float to_max_z_scale() { /* not implemented */ throw NULL; }
	/** Setter: Top range of Z axis destination motion */
	void to_max_z_scale(float value) {
		PyObject_SetAttrString(pyobjref, "to_max_z_scale", Py_BuildValue("f", value));
	}

};

/**************** Shrinkwrap Constraint ****************/

/**
 * Create constraint-based shrinkwrap relationship
 */
class ShrinkwrapConstraint : public Constraint {
public:
	ShrinkwrapConstraint(PyObject* pyobj) : Constraint(pyobj) {}

	ShrinkwrapConstraint() : Constraint(0)
	{
		// not implemented
	}

	/** Getter: Target Object */
	Object target();

	enum shrinkwrap_type_enum {
		shrinkwrap_type_NEAREST_SURFACE = 0,
		shrinkwrap_type_PROJECT = 1,
		shrinkwrap_type_NEAREST_VERTEX = 2,
	};

	/** Getter: Select type of shrinkwrap algorithm for target position */
	shrinkwrap_type_enum shrinkwrap_type() { /* not implemented */ throw NULL; }
	/** Setter: Select type of shrinkwrap algorithm for target position */
	void shrinkwrap_type(shrinkwrap_type_enum value) { /* not implemented */ }

	/** Getter: Distance to Target */
	float distance() { /* not implemented */ throw NULL; }
	/** Setter: Distance to Target */
	void distance(float value) {
		PyObject_SetAttrString(pyobjref, "distance", Py_BuildValue("f", value));
	}

	enum project_axis_enum {
		project_axis_POS_X = 0,
		project_axis_POS_Y = 1,
		project_axis_POS_Z = 2,
		project_axis_NEG_X = 3,
		project_axis_NEG_Y = 4,
		project_axis_NEG_Z = 5,
	};

	/** Getter: Axis constrain to */
	project_axis_enum project_axis() { /* not implemented */ throw NULL; }
	/** Setter: Axis constrain to */
	void project_axis(project_axis_enum value) { /* not implemented */ }

	enum project_axis_space_enum {
		project_axis_space_WORLD = 0,
		project_axis_space_POSE = 2,
		project_axis_space_LOCAL_WITH_PARENT = 3,
		project_axis_space_LOCAL = 1,
	};

	/** Getter: Space for the projection axis */
	project_axis_space_enum project_axis_space() { /* not implemented */ throw NULL; }
	/** Setter: Space for the projection axis */
	void project_axis_space(project_axis_space_enum value) { /* not implemented */ }

	/** Getter: Limit the distance used for projection (zero disables) */
	float project_limit() { /* not implemented */ throw NULL; }
	/** Setter: Limit the distance used for projection (zero disables) */
	void project_limit(float value) {
		PyObject_SetAttrString(pyobjref, "project_limit", Py_BuildValue("f", value));
	}

};

/**************** Damped Track Constraint ****************/

/**
 * Point toward target by taking the shortest rotation path
 */
class DampedTrackConstraint : public Constraint {
public:
	DampedTrackConstraint(PyObject* pyobj) : Constraint(pyobj) {}

	DampedTrackConstraint() : Constraint(0)
	{
		// not implemented
	}

	/** Getter: Target along length of bone: Head=0, Tail=1 */
	float head_tail() { /* not implemented */ throw NULL; }
	/** Setter: Target along length of bone: Head=0, Tail=1 */
	void head_tail(float value) {
		PyObject_SetAttrString(pyobjref, "head_tail", Py_BuildValue("f", value));
	}

	/** Getter: Target Object */
	Object target();

	/** Getter:  */
	std::string subtarget() { /* not implemented */ throw NULL; }
	/** Setter:  */
	void subtarget(const std::string& value) { /* not implemented */ }

	enum track_axis_enum {
		track_axis_TRACK_X = 0,
		track_axis_TRACK_Y = 1,
		track_axis_TRACK_Z = 2,
		track_axis_TRACK_NEGATIVE_X = 3,
		track_axis_TRACK_NEGATIVE_Y = 4,
		track_axis_TRACK_NEGATIVE_Z = 5,
	};

	/** Getter: Axis that points to the target object */
	track_axis_enum track_axis() { /* not implemented */ throw NULL; }
	/** Setter: Axis that points to the target object */
	void track_axis(track_axis_enum value) { /* not implemented */ }

};

/**************** Spline IK Constraint ****************/

/**
 * Align 'n' bones along a curve
 */
class SplineIKConstraint : public Constraint {
public:
	SplineIKConstraint(PyObject* pyobj) : Constraint(pyobj) {}

	SplineIKConstraint() : Constraint(0)
	{
		// not implemented
	}

	/** Getter: Curve that controls this relationship */
	Object target();

	/** Getter: How many bones are included in the chain */
	int chain_count() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "chain_count"));
	}

	/** Setter: How many bones are included in the chain */
	void chain_count(int value) {
		PyObject_SetAttrString(pyobjref, "chain_count", Py_BuildValue("i", value));
	}

	/** Getter: (EXPERIENCED USERS ONLY) The relative positions of the joints along the chain, as percentages */
	std::array<float, 32> joint_bindings() {
		// TODO: MISSING DEREF! USE #DEFINE!
		PyObject *seqval = PyObject_GetAttrString(pyobjref, "joint_bindings");
		std::array<float, 32> resarr;
		for (int i = 0; i < 32; i++)
			resarr[i] = (float)PyFloat_AsDouble(PySequence_GetItem(seqval, i));
		return resarr;
	}

	/** Setter: (EXPERIENCED USERS ONLY) The relative positions of the joints along the chain, as percentages */
	void joint_bindings(float values[32]) { /* not implemented */ }

	/** Getter: Offset the entire chain relative to the root joint */
	bool use_chain_offset() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_chain_offset")) == 1;
	}

	/** Setter: Offset the entire chain relative to the root joint */
	void use_chain_offset(bool value) {
		PyObject_SetAttrString(pyobjref, "use_chain_offset", Py_BuildValue("i", value));
	}

	/** Getter: Ignore the relative lengths of the bones when fitting to the curve */
	bool use_even_divisions() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_even_divisions")) == 1;
	}

	/** Setter: Ignore the relative lengths of the bones when fitting to the curve */
	void use_even_divisions(bool value) {
		PyObject_SetAttrString(pyobjref, "use_even_divisions", Py_BuildValue("i", value));
	}

	/** Getter: Stretch the Y axis of the bones to fit the curve */
	bool use_y_stretch() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_y_stretch")) == 1;
	}

	/** Setter: Stretch the Y axis of the bones to fit the curve */
	void use_y_stretch(bool value) {
		PyObject_SetAttrString(pyobjref, "use_y_stretch", Py_BuildValue("i", value));
	}

	/** Getter: Average radius of the endpoints is used to tweak the X and Z Scaling of the bones, on top of XZ Scale mode */
	bool use_curve_radius() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_curve_radius")) == 1;
	}

	/** Setter: Average radius of the endpoints is used to tweak the X and Z Scaling of the bones, on top of XZ Scale mode */
	void use_curve_radius(bool value) {
		PyObject_SetAttrString(pyobjref, "use_curve_radius", Py_BuildValue("i", value));
	}

	enum xz_scale_mode_enum {
		xz_scale_mode_NONE = 0,
		xz_scale_mode_BONE_ORIGINAL = 1,
		xz_scale_mode_INVERSE_PRESERVE = 2,
		xz_scale_mode_VOLUME_PRESERVE = 3,
	};

	/** Getter: Method used for determining the scaling of the X and Z axes of the bones */
	xz_scale_mode_enum xz_scale_mode() { /* not implemented */ throw NULL; }
	/** Setter: Method used for determining the scaling of the X and Z axes of the bones */
	void xz_scale_mode(xz_scale_mode_enum value) { /* not implemented */ }

	/** Getter: Factor between volume variation and stretching */
	float bulge() { /* not implemented */ throw NULL; }
	/** Setter: Factor between volume variation and stretching */
	void bulge(float value) {
		PyObject_SetAttrString(pyobjref, "bulge", Py_BuildValue("f", value));
	}

	/** Getter: Use lower limit for volume variation */
	bool use_bulge_min() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_bulge_min")) == 1;
	}

	/** Setter: Use lower limit for volume variation */
	void use_bulge_min(bool value) {
		PyObject_SetAttrString(pyobjref, "use_bulge_min", Py_BuildValue("i", value));
	}

	/** Getter: Use upper limit for volume variation */
	bool use_bulge_max() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_bulge_max")) == 1;
	}

	/** Setter: Use upper limit for volume variation */
	void use_bulge_max(bool value) {
		PyObject_SetAttrString(pyobjref, "use_bulge_max", Py_BuildValue("i", value));
	}

	/** Getter: Minimum volume stretching factor */
	float bulge_min() { /* not implemented */ throw NULL; }
	/** Setter: Minimum volume stretching factor */
	void bulge_min(float value) {
		PyObject_SetAttrString(pyobjref, "bulge_min", Py_BuildValue("f", value));
	}

	/** Getter: Maximum volume stretching factor */
	float bulge_max() { /* not implemented */ throw NULL; }
	/** Setter: Maximum volume stretching factor */
	void bulge_max(float value) {
		PyObject_SetAttrString(pyobjref, "bulge_max", Py_BuildValue("f", value));
	}

	/** Getter: Strength of volume stretching clamping */
	float bulge_smooth() { /* not implemented */ throw NULL; }
	/** Setter: Strength of volume stretching clamping */
	void bulge_smooth(float value) {
		PyObject_SetAttrString(pyobjref, "bulge_smooth", Py_BuildValue("f", value));
	}

};

/**************** Pivot Constraint ****************/

/**
 * Rotate around a different point
 */
class PivotConstraint : public Constraint {
public:
	PivotConstraint(PyObject* pyobj) : Constraint(pyobj) {}

	PivotConstraint() : Constraint(0)
	{
		// not implemented
	}

	/** Getter: Target along length of bone: Head=0, Tail=1 */
	float head_tail() { /* not implemented */ throw NULL; }
	/** Setter: Target along length of bone: Head=0, Tail=1 */
	void head_tail(float value) {
		PyObject_SetAttrString(pyobjref, "head_tail", Py_BuildValue("f", value));
	}

	/** Getter: Target Object, defining the position of the pivot when defined */
	Object target();

	/** Getter:  */
	std::string subtarget() { /* not implemented */ throw NULL; }
	/** Setter:  */
	void subtarget(const std::string& value) { /* not implemented */ }

	/** Getter: Offset will be an absolute point in space instead of relative to the target */
	bool use_relative_location() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_relative_location")) == 1;
	}

	/** Setter: Offset will be an absolute point in space instead of relative to the target */
	void use_relative_location(bool value) {
		PyObject_SetAttrString(pyobjref, "use_relative_location", Py_BuildValue("i", value));
	}

	/** Getter: Offset of pivot from target (when set), or from owner's location (when Fixed Position is off), or the absolute pivot point */
	std::array<float, 3> offset() {
		// TODO: MISSING DEREF! USE #DEFINE!
		PyObject *seqval = PyObject_GetAttrString(pyobjref, "offset");
		std::array<float, 3> resarr;
		for (int i = 0; i < 3; i++)
			resarr[i] = (float)PyFloat_AsDouble(PySequence_GetItem(seqval, i));
		return resarr;
	}

	/** Setter: Offset of pivot from target (when set), or from owner's location (when Fixed Position is off), or the absolute pivot point */
	void offset(float values[3]) { /* not implemented */ }

	enum rotation_range_enum {
		rotation_range_ALWAYS_ACTIVE = -1,
		rotation_range_NX = 0,
		rotation_range_NY = 1,
		rotation_range_NZ = 2,
		rotation_range_X = 3,
		rotation_range_Y = 4,
		rotation_range_Z = 5,
	};

	/** Getter: Rotation range on which pivoting should occur */
	rotation_range_enum rotation_range() { /* not implemented */ throw NULL; }
	/** Setter: Rotation range on which pivoting should occur */
	void rotation_range(rotation_range_enum value) { /* not implemented */ }

};

/**************** Follow Track Constraint ****************/

/**
 * Lock motion to the target motion track
 */
class FollowTrackConstraint : public Constraint {
public:
	FollowTrackConstraint(PyObject* pyobj) : Constraint(pyobj) {}

	FollowTrackConstraint() : Constraint(0)
	{
		// not implemented
	}

	/** Getter: Movie Clip to get tracking data from */
	MovieClip clip();

	/** Getter: Movie tracking track to follow */
	std::string track() { /* not implemented */ throw NULL; }
	/** Setter: Movie tracking track to follow */
	void track(const std::string& value) { /* not implemented */ }

	/** Getter: Use active clip defined in scene */
	bool use_active_clip() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_active_clip")) == 1;
	}

	/** Setter: Use active clip defined in scene */
	void use_active_clip(bool value) {
		PyObject_SetAttrString(pyobjref, "use_active_clip", Py_BuildValue("i", value));
	}

	/** Getter: Use 3D position of track to parent to */
	bool use_3d_position() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_3d_position")) == 1;
	}

	/** Setter: Use 3D position of track to parent to */
	void use_3d_position(bool value) {
		PyObject_SetAttrString(pyobjref, "use_3d_position", Py_BuildValue("i", value));
	}

	/** Getter: Movie tracking object to follow (if empty, camera object is used) */
	std::string object_value() { /* not implemented */ throw NULL; }
	/** Setter: Movie tracking object to follow (if empty, camera object is used) */
	void object_value(const std::string& value) { /* not implemented */ }

	/** Getter: Camera to which motion is parented (if empty active scene camera is used) */
	Object camera();

	/** Getter: Object used to define depth in camera space by projecting onto surface of this object */
	Object depth_object();

	enum frame_method_enum {
		frame_method_STRETCH = 0,
		frame_method_FIT = 1,
		frame_method_CROP = 2,
	};

	/** Getter: How the footage fits in the camera frame */
	frame_method_enum frame_method() { /* not implemented */ throw NULL; }
	/** Setter: How the footage fits in the camera frame */
	void frame_method(frame_method_enum value) { /* not implemented */ }

	/** Getter: Parent to undistorted position of 2D track */
	bool use_undistorted_position() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_undistorted_position")) == 1;
	}

	/** Setter: Parent to undistorted position of 2D track */
	void use_undistorted_position(bool value) {
		PyObject_SetAttrString(pyobjref, "use_undistorted_position", Py_BuildValue("i", value));
	}

};

/**************** Camera Solver Constraint ****************/

/**
 * Lock motion to the reconstructed camera movement
 */
class CameraSolverConstraint : public Constraint {
public:
	CameraSolverConstraint(PyObject* pyobj) : Constraint(pyobj) {}

	CameraSolverConstraint() : Constraint(0)
	{
		// not implemented
	}

	/** Getter: Movie Clip to get tracking data from */
	MovieClip clip();

	/** Getter: Use active clip defined in scene */
	bool use_active_clip() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_active_clip")) == 1;
	}

	/** Setter: Use active clip defined in scene */
	void use_active_clip(bool value) {
		PyObject_SetAttrString(pyobjref, "use_active_clip", Py_BuildValue("i", value));
	}

};

/**************** Object Solver Constraint ****************/

/**
 * Lock motion to the reconstructed object movement
 */
class ObjectSolverConstraint : public Constraint {
public:
	ObjectSolverConstraint(PyObject* pyobj) : Constraint(pyobj) {}

	ObjectSolverConstraint() : Constraint(0)
	{
		// not implemented
	}

	/** Getter: Movie Clip to get tracking data from */
	MovieClip clip();

	/** Getter: Use active clip defined in scene */
	bool use_active_clip() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_active_clip")) == 1;
	}

	/** Setter: Use active clip defined in scene */
	void use_active_clip(bool value) {
		PyObject_SetAttrString(pyobjref, "use_active_clip", Py_BuildValue("i", value));
	}

	/** Getter: Movie tracking object to follow */
	std::string object_value() { /* not implemented */ throw NULL; }
	/** Setter: Movie tracking object to follow */
	void object_value(const std::string& value) { /* not implemented */ }

	/** Getter: Camera to which motion is parented (if empty active scene camera is used) */
	Object camera();

};

/**************** Context ****************/

/**
 * Current windowmanager and data context
 */
class Context : public pyUniplug {
public:
	Context(PyObject* pyobj) : pyUniplug(pyobj) {}

	Context() : pyUniplug(0)
	{
		// not implemented
	}

	/** Getter:  */
	WindowManager window_manager();

	/** Getter:  */
	Window window();

	/** Getter:  */
	Screen screen();

	/** Getter:  */
	Area area();

	/** Getter:  */
	Space space_data();

	/** Getter:  */
	Region region();

	/** Getter:  */
	RegionView3D region_data();

	/** Getter:  */
	BlendData blend_data();

	/** Getter:  */
	Scene scene();

	/** Getter:  */
	ToolSettings tool_settings();

	/** Getter:  */
	UserPreferences user_preferences();

	enum mode_enum {
		mode_EDIT_MESH = 0,
		mode_EDIT_CURVE = 1,
		mode_EDIT_SURFACE = 2,
		mode_EDIT_TEXT = 3,
		mode_EDIT_ARMATURE = 4,
		mode_EDIT_METABALL = 5,
		mode_EDIT_LATTICE = 6,
		mode_POSE = 7,
		mode_SCULPT = 8,
		mode_PAINT_WEIGHT = 9,
		mode_PAINT_VERTEX = 10,
		mode_PAINT_TEXTURE = 11,
		mode_PARTICLE = 12,
		mode_OBJECT = 13,
	};

	/** Getter:  */
	mode_enum mode() { /* not implemented */ throw NULL; }
	/** Setter:  */
	void mode(mode_enum value) { /* not implemented */ }

};

/**************** Controller ****************/

/**
 * Game engine logic brick to process events, connecting sensors to actuators
 */
class Controller : public pyUniplug {
public:
	Controller(PyObject* pyobj) : pyUniplug(pyobj) {}

	Controller() : pyUniplug(0)
	{
		// not implemented
	}

	/** Getter:  */
	std::string name() { /* not implemented */ throw NULL; }
	/** Setter:  */
	void name(const std::string& value) { /* not implemented */ }

	enum type_enum {
		type_LOGIC_AND = 0,
		type_LOGIC_OR = 1,
		type_LOGIC_NAND = 4,
		type_LOGIC_NOR = 5,
		type_LOGIC_XOR = 6,
		type_LOGIC_XNOR = 7,
		type_EXPRESSION = 2,
		type_PYTHON = 3,
	};

	/** Getter:  */
	type_enum type() { /* not implemented */ throw NULL; }
	/** Setter:  */
	void type(type_enum value) { /* not implemented */ }

	/** Getter: Set controller expanded in the user interface */
	bool show_expanded() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "show_expanded")) == 1;
	}

	/** Setter: Set controller expanded in the user interface */
	void show_expanded(bool value) {
		PyObject_SetAttrString(pyobjref, "show_expanded", Py_BuildValue("i", value));
	}

	/** Getter: Set the active state of the controller */
	bool active() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "active")) == 1;
	}

	/** Setter: Set the active state of the controller */
	void active(bool value) {
		PyObject_SetAttrString(pyobjref, "active", Py_BuildValue("i", value));
	}

	/** Getter: Mark controller for execution before all non-marked controllers (good for startup scripts) */
	bool use_priority() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_priority")) == 1;
	}

	/** Setter: Mark controller for execution before all non-marked controllers (good for startup scripts) */
	void use_priority(bool value) {
		PyObject_SetAttrString(pyobjref, "use_priority", Py_BuildValue("i", value));
	}

	/** Getter: The list containing the actuators connected to the controller */
	std::map<std::string, Actuator> actuators() {
		// TODO: MISSING DEREF! USE #DEFINE!
		PyObject *seqval = PyObject_GetAttrString(pyobjref, "actuators");
		PyObject *seqkeys = PyObject_CallMethod(seqval, "keys", NULL);
		std::map<std::string, Actuator> resmap;
		for (int i = 0; i < PySequence_Length(seqval); i++) {
			PyObject *keyobj = PySequence_GetItem(seqkeys, i);
			std::string key = PyBytes_AsString(PyUnicode_AsASCIIString(keyobj));
			Actuator value = Actuator(PySequence_GetItem(seqval, i));
			resmap.insert(std::pair<std::string,Actuator>(key, value));
		}
		return resmap;
	}

	/** Setter: The list containing the actuators connected to the controller */
	void actuators(std::map<std::string, Actuator> value) { /* not implemented */ }

	/** Getter: Set Controller state index (1 to 30) */
	int states() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "states"));
	}

	/** Setter: Set Controller state index (1 to 30) */
	void states(int value) {
		PyObject_SetAttrString(pyobjref, "states", Py_BuildValue("i", value));
	}

	/**
	 * Link the controller with a sensor/actuator
	 * @param Sensor to link the controller to
	 * @param Actuator to link the controller to
	 */
	void link(Sensor sensor, Actuator actuator);

	/**
	 * Unlink the controller from a sensor/actuator
	 * @param Sensor to unlink the controller from
	 * @param Actuator to unlink the controller from
	 */
	void unlink(Sensor sensor, Actuator actuator);

};

/**************** Expression Controller ****************/

/**
 * Controller passing on events based on the evaluation of an expression
 */
class ExpressionController : public Controller {
public:
	ExpressionController(PyObject* pyobj) : Controller(pyobj) {}

	ExpressionController() : Controller(0)
	{
		// not implemented
	}

	/** Getter:  */
	std::string expression() { /* not implemented */ throw NULL; }
	/** Setter:  */
	void expression(const std::string& value) { /* not implemented */ }

};

/**************** Python Controller ****************/

/**
 * Controller executing a python script
 */
class PythonController : public Controller {
public:
	PythonController(PyObject* pyobj) : Controller(pyobj) {}

	PythonController() : Controller(0)
	{
		// not implemented
	}

	enum mode_enum {
		mode_SCRIPT = 0,
		mode_MODULE = 1,
	};

	/** Getter: Python script type (textblock or module - faster) */
	mode_enum mode() { /* not implemented */ throw NULL; }
	/** Setter: Python script type (textblock or module - faster) */
	void mode(mode_enum value) { /* not implemented */ }

	/** Getter: Text datablock with the python script */
	Text text();

	/** Getter: Module name and function to run, e.g. "someModule.main" (internal texts and external python files can be used) */
	std::string module() { /* not implemented */ throw NULL; }
	/** Setter: Module name and function to run, e.g. "someModule.main" (internal texts and external python files can be used) */
	void module(const std::string& value) { /* not implemented */ }

	/** Getter: Continuously reload the module from disk for editing external modules without restarting */
	bool use_debug() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_debug")) == 1;
	}

	/** Setter: Continuously reload the module from disk for editing external modules without restarting */
	void use_debug(bool value) {
		PyObject_SetAttrString(pyobjref, "use_debug", Py_BuildValue("i", value));
	}

};

/**************** And Controller ****************/

/**
 * Controller passing on events based on a logical AND operation
 */
class AndController : public Controller {
public:
	AndController(PyObject* pyobj) : Controller(pyobj) {}

	AndController() : Controller(0)
	{
		// not implemented
	}

};

/**************** Or Controller ****************/

/**
 * Controller passing on events based on a logical OR operation
 */
class OrController : public Controller {
public:
	OrController(PyObject* pyobj) : Controller(pyobj) {}

	OrController() : Controller(0)
	{
		// not implemented
	}

};

/**************** Nor Controller ****************/

/**
 * Controller passing on events based on a logical NOR operation
 */
class NorController : public Controller {
public:
	NorController(PyObject* pyobj) : Controller(pyobj) {}

	NorController() : Controller(0)
	{
		// not implemented
	}

};

/**************** Nand Controller ****************/

/**
 * Controller passing on events based on a logical NAND operation
 */
class NandController : public Controller {
public:
	NandController(PyObject* pyobj) : Controller(pyobj) {}

	NandController() : Controller(0)
	{
		// not implemented
	}

};

/**************** Xor Controller ****************/

/**
 * Controller passing on events based on a logical XOR operation
 */
class XorController : public Controller {
public:
	XorController(PyObject* pyobj) : Controller(pyobj) {}

	XorController() : Controller(0)
	{
		// not implemented
	}

};

/**************** Xnor Controller ****************/

/**
 * Controller passing on events based on a logical XNOR operation
 */
class XnorController : public Controller {
public:
	XnorController(PyObject* pyobj) : Controller(pyobj) {}

	XnorController() : Controller(0)
	{
		// not implemented
	}

};

/**************** Curve ****************/

/**
 * Curve datablock storing curves, splines and NURBS
 */
class Curve : public ID {
public:
	Curve(PyObject* pyobj) : ID(pyobj) {}

	Curve() : ID(0)
	{
		// not implemented
	}

	/** Getter:  */
	Key shape_keys();

	/** Getter: Collection of splines in this curve data object */
	std::map<std::string, Spline> splines();
	/** Setter: Collection of splines in this curve data object */
	void splines(std::map<std::string, Spline> value);

	/** Getter: Display Bezier handles in editmode */
	bool show_handles() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "show_handles")) == 1;
	}

	/** Setter: Display Bezier handles in editmode */
	void show_handles(bool value) {
		PyObject_SetAttrString(pyobjref, "show_handles", Py_BuildValue("i", value));
	}

	/** Getter: Display 3D curve normals in editmode */
	bool show_normal_face() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "show_normal_face")) == 1;
	}

	/** Setter: Display 3D curve normals in editmode */
	void show_normal_face(bool value) {
		PyObject_SetAttrString(pyobjref, "show_normal_face", Py_BuildValue("i", value));
	}

	/** Getter: The number of frames that are needed to traverse the path, defining the maximum value for the 'Evaluation Time' setting */
	int path_duration() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "path_duration"));
	}

	/** Setter: The number of frames that are needed to traverse the path, defining the maximum value for the 'Evaluation Time' setting */
	void path_duration(int value) {
		PyObject_SetAttrString(pyobjref, "path_duration", Py_BuildValue("i", value));
	}

	/** Getter: Enable the curve to become a translation path */
	bool use_path() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_path")) == 1;
	}

	/** Setter: Enable the curve to become a translation path */
	void use_path(bool value) {
		PyObject_SetAttrString(pyobjref, "use_path", Py_BuildValue("i", value));
	}

	/** Getter: Make curve path children to rotate along the path */
	bool use_path_follow() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_path_follow")) == 1;
	}

	/** Setter: Make curve path children to rotate along the path */
	void use_path_follow(bool value) {
		PyObject_SetAttrString(pyobjref, "use_path_follow", Py_BuildValue("i", value));
	}

	/** Getter: Option for curve-deform: make deformed child to stretch along entire path */
	bool use_stretch() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_stretch")) == 1;
	}

	/** Setter: Option for curve-deform: make deformed child to stretch along entire path */
	void use_stretch(bool value) {
		PyObject_SetAttrString(pyobjref, "use_stretch", Py_BuildValue("i", value));
	}

	/** Getter: Option for curve-deform: Use the mesh bounds to clamp the deformation */
	bool use_deform_bounds() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_deform_bounds")) == 1;
	}

	/** Setter: Option for curve-deform: Use the mesh bounds to clamp the deformation */
	void use_deform_bounds(bool value) {
		PyObject_SetAttrString(pyobjref, "use_deform_bounds", Py_BuildValue("i", value));
	}

	/** Getter: Option for paths and curve-deform: apply the curve radius with path following it and deforming */
	bool use_radius() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_radius")) == 1;
	}

	/** Setter: Option for paths and curve-deform: apply the curve radius with path following it and deforming */
	void use_radius(bool value) {
		PyObject_SetAttrString(pyobjref, "use_radius", Py_BuildValue("i", value));
	}

	/** Getter: Bevel resolution when depth is non-zero and no specific bevel object has been defined */
	int bevel_resolution() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "bevel_resolution"));
	}

	/** Setter: Bevel resolution when depth is non-zero and no specific bevel object has been defined */
	void bevel_resolution(int value) {
		PyObject_SetAttrString(pyobjref, "bevel_resolution", Py_BuildValue("i", value));
	}

	/** Getter: Offset the curve to adjust the width of a text */
	float offset() { /* not implemented */ throw NULL; }
	/** Setter: Offset the curve to adjust the width of a text */
	void offset(float value) {
		PyObject_SetAttrString(pyobjref, "offset", Py_BuildValue("f", value));
	}

	/** Getter: Amount of curve extrusion when not using a bevel object */
	float extrude() { /* not implemented */ throw NULL; }
	/** Setter: Amount of curve extrusion when not using a bevel object */
	void extrude(float value) {
		PyObject_SetAttrString(pyobjref, "extrude", Py_BuildValue("f", value));
	}

	/** Getter: Bevel depth when not using a bevel object */
	float bevel_depth() { /* not implemented */ throw NULL; }
	/** Setter: Bevel depth when not using a bevel object */
	void bevel_depth(float value) {
		PyObject_SetAttrString(pyobjref, "bevel_depth", Py_BuildValue("f", value));
	}

	/** Getter: Surface resolution in U direction */
	int resolution_u() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "resolution_u"));
	}

	/** Setter: Surface resolution in U direction */
	void resolution_u(int value) {
		PyObject_SetAttrString(pyobjref, "resolution_u", Py_BuildValue("i", value));
	}

	/** Getter: Surface resolution in V direction */
	int resolution_v() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "resolution_v"));
	}

	/** Setter: Surface resolution in V direction */
	void resolution_v(int value) {
		PyObject_SetAttrString(pyobjref, "resolution_v", Py_BuildValue("i", value));
	}

	/** Getter: Surface resolution in U direction used while rendering (zero uses preview resolution) */
	int render_resolution_u() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "render_resolution_u"));
	}

	/** Setter: Surface resolution in U direction used while rendering (zero uses preview resolution) */
	void render_resolution_u(int value) {
		PyObject_SetAttrString(pyobjref, "render_resolution_u", Py_BuildValue("i", value));
	}

	/** Getter: Surface resolution in V direction used while rendering (zero uses preview resolution) */
	int render_resolution_v() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "render_resolution_v"));
	}

	/** Setter: Surface resolution in V direction used while rendering (zero uses preview resolution) */
	void render_resolution_v(int value) {
		PyObject_SetAttrString(pyobjref, "render_resolution_v", Py_BuildValue("i", value));
	}

	/** Getter: Parametric position along the length of the curve that Objects 'following' it should be at (position is evaluated by dividing by the 'Path Length' value) */
	float eval_time() { /* not implemented */ throw NULL; }
	/** Setter: Parametric position along the length of the curve that Objects 'following' it should be at (position is evaluated by dividing by the 'Path Length' value) */
	void eval_time(float value) {
		PyObject_SetAttrString(pyobjref, "eval_time", Py_BuildValue("f", value));
	}

	/** Getter: Curve object name that defines the bevel shape */
	Object bevel_object();

	/** Getter: Curve object name that defines the taper (width) */
	Object taper_object();

	enum dimensions_enum {
		dimensions_2D = 0,
		dimensions_3D = 1,
	};

	/** Getter: Select 2D or 3D curve type */
	dimensions_enum dimensions() { /* not implemented */ throw NULL; }
	/** Setter: Select 2D or 3D curve type */
	void dimensions(dimensions_enum value) { /* not implemented */ }

	enum fill_mode_enum {
		fill_mode_FULL = 0,
		fill_mode_BACK = 4,
		fill_mode_FRONT = 2,
		fill_mode_HALF = 6,
	};

	/** Getter: Mode of filling curve */
	fill_mode_enum fill_mode() { /* not implemented */ throw NULL; }
	/** Setter: Mode of filling curve */
	void fill_mode(fill_mode_enum value) { /* not implemented */ }

	enum twist_mode_enum {
		twist_mode_Z_UP = 0,
		twist_mode_MINIMUM = 3,
		twist_mode_TANGENT = 4,
	};

	/** Getter: The type of tilt calculation for 3D Curves */
	twist_mode_enum twist_mode() { /* not implemented */ throw NULL; }
	/** Setter: The type of tilt calculation for 3D Curves */
	void twist_mode(twist_mode_enum value) { /* not implemented */ }

	enum bevel_factor_mapping_start_enum {
		bevel_factor_mapping_start_RESOLUTION = 0,
		bevel_factor_mapping_start_SEGMENTS = 1,
		bevel_factor_mapping_start_SPLINE = 2,
	};

	/** Getter: Determines how the start bevel factor is mapped to a spline */
	bevel_factor_mapping_start_enum bevel_factor_mapping_start() { /* not implemented */ throw NULL; }
	/** Setter: Determines how the start bevel factor is mapped to a spline */
	void bevel_factor_mapping_start(bevel_factor_mapping_start_enum value) { /* not implemented */ }

	enum bevel_factor_mapping_end_enum {
		bevel_factor_mapping_end_RESOLUTION = 0,
		bevel_factor_mapping_end_SEGMENTS = 1,
		bevel_factor_mapping_end_SPLINE = 2,
	};

	/** Getter: Determines how the end bevel factor is mapped to a spline */
	bevel_factor_mapping_end_enum bevel_factor_mapping_end() { /* not implemented */ throw NULL; }
	/** Setter: Determines how the end bevel factor is mapped to a spline */
	void bevel_factor_mapping_end(bevel_factor_mapping_end_enum value) { /* not implemented */ }

	/** Getter: Smoothing iteration for tangents */
	float twist_smooth() { /* not implemented */ throw NULL; }
	/** Setter: Smoothing iteration for tangents */
	void twist_smooth(float value) {
		PyObject_SetAttrString(pyobjref, "twist_smooth", Py_BuildValue("f", value));
	}

	/** Getter: Fill curve after applying shape keys and all modifiers */
	bool use_fill_deform() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_fill_deform")) == 1;
	}

	/** Setter: Fill curve after applying shape keys and all modifiers */
	void use_fill_deform(bool value) {
		PyObject_SetAttrString(pyobjref, "use_fill_deform", Py_BuildValue("i", value));
	}

	/** Getter: Fill caps for beveled curves */
	bool use_fill_caps() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_fill_caps")) == 1;
	}

	/** Setter: Fill caps for beveled curves */
	void use_fill_caps(bool value) {
		PyObject_SetAttrString(pyobjref, "use_fill_caps", Py_BuildValue("i", value));
	}

	/** Getter: Map effect of taper object on actually beveled curve */
	bool use_map_taper() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_map_taper")) == 1;
	}

	/** Setter: Map effect of taper object on actually beveled curve */
	void use_map_taper(bool value) {
		PyObject_SetAttrString(pyobjref, "use_map_taper", Py_BuildValue("i", value));
	}

	/** Getter: Adjust active object's texture space automatically when transforming object */
	bool use_auto_texspace() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_auto_texspace")) == 1;
	}

	/** Setter: Adjust active object's texture space automatically when transforming object */
	void use_auto_texspace(bool value) {
		PyObject_SetAttrString(pyobjref, "use_auto_texspace", Py_BuildValue("i", value));
	}

	/** Getter: Texture space location */
	std::array<float, 3> texspace_location() {
		// TODO: MISSING DEREF! USE #DEFINE!
		PyObject *seqval = PyObject_GetAttrString(pyobjref, "texspace_location");
		std::array<float, 3> resarr;
		for (int i = 0; i < 3; i++)
			resarr[i] = (float)PyFloat_AsDouble(PySequence_GetItem(seqval, i));
		return resarr;
	}

	/** Setter: Texture space location */
	void texspace_location(float values[3]) { /* not implemented */ }

	/** Getter: Texture space size */
	std::array<float, 3> texspace_size() {
		// TODO: MISSING DEREF! USE #DEFINE!
		PyObject *seqval = PyObject_GetAttrString(pyobjref, "texspace_size");
		std::array<float, 3> resarr;
		for (int i = 0; i < 3; i++)
			resarr[i] = (float)PyFloat_AsDouble(PySequence_GetItem(seqval, i));
		return resarr;
	}

	/** Setter: Texture space size */
	void texspace_size(float values[3]) { /* not implemented */ }

	/** Getter: Uses the UV values as Generated textured coordinates */
	bool use_uv_as_generated() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_uv_as_generated")) == 1;
	}

	/** Setter: Uses the UV values as Generated textured coordinates */
	void use_uv_as_generated(bool value) {
		PyObject_SetAttrString(pyobjref, "use_uv_as_generated", Py_BuildValue("i", value));
	}

	/** Getter:  */
	std::map<std::string, Material> materials();
	/** Setter:  */
	void materials(std::map<std::string, Material> value);

	/** Getter: Factor that defines from where beveling of spline happens (0=from the very beginning, 1=from the very end) */
	float bevel_factor_start() { /* not implemented */ throw NULL; }
	/** Setter: Factor that defines from where beveling of spline happens (0=from the very beginning, 1=from the very end) */
	void bevel_factor_start(float value) {
		PyObject_SetAttrString(pyobjref, "bevel_factor_start", Py_BuildValue("f", value));
	}

	/** Getter: Factor that defines to where beveling of spline happens (0=to the very beginning, 1=to the very end) */
	float bevel_factor_end() { /* not implemented */ throw NULL; }
	/** Setter: Factor that defines to where beveling of spline happens (0=to the very beginning, 1=to the very end) */
	void bevel_factor_end(float value) {
		PyObject_SetAttrString(pyobjref, "bevel_factor_end", Py_BuildValue("f", value));
	}

	/** Getter: True when used in editmode */
	bool is_editmode() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "is_editmode")) == 1;
	}

	/** Setter: True when used in editmode */
	void is_editmode(bool value) {
		PyObject_SetAttrString(pyobjref, "is_editmode", Py_BuildValue("i", value));
	}

	/** Getter: Animation data for this datablock */
	AnimData animation_data() {
		/* not implemented */ throw NULL;
	}

	/**
	 * Transform curve by a matrix
	 * @param Matrix
	 * @param Transform Shape Keys
	 */
	void transform(float matrix[16], bool shape_keys = false)
	{
		// not implemented
	}

	/**
	 * Validate material indices of splines or letters, return True when the curve has had invalid indices corrected (to default 0)
	 * @return 
	 */
	bool validate_material_indices()
	{
		// not implemented
		return true;
	}

};

/**************** Surface Curve ****************/

/**
 * Curve datablock used for storing surfaces
 */
class SurfaceCurve : public Curve {
public:
	SurfaceCurve(PyObject* pyobj) : Curve(pyobj) {}

	SurfaceCurve() : Curve(0)
	{
		// not implemented
	}

	/** Getter: Uses the UV values as Generated textured coordinates */
	bool use_uv_as_generated() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_uv_as_generated")) == 1;
	}

	/** Setter: Uses the UV values as Generated textured coordinates */
	void use_uv_as_generated(bool value) {
		PyObject_SetAttrString(pyobjref, "use_uv_as_generated", Py_BuildValue("i", value));
	}

};

/**************** Text Curve ****************/

/**
 * Curve datablock used for storing text
 */
class TextCurve : public Curve {
public:
	TextCurve(PyObject* pyobj) : Curve(pyobj) {}

	TextCurve() : Curve(0)
	{
		// not implemented
	}

	enum align_enum {
		align_LEFT = 0,
		align_CENTER = 1,
		align_RIGHT = 2,
		align_JUSTIFY = 3,
		align_FLUSH = 4,
	};

	/** Getter: Text align from the object center */
	align_enum align() { /* not implemented */ throw NULL; }
	/** Setter: Text align from the object center */
	void align(align_enum value) { /* not implemented */ }

	/** Getter:  */
	float size() { /* not implemented */ throw NULL; }
	/** Setter:  */
	void size(float value) {
		PyObject_SetAttrString(pyobjref, "size", Py_BuildValue("f", value));
	}

	/** Getter: Scale of small capitals */
	float small_caps_scale() { /* not implemented */ throw NULL; }
	/** Setter: Scale of small capitals */
	void small_caps_scale(float value) {
		PyObject_SetAttrString(pyobjref, "small_caps_scale", Py_BuildValue("f", value));
	}

	/** Getter:  */
	float space_line() { /* not implemented */ throw NULL; }
	/** Setter:  */
	void space_line(float value) {
		PyObject_SetAttrString(pyobjref, "space_line", Py_BuildValue("f", value));
	}

	/** Getter:  */
	float space_word() { /* not implemented */ throw NULL; }
	/** Setter:  */
	void space_word(float value) {
		PyObject_SetAttrString(pyobjref, "space_word", Py_BuildValue("f", value));
	}

	/** Getter:  */
	float space_character() { /* not implemented */ throw NULL; }
	/** Setter:  */
	void space_character(float value) {
		PyObject_SetAttrString(pyobjref, "space_character", Py_BuildValue("f", value));
	}

	/** Getter: Italic angle of the characters */
	float shear() { /* not implemented */ throw NULL; }
	/** Setter: Italic angle of the characters */
	void shear(float value) {
		PyObject_SetAttrString(pyobjref, "shear", Py_BuildValue("f", value));
	}

	/** Getter: Horizontal offset from the object origin */
	float offset_x() { /* not implemented */ throw NULL; }
	/** Setter: Horizontal offset from the object origin */
	void offset_x(float value) {
		PyObject_SetAttrString(pyobjref, "offset_x", Py_BuildValue("f", value));
	}

	/** Getter: Vertical offset from the object origin */
	float offset_y() { /* not implemented */ throw NULL; }
	/** Setter: Vertical offset from the object origin */
	void offset_y(float value) {
		PyObject_SetAttrString(pyobjref, "offset_y", Py_BuildValue("f", value));
	}

	/** Getter: Vertical position of underline */
	float underline_position() { /* not implemented */ throw NULL; }
	/** Setter: Vertical position of underline */
	void underline_position(float value) {
		PyObject_SetAttrString(pyobjref, "underline_position", Py_BuildValue("f", value));
	}

	/** Getter:  */
	float underline_height() { /* not implemented */ throw NULL; }
	/** Setter:  */
	void underline_height(float value) {
		PyObject_SetAttrString(pyobjref, "underline_height", Py_BuildValue("f", value));
	}

	/** Getter:  */
	std::map<std::string, TextBox> text_boxes();
	/** Setter:  */
	void text_boxes(std::map<std::string, TextBox> value);

	/** Getter:  */
	int active_textbox() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "active_textbox"));
	}

	/** Setter:  */
	void active_textbox(int value) {
		PyObject_SetAttrString(pyobjref, "active_textbox", Py_BuildValue("i", value));
	}

	/** Getter: Use Objects as font characters (give font objects a common name followed by the character they represent, eg. 'family_a', 'family_b', etc, set this setting to 'family_', and turn on Vertex Duplication) */
	std::string family() { /* not implemented */ throw NULL; }
	/** Setter: Use Objects as font characters (give font objects a common name followed by the character they represent, eg. 'family_a', 'family_b', etc, set this setting to 'family_', and turn on Vertex Duplication) */
	void family(const std::string& value) { /* not implemented */ }

	/** Getter: Content of this text object */
	std::string body() { /* not implemented */ throw NULL; }
	/** Setter: Content of this text object */
	void body(const std::string& value) { /* not implemented */ }

	/** Getter: Stores the style of each character */
	std::map<std::string, TextCharacterFormat> body_format();
	/** Setter: Stores the style of each character */
	void body_format(std::map<std::string, TextCharacterFormat> value);

	/** Getter: Curve deforming text object */
	Object follow_curve();

	/** Getter:  */
	VectorFont font();

	/** Getter:  */
	VectorFont font_bold();

	/** Getter:  */
	VectorFont font_italic();

	/** Getter:  */
	VectorFont font_bold_italic();

	/** Getter: Editing settings character formatting */
	TextCharacterFormat edit_format();

	/** Getter: Don't fill polygons while editing */
	bool use_fast_edit() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_fast_edit")) == 1;
	}

	/** Setter: Don't fill polygons while editing */
	void use_fast_edit(bool value) {
		PyObject_SetAttrString(pyobjref, "use_fast_edit", Py_BuildValue("i", value));
	}

	/** Getter: Uses the UV values as Generated textured coordinates */
	bool use_uv_as_generated() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_uv_as_generated")) == 1;
	}

	/** Setter: Uses the UV values as Generated textured coordinates */
	void use_uv_as_generated(bool value) {
		PyObject_SetAttrString(pyobjref, "use_uv_as_generated", Py_BuildValue("i", value));
	}

};

/**************** Text Box ****************/

/**
 * Text bounding box for layout
 */
class TextBox : public pyUniplug {
public:
	TextBox(PyObject* pyobj) : pyUniplug(pyobj) {}

	TextBox() : pyUniplug(0)
	{
		// not implemented
	}

	/** Getter:  */
	float x() { /* not implemented */ throw NULL; }
	/** Setter:  */
	void x(float value) {
		PyObject_SetAttrString(pyobjref, "x", Py_BuildValue("f", value));
	}

	/** Getter:  */
	float y() { /* not implemented */ throw NULL; }
	/** Setter:  */
	void y(float value) {
		PyObject_SetAttrString(pyobjref, "y", Py_BuildValue("f", value));
	}

	/** Getter:  */
	float width() { /* not implemented */ throw NULL; }
	/** Setter:  */
	void width(float value) {
		PyObject_SetAttrString(pyobjref, "width", Py_BuildValue("f", value));
	}

	/** Getter:  */
	float height() { /* not implemented */ throw NULL; }
	/** Setter:  */
	void height(float value) {
		PyObject_SetAttrString(pyobjref, "height", Py_BuildValue("f", value));
	}

};

/**************** Text Character Format ****************/

/**
 * Text character formatting settings
 */
class TextCharacterFormat : public pyUniplug {
public:
	TextCharacterFormat(PyObject* pyobj) : pyUniplug(pyobj) {}

	TextCharacterFormat() : pyUniplug(0)
	{
		// not implemented
	}

	/** Getter:  */
	bool use_bold() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_bold")) == 1;
	}

	/** Setter:  */
	void use_bold(bool value) {
		PyObject_SetAttrString(pyobjref, "use_bold", Py_BuildValue("i", value));
	}

	/** Getter:  */
	bool use_italic() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_italic")) == 1;
	}

	/** Setter:  */
	void use_italic(bool value) {
		PyObject_SetAttrString(pyobjref, "use_italic", Py_BuildValue("i", value));
	}

	/** Getter:  */
	bool use_underline() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_underline")) == 1;
	}

	/** Setter:  */
	void use_underline(bool value) {
		PyObject_SetAttrString(pyobjref, "use_underline", Py_BuildValue("i", value));
	}

	/** Getter:  */
	bool use_small_caps() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_small_caps")) == 1;
	}

	/** Setter:  */
	void use_small_caps(bool value) {
		PyObject_SetAttrString(pyobjref, "use_small_caps", Py_BuildValue("i", value));
	}

	/** Getter:  */
	int material_index() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "material_index"));
	}

	/** Setter:  */
	void material_index(int value) {
		PyObject_SetAttrString(pyobjref, "material_index", Py_BuildValue("i", value));
	}

};

/**************** SplinePoint ****************/

/**
 * Spline point without handles
 */
class SplinePoint : public pyUniplug {
public:
	SplinePoint(PyObject* pyobj) : pyUniplug(pyobj) {}

	SplinePoint() : pyUniplug(0)
	{
		// not implemented
	}

	/** Getter: Selection status */
	bool select() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "select")) == 1;
	}

	/** Setter: Selection status */
	void select(bool value) {
		PyObject_SetAttrString(pyobjref, "select", Py_BuildValue("i", value));
	}

	/** Getter: Visibility status */
	bool hide() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "hide")) == 1;
	}

	/** Setter: Visibility status */
	void hide(bool value) {
		PyObject_SetAttrString(pyobjref, "hide", Py_BuildValue("i", value));
	}

	/** Getter: Point coordinates */
	std::array<float, 4> co() {
		// TODO: MISSING DEREF! USE #DEFINE!
		PyObject *seqval = PyObject_GetAttrString(pyobjref, "co");
		std::array<float, 4> resarr;
		for (int i = 0; i < 4; i++)
			resarr[i] = (float)PyFloat_AsDouble(PySequence_GetItem(seqval, i));
		return resarr;
	}

	/** Setter: Point coordinates */
	void co(float values[4]) { /* not implemented */ }

	/** Getter: NURBS weight */
	float weight() { /* not implemented */ throw NULL; }
	/** Setter: NURBS weight */
	void weight(float value) {
		PyObject_SetAttrString(pyobjref, "weight", Py_BuildValue("f", value));
	}

	/** Getter: Tilt in 3D View */
	float tilt() { /* not implemented */ throw NULL; }
	/** Setter: Tilt in 3D View */
	void tilt(float value) {
		PyObject_SetAttrString(pyobjref, "tilt", Py_BuildValue("f", value));
	}

	/** Getter: Softbody goal weight */
	float weight_softbody() { /* not implemented */ throw NULL; }
	/** Setter: Softbody goal weight */
	void weight_softbody(float value) {
		PyObject_SetAttrString(pyobjref, "weight_softbody", Py_BuildValue("f", value));
	}

	/** Getter: Radius for beveling */
	float radius() { /* not implemented */ throw NULL; }
	/** Setter: Radius for beveling */
	void radius(float value) {
		PyObject_SetAttrString(pyobjref, "radius", Py_BuildValue("f", value));
	}

};

/**************** Bezier Curve Point ****************/

/**
 * Bezier curve point with two handles
 */
class BezierSplinePoint : public pyUniplug {
public:
	BezierSplinePoint(PyObject* pyobj) : pyUniplug(pyobj) {}

	BezierSplinePoint() : pyUniplug(0)
	{
		// not implemented
	}

	/** Getter: Handle 1 selection status */
	bool select_left_handle() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "select_left_handle")) == 1;
	}

	/** Setter: Handle 1 selection status */
	void select_left_handle(bool value) {
		PyObject_SetAttrString(pyobjref, "select_left_handle", Py_BuildValue("i", value));
	}

	/** Getter: Handle 2 selection status */
	bool select_right_handle() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "select_right_handle")) == 1;
	}

	/** Setter: Handle 2 selection status */
	void select_right_handle(bool value) {
		PyObject_SetAttrString(pyobjref, "select_right_handle", Py_BuildValue("i", value));
	}

	/** Getter: Control point selection status */
	bool select_control_point() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "select_control_point")) == 1;
	}

	/** Setter: Control point selection status */
	void select_control_point(bool value) {
		PyObject_SetAttrString(pyobjref, "select_control_point", Py_BuildValue("i", value));
	}

	/** Getter: Visibility status */
	bool hide() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "hide")) == 1;
	}

	/** Setter: Visibility status */
	void hide(bool value) {
		PyObject_SetAttrString(pyobjref, "hide", Py_BuildValue("i", value));
	}

	enum handle_left_type_enum {
		handle_left_type_FREE = 0,
		handle_left_type_VECTOR = 2,
		handle_left_type_ALIGNED = 3,
		handle_left_type_AUTO = 1,
	};

	/** Getter: Handle types */
	handle_left_type_enum handle_left_type() { /* not implemented */ throw NULL; }
	/** Setter: Handle types */
	void handle_left_type(handle_left_type_enum value) { /* not implemented */ }

	enum handle_right_type_enum {
		handle_right_type_FREE = 0,
		handle_right_type_VECTOR = 2,
		handle_right_type_ALIGNED = 3,
		handle_right_type_AUTO = 1,
	};

	/** Getter: Handle types */
	handle_right_type_enum handle_right_type() { /* not implemented */ throw NULL; }
	/** Setter: Handle types */
	void handle_right_type(handle_right_type_enum value) { /* not implemented */ }

	/** Getter: Coordinates of the first handle */
	std::array<float, 3> handle_left() {
		// TODO: MISSING DEREF! USE #DEFINE!
		PyObject *seqval = PyObject_GetAttrString(pyobjref, "handle_left");
		std::array<float, 3> resarr;
		for (int i = 0; i < 3; i++)
			resarr[i] = (float)PyFloat_AsDouble(PySequence_GetItem(seqval, i));
		return resarr;
	}

	/** Setter: Coordinates of the first handle */
	void handle_left(float values[3]) { /* not implemented */ }

	/** Getter: Coordinates of the control point */
	std::array<float, 3> co() {
		// TODO: MISSING DEREF! USE #DEFINE!
		PyObject *seqval = PyObject_GetAttrString(pyobjref, "co");
		std::array<float, 3> resarr;
		for (int i = 0; i < 3; i++)
			resarr[i] = (float)PyFloat_AsDouble(PySequence_GetItem(seqval, i));
		return resarr;
	}

	/** Setter: Coordinates of the control point */
	void co(float values[3]) { /* not implemented */ }

	/** Getter: Coordinates of the second handle */
	std::array<float, 3> handle_right() {
		// TODO: MISSING DEREF! USE #DEFINE!
		PyObject *seqval = PyObject_GetAttrString(pyobjref, "handle_right");
		std::array<float, 3> resarr;
		for (int i = 0; i < 3; i++)
			resarr[i] = (float)PyFloat_AsDouble(PySequence_GetItem(seqval, i));
		return resarr;
	}

	/** Setter: Coordinates of the second handle */
	void handle_right(float values[3]) { /* not implemented */ }

	/** Getter: Tilt in 3D View */
	float tilt() { /* not implemented */ throw NULL; }
	/** Setter: Tilt in 3D View */
	void tilt(float value) {
		PyObject_SetAttrString(pyobjref, "tilt", Py_BuildValue("f", value));
	}

	/** Getter: Softbody goal weight */
	float weight_softbody() { /* not implemented */ throw NULL; }
	/** Setter: Softbody goal weight */
	void weight_softbody(float value) {
		PyObject_SetAttrString(pyobjref, "weight_softbody", Py_BuildValue("f", value));
	}

	/** Getter: Radius for beveling */
	float radius() { /* not implemented */ throw NULL; }
	/** Setter: Radius for beveling */
	void radius(float value) {
		PyObject_SetAttrString(pyobjref, "radius", Py_BuildValue("f", value));
	}

};

/**************** Spline ****************/

/**
 * Element of a curve, either NURBS, Bezier or Polyline or a character with text objects
 */
class Spline : public pyUniplug {
public:
	Spline(PyObject* pyobj) : pyUniplug(pyobj) {}

	Spline() : pyUniplug(0)
	{
		// not implemented
	}

	/** Getter: Collection of points that make up this poly or nurbs spline */
	std::map<std::string, SplinePoint> points() {
		// TODO: MISSING DEREF! USE #DEFINE!
		PyObject *seqval = PyObject_GetAttrString(pyobjref, "points");
		PyObject *seqkeys = PyObject_CallMethod(seqval, "keys", NULL);
		std::map<std::string, SplinePoint> resmap;
		for (int i = 0; i < PySequence_Length(seqval); i++) {
			PyObject *keyobj = PySequence_GetItem(seqkeys, i);
			std::string key = PyBytes_AsString(PyUnicode_AsASCIIString(keyobj));
			SplinePoint value = SplinePoint(PySequence_GetItem(seqval, i));
			resmap.insert(std::pair<std::string,SplinePoint>(key, value));
		}
		return resmap;
	}

	/** Setter: Collection of points that make up this poly or nurbs spline */
	void points(std::map<std::string, SplinePoint> value) { /* not implemented */ }

	/** Getter: Collection of points for Bezier curves only */
	std::map<std::string, BezierSplinePoint> bezier_points() {
		// TODO: MISSING DEREF! USE #DEFINE!
		PyObject *seqval = PyObject_GetAttrString(pyobjref, "bezier_points");
		PyObject *seqkeys = PyObject_CallMethod(seqval, "keys", NULL);
		std::map<std::string, BezierSplinePoint> resmap;
		for (int i = 0; i < PySequence_Length(seqval); i++) {
			PyObject *keyobj = PySequence_GetItem(seqkeys, i);
			std::string key = PyBytes_AsString(PyUnicode_AsASCIIString(keyobj));
			BezierSplinePoint value = BezierSplinePoint(PySequence_GetItem(seqval, i));
			resmap.insert(std::pair<std::string,BezierSplinePoint>(key, value));
		}
		return resmap;
	}

	/** Setter: Collection of points for Bezier curves only */
	void bezier_points(std::map<std::string, BezierSplinePoint> value) { /* not implemented */ }

	enum tilt_interpolation_enum {
		tilt_interpolation_LINEAR = 0,
		tilt_interpolation_CARDINAL = 1,
		tilt_interpolation_BSPLINE = 2,
		tilt_interpolation_EASE = 3,
	};

	/** Getter: The type of tilt interpolation for 3D, Bezier curves */
	tilt_interpolation_enum tilt_interpolation() { /* not implemented */ throw NULL; }
	/** Setter: The type of tilt interpolation for 3D, Bezier curves */
	void tilt_interpolation(tilt_interpolation_enum value) { /* not implemented */ }

	enum radius_interpolation_enum {
		radius_interpolation_LINEAR = 0,
		radius_interpolation_CARDINAL = 1,
		radius_interpolation_BSPLINE = 2,
		radius_interpolation_EASE = 3,
	};

	/** Getter: The type of radius interpolation for Bezier curves */
	radius_interpolation_enum radius_interpolation() { /* not implemented */ throw NULL; }
	/** Setter: The type of radius interpolation for Bezier curves */
	void radius_interpolation(radius_interpolation_enum value) { /* not implemented */ }

	enum type_enum {
		type_POLY = 0,
		type_BEZIER = 1,
		type_BSPLINE = 2,
		type_CARDINAL = 3,
		type_NURBS = 4,
	};

	/** Getter: The interpolation type for this curve element */
	type_enum type() { /* not implemented */ throw NULL; }
	/** Setter: The interpolation type for this curve element */
	void type(type_enum value) { /* not implemented */ }

	/** Getter: Total number points for the curve or surface in the U direction */
	int point_count_u() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "point_count_u"));
	}

	/** Setter: Total number points for the curve or surface in the U direction */
	void point_count_u(int value) {
		PyObject_SetAttrString(pyobjref, "point_count_u", Py_BuildValue("i", value));
	}

	/** Getter: Total number points for the surface on the V direction */
	int point_count_v() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "point_count_v"));
	}

	/** Setter: Total number points for the surface on the V direction */
	void point_count_v(int value) {
		PyObject_SetAttrString(pyobjref, "point_count_v", Py_BuildValue("i", value));
	}

	/** Getter: NURBS order in the U direction (for splines and surfaces, higher values let points influence a greater area) */
	int order_u() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "order_u"));
	}

	/** Setter: NURBS order in the U direction (for splines and surfaces, higher values let points influence a greater area) */
	void order_u(int value) {
		PyObject_SetAttrString(pyobjref, "order_u", Py_BuildValue("i", value));
	}

	/** Getter: NURBS order in the V direction (for surfaces only, higher values let points influence a greater area) */
	int order_v() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "order_v"));
	}

	/** Setter: NURBS order in the V direction (for surfaces only, higher values let points influence a greater area) */
	void order_v(int value) {
		PyObject_SetAttrString(pyobjref, "order_v", Py_BuildValue("i", value));
	}

	/** Getter: Curve or Surface subdivisions per segment */
	int resolution_u() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "resolution_u"));
	}

	/** Setter: Curve or Surface subdivisions per segment */
	void resolution_u(int value) {
		PyObject_SetAttrString(pyobjref, "resolution_u", Py_BuildValue("i", value));
	}

	/** Getter: Surface subdivisions per segment */
	int resolution_v() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "resolution_v"));
	}

	/** Setter: Surface subdivisions per segment */
	void resolution_v(int value) {
		PyObject_SetAttrString(pyobjref, "resolution_v", Py_BuildValue("i", value));
	}

	/** Getter: Make this curve or surface a closed loop in the U direction */
	bool use_cyclic_u() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_cyclic_u")) == 1;
	}

	/** Setter: Make this curve or surface a closed loop in the U direction */
	void use_cyclic_u(bool value) {
		PyObject_SetAttrString(pyobjref, "use_cyclic_u", Py_BuildValue("i", value));
	}

	/** Getter: Make this surface a closed loop in the V direction */
	bool use_cyclic_v() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_cyclic_v")) == 1;
	}

	/** Setter: Make this surface a closed loop in the V direction */
	void use_cyclic_v(bool value) {
		PyObject_SetAttrString(pyobjref, "use_cyclic_v", Py_BuildValue("i", value));
	}

	/** Getter: Make this nurbs curve or surface meet the endpoints in the U direction (Cyclic U must be disabled) */
	bool use_endpoint_u() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_endpoint_u")) == 1;
	}

	/** Setter: Make this nurbs curve or surface meet the endpoints in the U direction (Cyclic U must be disabled) */
	void use_endpoint_u(bool value) {
		PyObject_SetAttrString(pyobjref, "use_endpoint_u", Py_BuildValue("i", value));
	}

	/** Getter: Make this nurbs surface meet the endpoints in the V direction (Cyclic V must be disabled) */
	bool use_endpoint_v() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_endpoint_v")) == 1;
	}

	/** Setter: Make this nurbs surface meet the endpoints in the V direction (Cyclic V must be disabled) */
	void use_endpoint_v(bool value) {
		PyObject_SetAttrString(pyobjref, "use_endpoint_v", Py_BuildValue("i", value));
	}

	/** Getter: Make this nurbs curve or surface act like a Bezier spline in the U direction (Order U must be 3 or 4, Cyclic U must be disabled) */
	bool use_bezier_u() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_bezier_u")) == 1;
	}

	/** Setter: Make this nurbs curve or surface act like a Bezier spline in the U direction (Order U must be 3 or 4, Cyclic U must be disabled) */
	void use_bezier_u(bool value) {
		PyObject_SetAttrString(pyobjref, "use_bezier_u", Py_BuildValue("i", value));
	}

	/** Getter: Make this nurbs surface act like a Bezier spline in the V direction (Order V must be 3 or 4, Cyclic V must be disabled) */
	bool use_bezier_v() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_bezier_v")) == 1;
	}

	/** Setter: Make this nurbs surface act like a Bezier spline in the V direction (Order V must be 3 or 4, Cyclic V must be disabled) */
	void use_bezier_v(bool value) {
		PyObject_SetAttrString(pyobjref, "use_bezier_v", Py_BuildValue("i", value));
	}

	/** Getter: Smooth the normals of the surface or beveled curve */
	bool use_smooth() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_smooth")) == 1;
	}

	/** Setter: Smooth the normals of the surface or beveled curve */
	void use_smooth(bool value) {
		PyObject_SetAttrString(pyobjref, "use_smooth", Py_BuildValue("i", value));
	}

	/** Getter: Hide this curve in Edit mode */
	bool hide() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "hide")) == 1;
	}

	/** Setter: Hide this curve in Edit mode */
	void hide(bool value) {
		PyObject_SetAttrString(pyobjref, "hide", Py_BuildValue("i", value));
	}

	/** Getter:  */
	int material_index() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "material_index"));
	}

	/** Setter:  */
	void material_index(int value) {
		PyObject_SetAttrString(pyobjref, "material_index", Py_BuildValue("i", value));
	}

	/** Getter: Location of this character in the text data (only for text curves) */
	int character_index() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "character_index"));
	}

	/** Setter: Location of this character in the text data (only for text curves) */
	void character_index(int value) {
		PyObject_SetAttrString(pyobjref, "character_index", Py_BuildValue("i", value));
	}

};

/**************** Dependency Graph ****************/

/**
 * 
 */
class Depsgraph : public pyUniplug {
public:
	Depsgraph(PyObject* pyobj) : pyUniplug(pyobj) {}

	Depsgraph() : pyUniplug(0)
	{
		// not implemented
	}

	/**
	 * Function: debug_graphviz
	 * @param File in which to store graphviz debug output
	 */
	void debug_graphviz(const std::string filename)
	{
		// not implemented
	}

	/**
	 * Function: debug_rebuild
	 */
	void debug_rebuild()
	{
		// not implemented
	}

	/**
	 * Report the number of elements in the Dependency Graph
	 */
	void debug_stats()
	{
		// not implemented
	}

};

/**************** Canvas Settings ****************/

/**
 * Dynamic Paint canvas settings
 */
class DynamicPaintCanvasSettings : public pyUniplug {
public:
	DynamicPaintCanvasSettings(PyObject* pyobj) : pyUniplug(pyobj) {}

	DynamicPaintCanvasSettings() : pyUniplug(0)
	{
		// not implemented
	}

	/** Getter: Paint surface list */
	std::map<std::string, DynamicPaintSurface> canvas_surfaces();
	/** Setter: Paint surface list */
	void canvas_surfaces(std::map<std::string, DynamicPaintSurface> value);

};

/**************** Brush Settings ****************/

/**
 * Brush settings
 */
class DynamicPaintBrushSettings : public pyUniplug {
public:
	DynamicPaintBrushSettings(PyObject* pyobj) : pyUniplug(pyobj) {}

	DynamicPaintBrushSettings() : pyUniplug(0)
	{
		// not implemented
	}

	/** Getter: Color of the paint */
	std::array<float, 3> paint_color() {
		// TODO: MISSING DEREF! USE #DEFINE!
		PyObject *seqval = PyObject_GetAttrString(pyobjref, "paint_color");
		std::array<float, 3> resarr;
		for (int i = 0; i < 3; i++)
			resarr[i] = (float)PyFloat_AsDouble(PySequence_GetItem(seqval, i));
		return resarr;
	}

	/** Setter: Color of the paint */
	void paint_color(float values[3]) { /* not implemented */ }

	/** Getter: Paint alpha */
	float paint_alpha() { /* not implemented */ throw NULL; }
	/** Setter: Paint alpha */
	void paint_alpha(float value) {
		PyObject_SetAttrString(pyobjref, "paint_alpha", Py_BuildValue("f", value));
	}

	/** Getter: Use object material to define color and influence */
	bool use_material() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_material")) == 1;
	}

	/** Setter: Use object material to define color and influence */
	void use_material(bool value) {
		PyObject_SetAttrString(pyobjref, "use_material", Py_BuildValue("i", value));
	}

	/** Getter: Material to use (if not defined, material linked to the mesh is used) */
	Material material();

	/** Getter: Only increase alpha value if paint alpha is higher than existing */
	bool use_absolute_alpha() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_absolute_alpha")) == 1;
	}

	/** Setter: Only increase alpha value if paint alpha is higher than existing */
	void use_absolute_alpha(bool value) {
		PyObject_SetAttrString(pyobjref, "use_absolute_alpha", Py_BuildValue("i", value));
	}

	/** Getter: Paint wetness, visible in wetmap (some effects only affect wet paint) */
	float paint_wetness() { /* not implemented */ throw NULL; }
	/** Setter: Paint wetness, visible in wetmap (some effects only affect wet paint) */
	void paint_wetness(float value) {
		PyObject_SetAttrString(pyobjref, "paint_wetness", Py_BuildValue("f", value));
	}

	/** Getter: Erase / remove paint instead of adding it */
	bool use_paint_erase() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_paint_erase")) == 1;
	}

	/** Setter: Erase / remove paint instead of adding it */
	void use_paint_erase(bool value) {
		PyObject_SetAttrString(pyobjref, "use_paint_erase", Py_BuildValue("i", value));
	}

	enum wave_type_enum {
		wave_type_CHANGE = 3,
		wave_type_DEPTH = 0,
		wave_type_FORCE = 1,
		wave_type_REFLECT = 2,
	};

	/** Getter:  */
	wave_type_enum wave_type() { /* not implemented */ throw NULL; }
	/** Setter:  */
	void wave_type(wave_type_enum value) { /* not implemented */ }

	/** Getter: Multiplier for wave influence of this brush */
	float wave_factor() { /* not implemented */ throw NULL; }
	/** Setter: Multiplier for wave influence of this brush */
	void wave_factor(float value) {
		PyObject_SetAttrString(pyobjref, "wave_factor", Py_BuildValue("f", value));
	}

	/** Getter: Maximum level of surface intersection used to influence waves (use 0.0 to disable) */
	float wave_clamp() { /* not implemented */ throw NULL; }
	/** Setter: Maximum level of surface intersection used to influence waves (use 0.0 to disable) */
	void wave_clamp(float value) {
		PyObject_SetAttrString(pyobjref, "wave_clamp", Py_BuildValue("f", value));
	}

	/** Getter: Make this brush to smudge existing paint as it moves */
	bool use_smudge() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_smudge")) == 1;
	}

	/** Setter: Make this brush to smudge existing paint as it moves */
	void use_smudge(bool value) {
		PyObject_SetAttrString(pyobjref, "use_smudge", Py_BuildValue("i", value));
	}

	/** Getter: Smudge effect strength */
	float smudge_strength() { /* not implemented */ throw NULL; }
	/** Setter: Smudge effect strength */
	void smudge_strength(float value) {
		PyObject_SetAttrString(pyobjref, "smudge_strength", Py_BuildValue("f", value));
	}

	/** Getter: Velocity considered as maximum influence (Blender units per frame) */
	float velocity_max() { /* not implemented */ throw NULL; }
	/** Setter: Velocity considered as maximum influence (Blender units per frame) */
	void velocity_max(float value) {
		PyObject_SetAttrString(pyobjref, "velocity_max", Py_BuildValue("f", value));
	}

	/** Getter: Multiply brush influence by velocity color ramp alpha */
	bool use_velocity_alpha() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_velocity_alpha")) == 1;
	}

	/** Setter: Multiply brush influence by velocity color ramp alpha */
	void use_velocity_alpha(bool value) {
		PyObject_SetAttrString(pyobjref, "use_velocity_alpha", Py_BuildValue("i", value));
	}

	/** Getter: Multiply brush intersection depth (displace, waves) by velocity ramp alpha */
	bool use_velocity_depth() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_velocity_depth")) == 1;
	}

	/** Setter: Multiply brush intersection depth (displace, waves) by velocity ramp alpha */
	void use_velocity_depth(bool value) {
		PyObject_SetAttrString(pyobjref, "use_velocity_depth", Py_BuildValue("i", value));
	}

	/** Getter: Replace brush color by velocity color ramp */
	bool use_velocity_color() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_velocity_color")) == 1;
	}

	/** Setter: Replace brush color by velocity color ramp */
	void use_velocity_color(bool value) {
		PyObject_SetAttrString(pyobjref, "use_velocity_color", Py_BuildValue("i", value));
	}

	enum paint_source_enum {
		paint_source_PARTICLE_SYSTEM = 3,
		paint_source_POINT = 4,
		paint_source_DISTANCE = 1,
		paint_source_VOLUME_DISTANCE = 2,
		paint_source_VOLUME = 0,
	};

	/** Getter:  */
	paint_source_enum paint_source() { /* not implemented */ throw NULL; }
	/** Setter:  */
	void paint_source(paint_source_enum value) { /* not implemented */ }

	/** Getter: Maximum distance from brush to mesh surface to affect paint */
	float paint_distance() { /* not implemented */ throw NULL; }
	/** Setter: Maximum distance from brush to mesh surface to affect paint */
	void paint_distance(float value) {
		PyObject_SetAttrString(pyobjref, "paint_distance", Py_BuildValue("f", value));
	}

	/** Getter: Only read color ramp alpha */
	bool use_proximity_ramp_alpha() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_proximity_ramp_alpha")) == 1;
	}

	/** Setter: Only read color ramp alpha */
	void use_proximity_ramp_alpha(bool value) {
		PyObject_SetAttrString(pyobjref, "use_proximity_ramp_alpha", Py_BuildValue("i", value));
	}

	enum proximity_falloff_enum {
		proximity_falloff_SMOOTH = 1,
		proximity_falloff_CONSTANT = 0,
		proximity_falloff_RAMP = 2,
	};

	/** Getter: Proximity falloff type */
	proximity_falloff_enum proximity_falloff() { /* not implemented */ throw NULL; }
	/** Setter: Proximity falloff type */
	void proximity_falloff(proximity_falloff_enum value) { /* not implemented */ }

	/** Getter: Brush is projected to canvas from defined direction within brush proximity */
	bool use_proximity_project() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_proximity_project")) == 1;
	}

	/** Setter: Brush is projected to canvas from defined direction within brush proximity */
	void use_proximity_project(bool value) {
		PyObject_SetAttrString(pyobjref, "use_proximity_project", Py_BuildValue("i", value));
	}

	enum ray_direction_enum {
		ray_direction_CANVAS = 0,
		ray_direction_BRUSH = 1,
		ray_direction_Z_AXIS = 2,
	};

	/** Getter: Ray direction to use for projection (if brush object is located in that direction it's painted) */
	ray_direction_enum ray_direction() { /* not implemented */ throw NULL; }
	/** Setter: Ray direction to use for projection (if brush object is located in that direction it's painted) */
	void ray_direction(ray_direction_enum value) { /* not implemented */ }

	/** Getter: Proximity falloff is applied inside the volume */
	bool invert_proximity() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "invert_proximity")) == 1;
	}

	/** Setter: Proximity falloff is applied inside the volume */
	void invert_proximity(bool value) {
		PyObject_SetAttrString(pyobjref, "invert_proximity", Py_BuildValue("i", value));
	}

	/** Getter: Negate influence inside the volume */
	bool use_negative_volume() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_negative_volume")) == 1;
	}

	/** Setter: Negate influence inside the volume */
	void use_negative_volume(bool value) {
		PyObject_SetAttrString(pyobjref, "use_negative_volume", Py_BuildValue("i", value));
	}

	/** Getter: The particle system to paint with */
	ParticleSystem particle_system();

	/** Getter: Use radius from particle settings */
	bool use_particle_radius() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_particle_radius")) == 1;
	}

	/** Setter: Use radius from particle settings */
	void use_particle_radius(bool value) {
		PyObject_SetAttrString(pyobjref, "use_particle_radius", Py_BuildValue("i", value));
	}

	/** Getter: Radius that will be painted solid */
	float solid_radius() { /* not implemented */ throw NULL; }
	/** Setter: Radius that will be painted solid */
	void solid_radius(float value) {
		PyObject_SetAttrString(pyobjref, "solid_radius", Py_BuildValue("f", value));
	}

	/** Getter: Smooth falloff added after solid radius */
	float smooth_radius() { /* not implemented */ throw NULL; }
	/** Setter: Smooth falloff added after solid radius */
	void smooth_radius(float value) {
		PyObject_SetAttrString(pyobjref, "smooth_radius", Py_BuildValue("f", value));
	}

	/** Getter: Color ramp used to define proximity falloff */
	ColorRamp paint_ramp() {
		/* not implemented */ throw NULL;
	}

	/** Getter: Color ramp used to define brush velocity effect */
	ColorRamp velocity_ramp() {
		/* not implemented */ throw NULL;
	}

};

/**************** Paint Surface ****************/

/**
 * A canvas surface layer
 */
class DynamicPaintSurface : public pyUniplug {
public:
	DynamicPaintSurface(PyObject* pyobj) : pyUniplug(pyobj) {}

	DynamicPaintSurface() : pyUniplug(0)
	{
		// not implemented
	}

	enum surface_format_enum {
		surface_format_VERTEX = 1,
		surface_format_IMAGE = 2,
	};

	/** Getter: Surface Format */
	surface_format_enum surface_format() { /* not implemented */ throw NULL; }
	/** Setter: Surface Format */
	void surface_format(surface_format_enum value) { /* not implemented */ }

	enum surface_type_enum {
		surface_type_PAINT = 0,
	};

	/** Getter: Surface Type */
	surface_type_enum surface_type() { /* not implemented */ throw NULL; }
	/** Setter: Surface Type */
	void surface_type(surface_type_enum value) { /* not implemented */ }

	/** Getter: Toggle whether surface is processed or ignored */
	bool is_active() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "is_active")) == 1;
	}

	/** Setter: Toggle whether surface is processed or ignored */
	void is_active(bool value) {
		PyObject_SetAttrString(pyobjref, "is_active", Py_BuildValue("i", value));
	}

	/** Getter: Display surface preview in 3D-views */
	bool show_preview() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "show_preview")) == 1;
	}

	/** Setter: Display surface preview in 3D-views */
	void show_preview(bool value) {
		PyObject_SetAttrString(pyobjref, "show_preview", Py_BuildValue("i", value));
	}

	/** Getter: Surface name */
	std::string name() { /* not implemented */ throw NULL; }
	/** Setter: Surface name */
	void name(const std::string& value) { /* not implemented */ }

	/** Getter: Only use brush objects from this group */
	Group brush_group();

	/** Getter: Enable to make surface changes disappear over time */
	bool use_dissolve() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_dissolve")) == 1;
	}

	/** Setter: Enable to make surface changes disappear over time */
	void use_dissolve(bool value) {
		PyObject_SetAttrString(pyobjref, "use_dissolve", Py_BuildValue("i", value));
	}

	/** Getter: Approximately in how many frames should dissolve happen */
	int dissolve_speed() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "dissolve_speed"));
	}

	/** Setter: Approximately in how many frames should dissolve happen */
	void dissolve_speed(int value) {
		PyObject_SetAttrString(pyobjref, "dissolve_speed", Py_BuildValue("i", value));
	}

	/** Getter: Enable to make surface wetness dry over time */
	bool use_drying() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_drying")) == 1;
	}

	/** Setter: Enable to make surface wetness dry over time */
	void use_drying(bool value) {
		PyObject_SetAttrString(pyobjref, "use_drying", Py_BuildValue("i", value));
	}

	/** Getter: Approximately in how many frames should drying happen */
	int dry_speed() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "dry_speed"));
	}

	/** Setter: Approximately in how many frames should drying happen */
	void dry_speed(int value) {
		PyObject_SetAttrString(pyobjref, "dry_speed", Py_BuildValue("i", value));
	}

	/** Getter: Output image resolution */
	int image_resolution() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "image_resolution"));
	}

	/** Setter: Output image resolution */
	void image_resolution(int value) {
		PyObject_SetAttrString(pyobjref, "image_resolution", Py_BuildValue("i", value));
	}

	/** Getter: UV map name */
	std::string uv_layer() { /* not implemented */ throw NULL; }
	/** Setter: UV map name */
	void uv_layer(const std::string& value) { /* not implemented */ }

	/** Getter: Simulation start frame */
	int frame_start() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "frame_start"));
	}

	/** Setter: Simulation start frame */
	void frame_start(int value) {
		PyObject_SetAttrString(pyobjref, "frame_start", Py_BuildValue("i", value));
	}

	/** Getter: Simulation end frame */
	int frame_end() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "frame_end"));
	}

	/** Setter: Simulation end frame */
	void frame_end(int value) {
		PyObject_SetAttrString(pyobjref, "frame_end", Py_BuildValue("i", value));
	}

	/** Getter: Do extra frames between scene frames to ensure smooth motion */
	int frame_substeps() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "frame_substeps"));
	}

	/** Setter: Do extra frames between scene frames to ensure smooth motion */
	void frame_substeps(int value) {
		PyObject_SetAttrString(pyobjref, "frame_substeps", Py_BuildValue("i", value));
	}

	/** Getter: Use 5x multisampling to smooth paint edges */
	bool use_antialiasing() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_antialiasing")) == 1;
	}

	/** Setter: Use 5x multisampling to smooth paint edges */
	void use_antialiasing(bool value) {
		PyObject_SetAttrString(pyobjref, "use_antialiasing", Py_BuildValue("i", value));
	}

	/** Getter: Adjust influence brush objects have on this surface */
	float brush_influence_scale() { /* not implemented */ throw NULL; }
	/** Setter: Adjust influence brush objects have on this surface */
	void brush_influence_scale(float value) {
		PyObject_SetAttrString(pyobjref, "brush_influence_scale", Py_BuildValue("f", value));
	}

	/** Getter: Adjust radius of proximity brushes or particles for this surface */
	float brush_radius_scale() { /* not implemented */ throw NULL; }
	/** Setter: Adjust radius of proximity brushes or particles for this surface */
	void brush_radius_scale(float value) {
		PyObject_SetAttrString(pyobjref, "brush_radius_scale", Py_BuildValue("f", value));
	}

	enum init_color_type_enum {
		init_color_type_NONE = 0,
		init_color_type_COLOR = 1,
		init_color_type_TEXTURE = 2,
		init_color_type_VERTEX_COLOR = 3,
	};

	/** Getter:  */
	init_color_type_enum init_color_type() { /* not implemented */ throw NULL; }
	/** Setter:  */
	void init_color_type(init_color_type_enum value) { /* not implemented */ }

	/** Getter: Initial color of the surface */
	std::array<float, 4> init_color() {
		// TODO: MISSING DEREF! USE #DEFINE!
		PyObject *seqval = PyObject_GetAttrString(pyobjref, "init_color");
		std::array<float, 4> resarr;
		for (int i = 0; i < 4; i++)
			resarr[i] = (float)PyFloat_AsDouble(PySequence_GetItem(seqval, i));
		return resarr;
	}

	/** Setter: Initial color of the surface */
	void init_color(float values[4]) { /* not implemented */ }

	/** Getter:  */
	Texture init_texture() {
		/* not implemented */ throw NULL;
	}

	/** Getter:  */
	std::string init_layername() { /* not implemented */ throw NULL; }
	/** Setter:  */
	void init_layername(const std::string& value) { /* not implemented */ }

	enum effect_ui_enum {
		effect_ui_SPREAD = 1,
		effect_ui_DRIP = 2,
		effect_ui_SHRINK = 3,
	};

	/** Getter:  */
	effect_ui_enum effect_ui() { /* not implemented */ throw NULL; }
	/** Setter:  */
	void effect_ui(effect_ui_enum value) { /* not implemented */ }

	/** Getter: Use logarithmic drying (makes high values to dry faster than low values) */
	bool use_dry_log() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_dry_log")) == 1;
	}

	/** Setter: Use logarithmic drying (makes high values to dry faster than low values) */
	void use_dry_log(bool value) {
		PyObject_SetAttrString(pyobjref, "use_dry_log", Py_BuildValue("i", value));
	}

	/** Getter: Use logarithmic dissolve (makes high values to fade faster than low values) */
	bool use_dissolve_log() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_dissolve_log")) == 1;
	}

	/** Setter: Use logarithmic dissolve (makes high values to fade faster than low values) */
	void use_dissolve_log(bool value) {
		PyObject_SetAttrString(pyobjref, "use_dissolve_log", Py_BuildValue("i", value));
	}

	/** Getter: Process spread effect (spread wet paint around surface) */
	bool use_spread() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_spread")) == 1;
	}

	/** Setter: Process spread effect (spread wet paint around surface) */
	void use_spread(bool value) {
		PyObject_SetAttrString(pyobjref, "use_spread", Py_BuildValue("i", value));
	}

	/** Getter: How fast spread effect moves on the canvas surface */
	float spread_speed() { /* not implemented */ throw NULL; }
	/** Setter: How fast spread effect moves on the canvas surface */
	void spread_speed(float value) {
		PyObject_SetAttrString(pyobjref, "spread_speed", Py_BuildValue("f", value));
	}

	/** Getter: The wetness level when colors start to shift to the background */
	float color_dry_threshold() { /* not implemented */ throw NULL; }
	/** Setter: The wetness level when colors start to shift to the background */
	void color_dry_threshold(float value) {
		PyObject_SetAttrString(pyobjref, "color_dry_threshold", Py_BuildValue("f", value));
	}

	/** Getter: How fast colors get mixed within wet paint */
	float color_spread_speed() { /* not implemented */ throw NULL; }
	/** Setter: How fast colors get mixed within wet paint */
	void color_spread_speed(float value) {
		PyObject_SetAttrString(pyobjref, "color_spread_speed", Py_BuildValue("f", value));
	}

	/** Getter: Process drip effect (drip wet paint to gravity direction) */
	bool use_drip() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_drip")) == 1;
	}

	/** Setter: Process drip effect (drip wet paint to gravity direction) */
	void use_drip(bool value) {
		PyObject_SetAttrString(pyobjref, "use_drip", Py_BuildValue("i", value));
	}

	/** Getter: Process shrink effect (shrink paint areas) */
	bool use_shrink() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_shrink")) == 1;
	}

	/** Setter: Process shrink effect (shrink paint areas) */
	void use_shrink(bool value) {
		PyObject_SetAttrString(pyobjref, "use_shrink", Py_BuildValue("i", value));
	}

	/** Getter: How fast shrink effect moves on the canvas surface */
	float shrink_speed() { /* not implemented */ throw NULL; }
	/** Setter: How fast shrink effect moves on the canvas surface */
	void shrink_speed(float value) {
		PyObject_SetAttrString(pyobjref, "shrink_speed", Py_BuildValue("f", value));
	}

	/** Getter:  */
	EffectorWeights effector_weights();

	/** Getter: How much surface velocity affects dripping */
	float drip_velocity() { /* not implemented */ throw NULL; }
	/** Setter: How much surface velocity affects dripping */
	void drip_velocity(float value) {
		PyObject_SetAttrString(pyobjref, "drip_velocity", Py_BuildValue("f", value));
	}

	/** Getter: How much surface acceleration affects dripping */
	float drip_acceleration() { /* not implemented */ throw NULL; }
	/** Setter: How much surface acceleration affects dripping */
	void drip_acceleration(float value) {
		PyObject_SetAttrString(pyobjref, "drip_acceleration", Py_BuildValue("f", value));
	}

	/** Getter: Multiply color by alpha (recommended for Blender input) */
	bool use_premultiply() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_premultiply")) == 1;
	}

	/** Setter: Multiply color by alpha (recommended for Blender input) */
	void use_premultiply(bool value) {
		PyObject_SetAttrString(pyobjref, "use_premultiply", Py_BuildValue("i", value));
	}

	/** Getter: Directory to save the textures */
	std::string image_output_path() { /* not implemented */ throw NULL; }
	/** Setter: Directory to save the textures */
	void image_output_path(const std::string& value) { /* not implemented */ }

	/** Getter: Name used to save output from this surface */
	std::string output_name_a() { /* not implemented */ throw NULL; }
	/** Setter: Name used to save output from this surface */
	void output_name_a(const std::string& value) { /* not implemented */ }

	/** Getter: Save this output layer */
	bool use_output_a() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_output_a")) == 1;
	}

	/** Setter: Save this output layer */
	void use_output_a(bool value) {
		PyObject_SetAttrString(pyobjref, "use_output_a", Py_BuildValue("i", value));
	}

	/** Getter: Name used to save output from this surface */
	std::string output_name_b() { /* not implemented */ throw NULL; }
	/** Setter: Name used to save output from this surface */
	void output_name_b(const std::string& value) { /* not implemented */ }

	/** Getter: Save this output layer */
	bool use_output_b() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_output_b")) == 1;
	}

	/** Setter: Save this output layer */
	void use_output_b(bool value) {
		PyObject_SetAttrString(pyobjref, "use_output_b", Py_BuildValue("i", value));
	}

	enum preview_id_enum {
		preview_id_PAINT = 0,
		preview_id_WETMAP = 1,
	};

	/** Getter:  */
	preview_id_enum preview_id() { /* not implemented */ throw NULL; }
	/** Setter:  */
	void preview_id(preview_id_enum value) { /* not implemented */ }

	/** Getter: Maximum level of depth intersection in object space (use 0.0 to disable) */
	float depth_clamp() { /* not implemented */ throw NULL; }
	/** Setter: Maximum level of depth intersection in object space (use 0.0 to disable) */
	void depth_clamp(float value) {
		PyObject_SetAttrString(pyobjref, "depth_clamp", Py_BuildValue("f", value));
	}

	/** Getter: Strength of displace when applied to the mesh */
	float displace_factor() { /* not implemented */ throw NULL; }
	/** Setter: Strength of displace when applied to the mesh */
	void displace_factor(float value) {
		PyObject_SetAttrString(pyobjref, "displace_factor", Py_BuildValue("f", value));
	}

	enum image_fileformat_enum {
		image_fileformat_PNG = 0,
		image_fileformat_OPENEXR = 1,
	};

	/** Getter:  */
	image_fileformat_enum image_fileformat() { /* not implemented */ throw NULL; }
	/** Setter:  */
	void image_fileformat(image_fileformat_enum value) { /* not implemented */ }

	enum displace_type_enum {
		displace_type_DISPLACE = 0,
		displace_type_DEPTH = 1,
	};

	/** Getter:  */
	displace_type_enum displace_type() { /* not implemented */ throw NULL; }
	/** Setter:  */
	void displace_type(displace_type_enum value) { /* not implemented */ }

	/** Getter: New displace is added cumulatively on top of existing */
	bool use_incremental_displace() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_incremental_displace")) == 1;
	}

	/** Setter: New displace is added cumulatively on top of existing */
	void use_incremental_displace(bool value) {
		PyObject_SetAttrString(pyobjref, "use_incremental_displace", Py_BuildValue("i", value));
	}

	/** Getter: Wave damping factor */
	float wave_damping() { /* not implemented */ throw NULL; }
	/** Setter: Wave damping factor */
	void wave_damping(float value) {
		PyObject_SetAttrString(pyobjref, "wave_damping", Py_BuildValue("f", value));
	}

	/** Getter: Wave propagation speed */
	float wave_speed() { /* not implemented */ throw NULL; }
	/** Setter: Wave propagation speed */
	void wave_speed(float value) {
		PyObject_SetAttrString(pyobjref, "wave_speed", Py_BuildValue("f", value));
	}

	/** Getter: Wave time scaling factor */
	float wave_timescale() { /* not implemented */ throw NULL; }
	/** Setter: Wave time scaling factor */
	void wave_timescale(float value) {
		PyObject_SetAttrString(pyobjref, "wave_timescale", Py_BuildValue("f", value));
	}

	/** Getter: Spring force that pulls water level back to zero */
	float wave_spring() { /* not implemented */ throw NULL; }
	/** Setter: Spring force that pulls water level back to zero */
	void wave_spring(float value) {
		PyObject_SetAttrString(pyobjref, "wave_spring", Py_BuildValue("f", value));
	}

	/** Getter: Limit maximum steepness of wave slope between simulation points (use higher values for smoother waves at expense of reduced detail) */
	float wave_smoothness() { /* not implemented */ throw NULL; }
	/** Setter: Limit maximum steepness of wave slope between simulation points (use higher values for smoother waves at expense of reduced detail) */
	void wave_smoothness(float value) {
		PyObject_SetAttrString(pyobjref, "wave_smoothness", Py_BuildValue("f", value));
	}

	/** Getter: Pass waves through mesh edges */
	bool use_wave_open_border() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_wave_open_border")) == 1;
	}

	/** Setter: Pass waves through mesh edges */
	void use_wave_open_border(bool value) {
		PyObject_SetAttrString(pyobjref, "use_wave_open_border", Py_BuildValue("i", value));
	}

	/** Getter:  */
	PointCache point_cache();

	/** Getter:  */
	bool is_cache_user() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "is_cache_user")) == 1;
	}

	/** Setter:  */
	void is_cache_user(bool value) {
		PyObject_SetAttrString(pyobjref, "is_cache_user", Py_BuildValue("i", value));
	}

	/** Getter: Whether this surface has some color preview for 3D view */
	bool use_color_preview() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_color_preview")) == 1;
	}

	/** Setter: Whether this surface has some color preview for 3D view */
	void use_color_preview(bool value) {
		PyObject_SetAttrString(pyobjref, "use_color_preview", Py_BuildValue("i", value));
	}

	/**
	 * Checks if surface output layer of given name exists
	 * @param Param 'object_value'
	 * @param Param 'index'
	 * @return 
	 */
	bool output_exists(Object object_value, int index);

};

/**************** F-Curve ****************/

/**
 * F-Curve defining values of a period of time
 */
class FCurve : public pyUniplug {
public:
	FCurve(PyObject* pyobj) : pyUniplug(pyobj) {}

	FCurve() : pyUniplug(0)
	{
		// not implemented
	}

	enum extrapolation_enum {
		extrapolation_CONSTANT = 0,
		extrapolation_LINEAR = 1,
	};

	/** Getter: Method used for evaluating value of F-Curve outside first and last keyframes */
	extrapolation_enum extrapolation() { /* not implemented */ throw NULL; }
	/** Setter: Method used for evaluating value of F-Curve outside first and last keyframes */
	void extrapolation(extrapolation_enum value) { /* not implemented */ }

	/** Getter: Channel Driver (only set for Driver F-Curves) */
	Driver driver();

	/** Getter: Action Group that this F-Curve belongs to */
	ActionGroup group() {
		/* not implemented */ throw NULL;
	}

	/** Getter: RNA Path to property affected by F-Curve */
	std::string data_path() { /* not implemented */ throw NULL; }
	/** Setter: RNA Path to property affected by F-Curve */
	void data_path(const std::string& value) { /* not implemented */ }

	/** Getter: Index to the specific property affected by F-Curve if applicable */
	int array_index() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "array_index"));
	}

	/** Setter: Index to the specific property affected by F-Curve if applicable */
	void array_index(int value) {
		PyObject_SetAttrString(pyobjref, "array_index", Py_BuildValue("i", value));
	}

	enum color_mode_enum {
		color_mode_AUTO_RAINBOW = 0,
		color_mode_AUTO_RGB = 1,
		color_mode_CUSTOM = 2,
	};

	/** Getter: Method used to determine color of F-Curve in Graph Editor */
	color_mode_enum color_mode() { /* not implemented */ throw NULL; }
	/** Setter: Method used to determine color of F-Curve in Graph Editor */
	void color_mode(color_mode_enum value) { /* not implemented */ }

	/** Getter: Color of the F-Curve in the Graph Editor */
	std::array<float, 3> color() {
		// TODO: MISSING DEREF! USE #DEFINE!
		PyObject *seqval = PyObject_GetAttrString(pyobjref, "color");
		std::array<float, 3> resarr;
		for (int i = 0; i < 3; i++)
			resarr[i] = (float)PyFloat_AsDouble(PySequence_GetItem(seqval, i));
		return resarr;
	}

	/** Setter: Color of the F-Curve in the Graph Editor */
	void color(float values[3]) { /* not implemented */ }

	/** Getter: F-Curve is selected for editing */
	bool select() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "select")) == 1;
	}

	/** Setter: F-Curve is selected for editing */
	void select(bool value) {
		PyObject_SetAttrString(pyobjref, "select", Py_BuildValue("i", value));
	}

	/** Getter: F-Curve's settings cannot be edited */
	bool lock_value() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "lock")) == 1;
	}

	/** Setter: F-Curve's settings cannot be edited */
	void lock_value(bool value) {
		PyObject_SetAttrString(pyobjref, "lock", Py_BuildValue("i", value));
	}

	/** Getter: F-Curve is not evaluated */
	bool mute() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "mute")) == 1;
	}

	/** Setter: F-Curve is not evaluated */
	void mute(bool value) {
		PyObject_SetAttrString(pyobjref, "mute", Py_BuildValue("i", value));
	}

	/** Getter: F-Curve and its keyframes are hidden in the Graph Editor graphs */
	bool hide() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "hide")) == 1;
	}

	/** Setter: F-Curve and its keyframes are hidden in the Graph Editor graphs */
	void hide(bool value) {
		PyObject_SetAttrString(pyobjref, "hide", Py_BuildValue("i", value));
	}

	/** Getter: False when F-Curve could not be evaluated in past, so should be skipped when evaluating */
	bool is_valid() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "is_valid")) == 1;
	}

	/** Setter: False when F-Curve could not be evaluated in past, so should be skipped when evaluating */
	void is_valid(bool value) {
		PyObject_SetAttrString(pyobjref, "is_valid", Py_BuildValue("i", value));
	}

	/** Getter: Sampled animation data */
	std::map<std::string, FCurveSample> sampled_points();
	/** Setter: Sampled animation data */
	void sampled_points(std::map<std::string, FCurveSample> value);

	/** Getter: User-editable keyframes */
	std::map<std::string, Keyframe> keyframe_points();
	/** Setter: User-editable keyframes */
	void keyframe_points(std::map<std::string, Keyframe> value);

	/** Getter: Modifiers affecting the shape of the F-Curve */
	std::map<std::string, FModifier> modifiers();
	/** Setter: Modifiers affecting the shape of the F-Curve */
	void modifiers(std::map<std::string, FModifier> value);

	/**
	 * Evaluate F-Curve
	 * @param Evaluate F-Curve at given frame
	 * @return Value of F-Curve specific frame
	 */
	float evaluate(float frame)
	{
		// not implemented
		throw NULL;
	}

	/**
	 * Ensure keyframes are sorted in chronological order and handles are set correctly
	 */
	void update()
	{
		// not implemented
	}

	/**
	 * Get the time extents for F-Curve
	 * @return Min/Max values
	 */
	std::array<float, 2> range()
	{
		// not implemented
		throw NULL;
	}

	/**
	 * Update FCurve flags set automatically from affected property (currently, integer/discrete flags set when the property is not a float)
	 * @param Data containing the property controlled by given FCurve
	 */
	void update_autoflags(AnyType data)
	{
		// not implemented
	}

	/**
	 * Convert current FCurve from keyframes to sample points, if necessary
	 * @param Param 'start'
	 * @param Param 'end'
	 */
	void convert_to_samples(int start, int end)
	{
		// not implemented
	}

	/**
	 * Convert current FCurve from sample points to keyframes (linear interpolation), if necessary
	 * @param Param 'start'
	 * @param Param 'end'
	 */
	void convert_to_keyframes(int start, int end)
	{
		// not implemented
	}

};

/**************** Keyframe ****************/

/**
 * Bezier curve point with two handles defining a Keyframe on an F-Curve
 */
class Keyframe : public pyUniplug {
public:
	Keyframe(PyObject* pyobj) : pyUniplug(pyobj) {}

	Keyframe() : pyUniplug(0)
	{
		// not implemented
	}

	/** Getter: Left handle selection status */
	bool select_left_handle() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "select_left_handle")) == 1;
	}

	/** Setter: Left handle selection status */
	void select_left_handle(bool value) {
		PyObject_SetAttrString(pyobjref, "select_left_handle", Py_BuildValue("i", value));
	}

	/** Getter: Right handle selection status */
	bool select_right_handle() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "select_right_handle")) == 1;
	}

	/** Setter: Right handle selection status */
	void select_right_handle(bool value) {
		PyObject_SetAttrString(pyobjref, "select_right_handle", Py_BuildValue("i", value));
	}

	/** Getter: Control point selection status */
	bool select_control_point() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "select_control_point")) == 1;
	}

	/** Setter: Control point selection status */
	void select_control_point(bool value) {
		PyObject_SetAttrString(pyobjref, "select_control_point", Py_BuildValue("i", value));
	}

	enum handle_left_type_enum {
		handle_left_type_FREE = 0,
		handle_left_type_VECTOR = 2,
		handle_left_type_ALIGNED = 3,
		handle_left_type_AUTO = 1,
		handle_left_type_AUTO_CLAMPED = 4,
	};

	/** Getter: Handle types */
	handle_left_type_enum handle_left_type() { /* not implemented */ throw NULL; }
	/** Setter: Handle types */
	void handle_left_type(handle_left_type_enum value) { /* not implemented */ }

	enum handle_right_type_enum {
		handle_right_type_FREE = 0,
		handle_right_type_VECTOR = 2,
		handle_right_type_ALIGNED = 3,
		handle_right_type_AUTO = 1,
		handle_right_type_AUTO_CLAMPED = 4,
	};

	/** Getter: Handle types */
	handle_right_type_enum handle_right_type() { /* not implemented */ throw NULL; }
	/** Setter: Handle types */
	void handle_right_type(handle_right_type_enum value) { /* not implemented */ }

	enum interpolation_enum {
		interpolation_CONSTANT = 0,
		interpolation_LINEAR = 1,
		interpolation_BEZIER = 2,
		interpolation_SINE = 12,
		interpolation_QUAD = 9,
		interpolation_CUBIC = 6,
		interpolation_QUART = 10,
		interpolation_QUINT = 11,
		interpolation_EXPO = 8,
		interpolation_CIRC = 5,
		interpolation_BACK = 3,
		interpolation_BOUNCE = 4,
		interpolation_ELASTIC = 7,
	};

	/** Getter: Interpolation method to use for segment of the F-Curve from this Keyframe until the next Keyframe */
	interpolation_enum interpolation() { /* not implemented */ throw NULL; }
	/** Setter: Interpolation method to use for segment of the F-Curve from this Keyframe until the next Keyframe */
	void interpolation(interpolation_enum value) { /* not implemented */ }

	enum type_enum {
		type_KEYFRAME = 0,
		type_BREAKDOWN = 2,
		type_EXTREME = 1,
		type_JITTER = 3,
	};

	/** Getter: Type of keyframe (for visual purposes only) */
	type_enum type() { /* not implemented */ throw NULL; }
	/** Setter: Type of keyframe (for visual purposes only) */
	void type(type_enum value) { /* not implemented */ }

	enum easing_enum {
		easing_AUTO = 0,
		easing_EASE_IN = 1,
		easing_EASE_OUT = 2,
		easing_EASE_IN_OUT = 3,
	};

	/** Getter: Which ends of the segment between this and the next keyframe easing interpolation is applied to */
	easing_enum easing() { /* not implemented */ throw NULL; }
	/** Setter: Which ends of the segment between this and the next keyframe easing interpolation is applied to */
	void easing(easing_enum value) { /* not implemented */ }

	/** Getter: Amount of overshoot for 'back' easing */
	float back() { /* not implemented */ throw NULL; }
	/** Setter: Amount of overshoot for 'back' easing */
	void back(float value) {
		PyObject_SetAttrString(pyobjref, "back", Py_BuildValue("f", value));
	}

	/** Getter: Amount to boost elastic bounces for 'elastic' easing */
	float amplitude() { /* not implemented */ throw NULL; }
	/** Setter: Amount to boost elastic bounces for 'elastic' easing */
	void amplitude(float value) {
		PyObject_SetAttrString(pyobjref, "amplitude", Py_BuildValue("f", value));
	}

	/** Getter: Time between bounces for elastic easing */
	float period() { /* not implemented */ throw NULL; }
	/** Setter: Time between bounces for elastic easing */
	void period(float value) {
		PyObject_SetAttrString(pyobjref, "period", Py_BuildValue("f", value));
	}

	/** Getter: Coordinates of the left handle (before the control point) */
	std::array<float, 2> handle_left() {
		// TODO: MISSING DEREF! USE #DEFINE!
		PyObject *seqval = PyObject_GetAttrString(pyobjref, "handle_left");
		std::array<float, 2> resarr;
		for (int i = 0; i < 2; i++)
			resarr[i] = (float)PyFloat_AsDouble(PySequence_GetItem(seqval, i));
		return resarr;
	}

	/** Setter: Coordinates of the left handle (before the control point) */
	void handle_left(float values[2]) { /* not implemented */ }

	/** Getter: Coordinates of the control point */
	std::array<float, 2> co() {
		// TODO: MISSING DEREF! USE #DEFINE!
		PyObject *seqval = PyObject_GetAttrString(pyobjref, "co");
		std::array<float, 2> resarr;
		for (int i = 0; i < 2; i++)
			resarr[i] = (float)PyFloat_AsDouble(PySequence_GetItem(seqval, i));
		return resarr;
	}

	/** Setter: Coordinates of the control point */
	void co(float values[2]) { /* not implemented */ }

	/** Getter: Coordinates of the right handle (after the control point) */
	std::array<float, 2> handle_right() {
		// TODO: MISSING DEREF! USE #DEFINE!
		PyObject *seqval = PyObject_GetAttrString(pyobjref, "handle_right");
		std::array<float, 2> resarr;
		for (int i = 0; i < 2; i++)
			resarr[i] = (float)PyFloat_AsDouble(PySequence_GetItem(seqval, i));
		return resarr;
	}

	/** Setter: Coordinates of the right handle (after the control point) */
	void handle_right(float values[2]) { /* not implemented */ }

};

/**************** F-Curve Sample ****************/

/**
 * Sample point for F-Curve
 */
class FCurveSample : public pyUniplug {
public:
	FCurveSample(PyObject* pyobj) : pyUniplug(pyobj) {}

	FCurveSample() : pyUniplug(0)
	{
		// not implemented
	}

	/** Getter: Selection status */
	bool select() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "select")) == 1;
	}

	/** Setter: Selection status */
	void select(bool value) {
		PyObject_SetAttrString(pyobjref, "select", Py_BuildValue("i", value));
	}

	/** Getter: Point coordinates */
	std::array<float, 2> co() {
		// TODO: MISSING DEREF! USE #DEFINE!
		PyObject *seqval = PyObject_GetAttrString(pyobjref, "co");
		std::array<float, 2> resarr;
		for (int i = 0; i < 2; i++)
			resarr[i] = (float)PyFloat_AsDouble(PySequence_GetItem(seqval, i));
		return resarr;
	}

	/** Setter: Point coordinates */
	void co(float values[2]) { /* not implemented */ }

};

/**************** Driver Target ****************/

/**
 * Source of input values for driver variables
 */
class DriverTarget : public pyUniplug {
public:
	DriverTarget(PyObject* pyobj) : pyUniplug(pyobj) {}

	DriverTarget() : pyUniplug(0)
	{
		// not implemented
	}

	/** Getter: ID-block that the specific property used can be found from (id_type property must be set first) */
	ID id() {
		/* not implemented */ throw NULL;
	}

	enum id_type_enum {
		id_type_ACTION = 17217,
		id_type_ARMATURE = 21057,
		id_type_BRUSH = 21058,
		id_type_CAMERA = 16707,
		id_type_CURVE = 21827,
		id_type_FONT = 18006,
		id_type_GREASEPENCIL = 17479,
		id_type_GROUP = 21063,
		id_type_IMAGE = 19785,
		id_type_KEY = 17739,
		id_type_LAMP = 16716,
		id_type_LIBRARY = 18764,
		id_type_LINESTYLE = 21324,
		id_type_LATTICE = 21580,
		id_type_MASK = 21325,
		id_type_MATERIAL = 16717,
		id_type_META = 16973,
		id_type_MESH = 17741,
		id_type_MOVIECLIP = 17229,
		id_type_NODETREE = 21582,
		id_type_OBJECT = 16975,
		id_type_PAINTCURVE = 17232,
		id_type_PALETTE = 19536,
		id_type_PARTICLE = 16720,
		id_type_SCENE = 17235,
		id_type_SCREEN = 21075,
		id_type_SOUND = 20307,
		id_type_SPEAKER = 19283,
		id_type_TEXT = 22612,
		id_type_TEXTURE = 17748,
		id_type_WINDOWMANAGER = 19799,
		id_type_WORLD = 20311,
	};

	/** Getter: Type of ID-block that can be used */
	id_type_enum id_type() { /* not implemented */ throw NULL; }
	/** Setter: Type of ID-block that can be used */
	void id_type(id_type_enum value) { /* not implemented */ }

	/** Getter: RNA Path (from ID-block) to property used */
	std::string data_path() { /* not implemented */ throw NULL; }
	/** Setter: RNA Path (from ID-block) to property used */
	void data_path(const std::string& value) { /* not implemented */ }

	/** Getter: Name of PoseBone to use as target */
	std::string bone_target() { /* not implemented */ throw NULL; }
	/** Setter: Name of PoseBone to use as target */
	void bone_target(const std::string& value) { /* not implemented */ }

	enum transform_type_enum {
		transform_type_LOC_X = 0,
		transform_type_LOC_Y = 1,
		transform_type_LOC_Z = 2,
		transform_type_ROT_X = 3,
		transform_type_ROT_Y = 4,
		transform_type_ROT_Z = 5,
		transform_type_SCALE_X = 6,
		transform_type_SCALE_Y = 7,
		transform_type_SCALE_Z = 8,
	};

	/** Getter: Driver variable type */
	transform_type_enum transform_type() { /* not implemented */ throw NULL; }
	/** Setter: Driver variable type */
	void transform_type(transform_type_enum value) { /* not implemented */ }

	enum transform_space_enum {
		transform_space_WORLD_SPACE = 0,
		transform_space_TRANSFORM_SPACE = 4,
		transform_space_LOCAL_SPACE = 12,
	};

	/** Getter: Space in which transforms are used */
	transform_space_enum transform_space() { /* not implemented */ throw NULL; }
	/** Setter: Space in which transforms are used */
	void transform_space(transform_space_enum value) { /* not implemented */ }

};

/**************** Driver Variable ****************/

/**
 * Variable from some source/target for driver relationship
 */
class DriverVariable : public pyUniplug {
public:
	DriverVariable(PyObject* pyobj) : pyUniplug(pyobj) {}

	DriverVariable() : pyUniplug(0)
	{
		// not implemented
	}

	/** Getter: Name to use in scripted expressions/functions (no spaces or dots are allowed, and must start with a letter) */
	std::string name() { /* not implemented */ throw NULL; }
	/** Setter: Name to use in scripted expressions/functions (no spaces or dots are allowed, and must start with a letter) */
	void name(const std::string& value) { /* not implemented */ }

	enum type_enum {
		type_SINGLE_PROP = 0,
		type_TRANSFORMS = 3,
		type_ROTATION_DIFF = 1,
		type_LOC_DIFF = 2,
	};

	/** Getter: Driver variable type */
	type_enum type() { /* not implemented */ throw NULL; }
	/** Setter: Driver variable type */
	void type(type_enum value) { /* not implemented */ }

	/** Getter: Sources of input data for evaluating this variable */
	std::map<std::string, DriverTarget> targets() {
		// TODO: MISSING DEREF! USE #DEFINE!
		PyObject *seqval = PyObject_GetAttrString(pyobjref, "targets");
		PyObject *seqkeys = PyObject_CallMethod(seqval, "keys", NULL);
		std::map<std::string, DriverTarget> resmap;
		for (int i = 0; i < PySequence_Length(seqval); i++) {
			PyObject *keyobj = PySequence_GetItem(seqkeys, i);
			std::string key = PyBytes_AsString(PyUnicode_AsASCIIString(keyobj));
			DriverTarget value = DriverTarget(PySequence_GetItem(seqval, i));
			resmap.insert(std::pair<std::string,DriverTarget>(key, value));
		}
		return resmap;
	}

	/** Setter: Sources of input data for evaluating this variable */
	void targets(std::map<std::string, DriverTarget> value) { /* not implemented */ }

};

/**************** Driver ****************/

/**
 * Driver for the value of a setting based on an external value
 */
class Driver : public pyUniplug {
public:
	Driver(PyObject* pyobj) : pyUniplug(pyobj) {}

	Driver() : pyUniplug(0)
	{
		// not implemented
	}

	enum type_enum {
		type_AVERAGE = 0,
		type_SUM = 2,
		type_SCRIPTED = 1,
		type_MIN = 3,
		type_MAX = 4,
	};

	/** Getter: Driver type */
	type_enum type() { /* not implemented */ throw NULL; }
	/** Setter: Driver type */
	void type(type_enum value) { /* not implemented */ }

	/** Getter: Expression to use for Scripted Expression */
	std::string expression() { /* not implemented */ throw NULL; }
	/** Setter: Expression to use for Scripted Expression */
	void expression(const std::string& value) { /* not implemented */ }

	/** Getter: Properties acting as inputs for this driver */
	std::map<std::string, DriverVariable> variables() {
		// TODO: MISSING DEREF! USE #DEFINE!
		PyObject *seqval = PyObject_GetAttrString(pyobjref, "variables");
		PyObject *seqkeys = PyObject_CallMethod(seqval, "keys", NULL);
		std::map<std::string, DriverVariable> resmap;
		for (int i = 0; i < PySequence_Length(seqval); i++) {
			PyObject *keyobj = PySequence_GetItem(seqkeys, i);
			std::string key = PyBytes_AsString(PyUnicode_AsASCIIString(keyobj));
			DriverVariable value = DriverVariable(PySequence_GetItem(seqval, i));
			resmap.insert(std::pair<std::string,DriverVariable>(key, value));
		}
		return resmap;
	}

	/** Setter: Properties acting as inputs for this driver */
	void variables(std::map<std::string, DriverVariable> value) { /* not implemented */ }

	/** Getter: Show intermediate values for the driver calculations to allow debugging of drivers */
	bool show_debug_info() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "show_debug_info")) == 1;
	}

	/** Setter: Show intermediate values for the driver calculations to allow debugging of drivers */
	void show_debug_info(bool value) {
		PyObject_SetAttrString(pyobjref, "show_debug_info", Py_BuildValue("i", value));
	}

	/** Getter: Driver could not be evaluated in past, so should be skipped */
	bool is_valid() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "is_valid")) == 1;
	}

	/** Setter: Driver could not be evaluated in past, so should be skipped */
	void is_valid(bool value) {
		PyObject_SetAttrString(pyobjref, "is_valid", Py_BuildValue("i", value));
	}

};

/**************** F-Modifier ****************/

/**
 * Modifier for values of F-Curve
 */
class FModifier : public pyUniplug {
public:
	FModifier(PyObject* pyobj) : pyUniplug(pyobj) {}

	FModifier() : pyUniplug(0)
	{
		// not implemented
	}

	enum type_enum {
		type_NULL = 0,
		type_GENERATOR = 1,
		type_FNGENERATOR = 2,
		type_ENVELOPE = 3,
		type_CYCLES = 4,
		type_NOISE = 5,
		type_PYTHON = 7,
		type_LIMITS = 8,
		type_STEPPED = 9,
	};

	/** Getter: F-Curve Modifier Type */
	type_enum type() { /* not implemented */ throw NULL; }
	/** Setter: F-Curve Modifier Type */
	void type(type_enum value) { /* not implemented */ }

	/** Getter: F-Curve Modifier's panel is expanded in UI */
	bool show_expanded() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "show_expanded")) == 1;
	}

	/** Setter: F-Curve Modifier's panel is expanded in UI */
	void show_expanded(bool value) {
		PyObject_SetAttrString(pyobjref, "show_expanded", Py_BuildValue("i", value));
	}

	/** Getter: F-Curve Modifier will not be evaluated */
	bool mute() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "mute")) == 1;
	}

	/** Setter: F-Curve Modifier will not be evaluated */
	void mute(bool value) {
		PyObject_SetAttrString(pyobjref, "mute", Py_BuildValue("i", value));
	}

	/** Getter: F-Curve Modifier has invalid settings and will not be evaluated */
	bool is_valid() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "is_valid")) == 1;
	}

	/** Setter: F-Curve Modifier has invalid settings and will not be evaluated */
	void is_valid(bool value) {
		PyObject_SetAttrString(pyobjref, "is_valid", Py_BuildValue("i", value));
	}

	/** Getter: F-Curve Modifier is the one being edited  */
	bool active() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "active")) == 1;
	}

	/** Setter: F-Curve Modifier is the one being edited  */
	void active(bool value) {
		PyObject_SetAttrString(pyobjref, "active", Py_BuildValue("i", value));
	}

	/** Getter: F-Curve Modifier is only applied for the specified frame range to help mask off effects in order to chain them */
	bool use_restricted_range() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_restricted_range")) == 1;
	}

	/** Setter: F-Curve Modifier is only applied for the specified frame range to help mask off effects in order to chain them */
	void use_restricted_range(bool value) {
		PyObject_SetAttrString(pyobjref, "use_restricted_range", Py_BuildValue("i", value));
	}

	/** Getter: Frame that modifier's influence starts (if Restrict Frame Range is in use) */
	float frame_start() { /* not implemented */ throw NULL; }
	/** Setter: Frame that modifier's influence starts (if Restrict Frame Range is in use) */
	void frame_start(float value) {
		PyObject_SetAttrString(pyobjref, "frame_start", Py_BuildValue("f", value));
	}

	/** Getter: Frame that modifier's influence ends (if Restrict Frame Range is in use) */
	float frame_end() { /* not implemented */ throw NULL; }
	/** Setter: Frame that modifier's influence ends (if Restrict Frame Range is in use) */
	void frame_end(float value) {
		PyObject_SetAttrString(pyobjref, "frame_end", Py_BuildValue("f", value));
	}

	/** Getter: Number of frames from start frame for influence to take effect */
	float blend_in() { /* not implemented */ throw NULL; }
	/** Setter: Number of frames from start frame for influence to take effect */
	void blend_in(float value) {
		PyObject_SetAttrString(pyobjref, "blend_in", Py_BuildValue("f", value));
	}

	/** Getter: Number of frames from end frame for influence to fade out */
	float blend_out() { /* not implemented */ throw NULL; }
	/** Setter: Number of frames from end frame for influence to fade out */
	void blend_out(float value) {
		PyObject_SetAttrString(pyobjref, "blend_out", Py_BuildValue("f", value));
	}

	/** Getter: F-Curve Modifier's effects will be tempered by a default factor */
	bool use_influence() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_influence")) == 1;
	}

	/** Setter: F-Curve Modifier's effects will be tempered by a default factor */
	void use_influence(bool value) {
		PyObject_SetAttrString(pyobjref, "use_influence", Py_BuildValue("i", value));
	}

	/** Getter: Amount of influence F-Curve Modifier will have when not fading in/out */
	float influence() { /* not implemented */ throw NULL; }
	/** Setter: Amount of influence F-Curve Modifier will have when not fading in/out */
	void influence(float value) {
		PyObject_SetAttrString(pyobjref, "influence", Py_BuildValue("f", value));
	}

};

/**************** Generator F-Modifier ****************/

/**
 * Deterministically generate values for the modified F-Curve
 */
class FModifierGenerator : public FModifier {
public:
	FModifierGenerator(PyObject* pyobj) : FModifier(pyobj) {}

	FModifierGenerator() : FModifier(0)
	{
		// not implemented
	}

	/** Getter: Values generated by this modifier are applied on top of the existing values instead of overwriting them */
	bool use_additive() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_additive")) == 1;
	}

	/** Setter: Values generated by this modifier are applied on top of the existing values instead of overwriting them */
	void use_additive(bool value) {
		PyObject_SetAttrString(pyobjref, "use_additive", Py_BuildValue("i", value));
	}

	enum mode_enum {
		mode_POLYNOMIAL = 0,
		mode_POLYNOMIAL_FACTORISED = 1,
	};

	/** Getter: Type of generator to use */
	mode_enum mode() { /* not implemented */ throw NULL; }
	/** Setter: Type of generator to use */
	void mode(mode_enum value) { /* not implemented */ }

	/** Getter: The highest power of 'x' for this polynomial (number of coefficients - 1) */
	int poly_order() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "poly_order"));
	}

	/** Setter: The highest power of 'x' for this polynomial (number of coefficients - 1) */
	void poly_order(int value) {
		PyObject_SetAttrString(pyobjref, "poly_order", Py_BuildValue("i", value));
	}

	/** Getter: Coefficients for 'x' (starting from lowest power of x^0) */
	std::array<float, 32> coefficients() {
		// TODO: MISSING DEREF! USE #DEFINE!
		PyObject *seqval = PyObject_GetAttrString(pyobjref, "coefficients");
		std::array<float, 32> resarr;
		for (int i = 0; i < 32; i++)
			resarr[i] = (float)PyFloat_AsDouble(PySequence_GetItem(seqval, i));
		return resarr;
	}

	/** Setter: Coefficients for 'x' (starting from lowest power of x^0) */
	void coefficients(float values[32]) { /* not implemented */ }

};

/**************** Built-In Function F-Modifier ****************/

/**
 * Generate values using a Built-In Function
 */
class FModifierFunctionGenerator : public FModifier {
public:
	FModifierFunctionGenerator(PyObject* pyobj) : FModifier(pyobj) {}

	FModifierFunctionGenerator() : FModifier(0)
	{
		// not implemented
	}

	/** Getter: Scale factor determining the maximum/minimum values */
	float amplitude() { /* not implemented */ throw NULL; }
	/** Setter: Scale factor determining the maximum/minimum values */
	void amplitude(float value) {
		PyObject_SetAttrString(pyobjref, "amplitude", Py_BuildValue("f", value));
	}

	/** Getter: Scale factor determining the 'speed' of the function */
	float phase_multiplier() { /* not implemented */ throw NULL; }
	/** Setter: Scale factor determining the 'speed' of the function */
	void phase_multiplier(float value) {
		PyObject_SetAttrString(pyobjref, "phase_multiplier", Py_BuildValue("f", value));
	}

	/** Getter: Constant factor to offset time by for function */
	float phase_offset() { /* not implemented */ throw NULL; }
	/** Setter: Constant factor to offset time by for function */
	void phase_offset(float value) {
		PyObject_SetAttrString(pyobjref, "phase_offset", Py_BuildValue("f", value));
	}

	/** Getter: Constant factor to offset values by */
	float value_offset() { /* not implemented */ throw NULL; }
	/** Setter: Constant factor to offset values by */
	void value_offset(float value) {
		PyObject_SetAttrString(pyobjref, "value_offset", Py_BuildValue("f", value));
	}

	/** Getter: Values generated by this modifier are applied on top of the existing values instead of overwriting them */
	bool use_additive() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_additive")) == 1;
	}

	/** Setter: Values generated by this modifier are applied on top of the existing values instead of overwriting them */
	void use_additive(bool value) {
		PyObject_SetAttrString(pyobjref, "use_additive", Py_BuildValue("i", value));
	}

	enum function_type_enum {
		function_type_SIN = 0,
		function_type_COS = 1,
		function_type_TAN = 2,
		function_type_SQRT = 3,
		function_type_LN = 4,
		function_type_SINC = 5,
	};

	/** Getter: Type of built-in function to use */
	function_type_enum function_type() { /* not implemented */ throw NULL; }
	/** Setter: Type of built-in function to use */
	void function_type(function_type_enum value) { /* not implemented */ }

};

/**************** Envelope F-Modifier ****************/

/**
 * Scale the values of the modified F-Curve
 */
class FModifierEnvelope : public FModifier {
public:
	FModifierEnvelope(PyObject* pyobj) : FModifier(pyobj) {}

	FModifierEnvelope() : FModifier(0)
	{
		// not implemented
	}

	/** Getter: Control points defining the shape of the envelope */
	std::map<std::string, FModifierEnvelopeControlPoint> control_points();
	/** Setter: Control points defining the shape of the envelope */
	void control_points(std::map<std::string, FModifierEnvelopeControlPoint> value);

	/** Getter: Value that envelope's influence is centered around / based on */
	float reference_value() { /* not implemented */ throw NULL; }
	/** Setter: Value that envelope's influence is centered around / based on */
	void reference_value(float value) {
		PyObject_SetAttrString(pyobjref, "reference_value", Py_BuildValue("f", value));
	}

	/** Getter: Lower distance from Reference Value for 1:1 default influence */
	float default_min() { /* not implemented */ throw NULL; }
	/** Setter: Lower distance from Reference Value for 1:1 default influence */
	void default_min(float value) {
		PyObject_SetAttrString(pyobjref, "default_min", Py_BuildValue("f", value));
	}

	/** Getter: Upper distance from Reference Value for 1:1 default influence */
	float default_max() { /* not implemented */ throw NULL; }
	/** Setter: Upper distance from Reference Value for 1:1 default influence */
	void default_max(float value) {
		PyObject_SetAttrString(pyobjref, "default_max", Py_BuildValue("f", value));
	}

};

/**************** Envelope Control Point ****************/

/**
 * Control point for envelope F-Modifier
 */
class FModifierEnvelopeControlPoint : public pyUniplug {
public:
	FModifierEnvelopeControlPoint(PyObject* pyobj) : pyUniplug(pyobj) {}

	FModifierEnvelopeControlPoint() : pyUniplug(0)
	{
		// not implemented
	}

	/** Getter: Lower bound of envelope at this control-point */
	float min() { /* not implemented */ throw NULL; }
	/** Setter: Lower bound of envelope at this control-point */
	void min(float value) {
		PyObject_SetAttrString(pyobjref, "min", Py_BuildValue("f", value));
	}

	/** Getter: Upper bound of envelope at this control-point */
	float max() { /* not implemented */ throw NULL; }
	/** Setter: Upper bound of envelope at this control-point */
	void max(float value) {
		PyObject_SetAttrString(pyobjref, "max", Py_BuildValue("f", value));
	}

	/** Getter: Frame this control-point occurs on */
	float frame() { /* not implemented */ throw NULL; }
	/** Setter: Frame this control-point occurs on */
	void frame(float value) {
		PyObject_SetAttrString(pyobjref, "frame", Py_BuildValue("f", value));
	}

};

/**************** Cycles F-Modifier ****************/

/**
 * Repeat the values of the modified F-Curve
 */
class FModifierCycles : public FModifier {
public:
	FModifierCycles(PyObject* pyobj) : FModifier(pyobj) {}

	FModifierCycles() : FModifier(0)
	{
		// not implemented
	}

	enum mode_before_enum {
		mode_before_NONE = 0,
		mode_before_REPEAT = 1,
		mode_before_REPEAT_OFFSET = 2,
		mode_before_MIRROR = 3,
	};

	/** Getter: Cycling mode to use before first keyframe */
	mode_before_enum mode_before() { /* not implemented */ throw NULL; }
	/** Setter: Cycling mode to use before first keyframe */
	void mode_before(mode_before_enum value) { /* not implemented */ }

	/** Getter: Maximum number of cycles to allow before first keyframe (0 = infinite) */
	int cycles_before() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "cycles_before"));
	}

	/** Setter: Maximum number of cycles to allow before first keyframe (0 = infinite) */
	void cycles_before(int value) {
		PyObject_SetAttrString(pyobjref, "cycles_before", Py_BuildValue("i", value));
	}

	enum mode_after_enum {
		mode_after_NONE = 0,
		mode_after_REPEAT = 1,
		mode_after_REPEAT_OFFSET = 2,
		mode_after_MIRROR = 3,
	};

	/** Getter: Cycling mode to use after last keyframe */
	mode_after_enum mode_after() { /* not implemented */ throw NULL; }
	/** Setter: Cycling mode to use after last keyframe */
	void mode_after(mode_after_enum value) { /* not implemented */ }

	/** Getter: Maximum number of cycles to allow after last keyframe (0 = infinite) */
	int cycles_after() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "cycles_after"));
	}

	/** Setter: Maximum number of cycles to allow after last keyframe (0 = infinite) */
	void cycles_after(int value) {
		PyObject_SetAttrString(pyobjref, "cycles_after", Py_BuildValue("i", value));
	}

};

/**************** Python F-Modifier ****************/

/**
 * Perform user-defined operation on the modified F-Curve
 */
class FModifierPython : public FModifier {
public:
	FModifierPython(PyObject* pyobj) : FModifier(pyobj) {}

	FModifierPython() : FModifier(0)
	{
		// not implemented
	}

};

/**************** Limit F-Modifier ****************/

/**
 * Limit the time/value ranges of the modified F-Curve
 */
class FModifierLimits : public FModifier {
public:
	FModifierLimits(PyObject* pyobj) : FModifier(pyobj) {}

	FModifierLimits() : FModifier(0)
	{
		// not implemented
	}

	/** Getter: Use the minimum X value */
	bool use_min_x() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_min_x")) == 1;
	}

	/** Setter: Use the minimum X value */
	void use_min_x(bool value) {
		PyObject_SetAttrString(pyobjref, "use_min_x", Py_BuildValue("i", value));
	}

	/** Getter: Use the minimum Y value */
	bool use_min_y() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_min_y")) == 1;
	}

	/** Setter: Use the minimum Y value */
	void use_min_y(bool value) {
		PyObject_SetAttrString(pyobjref, "use_min_y", Py_BuildValue("i", value));
	}

	/** Getter: Use the maximum X value */
	bool use_max_x() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_max_x")) == 1;
	}

	/** Setter: Use the maximum X value */
	void use_max_x(bool value) {
		PyObject_SetAttrString(pyobjref, "use_max_x", Py_BuildValue("i", value));
	}

	/** Getter: Use the maximum Y value */
	bool use_max_y() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_max_y")) == 1;
	}

	/** Setter: Use the maximum Y value */
	void use_max_y(bool value) {
		PyObject_SetAttrString(pyobjref, "use_max_y", Py_BuildValue("i", value));
	}

	/** Getter: Lowest X value to allow */
	float min_x() { /* not implemented */ throw NULL; }
	/** Setter: Lowest X value to allow */
	void min_x(float value) {
		PyObject_SetAttrString(pyobjref, "min_x", Py_BuildValue("f", value));
	}

	/** Getter: Lowest Y value to allow */
	float min_y() { /* not implemented */ throw NULL; }
	/** Setter: Lowest Y value to allow */
	void min_y(float value) {
		PyObject_SetAttrString(pyobjref, "min_y", Py_BuildValue("f", value));
	}

	/** Getter: Highest X value to allow */
	float max_x() { /* not implemented */ throw NULL; }
	/** Setter: Highest X value to allow */
	void max_x(float value) {
		PyObject_SetAttrString(pyobjref, "max_x", Py_BuildValue("f", value));
	}

	/** Getter: Highest Y value to allow */
	float max_y() { /* not implemented */ throw NULL; }
	/** Setter: Highest Y value to allow */
	void max_y(float value) {
		PyObject_SetAttrString(pyobjref, "max_y", Py_BuildValue("f", value));
	}

};

/**************** Noise F-Modifier ****************/

/**
 * Give randomness to the modified F-Curve
 */
class FModifierNoise : public FModifier {
public:
	FModifierNoise(PyObject* pyobj) : FModifier(pyobj) {}

	FModifierNoise() : FModifier(0)
	{
		// not implemented
	}

	enum blend_type_enum {
		blend_type_REPLACE = 0,
		blend_type_ADD = 1,
		blend_type_SUBTRACT = 2,
		blend_type_MULTIPLY = 3,
	};

	/** Getter: Method of modifying the existing F-Curve */
	blend_type_enum blend_type() { /* not implemented */ throw NULL; }
	/** Setter: Method of modifying the existing F-Curve */
	void blend_type(blend_type_enum value) { /* not implemented */ }

	/** Getter: Scaling (in time) of the noise */
	float scale() { /* not implemented */ throw NULL; }
	/** Setter: Scaling (in time) of the noise */
	void scale(float value) {
		PyObject_SetAttrString(pyobjref, "scale", Py_BuildValue("f", value));
	}

	/** Getter: Amplitude of the noise - the amount that it modifies the underlying curve */
	float strength() { /* not implemented */ throw NULL; }
	/** Setter: Amplitude of the noise - the amount that it modifies the underlying curve */
	void strength(float value) {
		PyObject_SetAttrString(pyobjref, "strength", Py_BuildValue("f", value));
	}

	/** Getter: A random seed for the noise effect */
	float phase() { /* not implemented */ throw NULL; }
	/** Setter: A random seed for the noise effect */
	void phase(float value) {
		PyObject_SetAttrString(pyobjref, "phase", Py_BuildValue("f", value));
	}

	/** Getter: Time offset for the noise effect */
	float offset() { /* not implemented */ throw NULL; }
	/** Setter: Time offset for the noise effect */
	void offset(float value) {
		PyObject_SetAttrString(pyobjref, "offset", Py_BuildValue("f", value));
	}

	/** Getter: Amount of fine level detail present in the noise */
	int depth() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "depth"));
	}

	/** Setter: Amount of fine level detail present in the noise */
	void depth(int value) {
		PyObject_SetAttrString(pyobjref, "depth", Py_BuildValue("i", value));
	}

};

/**************** Stepped Interpolation F-Modifier ****************/

/**
 * Hold each interpolated value from the F-Curve for several frames without changing the timing
 */
class FModifierStepped : public FModifier {
public:
	FModifierStepped(PyObject* pyobj) : FModifier(pyobj) {}

	FModifierStepped() : FModifier(0)
	{
		// not implemented
	}

	/** Getter: Number of frames to hold each value */
	float frame_step() { /* not implemented */ throw NULL; }
	/** Setter: Number of frames to hold each value */
	void frame_step(float value) {
		PyObject_SetAttrString(pyobjref, "frame_step", Py_BuildValue("f", value));
	}

	/** Getter: Reference number of frames before frames get held (use to get hold for '1-3' vs '5-7' holding patterns) */
	float frame_offset() { /* not implemented */ throw NULL; }
	/** Setter: Reference number of frames before frames get held (use to get hold for '1-3' vs '5-7' holding patterns) */
	void frame_offset(float value) {
		PyObject_SetAttrString(pyobjref, "frame_offset", Py_BuildValue("f", value));
	}

	/** Getter: Restrict modifier to only act after its 'start' frame */
	bool use_frame_start() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_frame_start")) == 1;
	}

	/** Setter: Restrict modifier to only act after its 'start' frame */
	void use_frame_start(bool value) {
		PyObject_SetAttrString(pyobjref, "use_frame_start", Py_BuildValue("i", value));
	}

	/** Getter: Restrict modifier to only act before its 'end' frame */
	bool use_frame_end() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_frame_end")) == 1;
	}

	/** Setter: Restrict modifier to only act before its 'end' frame */
	void use_frame_end(bool value) {
		PyObject_SetAttrString(pyobjref, "use_frame_end", Py_BuildValue("i", value));
	}

	/** Getter: Frame that modifier's influence starts (if applicable) */
	float frame_start() { /* not implemented */ throw NULL; }
	/** Setter: Frame that modifier's influence starts (if applicable) */
	void frame_start(float value) {
		PyObject_SetAttrString(pyobjref, "frame_start", Py_BuildValue("f", value));
	}

	/** Getter: Frame that modifier's influence ends (if applicable) */
	float frame_end() { /* not implemented */ throw NULL; }
	/** Setter: Frame that modifier's influence ends (if applicable) */
	void frame_end(float value) {
		PyObject_SetAttrString(pyobjref, "frame_end", Py_BuildValue("f", value));
	}

};

/**************** Fluid Simulation Settings ****************/

/**
 * Fluid simulation settings for an object taking part in the simulation
 */
class FluidSettings : public pyUniplug {
public:
	FluidSettings(PyObject* pyobj) : pyUniplug(pyobj) {}

	FluidSettings() : pyUniplug(0)
	{
		// not implemented
	}

	enum type_enum {
		type_NONE = 1,
		type_DOMAIN = 2,
		type_FLUID = 4,
		type_OBSTACLE = 8,
		type_INFLOW = 16,
		type_OUTFLOW = 32,
		type_PARTICLE = 64,
		type_CONTROL = 128,
	};

	/** Getter: Type of participation in the fluid simulation */
	type_enum type() { /* not implemented */ throw NULL; }
	/** Setter: Type of participation in the fluid simulation */
	void type(type_enum value) { /* not implemented */ }

};

/**************** Domain Fluid Simulation Settings ****************/

/**
 * Fluid simulation settings for the domain of a fluid simulation
 */
class DomainFluidSettings : public FluidSettings {
public:
	DomainFluidSettings(PyObject* pyobj) : FluidSettings(pyobj) {}

	DomainFluidSettings() : FluidSettings(0)
	{
		// not implemented
	}

	/** Getter: Override number of threads for the simulation, 0 is automatic */
	int threads() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "threads"));
	}

	/** Setter: Override number of threads for the simulation, 0 is automatic */
	void threads(int value) {
		PyObject_SetAttrString(pyobjref, "threads", Py_BuildValue("i", value));
	}

	/** Getter: Domain resolution in X,Y and Z direction */
	int resolution() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "resolution"));
	}

	/** Setter: Domain resolution in X,Y and Z direction */
	void resolution(int value) {
		PyObject_SetAttrString(pyobjref, "resolution", Py_BuildValue("i", value));
	}

	/** Getter: Preview resolution in X,Y and Z direction */
	int preview_resolution() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "preview_resolution"));
	}

	/** Setter: Preview resolution in X,Y and Z direction */
	void preview_resolution(int value) {
		PyObject_SetAttrString(pyobjref, "preview_resolution", Py_BuildValue("i", value));
	}

	enum viewport_display_mode_enum {
		viewport_display_mode_GEOMETRY = 1,
		viewport_display_mode_PREVIEW = 2,
		viewport_display_mode_FINAL = 3,
	};

	/** Getter: How to display the mesh in the viewport */
	viewport_display_mode_enum viewport_display_mode() { /* not implemented */ throw NULL; }
	/** Setter: How to display the mesh in the viewport */
	void viewport_display_mode(viewport_display_mode_enum value) { /* not implemented */ }

	enum render_display_mode_enum {
		render_display_mode_GEOMETRY = 1,
		render_display_mode_PREVIEW = 2,
		render_display_mode_FINAL = 3,
	};

	/** Getter: How to display the mesh for rendering */
	render_display_mode_enum render_display_mode() { /* not implemented */ throw NULL; }
	/** Setter: How to display the mesh for rendering */
	void render_display_mode(render_display_mode_enum value) { /* not implemented */ }

	/** Getter: Reverse fluid frames */
	bool use_reverse_frames() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_reverse_frames")) == 1;
	}

	/** Setter: Reverse fluid frames */
	void use_reverse_frames(bool value) {
		PyObject_SetAttrString(pyobjref, "use_reverse_frames", Py_BuildValue("i", value));
	}

	/** Getter: Directory (and/or filename prefix) to store baked fluid simulation files in */
	std::string filepath() { /* not implemented */ throw NULL; }
	/** Setter: Directory (and/or filename prefix) to store baked fluid simulation files in */
	void filepath(const std::string& value) { /* not implemented */ }

	/** Getter: Estimated amount of memory needed for baking the domain */
	std::string memory_estimate() { /* not implemented */ throw NULL; }
	/** Setter: Estimated amount of memory needed for baking the domain */
	void memory_estimate(const std::string& value) { /* not implemented */ }

	/** Getter: Gravity in X, Y and Z direction */
	std::array<float, 3> gravity() {
		// TODO: MISSING DEREF! USE #DEFINE!
		PyObject *seqval = PyObject_GetAttrString(pyobjref, "gravity");
		std::array<float, 3> resarr;
		for (int i = 0; i < 3; i++)
			resarr[i] = (float)PyFloat_AsDouble(PySequence_GetItem(seqval, i));
		return resarr;
	}

	/** Setter: Gravity in X, Y and Z direction */
	void gravity(float values[3]) { /* not implemented */ }

	/** Getter: Use a custom start and end time (in seconds) instead of the scene's timeline */
	bool use_time_override() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_time_override")) == 1;
	}

	/** Setter: Use a custom start and end time (in seconds) instead of the scene's timeline */
	void use_time_override(bool value) {
		PyObject_SetAttrString(pyobjref, "use_time_override", Py_BuildValue("i", value));
	}

	/** Getter: Simulation time of the first blender frame (in seconds) */
	float start_time() { /* not implemented */ throw NULL; }
	/** Setter: Simulation time of the first blender frame (in seconds) */
	void start_time(float value) {
		PyObject_SetAttrString(pyobjref, "start_time", Py_BuildValue("f", value));
	}

	/** Getter: Simulation time of the last blender frame (in seconds) */
	float end_time() { /* not implemented */ throw NULL; }
	/** Setter: Simulation time of the last blender frame (in seconds) */
	void end_time(float value) {
		PyObject_SetAttrString(pyobjref, "end_time", Py_BuildValue("f", value));
	}

	/** Getter: Offset when reading baked cache */
	int frame_offset() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "frame_offset"));
	}

	/** Setter: Offset when reading baked cache */
	void frame_offset(int value) {
		PyObject_SetAttrString(pyobjref, "frame_offset", Py_BuildValue("i", value));
	}

	/** Getter: Size of the simulation domain in meters */
	float simulation_scale() { /* not implemented */ throw NULL; }
	/** Setter: Size of the simulation domain in meters */
	void simulation_scale(float value) {
		PyObject_SetAttrString(pyobjref, "simulation_scale", Py_BuildValue("f", value));
	}

	/** Getter: Fluid motion rate (0 = stationary, 1 = normal speed) */
	float simulation_rate() { /* not implemented */ throw NULL; }
	/** Setter: Fluid motion rate (0 = stationary, 1 = normal speed) */
	void simulation_rate(float value) {
		PyObject_SetAttrString(pyobjref, "simulation_rate", Py_BuildValue("f", value));
	}

	/** Getter: Viscosity setting: value that is multiplied by 10 to the power of (exponent*-1) */
	float viscosity_base() { /* not implemented */ throw NULL; }
	/** Setter: Viscosity setting: value that is multiplied by 10 to the power of (exponent*-1) */
	void viscosity_base(float value) {
		PyObject_SetAttrString(pyobjref, "viscosity_base", Py_BuildValue("f", value));
	}

	/** Getter: Negative exponent for the viscosity value (to simplify entering small values e.g. 5*10^-6) */
	int viscosity_exponent() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "viscosity_exponent"));
	}

	/** Setter: Negative exponent for the viscosity value (to simplify entering small values e.g. 5*10^-6) */
	void viscosity_exponent(int value) {
		PyObject_SetAttrString(pyobjref, "viscosity_exponent", Py_BuildValue("i", value));
	}

	/** Getter: Number of coarsened grids to use (-1 for automatic) */
	int grid_levels() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "grid_levels"));
	}

	/** Setter: Number of coarsened grids to use (-1 for automatic) */
	void grid_levels(int value) {
		PyObject_SetAttrString(pyobjref, "grid_levels", Py_BuildValue("i", value));
	}

	/** Getter: Allowed compressibility due to gravitational force for standing fluid (directly affects simulation step size) */
	float compressibility() { /* not implemented */ throw NULL; }
	/** Setter: Allowed compressibility due to gravitational force for standing fluid (directly affects simulation step size) */
	void compressibility(float value) {
		PyObject_SetAttrString(pyobjref, "compressibility", Py_BuildValue("f", value));
	}

	enum slip_type_enum {
		slip_type_NOSLIP = 512,
		slip_type_PARTIALSLIP = 1024,
		slip_type_FREESLIP = 2048,
	};

	/** Getter:  */
	slip_type_enum slip_type() { /* not implemented */ throw NULL; }
	/** Setter:  */
	void slip_type(slip_type_enum value) { /* not implemented */ }

	/** Getter: Amount of mixing between no- and free-slip, 0 is no slip and 1 is free slip */
	float partial_slip_factor() { /* not implemented */ throw NULL; }
	/** Setter: Amount of mixing between no- and free-slip, 0 is no slip and 1 is free slip */
	void partial_slip_factor(float value) {
		PyObject_SetAttrString(pyobjref, "partial_slip_factor", Py_BuildValue("f", value));
	}

	/** Getter: Amount of surface smoothing (a value of 0 is off, 1 is normal smoothing and more than 1 is extra smoothing) */
	float surface_smooth() { /* not implemented */ throw NULL; }
	/** Setter: Amount of surface smoothing (a value of 0 is off, 1 is normal smoothing and more than 1 is extra smoothing) */
	void surface_smooth(float value) {
		PyObject_SetAttrString(pyobjref, "surface_smooth", Py_BuildValue("f", value));
	}

	/** Getter: Number of isosurface subdivisions (this is necessary for the inclusion of particles into the surface generation - WARNING: can lead to longer computation times !) */
	int surface_subdivisions() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "surface_subdivisions"));
	}

	/** Setter: Number of isosurface subdivisions (this is necessary for the inclusion of particles into the surface generation - WARNING: can lead to longer computation times !) */
	void surface_subdivisions(int value) {
		PyObject_SetAttrString(pyobjref, "surface_subdivisions", Py_BuildValue("i", value));
	}

	/** Getter: Generate speed vectors for vector blur */
	bool use_speed_vectors() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_speed_vectors")) == 1;
	}

	/** Setter: Generate speed vectors for vector blur */
	void use_speed_vectors(bool value) {
		PyObject_SetAttrString(pyobjref, "use_speed_vectors", Py_BuildValue("i", value));
	}

	/** Getter: Removes the air gap between fluid surface and obstacles - WARNING: Can result in a dissolving surface in other areas */
	bool use_surface_noobs() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_surface_noobs")) == 1;
	}

	/** Setter: Removes the air gap between fluid surface and obstacles - WARNING: Can result in a dissolving surface in other areas */
	void use_surface_noobs(bool value) {
		PyObject_SetAttrString(pyobjref, "use_surface_noobs", Py_BuildValue("i", value));
	}

	/** Getter: Number of tracer particles to generate */
	int tracer_particles() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "tracer_particles"));
	}

	/** Setter: Number of tracer particles to generate */
	void tracer_particles(int value) {
		PyObject_SetAttrString(pyobjref, "tracer_particles", Py_BuildValue("i", value));
	}

	/** Getter: Amount of particles to generate (0=off, 1=normal, >1=more) */
	float generate_particles() { /* not implemented */ throw NULL; }
	/** Setter: Amount of particles to generate (0=off, 1=normal, >1=more) */
	void generate_particles(float value) {
		PyObject_SetAttrString(pyobjref, "generate_particles", Py_BuildValue("f", value));
	}

	/** Getter: Vertices of the fluid mesh generated by simulation */
	std::map<std::string, FluidMeshVertex> fluid_mesh_vertices();
	/** Setter: Vertices of the fluid mesh generated by simulation */
	void fluid_mesh_vertices(std::map<std::string, FluidMeshVertex> value);

};

/**************** Fluid Mesh Vertex ****************/

/**
 * Vertex of a simulated fluid mesh
 */
class FluidMeshVertex : public pyUniplug {
public:
	FluidMeshVertex(PyObject* pyobj) : pyUniplug(pyobj) {}

	FluidMeshVertex() : pyUniplug(0)
	{
		// not implemented
	}

	/** Getter:  */
	std::array<float, 3> velocity() {
		// TODO: MISSING DEREF! USE #DEFINE!
		PyObject *seqval = PyObject_GetAttrString(pyobjref, "velocity");
		std::array<float, 3> resarr;
		for (int i = 0; i < 3; i++)
			resarr[i] = (float)PyFloat_AsDouble(PySequence_GetItem(seqval, i));
		return resarr;
	}

	/** Setter:  */
	void velocity(float values[3]) { /* not implemented */ }

};

/**************** Fluid Fluid Simulation Settings ****************/

/**
 * Fluid simulation settings for the fluid in the simulation
 */
class FluidFluidSettings : public FluidSettings {
public:
	FluidFluidSettings(PyObject* pyobj) : FluidSettings(pyobj) {}

	FluidFluidSettings() : FluidSettings(0)
	{
		// not implemented
	}

	/** Getter: Object contributes to the fluid simulation */
	bool use() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use")) == 1;
	}

	/** Setter: Object contributes to the fluid simulation */
	void use(bool value) {
		PyObject_SetAttrString(pyobjref, "use", Py_BuildValue("i", value));
	}

	enum volume_initialization_enum {
		volume_initialization_VOLUME = 1,
		volume_initialization_SHELL = 2,
		volume_initialization_BOTH = 3,
	};

	/** Getter: Volume initialization type (WARNING: complex volumes might require too much memory and break simulation) */
	volume_initialization_enum volume_initialization() { /* not implemented */ throw NULL; }
	/** Setter: Volume initialization type (WARNING: complex volumes might require too much memory and break simulation) */
	void volume_initialization(volume_initialization_enum value) { /* not implemented */ }

	/** Getter: Export this mesh as an animated one (slower and enforces No Slip, only use if really necessary [e.g. armatures or parented objects], animated pos/rot/scale F-Curves do not require it) */
	bool use_animated_mesh() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_animated_mesh")) == 1;
	}

	/** Setter: Export this mesh as an animated one (slower and enforces No Slip, only use if really necessary [e.g. armatures or parented objects], animated pos/rot/scale F-Curves do not require it) */
	void use_animated_mesh(bool value) {
		PyObject_SetAttrString(pyobjref, "use_animated_mesh", Py_BuildValue("i", value));
	}

	/** Getter: Initial velocity of fluid */
	std::array<float, 3> initial_velocity() {
		// TODO: MISSING DEREF! USE #DEFINE!
		PyObject *seqval = PyObject_GetAttrString(pyobjref, "initial_velocity");
		std::array<float, 3> resarr;
		for (int i = 0; i < 3; i++)
			resarr[i] = (float)PyFloat_AsDouble(PySequence_GetItem(seqval, i));
		return resarr;
	}

	/** Setter: Initial velocity of fluid */
	void initial_velocity(float values[3]) { /* not implemented */ }

};

/**************** Obstacle Fluid Simulation Settings ****************/

/**
 * Fluid simulation settings for obstacles in the simulation
 */
class ObstacleFluidSettings : public FluidSettings {
public:
	ObstacleFluidSettings(PyObject* pyobj) : FluidSettings(pyobj) {}

	ObstacleFluidSettings() : FluidSettings(0)
	{
		// not implemented
	}

	/** Getter: Object contributes to the fluid simulation */
	bool use() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use")) == 1;
	}

	/** Setter: Object contributes to the fluid simulation */
	void use(bool value) {
		PyObject_SetAttrString(pyobjref, "use", Py_BuildValue("i", value));
	}

	enum volume_initialization_enum {
		volume_initialization_VOLUME = 1,
		volume_initialization_SHELL = 2,
		volume_initialization_BOTH = 3,
	};

	/** Getter: Volume initialization type (WARNING: complex volumes might require too much memory and break simulation) */
	volume_initialization_enum volume_initialization() { /* not implemented */ throw NULL; }
	/** Setter: Volume initialization type (WARNING: complex volumes might require too much memory and break simulation) */
	void volume_initialization(volume_initialization_enum value) { /* not implemented */ }

	/** Getter: Export this mesh as an animated one (slower and enforces No Slip, only use if really necessary [e.g. armatures or parented objects], animated pos/rot/scale F-Curves do not require it) */
	bool use_animated_mesh() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_animated_mesh")) == 1;
	}

	/** Setter: Export this mesh as an animated one (slower and enforces No Slip, only use if really necessary [e.g. armatures or parented objects], animated pos/rot/scale F-Curves do not require it) */
	void use_animated_mesh(bool value) {
		PyObject_SetAttrString(pyobjref, "use_animated_mesh", Py_BuildValue("i", value));
	}

	enum slip_type_enum {
		slip_type_NOSLIP = 512,
		slip_type_PARTIALSLIP = 1024,
		slip_type_FREESLIP = 2048,
	};

	/** Getter:  */
	slip_type_enum slip_type() { /* not implemented */ throw NULL; }
	/** Setter:  */
	void slip_type(slip_type_enum value) { /* not implemented */ }

	/** Getter: Amount of mixing between no- and free-slip, 0 is no slip and 1 is free slip */
	float partial_slip_factor() { /* not implemented */ throw NULL; }
	/** Setter: Amount of mixing between no- and free-slip, 0 is no slip and 1 is free slip */
	void partial_slip_factor(float value) {
		PyObject_SetAttrString(pyobjref, "partial_slip_factor", Py_BuildValue("f", value));
	}

	/** Getter: This is an unphysical value for moving objects - it controls the impact an obstacle has on the fluid, =0 behaves a bit like outflow (deleting fluid), =1 is default, while >1 results in high forces (can be used to tweak total mass) */
	float impact_factor() { /* not implemented */ throw NULL; }
	/** Setter: This is an unphysical value for moving objects - it controls the impact an obstacle has on the fluid, =0 behaves a bit like outflow (deleting fluid), =1 is default, while >1 results in high forces (can be used to tweak total mass) */
	void impact_factor(float value) {
		PyObject_SetAttrString(pyobjref, "impact_factor", Py_BuildValue("f", value));
	}

};

/**************** Inflow Fluid Simulation Settings ****************/

/**
 * Fluid simulation settings for objects adding fluids in the simulation
 */
class InflowFluidSettings : public FluidSettings {
public:
	InflowFluidSettings(PyObject* pyobj) : FluidSettings(pyobj) {}

	InflowFluidSettings() : FluidSettings(0)
	{
		// not implemented
	}

	/** Getter: Object contributes to the fluid simulation */
	bool use() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use")) == 1;
	}

	/** Setter: Object contributes to the fluid simulation */
	void use(bool value) {
		PyObject_SetAttrString(pyobjref, "use", Py_BuildValue("i", value));
	}

	enum volume_initialization_enum {
		volume_initialization_VOLUME = 1,
		volume_initialization_SHELL = 2,
		volume_initialization_BOTH = 3,
	};

	/** Getter: Volume initialization type (WARNING: complex volumes might require too much memory and break simulation) */
	volume_initialization_enum volume_initialization() { /* not implemented */ throw NULL; }
	/** Setter: Volume initialization type (WARNING: complex volumes might require too much memory and break simulation) */
	void volume_initialization(volume_initialization_enum value) { /* not implemented */ }

	/** Getter: Export this mesh as an animated one (slower and enforces No Slip, only use if really necessary [e.g. armatures or parented objects], animated pos/rot/scale F-Curves do not require it) */
	bool use_animated_mesh() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_animated_mesh")) == 1;
	}

	/** Setter: Export this mesh as an animated one (slower and enforces No Slip, only use if really necessary [e.g. armatures or parented objects], animated pos/rot/scale F-Curves do not require it) */
	void use_animated_mesh(bool value) {
		PyObject_SetAttrString(pyobjref, "use_animated_mesh", Py_BuildValue("i", value));
	}

	/** Getter: Initial velocity of fluid */
	std::array<float, 3> inflow_velocity() {
		// TODO: MISSING DEREF! USE #DEFINE!
		PyObject *seqval = PyObject_GetAttrString(pyobjref, "inflow_velocity");
		std::array<float, 3> resarr;
		for (int i = 0; i < 3; i++)
			resarr[i] = (float)PyFloat_AsDouble(PySequence_GetItem(seqval, i));
		return resarr;
	}

	/** Setter: Initial velocity of fluid */
	void inflow_velocity(float values[3]) { /* not implemented */ }

	/** Getter: Use local coordinates for inflow (e.g. for rotating objects) */
	bool use_local_coords() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_local_coords")) == 1;
	}

	/** Setter: Use local coordinates for inflow (e.g. for rotating objects) */
	void use_local_coords(bool value) {
		PyObject_SetAttrString(pyobjref, "use_local_coords", Py_BuildValue("i", value));
	}

};

/**************** Outflow Fluid Simulation Settings ****************/

/**
 * Fluid simulation settings for objects removing fluids from the simulation
 */
class OutflowFluidSettings : public FluidSettings {
public:
	OutflowFluidSettings(PyObject* pyobj) : FluidSettings(pyobj) {}

	OutflowFluidSettings() : FluidSettings(0)
	{
		// not implemented
	}

	/** Getter: Object contributes to the fluid simulation */
	bool use() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use")) == 1;
	}

	/** Setter: Object contributes to the fluid simulation */
	void use(bool value) {
		PyObject_SetAttrString(pyobjref, "use", Py_BuildValue("i", value));
	}

	enum volume_initialization_enum {
		volume_initialization_VOLUME = 1,
		volume_initialization_SHELL = 2,
		volume_initialization_BOTH = 3,
	};

	/** Getter: Volume initialization type (WARNING: complex volumes might require too much memory and break simulation) */
	volume_initialization_enum volume_initialization() { /* not implemented */ throw NULL; }
	/** Setter: Volume initialization type (WARNING: complex volumes might require too much memory and break simulation) */
	void volume_initialization(volume_initialization_enum value) { /* not implemented */ }

	/** Getter: Export this mesh as an animated one (slower and enforces No Slip, only use if really necessary [e.g. armatures or parented objects], animated pos/rot/scale F-Curves do not require it) */
	bool use_animated_mesh() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_animated_mesh")) == 1;
	}

	/** Setter: Export this mesh as an animated one (slower and enforces No Slip, only use if really necessary [e.g. armatures or parented objects], animated pos/rot/scale F-Curves do not require it) */
	void use_animated_mesh(bool value) {
		PyObject_SetAttrString(pyobjref, "use_animated_mesh", Py_BuildValue("i", value));
	}

};

/**************** Particle Fluid Simulation Settings ****************/

/**
 * Fluid simulation settings for objects storing fluid particles generated by the simulation
 */
class ParticleFluidSettings : public FluidSettings {
public:
	ParticleFluidSettings(PyObject* pyobj) : FluidSettings(pyobj) {}

	ParticleFluidSettings() : FluidSettings(0)
	{
		// not implemented
	}

	/** Getter: Show drop particles */
	bool use_drops() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_drops")) == 1;
	}

	/** Setter: Show drop particles */
	void use_drops(bool value) {
		PyObject_SetAttrString(pyobjref, "use_drops", Py_BuildValue("i", value));
	}

	/** Getter: Show floating foam particles */
	bool use_floats() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_floats")) == 1;
	}

	/** Setter: Show floating foam particles */
	void use_floats(bool value) {
		PyObject_SetAttrString(pyobjref, "use_floats", Py_BuildValue("i", value));
	}

	/** Getter: Show tracer particles */
	bool show_tracer() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "show_tracer")) == 1;
	}

	/** Setter: Show tracer particles */
	void show_tracer(bool value) {
		PyObject_SetAttrString(pyobjref, "show_tracer", Py_BuildValue("i", value));
	}

	/** Getter: Amount of particle size scaling: 0=off (all same size), 1=full (range 0.2-2.0), >1=stronger */
	float particle_influence() { /* not implemented */ throw NULL; }
	/** Setter: Amount of particle size scaling: 0=off (all same size), 1=full (range 0.2-2.0), >1=stronger */
	void particle_influence(float value) {
		PyObject_SetAttrString(pyobjref, "particle_influence", Py_BuildValue("f", value));
	}

	/** Getter: Amount of particle alpha change, inverse of size influence: 0=off (all same alpha), 1=full (larger particles get lower alphas, smaller ones higher values) */
	float alpha_influence() { /* not implemented */ throw NULL; }
	/** Setter: Amount of particle alpha change, inverse of size influence: 0=off (all same alpha), 1=full (larger particles get lower alphas, smaller ones higher values) */
	void alpha_influence(float value) {
		PyObject_SetAttrString(pyobjref, "alpha_influence", Py_BuildValue("f", value));
	}

	/** Getter: Directory (and/or filename prefix) to store and load particles from */
	std::string filepath() { /* not implemented */ throw NULL; }
	/** Setter: Directory (and/or filename prefix) to store and load particles from */
	void filepath(const std::string& value) { /* not implemented */ }

};

/**************** Control Fluid Simulation Settings ****************/

/**
 * Fluid simulation settings for objects controlling the motion of fluid in the simulation
 */
class ControlFluidSettings : public FluidSettings {
public:
	ControlFluidSettings(PyObject* pyobj) : FluidSettings(pyobj) {}

	ControlFluidSettings() : FluidSettings(0)
	{
		// not implemented
	}

	/** Getter: Object contributes to the fluid simulation */
	bool use() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use")) == 1;
	}

	/** Setter: Object contributes to the fluid simulation */
	void use(bool value) {
		PyObject_SetAttrString(pyobjref, "use", Py_BuildValue("i", value));
	}

	/** Getter: Time when the control particles are activated */
	float start_time() { /* not implemented */ throw NULL; }
	/** Setter: Time when the control particles are activated */
	void start_time(float value) {
		PyObject_SetAttrString(pyobjref, "start_time", Py_BuildValue("f", value));
	}

	/** Getter: Time when the control particles are deactivated */
	float end_time() { /* not implemented */ throw NULL; }
	/** Setter: Time when the control particles are deactivated */
	void end_time(float value) {
		PyObject_SetAttrString(pyobjref, "end_time", Py_BuildValue("f", value));
	}

	/** Getter: Force strength for directional attraction towards the control object */
	float attraction_strength() { /* not implemented */ throw NULL; }
	/** Setter: Force strength for directional attraction towards the control object */
	void attraction_strength(float value) {
		PyObject_SetAttrString(pyobjref, "attraction_strength", Py_BuildValue("f", value));
	}

	/** Getter: Force field radius around the control object */
	float attraction_radius() { /* not implemented */ throw NULL; }
	/** Setter: Force field radius around the control object */
	void attraction_radius(float value) {
		PyObject_SetAttrString(pyobjref, "attraction_radius", Py_BuildValue("f", value));
	}

	/** Getter: Force strength of how much of the control object's velocity is influencing the fluid velocity */
	float velocity_strength() { /* not implemented */ throw NULL; }
	/** Setter: Force strength of how much of the control object's velocity is influencing the fluid velocity */
	void velocity_strength(float value) {
		PyObject_SetAttrString(pyobjref, "velocity_strength", Py_BuildValue("f", value));
	}

	/** Getter: Force field radius around the control object */
	float velocity_radius() { /* not implemented */ throw NULL; }
	/** Setter: Force field radius around the control object */
	void velocity_radius(float value) {
		PyObject_SetAttrString(pyobjref, "velocity_radius", Py_BuildValue("f", value));
	}

	/** Getter: Quality which is used for object sampling (higher = better but slower) */
	float quality() { /* not implemented */ throw NULL; }
	/** Setter: Quality which is used for object sampling (higher = better but slower) */
	void quality(float value) {
		PyObject_SetAttrString(pyobjref, "quality", Py_BuildValue("f", value));
	}

	/** Getter: Reverse control object movement */
	bool use_reverse_frames() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_reverse_frames")) == 1;
	}

	/** Setter: Reverse control object movement */
	void use_reverse_frames(bool value) {
		PyObject_SetAttrString(pyobjref, "use_reverse_frames", Py_BuildValue("i", value));
	}

};

/**************** Grease Pencil ****************/

/**
 * Freehand annotation sketchbook
 */
class GreasePencil : public ID {
public:
	GreasePencil(PyObject* pyobj) : ID(pyobj) {}

	GreasePencil() : ID(0)
	{
		// not implemented
	}

	/** Getter:  */
	std::map<std::string, GPencilLayer> layers();
	/** Setter:  */
	void layers(std::map<std::string, GPencilLayer> value);

	/** Getter: Animation data for this datablock */
	AnimData animation_data() {
		/* not implemented */ throw NULL;
	}

	enum draw_mode_enum {
		draw_mode_CURSOR = 16,
		draw_mode_VIEW = 0,
		draw_mode_SURFACE = 48,
		draw_mode_STROKE = 80,
	};

	/** Getter:  */
	draw_mode_enum draw_mode() { /* not implemented */ throw NULL; }
	/** Setter:  */
	void draw_mode(draw_mode_enum value) { /* not implemented */ }

	/** Getter: Only use the first and last parts of the stroke for snapping */
	bool use_stroke_endpoints() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_stroke_endpoints")) == 1;
	}

	/** Setter: Only use the first and last parts of the stroke for snapping */
	void use_stroke_endpoints(bool value) {
		PyObject_SetAttrString(pyobjref, "use_stroke_endpoints", Py_BuildValue("i", value));
	}

	/** Getter: Enable alternative keymap to make editing stroke points easier */
	bool use_stroke_edit_mode() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_stroke_edit_mode")) == 1;
	}

	/** Setter: Enable alternative keymap to make editing stroke points easier */
	void use_stroke_edit_mode(bool value) {
		PyObject_SetAttrString(pyobjref, "use_stroke_edit_mode", Py_BuildValue("i", value));
	}

	/**
	 * Remove all the grease pencil data
	 */
	void clear()
	{
		// not implemented
	}

};

/**************** Grease Pencil Layer ****************/

/**
 * Collection of related sketches
 */
class GPencilLayer : public pyUniplug {
public:
	GPencilLayer(PyObject* pyobj) : pyUniplug(pyobj) {}

	GPencilLayer() : pyUniplug(0)
	{
		// not implemented
	}

	/** Getter: Layer name */
	std::string info() { /* not implemented */ throw NULL; }
	/** Setter: Layer name */
	void info(const std::string& value) { /* not implemented */ }

	/** Getter: Sketches for this layer on different frames */
	std::map<std::string, GPencilFrame> frames();
	/** Setter: Sketches for this layer on different frames */
	void frames(std::map<std::string, GPencilFrame> value);

	/** Getter: Frame currently being displayed for this layer */
	GPencilFrame active_frame();

	/** Getter: Draw strokes as a series of circular blobs, resulting in a volumetric effect */
	bool use_volumetric_strokes() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_volumetric_strokes")) == 1;
	}

	/** Setter: Draw strokes as a series of circular blobs, resulting in a volumetric effect */
	void use_volumetric_strokes(bool value) {
		PyObject_SetAttrString(pyobjref, "use_volumetric_strokes", Py_BuildValue("i", value));
	}

	/** Getter: Color for all strokes in this layer */
	std::array<float, 3> color() {
		// TODO: MISSING DEREF! USE #DEFINE!
		PyObject *seqval = PyObject_GetAttrString(pyobjref, "color");
		std::array<float, 3> resarr;
		for (int i = 0; i < 3; i++)
			resarr[i] = (float)PyFloat_AsDouble(PySequence_GetItem(seqval, i));
		return resarr;
	}

	/** Setter: Color for all strokes in this layer */
	void color(float values[3]) { /* not implemented */ }

	/** Getter: Layer Opacity */
	float alpha() { /* not implemented */ throw NULL; }
	/** Setter: Layer Opacity */
	void alpha(float value) {
		PyObject_SetAttrString(pyobjref, "alpha", Py_BuildValue("f", value));
	}

	/** Getter: Color for filling region bounded by each stroke */
	std::array<float, 3> fill_color() {
		// TODO: MISSING DEREF! USE #DEFINE!
		PyObject *seqval = PyObject_GetAttrString(pyobjref, "fill_color");
		std::array<float, 3> resarr;
		for (int i = 0; i < 3; i++)
			resarr[i] = (float)PyFloat_AsDouble(PySequence_GetItem(seqval, i));
		return resarr;
	}

	/** Setter: Color for filling region bounded by each stroke */
	void fill_color(float values[3]) { /* not implemented */ }

	/** Getter: Opacity for filling region bounded by each stroke */
	float fill_alpha() { /* not implemented */ throw NULL; }
	/** Setter: Opacity for filling region bounded by each stroke */
	void fill_alpha(float value) {
		PyObject_SetAttrString(pyobjref, "fill_alpha", Py_BuildValue("f", value));
	}

	/** Getter: Thickness of strokes (in pixels) */
	int line_width() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "line_width"));
	}

	/** Setter: Thickness of strokes (in pixels) */
	void line_width(int value) {
		PyObject_SetAttrString(pyobjref, "line_width", Py_BuildValue("i", value));
	}

	/** Getter: Ghost frames on either side of frame */
	bool use_onion_skinning() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_onion_skinning")) == 1;
	}

	/** Setter: Ghost frames on either side of frame */
	void use_onion_skinning(bool value) {
		PyObject_SetAttrString(pyobjref, "use_onion_skinning", Py_BuildValue("i", value));
	}

	/** Getter: Maximum number of frames to show before current frame (0 = show only the previous sketch) */
	int ghost_before_range() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "ghost_before_range"));
	}

	/** Setter: Maximum number of frames to show before current frame (0 = show only the previous sketch) */
	void ghost_before_range(int value) {
		PyObject_SetAttrString(pyobjref, "ghost_before_range", Py_BuildValue("i", value));
	}

	/** Getter: Maximum number of frames to show after current frame (0 = show only the next sketch) */
	int ghost_after_range() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "ghost_after_range"));
	}

	/** Setter: Maximum number of frames to show after current frame (0 = show only the next sketch) */
	void ghost_after_range(int value) {
		PyObject_SetAttrString(pyobjref, "ghost_after_range", Py_BuildValue("i", value));
	}

	/** Getter: Use custom colors for ghost frames */
	bool use_ghost_custom_colors() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_ghost_custom_colors")) == 1;
	}

	/** Setter: Use custom colors for ghost frames */
	void use_ghost_custom_colors(bool value) {
		PyObject_SetAttrString(pyobjref, "use_ghost_custom_colors", Py_BuildValue("i", value));
	}

	/** Getter: Base color for ghosts before the active frame */
	std::array<float, 3> before_color() {
		// TODO: MISSING DEREF! USE #DEFINE!
		PyObject *seqval = PyObject_GetAttrString(pyobjref, "before_color");
		std::array<float, 3> resarr;
		for (int i = 0; i < 3; i++)
			resarr[i] = (float)PyFloat_AsDouble(PySequence_GetItem(seqval, i));
		return resarr;
	}

	/** Setter: Base color for ghosts before the active frame */
	void before_color(float values[3]) { /* not implemented */ }

	/** Getter: Base color for ghosts after the active frame */
	std::array<float, 3> after_color() {
		// TODO: MISSING DEREF! USE #DEFINE!
		PyObject *seqval = PyObject_GetAttrString(pyobjref, "after_color");
		std::array<float, 3> resarr;
		for (int i = 0; i < 3; i++)
			resarr[i] = (float)PyFloat_AsDouble(PySequence_GetItem(seqval, i));
		return resarr;
	}

	/** Setter: Base color for ghosts after the active frame */
	void after_color(float values[3]) { /* not implemented */ }

	/** Getter: Set layer Visibility */
	bool hide() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "hide")) == 1;
	}

	/** Setter: Set layer Visibility */
	void hide(bool value) {
		PyObject_SetAttrString(pyobjref, "hide", Py_BuildValue("i", value));
	}

	/** Getter: Protect layer from further editing and/or frame changes */
	bool lock_value() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "lock")) == 1;
	}

	/** Setter: Protect layer from further editing and/or frame changes */
	void lock_value(bool value) {
		PyObject_SetAttrString(pyobjref, "lock", Py_BuildValue("i", value));
	}

	/** Getter: Lock current frame displayed by layer */
	bool lock_frame() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "lock_frame")) == 1;
	}

	/** Setter: Lock current frame displayed by layer */
	void lock_frame(bool value) {
		PyObject_SetAttrString(pyobjref, "lock_frame", Py_BuildValue("i", value));
	}

	/** Getter: Layer is selected for editing in the Dope Sheet */
	bool select() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "select")) == 1;
	}

	/** Setter: Layer is selected for editing in the Dope Sheet */
	void select(bool value) {
		PyObject_SetAttrString(pyobjref, "select", Py_BuildValue("i", value));
	}

	/** Getter: Draw the points which make up the strokes (for debugging purposes) */
	bool show_points() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "show_points")) == 1;
	}

	/** Setter: Draw the points which make up the strokes (for debugging purposes) */
	void show_points(bool value) {
		PyObject_SetAttrString(pyobjref, "show_points", Py_BuildValue("i", value));
	}

	/** Getter: Make the layer draw in front of objects */
	bool show_x_ray() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "show_x_ray")) == 1;
	}

	/** Setter: Make the layer draw in front of objects */
	void show_x_ray(bool value) {
		PyObject_SetAttrString(pyobjref, "show_x_ray", Py_BuildValue("i", value));
	}

	/** Getter: True when opacity of stroke is set high enough to be visible */
	bool is_stroke_visible() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "is_stroke_visible")) == 1;
	}

	/** Setter: True when opacity of stroke is set high enough to be visible */
	void is_stroke_visible(bool value) {
		PyObject_SetAttrString(pyobjref, "is_stroke_visible", Py_BuildValue("i", value));
	}

	/** Getter: True when opacity of fill is set high enough to be visible */
	bool is_fill_visible() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "is_fill_visible")) == 1;
	}

	/** Setter: True when opacity of fill is set high enough to be visible */
	void is_fill_visible(bool value) {
		PyObject_SetAttrString(pyobjref, "is_fill_visible", Py_BuildValue("i", value));
	}

	/**
	 * Remove all the grease pencil layer data
	 */
	void clear()
	{
		// not implemented
	}

};

/**************** Grease Pencil Frame ****************/

/**
 * Collection of related sketches on a particular frame
 */
class GPencilFrame : public pyUniplug {
public:
	GPencilFrame(PyObject* pyobj) : pyUniplug(pyobj) {}

	GPencilFrame() : pyUniplug(0)
	{
		// not implemented
	}

	/** Getter: Freehand curves defining the sketch on this frame */
	std::map<std::string, GPencilStroke> strokes();
	/** Setter: Freehand curves defining the sketch on this frame */
	void strokes(std::map<std::string, GPencilStroke> value);

	/** Getter: The frame on which this sketch appears */
	int frame_number() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "frame_number"));
	}

	/** Setter: The frame on which this sketch appears */
	void frame_number(int value) {
		PyObject_SetAttrString(pyobjref, "frame_number", Py_BuildValue("i", value));
	}

	/** Getter: Frame is being edited (painted on) */
	bool is_edited() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "is_edited")) == 1;
	}

	/** Setter: Frame is being edited (painted on) */
	void is_edited(bool value) {
		PyObject_SetAttrString(pyobjref, "is_edited", Py_BuildValue("i", value));
	}

	/** Getter: Frame is selected for editing in the Dope Sheet */
	bool select() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "select")) == 1;
	}

	/** Setter: Frame is selected for editing in the Dope Sheet */
	void select(bool value) {
		PyObject_SetAttrString(pyobjref, "select", Py_BuildValue("i", value));
	}

	/**
	 * Remove all the grease pencil frame data
	 */
	void clear()
	{
		// not implemented
	}

};

/**************** Grease Pencil Stroke ****************/

/**
 * Freehand curve defining part of a sketch
 */
class GPencilStroke : public pyUniplug {
public:
	GPencilStroke(PyObject* pyobj) : pyUniplug(pyobj) {}

	GPencilStroke() : pyUniplug(0)
	{
		// not implemented
	}

	/** Getter: Stroke data points */
	std::map<std::string, GPencilStrokePoint> points();
	/** Setter: Stroke data points */
	void points(std::map<std::string, GPencilStrokePoint> value);

	enum draw_mode_enum {
		draw_mode_SCREEN = 0,
		draw_mode_3DSPACE = 1,
		draw_mode_2DSPACE = 2,
		draw_mode_2DIMAGE = 4,
	};

	/** Getter:  */
	draw_mode_enum draw_mode() { /* not implemented */ throw NULL; }
	/** Setter:  */
	void draw_mode(draw_mode_enum value) { /* not implemented */ }

	/** Getter: Stroke is selected for viewport editing */
	bool select() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "select")) == 1;
	}

	/** Setter: Stroke is selected for viewport editing */
	void select(bool value) {
		PyObject_SetAttrString(pyobjref, "select", Py_BuildValue("i", value));
	}

};

/**************** Grease Pencil Stroke Point ****************/

/**
 * Data point for freehand stroke curve
 */
class GPencilStrokePoint : public pyUniplug {
public:
	GPencilStrokePoint(PyObject* pyobj) : pyUniplug(pyobj) {}

	GPencilStrokePoint() : pyUniplug(0)
	{
		// not implemented
	}

	/** Getter:  */
	std::array<float, 3> co() {
		// TODO: MISSING DEREF! USE #DEFINE!
		PyObject *seqval = PyObject_GetAttrString(pyobjref, "co");
		std::array<float, 3> resarr;
		for (int i = 0; i < 3; i++)
			resarr[i] = (float)PyFloat_AsDouble(PySequence_GetItem(seqval, i));
		return resarr;
	}

	/** Setter:  */
	void co(float values[3]) { /* not implemented */ }

	/** Getter: Pressure of tablet at point when drawing it */
	float pressure() { /* not implemented */ throw NULL; }
	/** Setter: Pressure of tablet at point when drawing it */
	void pressure(float value) {
		PyObject_SetAttrString(pyobjref, "pressure", Py_BuildValue("f", value));
	}

	/** Getter: Point is selected for viewport editing */
	bool select() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "select")) == 1;
	}

	/** Setter: Point is selected for viewport editing */
	void select(bool value) {
		PyObject_SetAttrString(pyobjref, "select", Py_BuildValue("i", value));
	}

};

/**************** Group ****************/

/**
 * Group of Object datablocks
 */
class Group : public ID {
public:
	Group(PyObject* pyobj) : ID(pyobj) {}

	Group() : ID(0)
	{
		// not implemented
	}

	/** Getter: Offset from the origin to use when instancing as DupliGroup */
	std::array<float, 3> dupli_offset() {
		// TODO: MISSING DEREF! USE #DEFINE!
		PyObject *seqval = PyObject_GetAttrString(pyobjref, "dupli_offset");
		std::array<float, 3> resarr;
		for (int i = 0; i < 3; i++)
			resarr[i] = (float)PyFloat_AsDouble(PySequence_GetItem(seqval, i));
		return resarr;
	}

	/** Setter: Offset from the origin to use when instancing as DupliGroup */
	void dupli_offset(float values[3]) { /* not implemented */ }

	/** Getter: Layers visible when this group is instanced as a dupli */
	std::array<bool, 20> layers() {
		// TODO: MISSING DEREF! USE #DEFINE!
		PyObject *seqval = PyObject_GetAttrString(pyobjref, "layers");
		std::array<bool, 20> resarr;
		for (int i = 0; i < 20; i++)
			resarr[i] = PyLong_AsLong(PySequence_GetItem(seqval, i)) == 1;
		return resarr;
	}

	/** Setter: Layers visible when this group is instanced as a dupli */
	void layers(bool values[20]) { /* not implemented */ }

	/** Getter: A collection of this groups objects */
	std::map<std::string, Object> objects();
	/** Setter: A collection of this groups objects */
	void objects(std::map<std::string, Object> value);

};

/**************** Render Slot ****************/

/**
 * Parameters defining the render slot
 */
class RenderSlot : public pyUniplug {
public:
	RenderSlot(PyObject* pyobj) : pyUniplug(pyobj) {}

	RenderSlot() : pyUniplug(0)
	{
		// not implemented
	}

	/** Getter: Render slot name */
	std::string name() { /* not implemented */ throw NULL; }
	/** Setter: Render slot name */
	void name(const std::string& value) { /* not implemented */ }

};

/**************** Image ****************/

/**
 * Image datablock referencing an external or packed image
 */
class Image : public ID {
public:
	Image(PyObject* pyobj) : ID(pyobj) {}

	Image() : ID(0)
	{
		// not implemented
	}

	/** Getter: Image/Movie file name */
	std::string filepath() { /* not implemented */ throw NULL; }
	/** Setter: Image/Movie file name */
	void filepath(const std::string& value) { /* not implemented */ }

	/** Getter: Image/Movie file name (without data refreshing) */
	std::string filepath_raw() { /* not implemented */ throw NULL; }
	/** Setter: Image/Movie file name (without data refreshing) */
	void filepath_raw(const std::string& value) { /* not implemented */ }

	enum file_format_enum {
		file_format_BMP = 20,
		file_format_IRIS = 1,
		file_format_PNG = 17,
		file_format_JPEG = 4,
		file_format_JPEG2000 = 30,
		file_format_TARGA = 0,
		file_format_TARGA_RAW = 14,
		file_format_CINEON = 26,
		file_format_DPX = 27,
		file_format_OPEN_EXR_MULTILAYER = 28,
		file_format_OPEN_EXR = 23,
		file_format_HDR = 21,
		file_format_TIFF = 22,
		file_format_AVI_JPEG = 16,
		file_format_AVI_RAW = 15,
		file_format_FRAMESERVER = 25,
		file_format_H264 = 31,
		file_format_FFMPEG = 24,
		file_format_THEORA = 33,
		file_format_XVID = 32,
	};

	/** Getter: Format used for re-saving this file */
	file_format_enum file_format() { /* not implemented */ throw NULL; }
	/** Setter: Format used for re-saving this file */
	void file_format(file_format_enum value) { /* not implemented */ }

	enum source_enum {
		source_FILE = 1,
		source_SEQUENCE = 2,
		source_MOVIE = 3,
		source_GENERATED = 4,
		source_VIEWER = 5,
	};

	/** Getter: Where the image comes from */
	source_enum source() { /* not implemented */ throw NULL; }
	/** Setter: Where the image comes from */
	void source(source_enum value) { /* not implemented */ }

	enum type_enum {
		type_IMAGE = 0,
		type_MULTILAYER = 1,
		type_UV_TEST = 2,
		type_RENDER_RESULT = 4,
		type_COMPOSITING = 5,
	};

	/** Getter: How to generate the image */
	type_enum type() { /* not implemented */ throw NULL; }
	/** Setter: How to generate the image */
	void type(type_enum value) { /* not implemented */ }

	/** Getter: First packed file of the image */
	PackedFile packed_file();

	/** Getter: Collection of packed images */
	std::map<std::string, ImagePackedFile> packed_files();
	/** Setter: Collection of packed images */
	void packed_files(std::map<std::string, ImagePackedFile> value);

	enum field_order_enum {
		field_order_EVEN = 0,
		field_order_ODD = 2,
	};

	/** Getter: Order of video fields (select which lines are displayed first) */
	field_order_enum field_order() { /* not implemented */ throw NULL; }
	/** Setter: Order of video fields (select which lines are displayed first) */
	void field_order(field_order_enum value) { /* not implemented */ }

	/** Getter: Use fields of the image */
	bool use_fields() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_fields")) == 1;
	}

	/** Setter: Use fields of the image */
	void use_fields(bool value) {
		PyObject_SetAttrString(pyobjref, "use_fields", Py_BuildValue("i", value));
	}

	/** Getter: Apply render part of display transformation when displaying this image on the screen */
	bool use_view_as_render() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_view_as_render")) == 1;
	}

	/** Setter: Apply render part of display transformation when displaying this image on the screen */
	void use_view_as_render(bool value) {
		PyObject_SetAttrString(pyobjref, "use_view_as_render", Py_BuildValue("i", value));
	}

	/** Getter: Use the alpha channel information from the image or make image fully opaque */
	bool use_alpha() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_alpha")) == 1;
	}

	/** Setter: Use the alpha channel information from the image or make image fully opaque */
	void use_alpha(bool value) {
		PyObject_SetAttrString(pyobjref, "use_alpha", Py_BuildValue("i", value));
	}

	/** Getter: Deinterlace movie file on load */
	bool use_deinterlace() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_deinterlace")) == 1;
	}

	/** Setter: Deinterlace movie file on load */
	void use_deinterlace(bool value) {
		PyObject_SetAttrString(pyobjref, "use_deinterlace", Py_BuildValue("i", value));
	}

	/** Getter: Use Multiple Views (when available) */
	bool use_multiview() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_multiview")) == 1;
	}

	/** Setter: Use Multiple Views (when available) */
	void use_multiview(bool value) {
		PyObject_SetAttrString(pyobjref, "use_multiview", Py_BuildValue("i", value));
	}

	/** Getter: Image has left and right views */
	bool is_stereo_3d() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "is_stereo_3d")) == 1;
	}

	/** Setter: Image has left and right views */
	void is_stereo_3d(bool value) {
		PyObject_SetAttrString(pyobjref, "is_stereo_3d", Py_BuildValue("i", value));
	}

	/** Getter: Image has more than one view */
	bool is_multiview() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "is_multiview")) == 1;
	}

	/** Setter: Image has more than one view */
	void is_multiview(bool value) {
		PyObject_SetAttrString(pyobjref, "is_multiview", Py_BuildValue("i", value));
	}

	/** Getter: Image has changed and is not saved */
	bool is_dirty() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "is_dirty")) == 1;
	}

	/** Setter: Image has changed and is not saved */
	void is_dirty(bool value) {
		PyObject_SetAttrString(pyobjref, "is_dirty", Py_BuildValue("i", value));
	}

	enum generated_type_enum {
		generated_type_BLANK = 0,
		generated_type_UV_GRID = 1,
		generated_type_COLOR_GRID = 2,
	};

	/** Getter: Generated image type */
	generated_type_enum generated_type() { /* not implemented */ throw NULL; }
	/** Setter: Generated image type */
	void generated_type(generated_type_enum value) { /* not implemented */ }

	/** Getter: Generated image width */
	int generated_width() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "generated_width"));
	}

	/** Setter: Generated image width */
	void generated_width(int value) {
		PyObject_SetAttrString(pyobjref, "generated_width", Py_BuildValue("i", value));
	}

	/** Getter: Generated image height */
	int generated_height() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "generated_height"));
	}

	/** Setter: Generated image height */
	void generated_height(int value) {
		PyObject_SetAttrString(pyobjref, "generated_height", Py_BuildValue("i", value));
	}

	/** Getter: Generate floating point buffer */
	bool use_generated_float() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_generated_float")) == 1;
	}

	/** Setter: Generate floating point buffer */
	void use_generated_float(bool value) {
		PyObject_SetAttrString(pyobjref, "use_generated_float", Py_BuildValue("i", value));
	}

	/** Getter: Fill color for the generated image */
	std::array<float, 4> generated_color() {
		// TODO: MISSING DEREF! USE #DEFINE!
		PyObject *seqval = PyObject_GetAttrString(pyobjref, "generated_color");
		std::array<float, 4> resarr;
		for (int i = 0; i < 4; i++)
			resarr[i] = (float)PyFloat_AsDouble(PySequence_GetItem(seqval, i));
		return resarr;
	}

	/** Setter: Fill color for the generated image */
	void generated_color(float values[4]) { /* not implemented */ }

	enum mapping_enum {
		mapping_UV = 0,
		mapping_REFLECTION = 16,
	};

	/** Getter: Mapping type to use for this image in the game engine */
	mapping_enum mapping() { /* not implemented */ throw NULL; }
	/** Setter: Mapping type to use for this image in the game engine */
	void mapping(mapping_enum value) { /* not implemented */ }

	/** Getter: Display Aspect for this image, does not affect rendering */
	std::array<float, 2> display_aspect() {
		// TODO: MISSING DEREF! USE #DEFINE!
		PyObject *seqval = PyObject_GetAttrString(pyobjref, "display_aspect");
		std::array<float, 2> resarr;
		for (int i = 0; i < 2; i++)
			resarr[i] = (float)PyFloat_AsDouble(PySequence_GetItem(seqval, i));
		return resarr;
	}

	/** Setter: Display Aspect for this image, does not affect rendering */
	void display_aspect(float values[2]) { /* not implemented */ }

	/** Getter: Use as animated texture in the game engine */
	bool use_animation() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_animation")) == 1;
	}

	/** Setter: Use as animated texture in the game engine */
	void use_animation(bool value) {
		PyObject_SetAttrString(pyobjref, "use_animation", Py_BuildValue("i", value));
	}

	/** Getter: Start frame of an animated texture */
	int frame_start() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "frame_start"));
	}

	/** Setter: Start frame of an animated texture */
	void frame_start(int value) {
		PyObject_SetAttrString(pyobjref, "frame_start", Py_BuildValue("i", value));
	}

	/** Getter: End frame of an animated texture */
	int frame_end() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "frame_end"));
	}

	/** Setter: End frame of an animated texture */
	void frame_end(int value) {
		PyObject_SetAttrString(pyobjref, "frame_end", Py_BuildValue("i", value));
	}

	/** Getter: Speed of the animation in frames per second */
	int fps() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "fps"));
	}

	/** Setter: Speed of the animation in frames per second */
	void fps(int value) {
		PyObject_SetAttrString(pyobjref, "fps", Py_BuildValue("i", value));
	}

	/** Getter: Use of tilemode for faces (default shift-LMB to pick the tile for selected faces) */
	bool use_tiles() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_tiles")) == 1;
	}

	/** Setter: Use of tilemode for faces (default shift-LMB to pick the tile for selected faces) */
	void use_tiles(bool value) {
		PyObject_SetAttrString(pyobjref, "use_tiles", Py_BuildValue("i", value));
	}

	/** Getter: Degree of repetition in the X direction */
	int tiles_x() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "tiles_x"));
	}

	/** Setter: Degree of repetition in the X direction */
	void tiles_x(int value) {
		PyObject_SetAttrString(pyobjref, "tiles_x", Py_BuildValue("i", value));
	}

	/** Getter: Degree of repetition in the Y direction */
	int tiles_y() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "tiles_y"));
	}

	/** Setter: Degree of repetition in the Y direction */
	void tiles_y(int value) {
		PyObject_SetAttrString(pyobjref, "tiles_y", Py_BuildValue("i", value));
	}

	/** Getter: Disable texture repeating horizontally */
	bool use_clamp_x() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_clamp_x")) == 1;
	}

	/** Setter: Disable texture repeating horizontally */
	void use_clamp_x(bool value) {
		PyObject_SetAttrString(pyobjref, "use_clamp_x", Py_BuildValue("i", value));
	}

	/** Getter: Disable texture repeating vertically */
	bool use_clamp_y() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_clamp_y")) == 1;
	}

	/** Setter: Disable texture repeating vertically */
	void use_clamp_y(bool value) {
		PyObject_SetAttrString(pyobjref, "use_clamp_y", Py_BuildValue("i", value));
	}

	/** Getter: OpenGL bindcode */
	int bindcode() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "bindcode"));
	}

	/** Setter: OpenGL bindcode */
	void bindcode(int value) {
		PyObject_SetAttrString(pyobjref, "bindcode", Py_BuildValue("i", value));
	}

	/** Getter: Render slots of the image */
	std::map<std::string, RenderSlot> render_slots() {
		// TODO: MISSING DEREF! USE #DEFINE!
		PyObject *seqval = PyObject_GetAttrString(pyobjref, "render_slots");
		PyObject *seqkeys = PyObject_CallMethod(seqval, "keys", NULL);
		std::map<std::string, RenderSlot> resmap;
		for (int i = 0; i < PySequence_Length(seqval); i++) {
			PyObject *keyobj = PySequence_GetItem(seqkeys, i);
			std::string key = PyBytes_AsString(PyUnicode_AsASCIIString(keyobj));
			RenderSlot value = RenderSlot(PySequence_GetItem(seqval, i));
			resmap.insert(std::pair<std::string,RenderSlot>(key, value));
		}
		return resmap;
	}

	/** Setter: Render slots of the image */
	void render_slots(std::map<std::string, RenderSlot> value) { /* not implemented */ }

	/** Getter: True if this image has data */
	bool has_data() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "has_data")) == 1;
	}

	/** Setter: True if this image has data */
	void has_data(bool value) {
		PyObject_SetAttrString(pyobjref, "has_data", Py_BuildValue("i", value));
	}

	/** Getter: Image bit depth */
	int depth() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "depth"));
	}

	/** Setter: Image bit depth */
	void depth(int value) {
		PyObject_SetAttrString(pyobjref, "depth", Py_BuildValue("i", value));
	}

	/** Getter: Width and height in pixels, zero when image data cant be loaded */
	std::array<int, 2> size() {
		// TODO: MISSING DEREF! USE #DEFINE!
		PyObject *seqval = PyObject_GetAttrString(pyobjref, "size");
		std::array<int, 2> resarr;
		for (int i = 0; i < 2; i++)
			resarr[i] = PyLong_AsLong(PySequence_GetItem(seqval, i));
		return resarr;
	}

	/** Setter: Width and height in pixels, zero when image data cant be loaded */
	void size(int values[2]) { /* not implemented */ }

	/** Getter: X/Y pixels per meter */
	std::array<float, 2> resolution() {
		// TODO: MISSING DEREF! USE #DEFINE!
		PyObject *seqval = PyObject_GetAttrString(pyobjref, "resolution");
		std::array<float, 2> resarr;
		for (int i = 0; i < 2; i++)
			resarr[i] = (float)PyFloat_AsDouble(PySequence_GetItem(seqval, i));
		return resarr;
	}

	/** Setter: X/Y pixels per meter */
	void resolution(float values[2]) { /* not implemented */ }

	/** Getter: Duration (in frames) of the image (1 when not a video/sequence) */
	int frame_duration() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "frame_duration"));
	}

	/** Setter: Duration (in frames) of the image (1 when not a video/sequence) */
	void frame_duration(int value) {
		PyObject_SetAttrString(pyobjref, "frame_duration", Py_BuildValue("i", value));
	}

	/** Getter: Image pixels in floating point values */
	std::vector<float> pixels() {
		// TODO: MISSING DEREF! USE #DEFINE!
		PyObject *seqval = PyObject_GetAttrString(pyobjref, "pixels");
		std::vector<float> resvec;
		for (int i = 0; i < PySequence_Length(seqval); i++)
			resvec.push_back((float)PyFloat_AsDouble(PySequence_GetItem(seqval, i)));
		return resvec;
	}

	/** Setter: Image pixels in floating point values */
	void pixels(float values[]) { /* not implemented */ }

	/** Getter: Number of channels in pixels buffer */
	int channels() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "channels"));
	}

	/** Setter: Number of channels in pixels buffer */
	void channels(int value) {
		PyObject_SetAttrString(pyobjref, "channels", Py_BuildValue("i", value));
	}

	/** Getter: True if this image is stored in float buffer */
	bool is_float() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "is_float")) == 1;
	}

	/** Setter: True if this image is stored in float buffer */
	void is_float(bool value) {
		PyObject_SetAttrString(pyobjref, "is_float", Py_BuildValue("i", value));
	}

	/** Getter: Input color space settings */
	ColorManagedInputColorspaceSettings colorspace_settings() {
		/* not implemented */ throw NULL;
	}

	enum alpha_mode_enum {
		alpha_mode_STRAIGHT = 0,
		alpha_mode_PREMUL = 1,
	};

	/** Getter: Representation of alpha information in the RGBA pixels */
	alpha_mode_enum alpha_mode() { /* not implemented */ throw NULL; }
	/** Setter: Representation of alpha information in the RGBA pixels */
	void alpha_mode(alpha_mode_enum value) { /* not implemented */ }

	enum views_format_enum {
		views_format_INDIVIDUAL = 0,
		views_format_STEREO_3D = 1,
	};

	/** Getter: Mode to load image views */
	views_format_enum views_format() { /* not implemented */ throw NULL; }
	/** Setter: Mode to load image views */
	void views_format(views_format_enum value) { /* not implemented */ }

	/** Getter: Settings for stereo 3d */
	Stereo3dFormat stereo_3d_format();

	/**
	 * Save image to a specific path using a scenes render settings
	 * @param Save path
	 * @param Scene to take image parameters from
	 */
	void save_render(const std::string filepath, Scene scene);

	/**
	 * Save image to its source path
	 */
	void save()
	{
		// not implemented
	}

	/**
	 * Pack an image as embedded data into the .blend file
	 * @param Pack the image as PNG (needed for generated/dirty images)
	 * @param Raw data (bytes, exact content of the embedded file)
	 * @param length of given data (mandatory if data is provided)
	 */
	void pack(bool as_png = false, const std::string data = NULL, int data_len = 0)
	{
		// not implemented
	}

	/**
	 * Enum: unpack_method_items
	 */
	enum unpack_method_items {
		unpack_method_items_USE_LOCAL = 5,	
		unpack_method_items_WRITE_LOCAL = 4,	
		unpack_method_items_USE_ORIGINAL = 6,	
		unpack_method_items_WRITE_ORIGINAL = 3	
	};

	/**
	 * Save an image packed in the .blend file to disk
	 * @param How to unpack
	 */
	void unpack(unpack_method_items method = unpack_method_items_USE_LOCAL)
	{
		// not implemented
	}

	/**
	 * Reload the image from its source path
	 */
	void reload()
	{
		// not implemented
	}

	/**
	 * Update the display image from the floating point buffer
	 */
	void update()
	{
		// not implemented
	}

	/**
	 * Scale the image in pixels
	 * @param Width
	 * @param Height
	 */
	void scale(int width, int height)
	{
		// not implemented
	}

	/**
	 * Delay the image from being cleaned from the cache due inactivity
	 * @param Frame of image sequence or movie
	 * @param The texture minifying function to use if the image wasn't loaded
	 * @param The texture magnification function to use if the image wasn't loaded
	 * @return OpenGL error value
	 */
	int gl_touch(int frame = 0, int filter = 9985, int mag = 9729)
	{
		// not implemented
		throw NULL;
	}

	/**
	 * Load the image into OpenGL graphics memory
	 * @param Frame of image sequence or movie
	 * @param The texture minifying function
	 * @param The texture magnification function
	 * @return OpenGL error value
	 */
	int gl_load(int frame = 0, int filter = 9985, int mag = 9729)
	{
		// not implemented
		throw NULL;
	}

	/**
	 * Free the image from OpenGL graphics memory
	 */
	void gl_free()
	{
		// not implemented
	}

	/**
	 * Return the absolute path to the filepath of an image frame specified by the image user
	 * @param Image user of the image to get filepath for
	 * @return The resulting filepath from the image and it's user
	 */
	std::string filepath_from_user(ImageUser image_user);

	/**
	 * Free the image buffers from memory
	 */
	void buffers_free()
	{
		// not implemented
	}

};

/**************** Image User ****************/

/**
 * Parameters defining how an Image datablock is used by another datablock
 */
class ImageUser : public pyUniplug {
public:
	ImageUser(PyObject* pyobj) : pyUniplug(pyobj) {}

	ImageUser() : pyUniplug(0)
	{
		// not implemented
	}

	/** Getter: Always refresh image on frame changes */
	bool use_auto_refresh() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_auto_refresh")) == 1;
	}

	/** Setter: Always refresh image on frame changes */
	void use_auto_refresh(bool value) {
		PyObject_SetAttrString(pyobjref, "use_auto_refresh", Py_BuildValue("i", value));
	}

	/** Getter: Current frame number in image sequence or movie */
	int frame_current() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "frame_current"));
	}

	/** Setter: Current frame number in image sequence or movie */
	void frame_current(int value) {
		PyObject_SetAttrString(pyobjref, "frame_current", Py_BuildValue("i", value));
	}

	/** Getter: Cycle the images in the movie */
	bool use_cyclic() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_cyclic")) == 1;
	}

	/** Setter: Cycle the images in the movie */
	void use_cyclic(bool value) {
		PyObject_SetAttrString(pyobjref, "use_cyclic", Py_BuildValue("i", value));
	}

	/** Getter: Number of images of a movie to use */
	int frame_duration() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "frame_duration"));
	}

	/** Setter: Number of images of a movie to use */
	void frame_duration(int value) {
		PyObject_SetAttrString(pyobjref, "frame_duration", Py_BuildValue("i", value));
	}

	/** Getter: Offset the number of the frame to use in the animation */
	int frame_offset() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "frame_offset"));
	}

	/** Setter: Offset the number of the frame to use in the animation */
	void frame_offset(int value) {
		PyObject_SetAttrString(pyobjref, "frame_offset", Py_BuildValue("i", value));
	}

	/** Getter: Global starting frame of the movie/sequence, assuming first picture has a #1 */
	int frame_start() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "frame_start"));
	}

	/** Setter: Global starting frame of the movie/sequence, assuming first picture has a #1 */
	void frame_start(int value) {
		PyObject_SetAttrString(pyobjref, "frame_start", Py_BuildValue("i", value));
	}

	/** Getter: Number of fields per rendered frame (2 fields is 1 image) */
	int fields_per_frame() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "fields_per_frame"));
	}

	/** Setter: Number of fields per rendered frame (2 fields is 1 image) */
	void fields_per_frame(int value) {
		PyObject_SetAttrString(pyobjref, "fields_per_frame", Py_BuildValue("i", value));
	}

	/** Getter: Layer in multilayer image */
	int multilayer_layer() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "multilayer_layer"));
	}

	/** Setter: Layer in multilayer image */
	void multilayer_layer(int value) {
		PyObject_SetAttrString(pyobjref, "multilayer_layer", Py_BuildValue("i", value));
	}

	/** Getter: View in multilayer image */
	int multilayer_view() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "multilayer_view"));
	}

	/** Setter: View in multilayer image */
	void multilayer_view(int value) {
		PyObject_SetAttrString(pyobjref, "multilayer_view", Py_BuildValue("i", value));
	}

};

/**************** ImagePackedFile ****************/

/**
 * 
 */
class ImagePackedFile : public pyUniplug {
public:
	ImagePackedFile(PyObject* pyobj) : pyUniplug(pyobj) {}

	ImagePackedFile() : pyUniplug(0)
	{
		// not implemented
	}

	/** Getter:  */
	PackedFile packed_file();

	/** Getter:  */
	std::string filepath() { /* not implemented */ throw NULL; }
	/** Setter:  */
	void filepath(const std::string& value) { /* not implemented */ }

};

/**************** Key ****************/

/**
 * Shape keys datablock containing different shapes of geometric datablocks
 */
class Key : public ID {
public:
	Key(PyObject* pyobj) : ID(pyobj) {}

	Key() : ID(0)
	{
		// not implemented
	}

	/** Getter:  */
	ShapeKey reference_key();

	/** Getter: Shape keys */
	std::map<std::string, ShapeKey> key_blocks();
	/** Setter: Shape keys */
	void key_blocks(std::map<std::string, ShapeKey> value);

	/** Getter: Animation data for this datablock */
	AnimData animation_data() {
		/* not implemented */ throw NULL;
	}

	/** Getter: Datablock using these shape keys */
	ID user() {
		/* not implemented */ throw NULL;
	}

	/** Getter: Make shape keys relative, otherwise play through shapes as a sequence using the evaluation time */
	bool use_relative() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_relative")) == 1;
	}

	/** Setter: Make shape keys relative, otherwise play through shapes as a sequence using the evaluation time */
	void use_relative(bool value) {
		PyObject_SetAttrString(pyobjref, "use_relative", Py_BuildValue("i", value));
	}

	/** Getter: Evaluation time for absolute shape keys */
	float eval_time() { /* not implemented */ throw NULL; }
	/** Setter: Evaluation time for absolute shape keys */
	void eval_time(float value) {
		PyObject_SetAttrString(pyobjref, "eval_time", Py_BuildValue("f", value));
	}

};

/**************** Shape Key ****************/

/**
 * Shape key in a shape keys datablock
 */
class ShapeKey : public pyUniplug {
public:
	ShapeKey(PyObject* pyobj) : pyUniplug(pyobj) {}

	ShapeKey() : pyUniplug(0)
	{
		// not implemented
	}

	/** Getter: Name of Shape Key */
	std::string name() { /* not implemented */ throw NULL; }
	/** Setter: Name of Shape Key */
	void name(const std::string& value) { /* not implemented */ }

	/** Getter: Frame for absolute keys */
	float frame() { /* not implemented */ throw NULL; }
	/** Setter: Frame for absolute keys */
	void frame(float value) {
		PyObject_SetAttrString(pyobjref, "frame", Py_BuildValue("f", value));
	}

	/** Getter: Value of shape key at the current frame */
	float value() { /* not implemented */ throw NULL; }
	/** Setter: Value of shape key at the current frame */
	void value(float value) {
		PyObject_SetAttrString(pyobjref, "value", Py_BuildValue("f", value));
	}

	enum interpolation_enum {
		interpolation_KEY_LINEAR = 0,
		interpolation_KEY_CARDINAL = 1,
		interpolation_KEY_CATMULL_ROM = 3,
		interpolation_KEY_BSPLINE = 2,
	};

	/** Getter: Interpolation type for absolute shape keys */
	interpolation_enum interpolation() { /* not implemented */ throw NULL; }
	/** Setter: Interpolation type for absolute shape keys */
	void interpolation(interpolation_enum value) { /* not implemented */ }

	/** Getter: Vertex weight group, to blend with basis shape */
	std::string vertex_group() { /* not implemented */ throw NULL; }
	/** Setter: Vertex weight group, to blend with basis shape */
	void vertex_group(const std::string& value) { /* not implemented */ }

	/** Getter: Shape used as a relative key */
	ShapeKey relative_key() {
		/* not implemented */ throw NULL;
	}

	/** Getter: Mute this shape key */
	bool mute() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "mute")) == 1;
	}

	/** Setter: Mute this shape key */
	void mute(bool value) {
		PyObject_SetAttrString(pyobjref, "mute", Py_BuildValue("i", value));
	}

	/** Getter: Minimum for slider */
	float slider_min() { /* not implemented */ throw NULL; }
	/** Setter: Minimum for slider */
	void slider_min(float value) {
		PyObject_SetAttrString(pyobjref, "slider_min", Py_BuildValue("f", value));
	}

	/** Getter: Maximum for slider */
	float slider_max() { /* not implemented */ throw NULL; }
	/** Setter: Maximum for slider */
	void slider_max(float value) {
		PyObject_SetAttrString(pyobjref, "slider_max", Py_BuildValue("f", value));
	}

	/** Getter:  */
	std::map<std::string, UnknownType> data() {
		// TODO: MISSING DEREF! USE #DEFINE!
		PyObject *seqval = PyObject_GetAttrString(pyobjref, "data");
		PyObject *seqkeys = PyObject_CallMethod(seqval, "keys", NULL);
		std::map<std::string, UnknownType> resmap;
		for (int i = 0; i < PySequence_Length(seqval); i++) {
			PyObject *keyobj = PySequence_GetItem(seqkeys, i);
			std::string key = PyBytes_AsString(PyUnicode_AsASCIIString(keyobj));
			UnknownType value = UnknownType(PySequence_GetItem(seqval, i));
			resmap.insert(std::pair<std::string,UnknownType>(key, value));
		}
		return resmap;
	}

	/** Setter:  */
	void data(std::map<std::string, UnknownType> value) { /* not implemented */ }

};

/**************** Shape Key Point ****************/

/**
 * Point in a shape key
 */
class ShapeKeyPoint : public pyUniplug {
public:
	ShapeKeyPoint(PyObject* pyobj) : pyUniplug(pyobj) {}

	ShapeKeyPoint() : pyUniplug(0)
	{
		// not implemented
	}

	/** Getter:  */
	std::array<float, 3> co() {
		// TODO: MISSING DEREF! USE #DEFINE!
		PyObject *seqval = PyObject_GetAttrString(pyobjref, "co");
		std::array<float, 3> resarr;
		for (int i = 0; i < 3; i++)
			resarr[i] = (float)PyFloat_AsDouble(PySequence_GetItem(seqval, i));
		return resarr;
	}

	/** Setter:  */
	void co(float values[3]) { /* not implemented */ }

};

/**************** Shape Key Curve Point ****************/

/**
 * Point in a shape key for curves
 */
class ShapeKeyCurvePoint : public pyUniplug {
public:
	ShapeKeyCurvePoint(PyObject* pyobj) : pyUniplug(pyobj) {}

	ShapeKeyCurvePoint() : pyUniplug(0)
	{
		// not implemented
	}

	/** Getter:  */
	std::array<float, 3> co() {
		// TODO: MISSING DEREF! USE #DEFINE!
		PyObject *seqval = PyObject_GetAttrString(pyobjref, "co");
		std::array<float, 3> resarr;
		for (int i = 0; i < 3; i++)
			resarr[i] = (float)PyFloat_AsDouble(PySequence_GetItem(seqval, i));
		return resarr;
	}

	/** Setter:  */
	void co(float values[3]) { /* not implemented */ }

	/** Getter:  */
	float tilt() { /* not implemented */ throw NULL; }
	/** Setter:  */
	void tilt(float value) {
		PyObject_SetAttrString(pyobjref, "tilt", Py_BuildValue("f", value));
	}

};

/**************** Shape Key Bezier Point ****************/

/**
 * Point in a shape key for Bezier curves
 */
class ShapeKeyBezierPoint : public pyUniplug {
public:
	ShapeKeyBezierPoint(PyObject* pyobj) : pyUniplug(pyobj) {}

	ShapeKeyBezierPoint() : pyUniplug(0)
	{
		// not implemented
	}

	/** Getter:  */
	std::array<float, 3> co() {
		// TODO: MISSING DEREF! USE #DEFINE!
		PyObject *seqval = PyObject_GetAttrString(pyobjref, "co");
		std::array<float, 3> resarr;
		for (int i = 0; i < 3; i++)
			resarr[i] = (float)PyFloat_AsDouble(PySequence_GetItem(seqval, i));
		return resarr;
	}

	/** Setter:  */
	void co(float values[3]) { /* not implemented */ }

	/** Getter:  */
	std::array<float, 3> handle_left() {
		// TODO: MISSING DEREF! USE #DEFINE!
		PyObject *seqval = PyObject_GetAttrString(pyobjref, "handle_left");
		std::array<float, 3> resarr;
		for (int i = 0; i < 3; i++)
			resarr[i] = (float)PyFloat_AsDouble(PySequence_GetItem(seqval, i));
		return resarr;
	}

	/** Setter:  */
	void handle_left(float values[3]) { /* not implemented */ }

	/** Getter:  */
	std::array<float, 3> handle_right() {
		// TODO: MISSING DEREF! USE #DEFINE!
		PyObject *seqval = PyObject_GetAttrString(pyobjref, "handle_right");
		std::array<float, 3> resarr;
		for (int i = 0; i < 3; i++)
			resarr[i] = (float)PyFloat_AsDouble(PySequence_GetItem(seqval, i));
		return resarr;
	}

	/** Setter:  */
	void handle_right(float values[3]) { /* not implemented */ }

};

/**************** Lamp ****************/

/**
 * Lamp datablock for lighting a scene
 */
class Lamp : public ID {
public:
	Lamp(PyObject* pyobj) : ID(pyobj) {}

	Lamp() : ID(0)
	{
		// not implemented
	}

	enum type_enum {
		type_POINT = 0,
		type_SUN = 1,
		type_SPOT = 2,
		type_HEMI = 3,
		type_AREA = 4,
	};

	/** Getter: Type of Lamp */
	type_enum type() { /* not implemented */ throw NULL; }
	/** Setter: Type of Lamp */
	void type(type_enum value) { /* not implemented */ }

	/** Getter: Falloff distance - the light is at half the original intensity at this point */
	float distance() { /* not implemented */ throw NULL; }
	/** Setter: Falloff distance - the light is at half the original intensity at this point */
	void distance(float value) {
		PyObject_SetAttrString(pyobjref, "distance", Py_BuildValue("f", value));
	}

	/** Getter: Amount of light that the lamp emits */
	float energy() { /* not implemented */ throw NULL; }
	/** Setter: Amount of light that the lamp emits */
	void energy(float value) {
		PyObject_SetAttrString(pyobjref, "energy", Py_BuildValue("f", value));
	}

	/** Getter: Light color */
	std::array<float, 3> color() {
		// TODO: MISSING DEREF! USE #DEFINE!
		PyObject *seqval = PyObject_GetAttrString(pyobjref, "color");
		std::array<float, 3> resarr;
		for (int i = 0; i < 3; i++)
			resarr[i] = (float)PyFloat_AsDouble(PySequence_GetItem(seqval, i));
		return resarr;
	}

	/** Setter: Light color */
	void color(float values[3]) { /* not implemented */ }

	/** Getter: Illuminate objects only on the same layers the lamp is on */
	bool use_own_layer() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_own_layer")) == 1;
	}

	/** Setter: Illuminate objects only on the same layers the lamp is on */
	void use_own_layer(bool value) {
		PyObject_SetAttrString(pyobjref, "use_own_layer", Py_BuildValue("i", value));
	}

	/** Getter: Cast negative light */
	bool use_negative() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_negative")) == 1;
	}

	/** Setter: Cast negative light */
	void use_negative(bool value) {
		PyObject_SetAttrString(pyobjref, "use_negative", Py_BuildValue("i", value));
	}

	/** Getter: Create specular highlights */
	bool use_specular() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_specular")) == 1;
	}

	/** Setter: Create specular highlights */
	void use_specular(bool value) {
		PyObject_SetAttrString(pyobjref, "use_specular", Py_BuildValue("i", value));
	}

	/** Getter: Do diffuse shading */
	bool use_diffuse() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_diffuse")) == 1;
	}

	/** Setter: Do diffuse shading */
	void use_diffuse(bool value) {
		PyObject_SetAttrString(pyobjref, "use_diffuse", Py_BuildValue("i", value));
	}

	/** Getter: Node tree for node based lamps */
	NodeTree node_tree();

	/** Getter: Use shader nodes to render the lamp */
	bool use_nodes() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_nodes")) == 1;
	}

	/** Setter: Use shader nodes to render the lamp */
	void use_nodes(bool value) {
		PyObject_SetAttrString(pyobjref, "use_nodes", Py_BuildValue("i", value));
	}

	/** Getter: Animation data for this datablock */
	AnimData animation_data() {
		/* not implemented */ throw NULL;
	}

	/** Getter: Texture slots defining the mapping and influence of textures */
	std::map<std::string, LampTextureSlot> texture_slots();
	/** Setter: Texture slots defining the mapping and influence of textures */
	void texture_slots(std::map<std::string, LampTextureSlot> value);

	/** Getter: Active texture slot being displayed */
	Texture active_texture() {
		/* not implemented */ throw NULL;
	}

	/** Getter: Index of active texture slot */
	int active_texture_index() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "active_texture_index"));
	}

	/** Setter: Index of active texture slot */
	void active_texture_index(int value) {
		PyObject_SetAttrString(pyobjref, "active_texture_index", Py_BuildValue("i", value));
	}

};

/**************** Point Lamp ****************/

/**
 * Omnidirectional point lamp
 */
class PointLamp : public Lamp {
public:
	PointLamp(PyObject* pyobj) : Lamp(pyobj) {}

	PointLamp() : Lamp(0)
	{
		// not implemented
	}

	enum falloff_type_enum {
		falloff_type_CONSTANT = 0,
		falloff_type_INVERSE_LINEAR = 1,
		falloff_type_INVERSE_SQUARE = 2,
		falloff_type_CUSTOM_CURVE = 3,
		falloff_type_LINEAR_QUADRATIC_WEIGHTED = 4,
	};

	/** Getter: Intensity Decay with distance */
	falloff_type_enum falloff_type() { /* not implemented */ throw NULL; }
	/** Setter: Intensity Decay with distance */
	void falloff_type(falloff_type_enum value) { /* not implemented */ }

	/** Getter: Custom Lamp Falloff Curve */
	CurveMapping falloff_curve() {
		/* not implemented */ throw NULL;
	}

	/** Getter: Set light intensity to zero beyond lamp distance */
	bool use_sphere() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_sphere")) == 1;
	}

	/** Setter: Set light intensity to zero beyond lamp distance */
	void use_sphere(bool value) {
		PyObject_SetAttrString(pyobjref, "use_sphere", Py_BuildValue("i", value));
	}

	/** Getter: Linear distance attenuation */
	float linear_attenuation() { /* not implemented */ throw NULL; }
	/** Setter: Linear distance attenuation */
	void linear_attenuation(float value) {
		PyObject_SetAttrString(pyobjref, "linear_attenuation", Py_BuildValue("f", value));
	}

	/** Getter: Quadratic distance attenuation */
	float quadratic_attenuation() { /* not implemented */ throw NULL; }
	/** Setter: Quadratic distance attenuation */
	void quadratic_attenuation(float value) {
		PyObject_SetAttrString(pyobjref, "quadratic_attenuation", Py_BuildValue("f", value));
	}

	/** Getter:  */
	bool use_shadow() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_shadow")) == 1;
	}

	/** Setter:  */
	void use_shadow(bool value) {
		PyObject_SetAttrString(pyobjref, "use_shadow", Py_BuildValue("i", value));
	}

	enum shadow_method_enum {
		shadow_method_NOSHADOW = 0,
		shadow_method_RAY_SHADOW = 8192,
	};

	/** Getter:  */
	shadow_method_enum shadow_method() { /* not implemented */ throw NULL; }
	/** Setter:  */
	void shadow_method(shadow_method_enum value) { /* not implemented */ }

	/** Getter: Resolution of the shadow buffer, higher values give crisper shadows but use more memory */
	int shadow_buffer_size() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "shadow_buffer_size"));
	}

	/** Setter: Resolution of the shadow buffer, higher values give crisper shadows but use more memory */
	void shadow_buffer_size(int value) {
		PyObject_SetAttrString(pyobjref, "shadow_buffer_size", Py_BuildValue("i", value));
	}

	enum shadow_filter_type_enum {
		shadow_filter_type_BOX = 0,
		shadow_filter_type_TENT = 1,
		shadow_filter_type_GAUSS = 2,
	};

	/** Getter: Type of shadow filter (Buffer Shadows) */
	shadow_filter_type_enum shadow_filter_type() { /* not implemented */ throw NULL; }
	/** Setter: Type of shadow filter (Buffer Shadows) */
	void shadow_filter_type(shadow_filter_type_enum value) { /* not implemented */ }

	enum shadow_sample_buffers_enum {
		shadow_sample_buffers_BUFFERS_1 = 1,
		shadow_sample_buffers_BUFFERS_4 = 4,
		shadow_sample_buffers_BUFFERS_9 = 9,
	};

	/** Getter: Number of shadow buffers to render for better AA, this increases memory usage */
	shadow_sample_buffers_enum shadow_sample_buffers() { /* not implemented */ throw NULL; }
	/** Setter: Number of shadow buffers to render for better AA, this increases memory usage */
	void shadow_sample_buffers(shadow_sample_buffers_enum value) { /* not implemented */ }

	/** Getter: Shadow map clip start, below which objects will not generate shadows */
	float shadow_buffer_clip_start() { /* not implemented */ throw NULL; }
	/** Setter: Shadow map clip start, below which objects will not generate shadows */
	void shadow_buffer_clip_start(float value) {
		PyObject_SetAttrString(pyobjref, "shadow_buffer_clip_start", Py_BuildValue("f", value));
	}

	/** Getter: Shadow map clip end, beyond which objects will not generate shadows */
	float shadow_buffer_clip_end() { /* not implemented */ throw NULL; }
	/** Setter: Shadow map clip end, beyond which objects will not generate shadows */
	void shadow_buffer_clip_end(float value) {
		PyObject_SetAttrString(pyobjref, "shadow_buffer_clip_end", Py_BuildValue("f", value));
	}

	/** Getter: Shadow buffer sampling bias */
	float shadow_buffer_bias() { /* not implemented */ throw NULL; }
	/** Setter: Shadow buffer sampling bias */
	void shadow_buffer_bias(float value) {
		PyObject_SetAttrString(pyobjref, "shadow_buffer_bias", Py_BuildValue("f", value));
	}

	/** Getter: Bias for reducing light-bleed on variance shadow maps */
	float shadow_buffer_bleed_bias() { /* not implemented */ throw NULL; }
	/** Setter: Bias for reducing light-bleed on variance shadow maps */
	void shadow_buffer_bleed_bias(float value) {
		PyObject_SetAttrString(pyobjref, "shadow_buffer_bleed_bias", Py_BuildValue("f", value));
	}

	/** Getter: Size of shadow buffer sampling area */
	float shadow_buffer_soft() { /* not implemented */ throw NULL; }
	/** Setter: Size of shadow buffer sampling area */
	void shadow_buffer_soft(float value) {
		PyObject_SetAttrString(pyobjref, "shadow_buffer_soft", Py_BuildValue("f", value));
	}

	/** Getter: Number of shadow buffer samples */
	int shadow_buffer_samples() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "shadow_buffer_samples"));
	}

	/** Setter: Number of shadow buffer samples */
	void shadow_buffer_samples(int value) {
		PyObject_SetAttrString(pyobjref, "shadow_buffer_samples", Py_BuildValue("i", value));
	}

	enum shadow_buffer_type_enum {
		shadow_buffer_type_REGULAR = 0,
		shadow_buffer_type_HALFWAY = 2,
		shadow_buffer_type_IRREGULAR = 1,
		shadow_buffer_type_DEEP = 3,
	};

	/** Getter: Type of shadow buffer */
	shadow_buffer_type_enum shadow_buffer_type() { /* not implemented */ throw NULL; }
	/** Setter: Type of shadow buffer */
	void shadow_buffer_type(shadow_buffer_type_enum value) { /* not implemented */ }

	enum ge_shadow_buffer_type_enum {
		ge_shadow_buffer_type_SIMPLE = 0,
		ge_shadow_buffer_type_VARIANCE = 1,
	};

	/** Getter: The shadow mapping algorithm used */
	ge_shadow_buffer_type_enum ge_shadow_buffer_type() { /* not implemented */ throw NULL; }
	/** Setter: The shadow mapping algorithm used */
	void ge_shadow_buffer_type(ge_shadow_buffer_type_enum value) { /* not implemented */ }

	/** Getter: Automatic calculation of clipping-start, based on visible vertices */
	bool use_auto_clip_start() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_auto_clip_start")) == 1;
	}

	/** Setter: Automatic calculation of clipping-start, based on visible vertices */
	void use_auto_clip_start(bool value) {
		PyObject_SetAttrString(pyobjref, "use_auto_clip_start", Py_BuildValue("i", value));
	}

	/** Getter: Automatic calculation of clipping-end, based on visible vertices */
	bool use_auto_clip_end() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_auto_clip_end")) == 1;
	}

	/** Setter: Automatic calculation of clipping-end, based on visible vertices */
	void use_auto_clip_end(bool value) {
		PyObject_SetAttrString(pyobjref, "use_auto_clip_end", Py_BuildValue("i", value));
	}

	/** Getter: Deep shadow map compression threshold */
	float compression_threshold() { /* not implemented */ throw NULL; }
	/** Setter: Deep shadow map compression threshold */
	void compression_threshold(float value) {
		PyObject_SetAttrString(pyobjref, "compression_threshold", Py_BuildValue("f", value));
	}

	/** Getter: Color of shadows cast by the lamp */
	std::array<float, 3> shadow_color() {
		// TODO: MISSING DEREF! USE #DEFINE!
		PyObject *seqval = PyObject_GetAttrString(pyobjref, "shadow_color");
		std::array<float, 3> resarr;
		for (int i = 0; i < 3; i++)
			resarr[i] = (float)PyFloat_AsDouble(PySequence_GetItem(seqval, i));
		return resarr;
	}

	/** Setter: Color of shadows cast by the lamp */
	void shadow_color(float values[3]) { /* not implemented */ }

	/** Getter: Cast shadows only, without illuminating objects */
	bool use_only_shadow() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_only_shadow")) == 1;
	}

	/** Setter: Cast shadows only, without illuminating objects */
	void use_only_shadow(bool value) {
		PyObject_SetAttrString(pyobjref, "use_only_shadow", Py_BuildValue("i", value));
	}

	enum shadow_ray_sample_method_enum {
		shadow_ray_sample_method_ADAPTIVE_QMC = 1,
		shadow_ray_sample_method_CONSTANT_QMC = 2,
	};

	/** Getter: Method for generating shadow samples: Adaptive QMC is fastest, Constant QMC is less noisy but slower */
	shadow_ray_sample_method_enum shadow_ray_sample_method() { /* not implemented */ throw NULL; }
	/** Setter: Method for generating shadow samples: Adaptive QMC is fastest, Constant QMC is less noisy but slower */
	void shadow_ray_sample_method(shadow_ray_sample_method_enum value) { /* not implemented */ }

	/** Getter: Number of samples taken extra (samples x samples) */
	int shadow_ray_samples() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "shadow_ray_samples"));
	}

	/** Setter: Number of samples taken extra (samples x samples) */
	void shadow_ray_samples(int value) {
		PyObject_SetAttrString(pyobjref, "shadow_ray_samples", Py_BuildValue("i", value));
	}

	/** Getter: Threshold for Adaptive Sampling (Raytraced shadows) */
	float shadow_adaptive_threshold() { /* not implemented */ throw NULL; }
	/** Setter: Threshold for Adaptive Sampling (Raytraced shadows) */
	void shadow_adaptive_threshold(float value) {
		PyObject_SetAttrString(pyobjref, "shadow_adaptive_threshold", Py_BuildValue("f", value));
	}

	/** Getter: Light size for ray shadow sampling (Raytraced shadows) */
	float shadow_soft_size() { /* not implemented */ throw NULL; }
	/** Setter: Light size for ray shadow sampling (Raytraced shadows) */
	void shadow_soft_size(float value) {
		PyObject_SetAttrString(pyobjref, "shadow_soft_size", Py_BuildValue("f", value));
	}

	/** Getter: Objects on the same layers only cast shadows */
	bool use_shadow_layer() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_shadow_layer")) == 1;
	}

	/** Setter: Objects on the same layers only cast shadows */
	void use_shadow_layer(bool value) {
		PyObject_SetAttrString(pyobjref, "use_shadow_layer", Py_BuildValue("i", value));
	}

};

/**************** Area Lamp ****************/

/**
 * Directional area lamp
 */
class AreaLamp : public Lamp {
public:
	AreaLamp(PyObject* pyobj) : Lamp(pyobj) {}

	AreaLamp() : Lamp(0)
	{
		// not implemented
	}

	/** Getter:  */
	bool use_shadow() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_shadow")) == 1;
	}

	/** Setter:  */
	void use_shadow(bool value) {
		PyObject_SetAttrString(pyobjref, "use_shadow", Py_BuildValue("i", value));
	}

	enum shadow_method_enum {
		shadow_method_NOSHADOW = 0,
		shadow_method_RAY_SHADOW = 8192,
	};

	/** Getter:  */
	shadow_method_enum shadow_method() { /* not implemented */ throw NULL; }
	/** Setter:  */
	void shadow_method(shadow_method_enum value) { /* not implemented */ }

	/** Getter: Resolution of the shadow buffer, higher values give crisper shadows but use more memory */
	int shadow_buffer_size() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "shadow_buffer_size"));
	}

	/** Setter: Resolution of the shadow buffer, higher values give crisper shadows but use more memory */
	void shadow_buffer_size(int value) {
		PyObject_SetAttrString(pyobjref, "shadow_buffer_size", Py_BuildValue("i", value));
	}

	enum shadow_filter_type_enum {
		shadow_filter_type_BOX = 0,
		shadow_filter_type_TENT = 1,
		shadow_filter_type_GAUSS = 2,
	};

	/** Getter: Type of shadow filter (Buffer Shadows) */
	shadow_filter_type_enum shadow_filter_type() { /* not implemented */ throw NULL; }
	/** Setter: Type of shadow filter (Buffer Shadows) */
	void shadow_filter_type(shadow_filter_type_enum value) { /* not implemented */ }

	enum shadow_sample_buffers_enum {
		shadow_sample_buffers_BUFFERS_1 = 1,
		shadow_sample_buffers_BUFFERS_4 = 4,
		shadow_sample_buffers_BUFFERS_9 = 9,
	};

	/** Getter: Number of shadow buffers to render for better AA, this increases memory usage */
	shadow_sample_buffers_enum shadow_sample_buffers() { /* not implemented */ throw NULL; }
	/** Setter: Number of shadow buffers to render for better AA, this increases memory usage */
	void shadow_sample_buffers(shadow_sample_buffers_enum value) { /* not implemented */ }

	/** Getter: Shadow map clip start, below which objects will not generate shadows */
	float shadow_buffer_clip_start() { /* not implemented */ throw NULL; }
	/** Setter: Shadow map clip start, below which objects will not generate shadows */
	void shadow_buffer_clip_start(float value) {
		PyObject_SetAttrString(pyobjref, "shadow_buffer_clip_start", Py_BuildValue("f", value));
	}

	/** Getter: Shadow map clip end, beyond which objects will not generate shadows */
	float shadow_buffer_clip_end() { /* not implemented */ throw NULL; }
	/** Setter: Shadow map clip end, beyond which objects will not generate shadows */
	void shadow_buffer_clip_end(float value) {
		PyObject_SetAttrString(pyobjref, "shadow_buffer_clip_end", Py_BuildValue("f", value));
	}

	/** Getter: Shadow buffer sampling bias */
	float shadow_buffer_bias() { /* not implemented */ throw NULL; }
	/** Setter: Shadow buffer sampling bias */
	void shadow_buffer_bias(float value) {
		PyObject_SetAttrString(pyobjref, "shadow_buffer_bias", Py_BuildValue("f", value));
	}

	/** Getter: Bias for reducing light-bleed on variance shadow maps */
	float shadow_buffer_bleed_bias() { /* not implemented */ throw NULL; }
	/** Setter: Bias for reducing light-bleed on variance shadow maps */
	void shadow_buffer_bleed_bias(float value) {
		PyObject_SetAttrString(pyobjref, "shadow_buffer_bleed_bias", Py_BuildValue("f", value));
	}

	/** Getter: Size of shadow buffer sampling area */
	float shadow_buffer_soft() { /* not implemented */ throw NULL; }
	/** Setter: Size of shadow buffer sampling area */
	void shadow_buffer_soft(float value) {
		PyObject_SetAttrString(pyobjref, "shadow_buffer_soft", Py_BuildValue("f", value));
	}

	/** Getter: Number of shadow buffer samples */
	int shadow_buffer_samples() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "shadow_buffer_samples"));
	}

	/** Setter: Number of shadow buffer samples */
	void shadow_buffer_samples(int value) {
		PyObject_SetAttrString(pyobjref, "shadow_buffer_samples", Py_BuildValue("i", value));
	}

	enum shadow_buffer_type_enum {
		shadow_buffer_type_REGULAR = 0,
		shadow_buffer_type_HALFWAY = 2,
		shadow_buffer_type_IRREGULAR = 1,
		shadow_buffer_type_DEEP = 3,
	};

	/** Getter: Type of shadow buffer */
	shadow_buffer_type_enum shadow_buffer_type() { /* not implemented */ throw NULL; }
	/** Setter: Type of shadow buffer */
	void shadow_buffer_type(shadow_buffer_type_enum value) { /* not implemented */ }

	enum ge_shadow_buffer_type_enum {
		ge_shadow_buffer_type_SIMPLE = 0,
		ge_shadow_buffer_type_VARIANCE = 1,
	};

	/** Getter: The shadow mapping algorithm used */
	ge_shadow_buffer_type_enum ge_shadow_buffer_type() { /* not implemented */ throw NULL; }
	/** Setter: The shadow mapping algorithm used */
	void ge_shadow_buffer_type(ge_shadow_buffer_type_enum value) { /* not implemented */ }

	/** Getter: Automatic calculation of clipping-start, based on visible vertices */
	bool use_auto_clip_start() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_auto_clip_start")) == 1;
	}

	/** Setter: Automatic calculation of clipping-start, based on visible vertices */
	void use_auto_clip_start(bool value) {
		PyObject_SetAttrString(pyobjref, "use_auto_clip_start", Py_BuildValue("i", value));
	}

	/** Getter: Automatic calculation of clipping-end, based on visible vertices */
	bool use_auto_clip_end() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_auto_clip_end")) == 1;
	}

	/** Setter: Automatic calculation of clipping-end, based on visible vertices */
	void use_auto_clip_end(bool value) {
		PyObject_SetAttrString(pyobjref, "use_auto_clip_end", Py_BuildValue("i", value));
	}

	/** Getter: Deep shadow map compression threshold */
	float compression_threshold() { /* not implemented */ throw NULL; }
	/** Setter: Deep shadow map compression threshold */
	void compression_threshold(float value) {
		PyObject_SetAttrString(pyobjref, "compression_threshold", Py_BuildValue("f", value));
	}

	/** Getter: Color of shadows cast by the lamp */
	std::array<float, 3> shadow_color() {
		// TODO: MISSING DEREF! USE #DEFINE!
		PyObject *seqval = PyObject_GetAttrString(pyobjref, "shadow_color");
		std::array<float, 3> resarr;
		for (int i = 0; i < 3; i++)
			resarr[i] = (float)PyFloat_AsDouble(PySequence_GetItem(seqval, i));
		return resarr;
	}

	/** Setter: Color of shadows cast by the lamp */
	void shadow_color(float values[3]) { /* not implemented */ }

	/** Getter: Cast shadows only, without illuminating objects */
	bool use_only_shadow() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_only_shadow")) == 1;
	}

	/** Setter: Cast shadows only, without illuminating objects */
	void use_only_shadow(bool value) {
		PyObject_SetAttrString(pyobjref, "use_only_shadow", Py_BuildValue("i", value));
	}

	enum shadow_ray_sample_method_enum {
		shadow_ray_sample_method_ADAPTIVE_QMC = 1,
		shadow_ray_sample_method_CONSTANT_QMC = 2,
		shadow_ray_sample_method_CONSTANT_JITTERED = 0,
	};

	/** Getter: Method for generating shadow samples: Adaptive QMC is fastest, Constant QMC is less noisy but slower */
	shadow_ray_sample_method_enum shadow_ray_sample_method() { /* not implemented */ throw NULL; }
	/** Setter: Method for generating shadow samples: Adaptive QMC is fastest, Constant QMC is less noisy but slower */
	void shadow_ray_sample_method(shadow_ray_sample_method_enum value) { /* not implemented */ }

	/** Getter: Number of samples taken extra (samples x samples) */
	int shadow_ray_samples_x() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "shadow_ray_samples_x"));
	}

	/** Setter: Number of samples taken extra (samples x samples) */
	void shadow_ray_samples_x(int value) {
		PyObject_SetAttrString(pyobjref, "shadow_ray_samples_x", Py_BuildValue("i", value));
	}

	/** Getter: Number of samples taken extra (samples x samples) */
	int shadow_ray_samples_y() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "shadow_ray_samples_y"));
	}

	/** Setter: Number of samples taken extra (samples x samples) */
	void shadow_ray_samples_y(int value) {
		PyObject_SetAttrString(pyobjref, "shadow_ray_samples_y", Py_BuildValue("i", value));
	}

	/** Getter: Threshold for Adaptive Sampling (Raytraced shadows) */
	float shadow_adaptive_threshold() { /* not implemented */ throw NULL; }
	/** Setter: Threshold for Adaptive Sampling (Raytraced shadows) */
	void shadow_adaptive_threshold(float value) {
		PyObject_SetAttrString(pyobjref, "shadow_adaptive_threshold", Py_BuildValue("f", value));
	}

	/** Getter: Light size for ray shadow sampling (Raytraced shadows) */
	float shadow_soft_size() { /* not implemented */ throw NULL; }
	/** Setter: Light size for ray shadow sampling (Raytraced shadows) */
	void shadow_soft_size(float value) {
		PyObject_SetAttrString(pyobjref, "shadow_soft_size", Py_BuildValue("f", value));
	}

	/** Getter: Objects on the same layers only cast shadows */
	bool use_shadow_layer() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_shadow_layer")) == 1;
	}

	/** Setter: Objects on the same layers only cast shadows */
	void use_shadow_layer(bool value) {
		PyObject_SetAttrString(pyobjref, "use_shadow_layer", Py_BuildValue("i", value));
	}

	/** Getter: Emphasize parts that are fully shadowed (Constant Jittered sampling) */
	bool use_umbra() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_umbra")) == 1;
	}

	/** Setter: Emphasize parts that are fully shadowed (Constant Jittered sampling) */
	void use_umbra(bool value) {
		PyObject_SetAttrString(pyobjref, "use_umbra", Py_BuildValue("i", value));
	}

	/** Getter: Use 2x2 dithering for sampling  (Constant Jittered sampling) */
	bool use_dither() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_dither")) == 1;
	}

	/** Setter: Use 2x2 dithering for sampling  (Constant Jittered sampling) */
	void use_dither(bool value) {
		PyObject_SetAttrString(pyobjref, "use_dither", Py_BuildValue("i", value));
	}

	/** Getter: Use noise for sampling  (Constant Jittered sampling) */
	bool use_jitter() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_jitter")) == 1;
	}

	/** Setter: Use noise for sampling  (Constant Jittered sampling) */
	void use_jitter(bool value) {
		PyObject_SetAttrString(pyobjref, "use_jitter", Py_BuildValue("i", value));
	}

	enum shape_enum {
		shape_SQUARE = 0,
		shape_RECTANGLE = 1,
	};

	/** Getter: Shape of the area lamp */
	shape_enum shape() { /* not implemented */ throw NULL; }
	/** Setter: Shape of the area lamp */
	void shape(shape_enum value) { /* not implemented */ }

	/** Getter: Size of the area of the area Lamp, X direction size for Rectangle shapes */
	float size() { /* not implemented */ throw NULL; }
	/** Setter: Size of the area of the area Lamp, X direction size for Rectangle shapes */
	void size(float value) {
		PyObject_SetAttrString(pyobjref, "size", Py_BuildValue("f", value));
	}

	/** Getter: Size of the area of the area Lamp in the Y direction for Rectangle shapes */
	float size_y() { /* not implemented */ throw NULL; }
	/** Setter: Size of the area of the area Lamp in the Y direction for Rectangle shapes */
	void size_y(float value) {
		PyObject_SetAttrString(pyobjref, "size_y", Py_BuildValue("f", value));
	}

	/** Getter: Light gamma correction value */
	float gamma() { /* not implemented */ throw NULL; }
	/** Setter: Light gamma correction value */
	void gamma(float value) {
		PyObject_SetAttrString(pyobjref, "gamma", Py_BuildValue("f", value));
	}

};

/**************** Spot Lamp ****************/

/**
 * Directional cone lamp
 */
class SpotLamp : public Lamp {
public:
	SpotLamp(PyObject* pyobj) : Lamp(pyobj) {}

	SpotLamp() : Lamp(0)
	{
		// not implemented
	}

	enum falloff_type_enum {
		falloff_type_CONSTANT = 0,
		falloff_type_INVERSE_LINEAR = 1,
		falloff_type_INVERSE_SQUARE = 2,
		falloff_type_CUSTOM_CURVE = 3,
		falloff_type_LINEAR_QUADRATIC_WEIGHTED = 4,
	};

	/** Getter: Intensity Decay with distance */
	falloff_type_enum falloff_type() { /* not implemented */ throw NULL; }
	/** Setter: Intensity Decay with distance */
	void falloff_type(falloff_type_enum value) { /* not implemented */ }

	/** Getter: Custom Lamp Falloff Curve */
	CurveMapping falloff_curve() {
		/* not implemented */ throw NULL;
	}

	/** Getter: Set light intensity to zero beyond lamp distance */
	bool use_sphere() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_sphere")) == 1;
	}

	/** Setter: Set light intensity to zero beyond lamp distance */
	void use_sphere(bool value) {
		PyObject_SetAttrString(pyobjref, "use_sphere", Py_BuildValue("i", value));
	}

	/** Getter: Linear distance attenuation */
	float linear_attenuation() { /* not implemented */ throw NULL; }
	/** Setter: Linear distance attenuation */
	void linear_attenuation(float value) {
		PyObject_SetAttrString(pyobjref, "linear_attenuation", Py_BuildValue("f", value));
	}

	/** Getter: Quadratic distance attenuation */
	float quadratic_attenuation() { /* not implemented */ throw NULL; }
	/** Setter: Quadratic distance attenuation */
	void quadratic_attenuation(float value) {
		PyObject_SetAttrString(pyobjref, "quadratic_attenuation", Py_BuildValue("f", value));
	}

	/** Getter:  */
	bool use_shadow() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_shadow")) == 1;
	}

	/** Setter:  */
	void use_shadow(bool value) {
		PyObject_SetAttrString(pyobjref, "use_shadow", Py_BuildValue("i", value));
	}

	enum shadow_method_enum {
		shadow_method_NOSHADOW = 0,
		shadow_method_BUFFER_SHADOW = 1,
		shadow_method_RAY_SHADOW = 8192,
	};

	/** Getter:  */
	shadow_method_enum shadow_method() { /* not implemented */ throw NULL; }
	/** Setter:  */
	void shadow_method(shadow_method_enum value) { /* not implemented */ }

	/** Getter: Resolution of the shadow buffer, higher values give crisper shadows but use more memory */
	int shadow_buffer_size() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "shadow_buffer_size"));
	}

	/** Setter: Resolution of the shadow buffer, higher values give crisper shadows but use more memory */
	void shadow_buffer_size(int value) {
		PyObject_SetAttrString(pyobjref, "shadow_buffer_size", Py_BuildValue("i", value));
	}

	enum shadow_filter_type_enum {
		shadow_filter_type_BOX = 0,
		shadow_filter_type_TENT = 1,
		shadow_filter_type_GAUSS = 2,
	};

	/** Getter: Type of shadow filter (Buffer Shadows) */
	shadow_filter_type_enum shadow_filter_type() { /* not implemented */ throw NULL; }
	/** Setter: Type of shadow filter (Buffer Shadows) */
	void shadow_filter_type(shadow_filter_type_enum value) { /* not implemented */ }

	enum shadow_sample_buffers_enum {
		shadow_sample_buffers_BUFFERS_1 = 1,
		shadow_sample_buffers_BUFFERS_4 = 4,
		shadow_sample_buffers_BUFFERS_9 = 9,
	};

	/** Getter: Number of shadow buffers to render for better AA, this increases memory usage */
	shadow_sample_buffers_enum shadow_sample_buffers() { /* not implemented */ throw NULL; }
	/** Setter: Number of shadow buffers to render for better AA, this increases memory usage */
	void shadow_sample_buffers(shadow_sample_buffers_enum value) { /* not implemented */ }

	/** Getter: Shadow map clip start, below which objects will not generate shadows */
	float shadow_buffer_clip_start() { /* not implemented */ throw NULL; }
	/** Setter: Shadow map clip start, below which objects will not generate shadows */
	void shadow_buffer_clip_start(float value) {
		PyObject_SetAttrString(pyobjref, "shadow_buffer_clip_start", Py_BuildValue("f", value));
	}

	/** Getter: Shadow map clip end, beyond which objects will not generate shadows */
	float shadow_buffer_clip_end() { /* not implemented */ throw NULL; }
	/** Setter: Shadow map clip end, beyond which objects will not generate shadows */
	void shadow_buffer_clip_end(float value) {
		PyObject_SetAttrString(pyobjref, "shadow_buffer_clip_end", Py_BuildValue("f", value));
	}

	/** Getter: Shadow buffer sampling bias */
	float shadow_buffer_bias() { /* not implemented */ throw NULL; }
	/** Setter: Shadow buffer sampling bias */
	void shadow_buffer_bias(float value) {
		PyObject_SetAttrString(pyobjref, "shadow_buffer_bias", Py_BuildValue("f", value));
	}

	/** Getter: Bias for reducing light-bleed on variance shadow maps */
	float shadow_buffer_bleed_bias() { /* not implemented */ throw NULL; }
	/** Setter: Bias for reducing light-bleed on variance shadow maps */
	void shadow_buffer_bleed_bias(float value) {
		PyObject_SetAttrString(pyobjref, "shadow_buffer_bleed_bias", Py_BuildValue("f", value));
	}

	/** Getter: Size of shadow buffer sampling area */
	float shadow_buffer_soft() { /* not implemented */ throw NULL; }
	/** Setter: Size of shadow buffer sampling area */
	void shadow_buffer_soft(float value) {
		PyObject_SetAttrString(pyobjref, "shadow_buffer_soft", Py_BuildValue("f", value));
	}

	/** Getter: Number of shadow buffer samples */
	int shadow_buffer_samples() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "shadow_buffer_samples"));
	}

	/** Setter: Number of shadow buffer samples */
	void shadow_buffer_samples(int value) {
		PyObject_SetAttrString(pyobjref, "shadow_buffer_samples", Py_BuildValue("i", value));
	}

	enum shadow_buffer_type_enum {
		shadow_buffer_type_REGULAR = 0,
		shadow_buffer_type_HALFWAY = 2,
		shadow_buffer_type_IRREGULAR = 1,
		shadow_buffer_type_DEEP = 3,
	};

	/** Getter: Type of shadow buffer */
	shadow_buffer_type_enum shadow_buffer_type() { /* not implemented */ throw NULL; }
	/** Setter: Type of shadow buffer */
	void shadow_buffer_type(shadow_buffer_type_enum value) { /* not implemented */ }

	enum ge_shadow_buffer_type_enum {
		ge_shadow_buffer_type_SIMPLE = 0,
		ge_shadow_buffer_type_VARIANCE = 1,
	};

	/** Getter: The shadow mapping algorithm used */
	ge_shadow_buffer_type_enum ge_shadow_buffer_type() { /* not implemented */ throw NULL; }
	/** Setter: The shadow mapping algorithm used */
	void ge_shadow_buffer_type(ge_shadow_buffer_type_enum value) { /* not implemented */ }

	/** Getter: Automatic calculation of clipping-start, based on visible vertices */
	bool use_auto_clip_start() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_auto_clip_start")) == 1;
	}

	/** Setter: Automatic calculation of clipping-start, based on visible vertices */
	void use_auto_clip_start(bool value) {
		PyObject_SetAttrString(pyobjref, "use_auto_clip_start", Py_BuildValue("i", value));
	}

	/** Getter: Automatic calculation of clipping-end, based on visible vertices */
	bool use_auto_clip_end() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_auto_clip_end")) == 1;
	}

	/** Setter: Automatic calculation of clipping-end, based on visible vertices */
	void use_auto_clip_end(bool value) {
		PyObject_SetAttrString(pyobjref, "use_auto_clip_end", Py_BuildValue("i", value));
	}

	/** Getter: Deep shadow map compression threshold */
	float compression_threshold() { /* not implemented */ throw NULL; }
	/** Setter: Deep shadow map compression threshold */
	void compression_threshold(float value) {
		PyObject_SetAttrString(pyobjref, "compression_threshold", Py_BuildValue("f", value));
	}

	/** Getter: Color of shadows cast by the lamp */
	std::array<float, 3> shadow_color() {
		// TODO: MISSING DEREF! USE #DEFINE!
		PyObject *seqval = PyObject_GetAttrString(pyobjref, "shadow_color");
		std::array<float, 3> resarr;
		for (int i = 0; i < 3; i++)
			resarr[i] = (float)PyFloat_AsDouble(PySequence_GetItem(seqval, i));
		return resarr;
	}

	/** Setter: Color of shadows cast by the lamp */
	void shadow_color(float values[3]) { /* not implemented */ }

	/** Getter: Cast shadows only, without illuminating objects */
	bool use_only_shadow() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_only_shadow")) == 1;
	}

	/** Setter: Cast shadows only, without illuminating objects */
	void use_only_shadow(bool value) {
		PyObject_SetAttrString(pyobjref, "use_only_shadow", Py_BuildValue("i", value));
	}

	enum shadow_ray_sample_method_enum {
		shadow_ray_sample_method_ADAPTIVE_QMC = 1,
		shadow_ray_sample_method_CONSTANT_QMC = 2,
	};

	/** Getter: Method for generating shadow samples: Adaptive QMC is fastest, Constant QMC is less noisy but slower */
	shadow_ray_sample_method_enum shadow_ray_sample_method() { /* not implemented */ throw NULL; }
	/** Setter: Method for generating shadow samples: Adaptive QMC is fastest, Constant QMC is less noisy but slower */
	void shadow_ray_sample_method(shadow_ray_sample_method_enum value) { /* not implemented */ }

	/** Getter: Number of samples taken extra (samples x samples) */
	int shadow_ray_samples() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "shadow_ray_samples"));
	}

	/** Setter: Number of samples taken extra (samples x samples) */
	void shadow_ray_samples(int value) {
		PyObject_SetAttrString(pyobjref, "shadow_ray_samples", Py_BuildValue("i", value));
	}

	/** Getter: Threshold for Adaptive Sampling (Raytraced shadows) */
	float shadow_adaptive_threshold() { /* not implemented */ throw NULL; }
	/** Setter: Threshold for Adaptive Sampling (Raytraced shadows) */
	void shadow_adaptive_threshold(float value) {
		PyObject_SetAttrString(pyobjref, "shadow_adaptive_threshold", Py_BuildValue("f", value));
	}

	/** Getter: Light size for ray shadow sampling (Raytraced shadows) */
	float shadow_soft_size() { /* not implemented */ throw NULL; }
	/** Setter: Light size for ray shadow sampling (Raytraced shadows) */
	void shadow_soft_size(float value) {
		PyObject_SetAttrString(pyobjref, "shadow_soft_size", Py_BuildValue("f", value));
	}

	/** Getter: Objects on the same layers only cast shadows */
	bool use_shadow_layer() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_shadow_layer")) == 1;
	}

	/** Setter: Objects on the same layers only cast shadows */
	void use_shadow_layer(bool value) {
		PyObject_SetAttrString(pyobjref, "use_shadow_layer", Py_BuildValue("i", value));
	}

	/** Getter: Cast a square spot light shape */
	bool use_square() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_square")) == 1;
	}

	/** Setter: Cast a square spot light shape */
	void use_square(bool value) {
		PyObject_SetAttrString(pyobjref, "use_square", Py_BuildValue("i", value));
	}

	/** Getter: Render spotlight with a volumetric halo */
	bool use_halo() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_halo")) == 1;
	}

	/** Setter: Render spotlight with a volumetric halo */
	void use_halo(bool value) {
		PyObject_SetAttrString(pyobjref, "use_halo", Py_BuildValue("i", value));
	}

	/** Getter: Brightness of the spotlight's halo cone */
	float halo_intensity() { /* not implemented */ throw NULL; }
	/** Setter: Brightness of the spotlight's halo cone */
	void halo_intensity(float value) {
		PyObject_SetAttrString(pyobjref, "halo_intensity", Py_BuildValue("f", value));
	}

	/** Getter: Volumetric halo sampling frequency */
	int halo_step() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "halo_step"));
	}

	/** Setter: Volumetric halo sampling frequency */
	void halo_step(int value) {
		PyObject_SetAttrString(pyobjref, "halo_step", Py_BuildValue("i", value));
	}

	/** Getter: The softness of the spotlight edge */
	float spot_blend() { /* not implemented */ throw NULL; }
	/** Setter: The softness of the spotlight edge */
	void spot_blend(float value) {
		PyObject_SetAttrString(pyobjref, "spot_blend", Py_BuildValue("f", value));
	}

	/** Getter: Angle of the spotlight beam */
	float spot_size() { /* not implemented */ throw NULL; }
	/** Setter: Angle of the spotlight beam */
	void spot_size(float value) {
		PyObject_SetAttrString(pyobjref, "spot_size", Py_BuildValue("f", value));
	}

	/** Getter: Draw transparent cone in 3D view to visualize which objects are contained in it */
	bool show_cone() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "show_cone")) == 1;
	}

	/** Setter: Draw transparent cone in 3D view to visualize which objects are contained in it */
	void show_cone(bool value) {
		PyObject_SetAttrString(pyobjref, "show_cone", Py_BuildValue("i", value));
	}

};

/**************** Sun Lamp ****************/

/**
 * Constant direction parallel ray lamp
 */
class SunLamp : public Lamp {
public:
	SunLamp(PyObject* pyobj) : Lamp(pyobj) {}

	SunLamp() : Lamp(0)
	{
		// not implemented
	}

	/** Getter:  */
	bool use_shadow() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_shadow")) == 1;
	}

	/** Setter:  */
	void use_shadow(bool value) {
		PyObject_SetAttrString(pyobjref, "use_shadow", Py_BuildValue("i", value));
	}

	enum shadow_method_enum {
		shadow_method_NOSHADOW = 0,
		shadow_method_RAY_SHADOW = 8192,
	};

	/** Getter:  */
	shadow_method_enum shadow_method() { /* not implemented */ throw NULL; }
	/** Setter:  */
	void shadow_method(shadow_method_enum value) { /* not implemented */ }

	/** Getter: Resolution of the shadow buffer, higher values give crisper shadows but use more memory */
	int shadow_buffer_size() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "shadow_buffer_size"));
	}

	/** Setter: Resolution of the shadow buffer, higher values give crisper shadows but use more memory */
	void shadow_buffer_size(int value) {
		PyObject_SetAttrString(pyobjref, "shadow_buffer_size", Py_BuildValue("i", value));
	}

	enum shadow_filter_type_enum {
		shadow_filter_type_BOX = 0,
		shadow_filter_type_TENT = 1,
		shadow_filter_type_GAUSS = 2,
	};

	/** Getter: Type of shadow filter (Buffer Shadows) */
	shadow_filter_type_enum shadow_filter_type() { /* not implemented */ throw NULL; }
	/** Setter: Type of shadow filter (Buffer Shadows) */
	void shadow_filter_type(shadow_filter_type_enum value) { /* not implemented */ }

	enum shadow_sample_buffers_enum {
		shadow_sample_buffers_BUFFERS_1 = 1,
		shadow_sample_buffers_BUFFERS_4 = 4,
		shadow_sample_buffers_BUFFERS_9 = 9,
	};

	/** Getter: Number of shadow buffers to render for better AA, this increases memory usage */
	shadow_sample_buffers_enum shadow_sample_buffers() { /* not implemented */ throw NULL; }
	/** Setter: Number of shadow buffers to render for better AA, this increases memory usage */
	void shadow_sample_buffers(shadow_sample_buffers_enum value) { /* not implemented */ }

	/** Getter: Shadow map clip start, below which objects will not generate shadows */
	float shadow_buffer_clip_start() { /* not implemented */ throw NULL; }
	/** Setter: Shadow map clip start, below which objects will not generate shadows */
	void shadow_buffer_clip_start(float value) {
		PyObject_SetAttrString(pyobjref, "shadow_buffer_clip_start", Py_BuildValue("f", value));
	}

	/** Getter: Shadow map clip end, beyond which objects will not generate shadows */
	float shadow_buffer_clip_end() { /* not implemented */ throw NULL; }
	/** Setter: Shadow map clip end, beyond which objects will not generate shadows */
	void shadow_buffer_clip_end(float value) {
		PyObject_SetAttrString(pyobjref, "shadow_buffer_clip_end", Py_BuildValue("f", value));
	}

	/** Getter: Shadow buffer sampling bias */
	float shadow_buffer_bias() { /* not implemented */ throw NULL; }
	/** Setter: Shadow buffer sampling bias */
	void shadow_buffer_bias(float value) {
		PyObject_SetAttrString(pyobjref, "shadow_buffer_bias", Py_BuildValue("f", value));
	}

	/** Getter: Bias for reducing light-bleed on variance shadow maps */
	float shadow_buffer_bleed_bias() { /* not implemented */ throw NULL; }
	/** Setter: Bias for reducing light-bleed on variance shadow maps */
	void shadow_buffer_bleed_bias(float value) {
		PyObject_SetAttrString(pyobjref, "shadow_buffer_bleed_bias", Py_BuildValue("f", value));
	}

	/** Getter: Size of shadow buffer sampling area */
	float shadow_buffer_soft() { /* not implemented */ throw NULL; }
	/** Setter: Size of shadow buffer sampling area */
	void shadow_buffer_soft(float value) {
		PyObject_SetAttrString(pyobjref, "shadow_buffer_soft", Py_BuildValue("f", value));
	}

	/** Getter: Number of shadow buffer samples */
	int shadow_buffer_samples() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "shadow_buffer_samples"));
	}

	/** Setter: Number of shadow buffer samples */
	void shadow_buffer_samples(int value) {
		PyObject_SetAttrString(pyobjref, "shadow_buffer_samples", Py_BuildValue("i", value));
	}

	enum shadow_buffer_type_enum {
		shadow_buffer_type_REGULAR = 0,
		shadow_buffer_type_HALFWAY = 2,
		shadow_buffer_type_IRREGULAR = 1,
		shadow_buffer_type_DEEP = 3,
	};

	/** Getter: Type of shadow buffer */
	shadow_buffer_type_enum shadow_buffer_type() { /* not implemented */ throw NULL; }
	/** Setter: Type of shadow buffer */
	void shadow_buffer_type(shadow_buffer_type_enum value) { /* not implemented */ }

	enum ge_shadow_buffer_type_enum {
		ge_shadow_buffer_type_SIMPLE = 0,
		ge_shadow_buffer_type_VARIANCE = 1,
	};

	/** Getter: The shadow mapping algorithm used */
	ge_shadow_buffer_type_enum ge_shadow_buffer_type() { /* not implemented */ throw NULL; }
	/** Setter: The shadow mapping algorithm used */
	void ge_shadow_buffer_type(ge_shadow_buffer_type_enum value) { /* not implemented */ }

	/** Getter: Automatic calculation of clipping-start, based on visible vertices */
	bool use_auto_clip_start() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_auto_clip_start")) == 1;
	}

	/** Setter: Automatic calculation of clipping-start, based on visible vertices */
	void use_auto_clip_start(bool value) {
		PyObject_SetAttrString(pyobjref, "use_auto_clip_start", Py_BuildValue("i", value));
	}

	/** Getter: Automatic calculation of clipping-end, based on visible vertices */
	bool use_auto_clip_end() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_auto_clip_end")) == 1;
	}

	/** Setter: Automatic calculation of clipping-end, based on visible vertices */
	void use_auto_clip_end(bool value) {
		PyObject_SetAttrString(pyobjref, "use_auto_clip_end", Py_BuildValue("i", value));
	}

	/** Getter: Deep shadow map compression threshold */
	float compression_threshold() { /* not implemented */ throw NULL; }
	/** Setter: Deep shadow map compression threshold */
	void compression_threshold(float value) {
		PyObject_SetAttrString(pyobjref, "compression_threshold", Py_BuildValue("f", value));
	}

	/** Getter: Color of shadows cast by the lamp */
	std::array<float, 3> shadow_color() {
		// TODO: MISSING DEREF! USE #DEFINE!
		PyObject *seqval = PyObject_GetAttrString(pyobjref, "shadow_color");
		std::array<float, 3> resarr;
		for (int i = 0; i < 3; i++)
			resarr[i] = (float)PyFloat_AsDouble(PySequence_GetItem(seqval, i));
		return resarr;
	}

	/** Setter: Color of shadows cast by the lamp */
	void shadow_color(float values[3]) { /* not implemented */ }

	/** Getter: Cast shadows only, without illuminating objects */
	bool use_only_shadow() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_only_shadow")) == 1;
	}

	/** Setter: Cast shadows only, without illuminating objects */
	void use_only_shadow(bool value) {
		PyObject_SetAttrString(pyobjref, "use_only_shadow", Py_BuildValue("i", value));
	}

	enum shadow_ray_sample_method_enum {
		shadow_ray_sample_method_ADAPTIVE_QMC = 1,
		shadow_ray_sample_method_CONSTANT_QMC = 2,
	};

	/** Getter: Method for generating shadow samples: Adaptive QMC is fastest, Constant QMC is less noisy but slower */
	shadow_ray_sample_method_enum shadow_ray_sample_method() { /* not implemented */ throw NULL; }
	/** Setter: Method for generating shadow samples: Adaptive QMC is fastest, Constant QMC is less noisy but slower */
	void shadow_ray_sample_method(shadow_ray_sample_method_enum value) { /* not implemented */ }

	/** Getter: Number of samples taken extra (samples x samples) */
	int shadow_ray_samples() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "shadow_ray_samples"));
	}

	/** Setter: Number of samples taken extra (samples x samples) */
	void shadow_ray_samples(int value) {
		PyObject_SetAttrString(pyobjref, "shadow_ray_samples", Py_BuildValue("i", value));
	}

	/** Getter: Threshold for Adaptive Sampling (Raytraced shadows) */
	float shadow_adaptive_threshold() { /* not implemented */ throw NULL; }
	/** Setter: Threshold for Adaptive Sampling (Raytraced shadows) */
	void shadow_adaptive_threshold(float value) {
		PyObject_SetAttrString(pyobjref, "shadow_adaptive_threshold", Py_BuildValue("f", value));
	}

	/** Getter: Light size for ray shadow sampling (Raytraced shadows) */
	float shadow_soft_size() { /* not implemented */ throw NULL; }
	/** Setter: Light size for ray shadow sampling (Raytraced shadows) */
	void shadow_soft_size(float value) {
		PyObject_SetAttrString(pyobjref, "shadow_soft_size", Py_BuildValue("f", value));
	}

	/** Getter: Objects on the same layers only cast shadows */
	bool use_shadow_layer() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_shadow_layer")) == 1;
	}

	/** Setter: Objects on the same layers only cast shadows */
	void use_shadow_layer(bool value) {
		PyObject_SetAttrString(pyobjref, "use_shadow_layer", Py_BuildValue("i", value));
	}

	/** Getter: Sky related settings for sun lamps */
	LampSkySettings sky();

	/** Getter: Size of the frustum used for creating the shadow map */
	float shadow_frustum_size() { /* not implemented */ throw NULL; }
	/** Setter: Size of the frustum used for creating the shadow map */
	void shadow_frustum_size(float value) {
		PyObject_SetAttrString(pyobjref, "shadow_frustum_size", Py_BuildValue("f", value));
	}

	/** Getter: Draw a box in 3D view to visualize which objects are contained in it */
	bool show_shadow_box() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "show_shadow_box")) == 1;
	}

	/** Setter: Draw a box in 3D view to visualize which objects are contained in it */
	void show_shadow_box(bool value) {
		PyObject_SetAttrString(pyobjref, "show_shadow_box", Py_BuildValue("i", value));
	}

};

/**************** Lamp Sky Settings ****************/

/**
 * Sky related settings for a sun lamp
 */
class LampSkySettings : public pyUniplug {
public:
	LampSkySettings(PyObject* pyobj) : pyUniplug(pyobj) {}

	LampSkySettings() : pyUniplug(0)
	{
		// not implemented
	}

	enum sky_color_space_enum {
		sky_color_space_SMPTE = 0,
		sky_color_space_REC709 = 1,
		sky_color_space_CIE = 2,
	};

	/** Getter: Color space to use for internal XYZ->RGB color conversion */
	sky_color_space_enum sky_color_space() { /* not implemented */ throw NULL; }
	/** Setter: Color space to use for internal XYZ->RGB color conversion */
	void sky_color_space(sky_color_space_enum value) { /* not implemented */ }

	enum sky_blend_type_enum {
		sky_blend_type_MIX = 0,
		sky_blend_type_ADD = 1,
		sky_blend_type_MULTIPLY = 2,
		sky_blend_type_SUBTRACT = 3,
		sky_blend_type_SCREEN = 4,
		sky_blend_type_DIVIDE = 5,
		sky_blend_type_DIFFERENCE = 6,
		sky_blend_type_DARKEN = 7,
		sky_blend_type_LIGHTEN = 8,
		sky_blend_type_OVERLAY = 9,
		sky_blend_type_DODGE = 10,
		sky_blend_type_BURN = 11,
		sky_blend_type_HUE = 12,
		sky_blend_type_SATURATION = 13,
		sky_blend_type_VALUE = 14,
		sky_blend_type_COLOR = 15,
		sky_blend_type_SOFT_LIGHT = 16,
		sky_blend_type_LINEAR_LIGHT = 17,
	};

	/** Getter: Blend mode for combining sun sky with world sky */
	sky_blend_type_enum sky_blend_type() { /* not implemented */ throw NULL; }
	/** Setter: Blend mode for combining sun sky with world sky */
	void sky_blend_type(sky_blend_type_enum value) { /* not implemented */ }

	/** Getter: Horizon brightness */
	float horizon_brightness() { /* not implemented */ throw NULL; }
	/** Setter: Horizon brightness */
	void horizon_brightness(float value) {
		PyObject_SetAttrString(pyobjref, "horizon_brightness", Py_BuildValue("f", value));
	}

	/** Getter: Horizon Spread */
	float spread() { /* not implemented */ throw NULL; }
	/** Setter: Horizon Spread */
	void spread(float value) {
		PyObject_SetAttrString(pyobjref, "spread", Py_BuildValue("f", value));
	}

	/** Getter: Sun brightness */
	float sun_brightness() { /* not implemented */ throw NULL; }
	/** Setter: Sun brightness */
	void sun_brightness(float value) {
		PyObject_SetAttrString(pyobjref, "sun_brightness", Py_BuildValue("f", value));
	}

	/** Getter: Sun size */
	float sun_size() { /* not implemented */ throw NULL; }
	/** Setter: Sun size */
	void sun_size(float value) {
		PyObject_SetAttrString(pyobjref, "sun_size", Py_BuildValue("f", value));
	}

	/** Getter: Backscattered light */
	float backscattered_light() { /* not implemented */ throw NULL; }
	/** Setter: Backscattered light */
	void backscattered_light(float value) {
		PyObject_SetAttrString(pyobjref, "backscattered_light", Py_BuildValue("f", value));
	}

	/** Getter: Sun intensity */
	float sun_intensity() { /* not implemented */ throw NULL; }
	/** Setter: Sun intensity */
	void sun_intensity(float value) {
		PyObject_SetAttrString(pyobjref, "sun_intensity", Py_BuildValue("f", value));
	}

	/** Getter: Sky turbidity */
	float atmosphere_turbidity() { /* not implemented */ throw NULL; }
	/** Setter: Sky turbidity */
	void atmosphere_turbidity(float value) {
		PyObject_SetAttrString(pyobjref, "atmosphere_turbidity", Py_BuildValue("f", value));
	}

	/** Getter: Scatter contribution factor */
	float atmosphere_inscattering() { /* not implemented */ throw NULL; }
	/** Setter: Scatter contribution factor */
	void atmosphere_inscattering(float value) {
		PyObject_SetAttrString(pyobjref, "atmosphere_inscattering", Py_BuildValue("f", value));
	}

	/** Getter: Extinction scattering contribution factor */
	float atmosphere_extinction() { /* not implemented */ throw NULL; }
	/** Setter: Extinction scattering contribution factor */
	void atmosphere_extinction(float value) {
		PyObject_SetAttrString(pyobjref, "atmosphere_extinction", Py_BuildValue("f", value));
	}

	/** Getter: Multiplier to convert blender units to physical distance */
	float atmosphere_distance_factor() { /* not implemented */ throw NULL; }
	/** Setter: Multiplier to convert blender units to physical distance */
	void atmosphere_distance_factor(float value) {
		PyObject_SetAttrString(pyobjref, "atmosphere_distance_factor", Py_BuildValue("f", value));
	}

	/** Getter: Blend factor with sky */
	float sky_blend() { /* not implemented */ throw NULL; }
	/** Setter: Blend factor with sky */
	void sky_blend(float value) {
		PyObject_SetAttrString(pyobjref, "sky_blend", Py_BuildValue("f", value));
	}

	/** Getter: Strength of sky shading exponential exposure correction */
	float sky_exposure() { /* not implemented */ throw NULL; }
	/** Setter: Strength of sky shading exponential exposure correction */
	void sky_exposure(float value) {
		PyObject_SetAttrString(pyobjref, "sky_exposure", Py_BuildValue("f", value));
	}

	/** Getter: Apply sun effect on sky */
	bool use_sky() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_sky")) == 1;
	}

	/** Setter: Apply sun effect on sky */
	void use_sky(bool value) {
		PyObject_SetAttrString(pyobjref, "use_sky", Py_BuildValue("i", value));
	}

	/** Getter: Apply sun effect on atmosphere */
	bool use_atmosphere() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_atmosphere")) == 1;
	}

	/** Setter: Apply sun effect on atmosphere */
	void use_atmosphere(bool value) {
		PyObject_SetAttrString(pyobjref, "use_atmosphere", Py_BuildValue("i", value));
	}

};

/**************** Hemi Lamp ****************/

/**
 * 180 degree constant lamp
 */
class HemiLamp : public Lamp {
public:
	HemiLamp(PyObject* pyobj) : Lamp(pyobj) {}

	HemiLamp() : Lamp(0)
	{
		// not implemented
	}

};

/**************** Lamp Texture Slot ****************/

/**
 * Texture slot for textures in a Lamp datablock
 */
class LampTextureSlot : public TextureSlot {
public:
	LampTextureSlot(PyObject* pyobj) : TextureSlot(pyobj) {}

	LampTextureSlot() : TextureSlot(0)
	{
		// not implemented
	}

	enum texture_coords_enum {
		texture_coords_GLOBAL = 8,
		texture_coords_VIEW = 128,
		texture_coords_OBJECT = 32,
	};

	/** Getter:  */
	texture_coords_enum texture_coords() { /* not implemented */ throw NULL; }
	/** Setter:  */
	void texture_coords(texture_coords_enum value) { /* not implemented */ }

	/** Getter: Object to use for mapping with Object texture coordinates */
	Object object_value();

	/** Getter: Let the texture affect the basic color of the lamp */
	bool use_map_color() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_map_color")) == 1;
	}

	/** Setter: Let the texture affect the basic color of the lamp */
	void use_map_color(bool value) {
		PyObject_SetAttrString(pyobjref, "use_map_color", Py_BuildValue("i", value));
	}

	/** Getter: Let the texture affect the shadow color of the lamp */
	bool use_map_shadow() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_map_shadow")) == 1;
	}

	/** Setter: Let the texture affect the shadow color of the lamp */
	void use_map_shadow(bool value) {
		PyObject_SetAttrString(pyobjref, "use_map_shadow", Py_BuildValue("i", value));
	}

	/** Getter: Amount texture affects color values */
	float color_factor() { /* not implemented */ throw NULL; }
	/** Setter: Amount texture affects color values */
	void color_factor(float value) {
		PyObject_SetAttrString(pyobjref, "color_factor", Py_BuildValue("f", value));
	}

	/** Getter: Amount texture affects shadow */
	float shadow_factor() { /* not implemented */ throw NULL; }
	/** Setter: Amount texture affects shadow */
	void shadow_factor(float value) {
		PyObject_SetAttrString(pyobjref, "shadow_factor", Py_BuildValue("f", value));
	}

};

/**************** Lattice ****************/

/**
 * Lattice datablock defining a grid for deforming other objects
 */
class Lattice : public ID {
public:
	Lattice(PyObject* pyobj) : ID(pyobj) {}

	Lattice() : ID(0)
	{
		// not implemented
	}

	/** Getter: Point in U direction (can't be changed when there are shape keys) */
	int points_u() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "points_u"));
	}

	/** Setter: Point in U direction (can't be changed when there are shape keys) */
	void points_u(int value) {
		PyObject_SetAttrString(pyobjref, "points_u", Py_BuildValue("i", value));
	}

	/** Getter: Point in V direction (can't be changed when there are shape keys) */
	int points_v() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "points_v"));
	}

	/** Setter: Point in V direction (can't be changed when there are shape keys) */
	void points_v(int value) {
		PyObject_SetAttrString(pyobjref, "points_v", Py_BuildValue("i", value));
	}

	/** Getter: Point in W direction (can't be changed when there are shape keys) */
	int points_w() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "points_w"));
	}

	/** Setter: Point in W direction (can't be changed when there are shape keys) */
	void points_w(int value) {
		PyObject_SetAttrString(pyobjref, "points_w", Py_BuildValue("i", value));
	}

	enum interpolation_type_u_enum {
		interpolation_type_u_KEY_LINEAR = 0,
		interpolation_type_u_KEY_CARDINAL = 1,
		interpolation_type_u_KEY_CATMULL_ROM = 3,
		interpolation_type_u_KEY_BSPLINE = 2,
	};

	/** Getter:  */
	interpolation_type_u_enum interpolation_type_u() { /* not implemented */ throw NULL; }
	/** Setter:  */
	void interpolation_type_u(interpolation_type_u_enum value) { /* not implemented */ }

	enum interpolation_type_v_enum {
		interpolation_type_v_KEY_LINEAR = 0,
		interpolation_type_v_KEY_CARDINAL = 1,
		interpolation_type_v_KEY_CATMULL_ROM = 3,
		interpolation_type_v_KEY_BSPLINE = 2,
	};

	/** Getter:  */
	interpolation_type_v_enum interpolation_type_v() { /* not implemented */ throw NULL; }
	/** Setter:  */
	void interpolation_type_v(interpolation_type_v_enum value) { /* not implemented */ }

	enum interpolation_type_w_enum {
		interpolation_type_w_KEY_LINEAR = 0,
		interpolation_type_w_KEY_CARDINAL = 1,
		interpolation_type_w_KEY_CATMULL_ROM = 3,
		interpolation_type_w_KEY_BSPLINE = 2,
	};

	/** Getter:  */
	interpolation_type_w_enum interpolation_type_w() { /* not implemented */ throw NULL; }
	/** Setter:  */
	void interpolation_type_w(interpolation_type_w_enum value) { /* not implemented */ }

	/** Getter: Only draw, and take into account, the outer vertices */
	bool use_outside() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_outside")) == 1;
	}

	/** Setter: Only draw, and take into account, the outer vertices */
	void use_outside(bool value) {
		PyObject_SetAttrString(pyobjref, "use_outside", Py_BuildValue("i", value));
	}

	/** Getter: Vertex group to apply the influence of the lattice */
	std::string vertex_group() { /* not implemented */ throw NULL; }
	/** Setter: Vertex group to apply the influence of the lattice */
	void vertex_group(const std::string& value) { /* not implemented */ }

	/** Getter:  */
	Key shape_keys() {
		/* not implemented */ throw NULL;
	}

	/** Getter: Points of the lattice */
	std::map<std::string, LatticePoint> points();
	/** Setter: Points of the lattice */
	void points(std::map<std::string, LatticePoint> value);

	/** Getter: True when used in editmode */
	bool is_editmode() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "is_editmode")) == 1;
	}

	/** Setter: True when used in editmode */
	void is_editmode(bool value) {
		PyObject_SetAttrString(pyobjref, "is_editmode", Py_BuildValue("i", value));
	}

	/** Getter: Animation data for this datablock */
	AnimData animation_data() {
		/* not implemented */ throw NULL;
	}

	/**
	 * Transform lattice by a matrix
	 * @param Matrix
	 * @param Transform Shape Keys
	 */
	void transform(float matrix[16], bool shape_keys = false)
	{
		// not implemented
	}

};

/**************** LatticePoint ****************/

/**
 * Point in the lattice grid
 */
class LatticePoint : public pyUniplug {
public:
	LatticePoint(PyObject* pyobj) : pyUniplug(pyobj) {}

	LatticePoint() : pyUniplug(0)
	{
		// not implemented
	}

	/** Getter: Selection status */
	bool select() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "select")) == 1;
	}

	/** Setter: Selection status */
	void select(bool value) {
		PyObject_SetAttrString(pyobjref, "select", Py_BuildValue("i", value));
	}

	/** Getter: Original undeformed location used to calculate the strength of the deform effect (edit/animate the Deformed Location instead) */
	std::array<float, 3> co() {
		// TODO: MISSING DEREF! USE #DEFINE!
		PyObject *seqval = PyObject_GetAttrString(pyobjref, "co");
		std::array<float, 3> resarr;
		for (int i = 0; i < 3; i++)
			resarr[i] = (float)PyFloat_AsDouble(PySequence_GetItem(seqval, i));
		return resarr;
	}

	/** Setter: Original undeformed location used to calculate the strength of the deform effect (edit/animate the Deformed Location instead) */
	void co(float values[3]) { /* not implemented */ }

	/** Getter:  */
	std::array<float, 3> co_deform() {
		// TODO: MISSING DEREF! USE #DEFINE!
		PyObject *seqval = PyObject_GetAttrString(pyobjref, "co_deform");
		std::array<float, 3> resarr;
		for (int i = 0; i < 3; i++)
			resarr[i] = (float)PyFloat_AsDouble(PySequence_GetItem(seqval, i));
		return resarr;
	}

	/** Setter:  */
	void co_deform(float values[3]) { /* not implemented */ }

	/** Getter: Softbody goal weight */
	float weight_softbody() { /* not implemented */ throw NULL; }
	/** Setter: Softbody goal weight */
	void weight_softbody(float value) {
		PyObject_SetAttrString(pyobjref, "weight_softbody", Py_BuildValue("f", value));
	}

	/** Getter: Weights for the vertex groups this point is member of */
	std::map<std::string, VertexGroupElement> groups();
	/** Setter: Weights for the vertex groups this point is member of */
	void groups(std::map<std::string, VertexGroupElement> value);

};

/**************** Line Style Modifier ****************/

/**
 * Base type to define modifiers
 */
class LineStyleModifier : public pyUniplug {
public:
	LineStyleModifier(PyObject* pyobj) : pyUniplug(pyobj) {}

	LineStyleModifier() : pyUniplug(0)
	{
		// not implemented
	}

};

/**************** Line Style Color Modifier ****************/

/**
 * Base type to define line color modifiers
 */
class LineStyleColorModifier : public LineStyleModifier {
public:
	LineStyleColorModifier(PyObject* pyobj) : LineStyleModifier(pyobj) {}

	LineStyleColorModifier() : LineStyleModifier(0)
	{
		// not implemented
	}

};

/**************** Along Stroke ****************/

/**
 * Change line color along stroke
 */
class LineStyleColorModifier_AlongStroke : public LineStyleColorModifier {
public:
	LineStyleColorModifier_AlongStroke(PyObject* pyobj) : LineStyleColorModifier(pyobj) {}

	LineStyleColorModifier_AlongStroke() : LineStyleColorModifier(0)
	{
		// not implemented
	}

	enum type_enum {
		type_ALONG_STROKE = 1,
		type_DISTANCE_FROM_CAMERA = 2,
		type_DISTANCE_FROM_OBJECT = 3,
		type_MATERIAL = 4,
	};

	/** Getter: Type of the modifier */
	type_enum type() { /* not implemented */ throw NULL; }
	/** Setter: Type of the modifier */
	void type(type_enum value) { /* not implemented */ }

	/** Getter: Name of the modifier */
	std::string name() { /* not implemented */ throw NULL; }
	/** Setter: Name of the modifier */
	void name(const std::string& value) { /* not implemented */ }

	enum blend_enum {
		blend_MIX = 0,
		blend_ADD = 1,
		blend_MULTIPLY = 2,
		blend_SUBTRACT = 3,
		blend_SCREEN = 4,
		blend_DIVIDE = 5,
		blend_DIFFERENCE = 6,
		blend_DARKEN = 7,
		blend_LIGHTEN = 8,
		blend_OVERLAY = 9,
		blend_DODGE = 10,
		blend_BURN = 11,
		blend_HUE = 12,
		blend_SATURATION = 13,
		blend_VALUE = 14,
		blend_COLOR = 15,
		blend_SOFT_LIGHT = 16,
		blend_LINEAR_LIGHT = 17,
	};

	/** Getter: Specify how the modifier value is blended into the base value */
	blend_enum blend() { /* not implemented */ throw NULL; }
	/** Setter: Specify how the modifier value is blended into the base value */
	void blend(blend_enum value) { /* not implemented */ }

	/** Getter: Influence factor by which the modifier changes the property */
	float influence() { /* not implemented */ throw NULL; }
	/** Setter: Influence factor by which the modifier changes the property */
	void influence(float value) {
		PyObject_SetAttrString(pyobjref, "influence", Py_BuildValue("f", value));
	}

	/** Getter: Enable or disable this modifier during stroke rendering */
	bool use() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use")) == 1;
	}

	/** Setter: Enable or disable this modifier during stroke rendering */
	void use(bool value) {
		PyObject_SetAttrString(pyobjref, "use", Py_BuildValue("i", value));
	}

	/** Getter: True if the modifier tab is expanded */
	bool expanded() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "expanded")) == 1;
	}

	/** Setter: True if the modifier tab is expanded */
	void expanded(bool value) {
		PyObject_SetAttrString(pyobjref, "expanded", Py_BuildValue("i", value));
	}

	/** Getter: Color ramp used to change line color */
	ColorRamp color_ramp() {
		/* not implemented */ throw NULL;
	}

};

/**************** Distance from Camera ****************/

/**
 * Change line color based on the distance from the camera
 */
class LineStyleColorModifier_DistanceFromCamera : public LineStyleColorModifier {
public:
	LineStyleColorModifier_DistanceFromCamera(PyObject* pyobj) : LineStyleColorModifier(pyobj) {}

	LineStyleColorModifier_DistanceFromCamera() : LineStyleColorModifier(0)
	{
		// not implemented
	}

	enum type_enum {
		type_ALONG_STROKE = 1,
		type_DISTANCE_FROM_CAMERA = 2,
		type_DISTANCE_FROM_OBJECT = 3,
		type_MATERIAL = 4,
	};

	/** Getter: Type of the modifier */
	type_enum type() { /* not implemented */ throw NULL; }
	/** Setter: Type of the modifier */
	void type(type_enum value) { /* not implemented */ }

	/** Getter: Name of the modifier */
	std::string name() { /* not implemented */ throw NULL; }
	/** Setter: Name of the modifier */
	void name(const std::string& value) { /* not implemented */ }

	enum blend_enum {
		blend_MIX = 0,
		blend_ADD = 1,
		blend_MULTIPLY = 2,
		blend_SUBTRACT = 3,
		blend_SCREEN = 4,
		blend_DIVIDE = 5,
		blend_DIFFERENCE = 6,
		blend_DARKEN = 7,
		blend_LIGHTEN = 8,
		blend_OVERLAY = 9,
		blend_DODGE = 10,
		blend_BURN = 11,
		blend_HUE = 12,
		blend_SATURATION = 13,
		blend_VALUE = 14,
		blend_COLOR = 15,
		blend_SOFT_LIGHT = 16,
		blend_LINEAR_LIGHT = 17,
	};

	/** Getter: Specify how the modifier value is blended into the base value */
	blend_enum blend() { /* not implemented */ throw NULL; }
	/** Setter: Specify how the modifier value is blended into the base value */
	void blend(blend_enum value) { /* not implemented */ }

	/** Getter: Influence factor by which the modifier changes the property */
	float influence() { /* not implemented */ throw NULL; }
	/** Setter: Influence factor by which the modifier changes the property */
	void influence(float value) {
		PyObject_SetAttrString(pyobjref, "influence", Py_BuildValue("f", value));
	}

	/** Getter: Enable or disable this modifier during stroke rendering */
	bool use() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use")) == 1;
	}

	/** Setter: Enable or disable this modifier during stroke rendering */
	void use(bool value) {
		PyObject_SetAttrString(pyobjref, "use", Py_BuildValue("i", value));
	}

	/** Getter: True if the modifier tab is expanded */
	bool expanded() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "expanded")) == 1;
	}

	/** Setter: True if the modifier tab is expanded */
	void expanded(bool value) {
		PyObject_SetAttrString(pyobjref, "expanded", Py_BuildValue("i", value));
	}

	/** Getter: Color ramp used to change line color */
	ColorRamp color_ramp() {
		/* not implemented */ throw NULL;
	}

	/** Getter: Lower bound of the input range the mapping is applied */
	float range_min() { /* not implemented */ throw NULL; }
	/** Setter: Lower bound of the input range the mapping is applied */
	void range_min(float value) {
		PyObject_SetAttrString(pyobjref, "range_min", Py_BuildValue("f", value));
	}

	/** Getter: Upper bound of the input range the mapping is applied */
	float range_max() { /* not implemented */ throw NULL; }
	/** Setter: Upper bound of the input range the mapping is applied */
	void range_max(float value) {
		PyObject_SetAttrString(pyobjref, "range_max", Py_BuildValue("f", value));
	}

};

/**************** Distance from Object ****************/

/**
 * Change line color based on the distance from an object
 */
class LineStyleColorModifier_DistanceFromObject : public LineStyleColorModifier {
public:
	LineStyleColorModifier_DistanceFromObject(PyObject* pyobj) : LineStyleColorModifier(pyobj) {}

	LineStyleColorModifier_DistanceFromObject() : LineStyleColorModifier(0)
	{
		// not implemented
	}

	enum type_enum {
		type_ALONG_STROKE = 1,
		type_DISTANCE_FROM_CAMERA = 2,
		type_DISTANCE_FROM_OBJECT = 3,
		type_MATERIAL = 4,
	};

	/** Getter: Type of the modifier */
	type_enum type() { /* not implemented */ throw NULL; }
	/** Setter: Type of the modifier */
	void type(type_enum value) { /* not implemented */ }

	/** Getter: Name of the modifier */
	std::string name() { /* not implemented */ throw NULL; }
	/** Setter: Name of the modifier */
	void name(const std::string& value) { /* not implemented */ }

	enum blend_enum {
		blend_MIX = 0,
		blend_ADD = 1,
		blend_MULTIPLY = 2,
		blend_SUBTRACT = 3,
		blend_SCREEN = 4,
		blend_DIVIDE = 5,
		blend_DIFFERENCE = 6,
		blend_DARKEN = 7,
		blend_LIGHTEN = 8,
		blend_OVERLAY = 9,
		blend_DODGE = 10,
		blend_BURN = 11,
		blend_HUE = 12,
		blend_SATURATION = 13,
		blend_VALUE = 14,
		blend_COLOR = 15,
		blend_SOFT_LIGHT = 16,
		blend_LINEAR_LIGHT = 17,
	};

	/** Getter: Specify how the modifier value is blended into the base value */
	blend_enum blend() { /* not implemented */ throw NULL; }
	/** Setter: Specify how the modifier value is blended into the base value */
	void blend(blend_enum value) { /* not implemented */ }

	/** Getter: Influence factor by which the modifier changes the property */
	float influence() { /* not implemented */ throw NULL; }
	/** Setter: Influence factor by which the modifier changes the property */
	void influence(float value) {
		PyObject_SetAttrString(pyobjref, "influence", Py_BuildValue("f", value));
	}

	/** Getter: Enable or disable this modifier during stroke rendering */
	bool use() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use")) == 1;
	}

	/** Setter: Enable or disable this modifier during stroke rendering */
	void use(bool value) {
		PyObject_SetAttrString(pyobjref, "use", Py_BuildValue("i", value));
	}

	/** Getter: True if the modifier tab is expanded */
	bool expanded() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "expanded")) == 1;
	}

	/** Setter: True if the modifier tab is expanded */
	void expanded(bool value) {
		PyObject_SetAttrString(pyobjref, "expanded", Py_BuildValue("i", value));
	}

	/** Getter: Color ramp used to change line color */
	ColorRamp color_ramp() {
		/* not implemented */ throw NULL;
	}

	/** Getter: Lower bound of the input range the mapping is applied */
	float range_min() { /* not implemented */ throw NULL; }
	/** Setter: Lower bound of the input range the mapping is applied */
	void range_min(float value) {
		PyObject_SetAttrString(pyobjref, "range_min", Py_BuildValue("f", value));
	}

	/** Getter: Upper bound of the input range the mapping is applied */
	float range_max() { /* not implemented */ throw NULL; }
	/** Setter: Upper bound of the input range the mapping is applied */
	void range_max(float value) {
		PyObject_SetAttrString(pyobjref, "range_max", Py_BuildValue("f", value));
	}

	/** Getter: Target object from which the distance is measured */
	Object target();

};

/**************** Material ****************/

/**
 * Change line color based on a material attribute
 */
class LineStyleColorModifier_Material : public LineStyleColorModifier {
public:
	LineStyleColorModifier_Material(PyObject* pyobj) : LineStyleColorModifier(pyobj) {}

	LineStyleColorModifier_Material() : LineStyleColorModifier(0)
	{
		// not implemented
	}

	enum type_enum {
		type_ALONG_STROKE = 1,
		type_DISTANCE_FROM_CAMERA = 2,
		type_DISTANCE_FROM_OBJECT = 3,
		type_MATERIAL = 4,
	};

	/** Getter: Type of the modifier */
	type_enum type() { /* not implemented */ throw NULL; }
	/** Setter: Type of the modifier */
	void type(type_enum value) { /* not implemented */ }

	/** Getter: Name of the modifier */
	std::string name() { /* not implemented */ throw NULL; }
	/** Setter: Name of the modifier */
	void name(const std::string& value) { /* not implemented */ }

	enum blend_enum {
		blend_MIX = 0,
		blend_ADD = 1,
		blend_MULTIPLY = 2,
		blend_SUBTRACT = 3,
		blend_SCREEN = 4,
		blend_DIVIDE = 5,
		blend_DIFFERENCE = 6,
		blend_DARKEN = 7,
		blend_LIGHTEN = 8,
		blend_OVERLAY = 9,
		blend_DODGE = 10,
		blend_BURN = 11,
		blend_HUE = 12,
		blend_SATURATION = 13,
		blend_VALUE = 14,
		blend_COLOR = 15,
		blend_SOFT_LIGHT = 16,
		blend_LINEAR_LIGHT = 17,
	};

	/** Getter: Specify how the modifier value is blended into the base value */
	blend_enum blend() { /* not implemented */ throw NULL; }
	/** Setter: Specify how the modifier value is blended into the base value */
	void blend(blend_enum value) { /* not implemented */ }

	/** Getter: Influence factor by which the modifier changes the property */
	float influence() { /* not implemented */ throw NULL; }
	/** Setter: Influence factor by which the modifier changes the property */
	void influence(float value) {
		PyObject_SetAttrString(pyobjref, "influence", Py_BuildValue("f", value));
	}

	/** Getter: Enable or disable this modifier during stroke rendering */
	bool use() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use")) == 1;
	}

	/** Setter: Enable or disable this modifier during stroke rendering */
	void use(bool value) {
		PyObject_SetAttrString(pyobjref, "use", Py_BuildValue("i", value));
	}

	/** Getter: True if the modifier tab is expanded */
	bool expanded() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "expanded")) == 1;
	}

	/** Setter: True if the modifier tab is expanded */
	void expanded(bool value) {
		PyObject_SetAttrString(pyobjref, "expanded", Py_BuildValue("i", value));
	}

	enum material_attribute_enum {
		material_attribute_LINE = 11,
		material_attribute_LINE_R = 12,
		material_attribute_LINE_G = 13,
		material_attribute_LINE_B = 14,
		material_attribute_LINE_A = 15,
		material_attribute_DIFF = 1,
		material_attribute_DIFF_R = 2,
		material_attribute_DIFF_G = 3,
		material_attribute_DIFF_B = 4,
		material_attribute_SPEC = 5,
		material_attribute_SPEC_R = 6,
		material_attribute_SPEC_G = 7,
		material_attribute_SPEC_B = 8,
		material_attribute_SPEC_HARD = 9,
		material_attribute_ALPHA = 10,
	};

	/** Getter: Specify which material attribute is used */
	material_attribute_enum material_attribute() { /* not implemented */ throw NULL; }
	/** Setter: Specify which material attribute is used */
	void material_attribute(material_attribute_enum value) { /* not implemented */ }

	/** Getter: Color ramp used to change line color */
	ColorRamp color_ramp() {
		/* not implemented */ throw NULL;
	}

	/** Getter: Use color ramp to map the BW average into an RGB color */
	bool use_ramp() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_ramp")) == 1;
	}

	/** Setter: Use color ramp to map the BW average into an RGB color */
	void use_ramp(bool value) {
		PyObject_SetAttrString(pyobjref, "use_ramp", Py_BuildValue("i", value));
	}

};

/**************** Line Style Alpha Modifier ****************/

/**
 * Base type to define alpha transparency modifiers
 */
class LineStyleAlphaModifier : public LineStyleModifier {
public:
	LineStyleAlphaModifier(PyObject* pyobj) : LineStyleModifier(pyobj) {}

	LineStyleAlphaModifier() : LineStyleModifier(0)
	{
		// not implemented
	}

};

/**************** Along Stroke ****************/

/**
 * Change alpha transparency along stroke
 */
class LineStyleAlphaModifier_AlongStroke : public LineStyleAlphaModifier {
public:
	LineStyleAlphaModifier_AlongStroke(PyObject* pyobj) : LineStyleAlphaModifier(pyobj) {}

	LineStyleAlphaModifier_AlongStroke() : LineStyleAlphaModifier(0)
	{
		// not implemented
	}

	enum type_enum {
		type_ALONG_STROKE = 1,
		type_DISTANCE_FROM_CAMERA = 2,
		type_DISTANCE_FROM_OBJECT = 3,
		type_MATERIAL = 4,
	};

	/** Getter: Type of the modifier */
	type_enum type() { /* not implemented */ throw NULL; }
	/** Setter: Type of the modifier */
	void type(type_enum value) { /* not implemented */ }

	/** Getter: Name of the modifier */
	std::string name() { /* not implemented */ throw NULL; }
	/** Setter: Name of the modifier */
	void name(const std::string& value) { /* not implemented */ }

	enum blend_enum {
		blend_MIX = 0,
		blend_ADD = 1,
		blend_SUBTRACT = 3,
		blend_MULTIPLY = 2,
		blend_DIVIDE = 4,
		blend_DIFFERENCE = 5,
		blend_MININUM = 6,
		blend_MAXIMUM = 7,
	};

	/** Getter: Specify how the modifier value is blended into the base value */
	blend_enum blend() { /* not implemented */ throw NULL; }
	/** Setter: Specify how the modifier value is blended into the base value */
	void blend(blend_enum value) { /* not implemented */ }

	/** Getter: Influence factor by which the modifier changes the property */
	float influence() { /* not implemented */ throw NULL; }
	/** Setter: Influence factor by which the modifier changes the property */
	void influence(float value) {
		PyObject_SetAttrString(pyobjref, "influence", Py_BuildValue("f", value));
	}

	/** Getter: Enable or disable this modifier during stroke rendering */
	bool use() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use")) == 1;
	}

	/** Setter: Enable or disable this modifier during stroke rendering */
	void use(bool value) {
		PyObject_SetAttrString(pyobjref, "use", Py_BuildValue("i", value));
	}

	/** Getter: True if the modifier tab is expanded */
	bool expanded() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "expanded")) == 1;
	}

	/** Setter: True if the modifier tab is expanded */
	void expanded(bool value) {
		PyObject_SetAttrString(pyobjref, "expanded", Py_BuildValue("i", value));
	}

	enum mapping_enum {
		mapping_LINEAR = 0,
		mapping_CURVE = 1,
	};

	/** Getter: Select the mapping type */
	mapping_enum mapping() { /* not implemented */ throw NULL; }
	/** Setter: Select the mapping type */
	void mapping(mapping_enum value) { /* not implemented */ }

	/** Getter: Invert the fade-out direction of the linear mapping */
	bool invert() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "invert")) == 1;
	}

	/** Setter: Invert the fade-out direction of the linear mapping */
	void invert(bool value) {
		PyObject_SetAttrString(pyobjref, "invert", Py_BuildValue("i", value));
	}

	/** Getter: Curve used for the curve mapping */
	CurveMapping curve() {
		/* not implemented */ throw NULL;
	}

};

/**************** Distance from Camera ****************/

/**
 * Change alpha transparency based on the distance from the camera
 */
class LineStyleAlphaModifier_DistanceFromCamera : public LineStyleAlphaModifier {
public:
	LineStyleAlphaModifier_DistanceFromCamera(PyObject* pyobj) : LineStyleAlphaModifier(pyobj) {}

	LineStyleAlphaModifier_DistanceFromCamera() : LineStyleAlphaModifier(0)
	{
		// not implemented
	}

	enum type_enum {
		type_ALONG_STROKE = 1,
		type_DISTANCE_FROM_CAMERA = 2,
		type_DISTANCE_FROM_OBJECT = 3,
		type_MATERIAL = 4,
	};

	/** Getter: Type of the modifier */
	type_enum type() { /* not implemented */ throw NULL; }
	/** Setter: Type of the modifier */
	void type(type_enum value) { /* not implemented */ }

	/** Getter: Name of the modifier */
	std::string name() { /* not implemented */ throw NULL; }
	/** Setter: Name of the modifier */
	void name(const std::string& value) { /* not implemented */ }

	enum blend_enum {
		blend_MIX = 0,
		blend_ADD = 1,
		blend_SUBTRACT = 3,
		blend_MULTIPLY = 2,
		blend_DIVIDE = 4,
		blend_DIFFERENCE = 5,
		blend_MININUM = 6,
		blend_MAXIMUM = 7,
	};

	/** Getter: Specify how the modifier value is blended into the base value */
	blend_enum blend() { /* not implemented */ throw NULL; }
	/** Setter: Specify how the modifier value is blended into the base value */
	void blend(blend_enum value) { /* not implemented */ }

	/** Getter: Influence factor by which the modifier changes the property */
	float influence() { /* not implemented */ throw NULL; }
	/** Setter: Influence factor by which the modifier changes the property */
	void influence(float value) {
		PyObject_SetAttrString(pyobjref, "influence", Py_BuildValue("f", value));
	}

	/** Getter: Enable or disable this modifier during stroke rendering */
	bool use() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use")) == 1;
	}

	/** Setter: Enable or disable this modifier during stroke rendering */
	void use(bool value) {
		PyObject_SetAttrString(pyobjref, "use", Py_BuildValue("i", value));
	}

	/** Getter: True if the modifier tab is expanded */
	bool expanded() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "expanded")) == 1;
	}

	/** Setter: True if the modifier tab is expanded */
	void expanded(bool value) {
		PyObject_SetAttrString(pyobjref, "expanded", Py_BuildValue("i", value));
	}

	enum mapping_enum {
		mapping_LINEAR = 0,
		mapping_CURVE = 1,
	};

	/** Getter: Select the mapping type */
	mapping_enum mapping() { /* not implemented */ throw NULL; }
	/** Setter: Select the mapping type */
	void mapping(mapping_enum value) { /* not implemented */ }

	/** Getter: Invert the fade-out direction of the linear mapping */
	bool invert() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "invert")) == 1;
	}

	/** Setter: Invert the fade-out direction of the linear mapping */
	void invert(bool value) {
		PyObject_SetAttrString(pyobjref, "invert", Py_BuildValue("i", value));
	}

	/** Getter: Curve used for the curve mapping */
	CurveMapping curve() {
		/* not implemented */ throw NULL;
	}

	/** Getter: Lower bound of the input range the mapping is applied */
	float range_min() { /* not implemented */ throw NULL; }
	/** Setter: Lower bound of the input range the mapping is applied */
	void range_min(float value) {
		PyObject_SetAttrString(pyobjref, "range_min", Py_BuildValue("f", value));
	}

	/** Getter: Upper bound of the input range the mapping is applied */
	float range_max() { /* not implemented */ throw NULL; }
	/** Setter: Upper bound of the input range the mapping is applied */
	void range_max(float value) {
		PyObject_SetAttrString(pyobjref, "range_max", Py_BuildValue("f", value));
	}

};

/**************** Distance from Object ****************/

/**
 * Change alpha transparency based on the distance from an object
 */
class LineStyleAlphaModifier_DistanceFromObject : public LineStyleAlphaModifier {
public:
	LineStyleAlphaModifier_DistanceFromObject(PyObject* pyobj) : LineStyleAlphaModifier(pyobj) {}

	LineStyleAlphaModifier_DistanceFromObject() : LineStyleAlphaModifier(0)
	{
		// not implemented
	}

	enum type_enum {
		type_ALONG_STROKE = 1,
		type_DISTANCE_FROM_CAMERA = 2,
		type_DISTANCE_FROM_OBJECT = 3,
		type_MATERIAL = 4,
	};

	/** Getter: Type of the modifier */
	type_enum type() { /* not implemented */ throw NULL; }
	/** Setter: Type of the modifier */
	void type(type_enum value) { /* not implemented */ }

	/** Getter: Name of the modifier */
	std::string name() { /* not implemented */ throw NULL; }
	/** Setter: Name of the modifier */
	void name(const std::string& value) { /* not implemented */ }

	enum blend_enum {
		blend_MIX = 0,
		blend_ADD = 1,
		blend_SUBTRACT = 3,
		blend_MULTIPLY = 2,
		blend_DIVIDE = 4,
		blend_DIFFERENCE = 5,
		blend_MININUM = 6,
		blend_MAXIMUM = 7,
	};

	/** Getter: Specify how the modifier value is blended into the base value */
	blend_enum blend() { /* not implemented */ throw NULL; }
	/** Setter: Specify how the modifier value is blended into the base value */
	void blend(blend_enum value) { /* not implemented */ }

	/** Getter: Influence factor by which the modifier changes the property */
	float influence() { /* not implemented */ throw NULL; }
	/** Setter: Influence factor by which the modifier changes the property */
	void influence(float value) {
		PyObject_SetAttrString(pyobjref, "influence", Py_BuildValue("f", value));
	}

	/** Getter: Enable or disable this modifier during stroke rendering */
	bool use() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use")) == 1;
	}

	/** Setter: Enable or disable this modifier during stroke rendering */
	void use(bool value) {
		PyObject_SetAttrString(pyobjref, "use", Py_BuildValue("i", value));
	}

	/** Getter: True if the modifier tab is expanded */
	bool expanded() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "expanded")) == 1;
	}

	/** Setter: True if the modifier tab is expanded */
	void expanded(bool value) {
		PyObject_SetAttrString(pyobjref, "expanded", Py_BuildValue("i", value));
	}

	enum mapping_enum {
		mapping_LINEAR = 0,
		mapping_CURVE = 1,
	};

	/** Getter: Select the mapping type */
	mapping_enum mapping() { /* not implemented */ throw NULL; }
	/** Setter: Select the mapping type */
	void mapping(mapping_enum value) { /* not implemented */ }

	/** Getter: Invert the fade-out direction of the linear mapping */
	bool invert() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "invert")) == 1;
	}

	/** Setter: Invert the fade-out direction of the linear mapping */
	void invert(bool value) {
		PyObject_SetAttrString(pyobjref, "invert", Py_BuildValue("i", value));
	}

	/** Getter: Curve used for the curve mapping */
	CurveMapping curve() {
		/* not implemented */ throw NULL;
	}

	/** Getter: Lower bound of the input range the mapping is applied */
	float range_min() { /* not implemented */ throw NULL; }
	/** Setter: Lower bound of the input range the mapping is applied */
	void range_min(float value) {
		PyObject_SetAttrString(pyobjref, "range_min", Py_BuildValue("f", value));
	}

	/** Getter: Upper bound of the input range the mapping is applied */
	float range_max() { /* not implemented */ throw NULL; }
	/** Setter: Upper bound of the input range the mapping is applied */
	void range_max(float value) {
		PyObject_SetAttrString(pyobjref, "range_max", Py_BuildValue("f", value));
	}

	/** Getter: Target object from which the distance is measured */
	Object target();

};

/**************** Material ****************/

/**
 * Change alpha transparency based on a material attribute
 */
class LineStyleAlphaModifier_Material : public LineStyleAlphaModifier {
public:
	LineStyleAlphaModifier_Material(PyObject* pyobj) : LineStyleAlphaModifier(pyobj) {}

	LineStyleAlphaModifier_Material() : LineStyleAlphaModifier(0)
	{
		// not implemented
	}

	enum type_enum {
		type_ALONG_STROKE = 1,
		type_DISTANCE_FROM_CAMERA = 2,
		type_DISTANCE_FROM_OBJECT = 3,
		type_MATERIAL = 4,
	};

	/** Getter: Type of the modifier */
	type_enum type() { /* not implemented */ throw NULL; }
	/** Setter: Type of the modifier */
	void type(type_enum value) { /* not implemented */ }

	/** Getter: Name of the modifier */
	std::string name() { /* not implemented */ throw NULL; }
	/** Setter: Name of the modifier */
	void name(const std::string& value) { /* not implemented */ }

	enum blend_enum {
		blend_MIX = 0,
		blend_ADD = 1,
		blend_SUBTRACT = 3,
		blend_MULTIPLY = 2,
		blend_DIVIDE = 4,
		blend_DIFFERENCE = 5,
		blend_MININUM = 6,
		blend_MAXIMUM = 7,
	};

	/** Getter: Specify how the modifier value is blended into the base value */
	blend_enum blend() { /* not implemented */ throw NULL; }
	/** Setter: Specify how the modifier value is blended into the base value */
	void blend(blend_enum value) { /* not implemented */ }

	/** Getter: Influence factor by which the modifier changes the property */
	float influence() { /* not implemented */ throw NULL; }
	/** Setter: Influence factor by which the modifier changes the property */
	void influence(float value) {
		PyObject_SetAttrString(pyobjref, "influence", Py_BuildValue("f", value));
	}

	/** Getter: Enable or disable this modifier during stroke rendering */
	bool use() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use")) == 1;
	}

	/** Setter: Enable or disable this modifier during stroke rendering */
	void use(bool value) {
		PyObject_SetAttrString(pyobjref, "use", Py_BuildValue("i", value));
	}

	/** Getter: True if the modifier tab is expanded */
	bool expanded() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "expanded")) == 1;
	}

	/** Setter: True if the modifier tab is expanded */
	void expanded(bool value) {
		PyObject_SetAttrString(pyobjref, "expanded", Py_BuildValue("i", value));
	}

	enum material_attribute_enum {
		material_attribute_LINE = 11,
		material_attribute_LINE_R = 12,
		material_attribute_LINE_G = 13,
		material_attribute_LINE_B = 14,
		material_attribute_LINE_A = 15,
		material_attribute_DIFF = 1,
		material_attribute_DIFF_R = 2,
		material_attribute_DIFF_G = 3,
		material_attribute_DIFF_B = 4,
		material_attribute_SPEC = 5,
		material_attribute_SPEC_R = 6,
		material_attribute_SPEC_G = 7,
		material_attribute_SPEC_B = 8,
		material_attribute_SPEC_HARD = 9,
		material_attribute_ALPHA = 10,
	};

	/** Getter: Specify which material attribute is used */
	material_attribute_enum material_attribute() { /* not implemented */ throw NULL; }
	/** Setter: Specify which material attribute is used */
	void material_attribute(material_attribute_enum value) { /* not implemented */ }

	enum mapping_enum {
		mapping_LINEAR = 0,
		mapping_CURVE = 1,
	};

	/** Getter: Select the mapping type */
	mapping_enum mapping() { /* not implemented */ throw NULL; }
	/** Setter: Select the mapping type */
	void mapping(mapping_enum value) { /* not implemented */ }

	/** Getter: Invert the fade-out direction of the linear mapping */
	bool invert() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "invert")) == 1;
	}

	/** Setter: Invert the fade-out direction of the linear mapping */
	void invert(bool value) {
		PyObject_SetAttrString(pyobjref, "invert", Py_BuildValue("i", value));
	}

	/** Getter: Curve used for the curve mapping */
	CurveMapping curve() {
		/* not implemented */ throw NULL;
	}

};

/**************** Line Style Thickness Modifier ****************/

/**
 * Base type to define line thickness modifiers
 */
class LineStyleThicknessModifier : public LineStyleModifier {
public:
	LineStyleThicknessModifier(PyObject* pyobj) : LineStyleModifier(pyobj) {}

	LineStyleThicknessModifier() : LineStyleModifier(0)
	{
		// not implemented
	}

};

/**************** Along Stroke ****************/

/**
 * Change line thickness along stroke
 */
class LineStyleThicknessModifier_AlongStroke : public LineStyleThicknessModifier {
public:
	LineStyleThicknessModifier_AlongStroke(PyObject* pyobj) : LineStyleThicknessModifier(pyobj) {}

	LineStyleThicknessModifier_AlongStroke() : LineStyleThicknessModifier(0)
	{
		// not implemented
	}

	enum type_enum {
		type_ALONG_STROKE = 1,
		type_CALLIGRAPHY = 13,
		type_DISTANCE_FROM_CAMERA = 2,
		type_DISTANCE_FROM_OBJECT = 3,
		type_MATERIAL = 4,
	};

	/** Getter: Type of the modifier */
	type_enum type() { /* not implemented */ throw NULL; }
	/** Setter: Type of the modifier */
	void type(type_enum value) { /* not implemented */ }

	/** Getter: Name of the modifier */
	std::string name() { /* not implemented */ throw NULL; }
	/** Setter: Name of the modifier */
	void name(const std::string& value) { /* not implemented */ }

	enum blend_enum {
		blend_MIX = 0,
		blend_ADD = 1,
		blend_SUBTRACT = 3,
		blend_MULTIPLY = 2,
		blend_DIVIDE = 4,
		blend_DIFFERENCE = 5,
		blend_MININUM = 6,
		blend_MAXIMUM = 7,
	};

	/** Getter: Specify how the modifier value is blended into the base value */
	blend_enum blend() { /* not implemented */ throw NULL; }
	/** Setter: Specify how the modifier value is blended into the base value */
	void blend(blend_enum value) { /* not implemented */ }

	/** Getter: Influence factor by which the modifier changes the property */
	float influence() { /* not implemented */ throw NULL; }
	/** Setter: Influence factor by which the modifier changes the property */
	void influence(float value) {
		PyObject_SetAttrString(pyobjref, "influence", Py_BuildValue("f", value));
	}

	/** Getter: Enable or disable this modifier during stroke rendering */
	bool use() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use")) == 1;
	}

	/** Setter: Enable or disable this modifier during stroke rendering */
	void use(bool value) {
		PyObject_SetAttrString(pyobjref, "use", Py_BuildValue("i", value));
	}

	/** Getter: True if the modifier tab is expanded */
	bool expanded() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "expanded")) == 1;
	}

	/** Setter: True if the modifier tab is expanded */
	void expanded(bool value) {
		PyObject_SetAttrString(pyobjref, "expanded", Py_BuildValue("i", value));
	}

	enum mapping_enum {
		mapping_LINEAR = 0,
		mapping_CURVE = 1,
	};

	/** Getter: Select the mapping type */
	mapping_enum mapping() { /* not implemented */ throw NULL; }
	/** Setter: Select the mapping type */
	void mapping(mapping_enum value) { /* not implemented */ }

	/** Getter: Invert the fade-out direction of the linear mapping */
	bool invert() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "invert")) == 1;
	}

	/** Setter: Invert the fade-out direction of the linear mapping */
	void invert(bool value) {
		PyObject_SetAttrString(pyobjref, "invert", Py_BuildValue("i", value));
	}

	/** Getter: Curve used for the curve mapping */
	CurveMapping curve() {
		/* not implemented */ throw NULL;
	}

	/** Getter: Minimum output value of the mapping */
	float value_min() { /* not implemented */ throw NULL; }
	/** Setter: Minimum output value of the mapping */
	void value_min(float value) {
		PyObject_SetAttrString(pyobjref, "value_min", Py_BuildValue("f", value));
	}

	/** Getter: Maximum output value of the mapping */
	float value_max() { /* not implemented */ throw NULL; }
	/** Setter: Maximum output value of the mapping */
	void value_max(float value) {
		PyObject_SetAttrString(pyobjref, "value_max", Py_BuildValue("f", value));
	}

};

/**************** Distance from Camera ****************/

/**
 * Change line thickness based on the distance from the camera
 */
class LineStyleThicknessModifier_DistanceFromCamera : public LineStyleThicknessModifier {
public:
	LineStyleThicknessModifier_DistanceFromCamera(PyObject* pyobj) : LineStyleThicknessModifier(pyobj) {}

	LineStyleThicknessModifier_DistanceFromCamera() : LineStyleThicknessModifier(0)
	{
		// not implemented
	}

	enum type_enum {
		type_ALONG_STROKE = 1,
		type_CALLIGRAPHY = 13,
		type_DISTANCE_FROM_CAMERA = 2,
		type_DISTANCE_FROM_OBJECT = 3,
		type_MATERIAL = 4,
	};

	/** Getter: Type of the modifier */
	type_enum type() { /* not implemented */ throw NULL; }
	/** Setter: Type of the modifier */
	void type(type_enum value) { /* not implemented */ }

	/** Getter: Name of the modifier */
	std::string name() { /* not implemented */ throw NULL; }
	/** Setter: Name of the modifier */
	void name(const std::string& value) { /* not implemented */ }

	enum blend_enum {
		blend_MIX = 0,
		blend_ADD = 1,
		blend_SUBTRACT = 3,
		blend_MULTIPLY = 2,
		blend_DIVIDE = 4,
		blend_DIFFERENCE = 5,
		blend_MININUM = 6,
		blend_MAXIMUM = 7,
	};

	/** Getter: Specify how the modifier value is blended into the base value */
	blend_enum blend() { /* not implemented */ throw NULL; }
	/** Setter: Specify how the modifier value is blended into the base value */
	void blend(blend_enum value) { /* not implemented */ }

	/** Getter: Influence factor by which the modifier changes the property */
	float influence() { /* not implemented */ throw NULL; }
	/** Setter: Influence factor by which the modifier changes the property */
	void influence(float value) {
		PyObject_SetAttrString(pyobjref, "influence", Py_BuildValue("f", value));
	}

	/** Getter: Enable or disable this modifier during stroke rendering */
	bool use() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use")) == 1;
	}

	/** Setter: Enable or disable this modifier during stroke rendering */
	void use(bool value) {
		PyObject_SetAttrString(pyobjref, "use", Py_BuildValue("i", value));
	}

	/** Getter: True if the modifier tab is expanded */
	bool expanded() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "expanded")) == 1;
	}

	/** Setter: True if the modifier tab is expanded */
	void expanded(bool value) {
		PyObject_SetAttrString(pyobjref, "expanded", Py_BuildValue("i", value));
	}

	enum mapping_enum {
		mapping_LINEAR = 0,
		mapping_CURVE = 1,
	};

	/** Getter: Select the mapping type */
	mapping_enum mapping() { /* not implemented */ throw NULL; }
	/** Setter: Select the mapping type */
	void mapping(mapping_enum value) { /* not implemented */ }

	/** Getter: Invert the fade-out direction of the linear mapping */
	bool invert() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "invert")) == 1;
	}

	/** Setter: Invert the fade-out direction of the linear mapping */
	void invert(bool value) {
		PyObject_SetAttrString(pyobjref, "invert", Py_BuildValue("i", value));
	}

	/** Getter: Curve used for the curve mapping */
	CurveMapping curve() {
		/* not implemented */ throw NULL;
	}

	/** Getter: Lower bound of the input range the mapping is applied */
	float range_min() { /* not implemented */ throw NULL; }
	/** Setter: Lower bound of the input range the mapping is applied */
	void range_min(float value) {
		PyObject_SetAttrString(pyobjref, "range_min", Py_BuildValue("f", value));
	}

	/** Getter: Upper bound of the input range the mapping is applied */
	float range_max() { /* not implemented */ throw NULL; }
	/** Setter: Upper bound of the input range the mapping is applied */
	void range_max(float value) {
		PyObject_SetAttrString(pyobjref, "range_max", Py_BuildValue("f", value));
	}

	/** Getter: Minimum output value of the mapping */
	float value_min() { /* not implemented */ throw NULL; }
	/** Setter: Minimum output value of the mapping */
	void value_min(float value) {
		PyObject_SetAttrString(pyobjref, "value_min", Py_BuildValue("f", value));
	}

	/** Getter: Maximum output value of the mapping */
	float value_max() { /* not implemented */ throw NULL; }
	/** Setter: Maximum output value of the mapping */
	void value_max(float value) {
		PyObject_SetAttrString(pyobjref, "value_max", Py_BuildValue("f", value));
	}

};

/**************** Distance from Object ****************/

/**
 * Change line thickness based on the distance from an object
 */
class LineStyleThicknessModifier_DistanceFromObject : public LineStyleThicknessModifier {
public:
	LineStyleThicknessModifier_DistanceFromObject(PyObject* pyobj) : LineStyleThicknessModifier(pyobj) {}

	LineStyleThicknessModifier_DistanceFromObject() : LineStyleThicknessModifier(0)
	{
		// not implemented
	}

	enum type_enum {
		type_ALONG_STROKE = 1,
		type_CALLIGRAPHY = 13,
		type_DISTANCE_FROM_CAMERA = 2,
		type_DISTANCE_FROM_OBJECT = 3,
		type_MATERIAL = 4,
	};

	/** Getter: Type of the modifier */
	type_enum type() { /* not implemented */ throw NULL; }
	/** Setter: Type of the modifier */
	void type(type_enum value) { /* not implemented */ }

	/** Getter: Name of the modifier */
	std::string name() { /* not implemented */ throw NULL; }
	/** Setter: Name of the modifier */
	void name(const std::string& value) { /* not implemented */ }

	enum blend_enum {
		blend_MIX = 0,
		blend_ADD = 1,
		blend_SUBTRACT = 3,
		blend_MULTIPLY = 2,
		blend_DIVIDE = 4,
		blend_DIFFERENCE = 5,
		blend_MININUM = 6,
		blend_MAXIMUM = 7,
	};

	/** Getter: Specify how the modifier value is blended into the base value */
	blend_enum blend() { /* not implemented */ throw NULL; }
	/** Setter: Specify how the modifier value is blended into the base value */
	void blend(blend_enum value) { /* not implemented */ }

	/** Getter: Influence factor by which the modifier changes the property */
	float influence() { /* not implemented */ throw NULL; }
	/** Setter: Influence factor by which the modifier changes the property */
	void influence(float value) {
		PyObject_SetAttrString(pyobjref, "influence", Py_BuildValue("f", value));
	}

	/** Getter: Enable or disable this modifier during stroke rendering */
	bool use() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use")) == 1;
	}

	/** Setter: Enable or disable this modifier during stroke rendering */
	void use(bool value) {
		PyObject_SetAttrString(pyobjref, "use", Py_BuildValue("i", value));
	}

	/** Getter: True if the modifier tab is expanded */
	bool expanded() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "expanded")) == 1;
	}

	/** Setter: True if the modifier tab is expanded */
	void expanded(bool value) {
		PyObject_SetAttrString(pyobjref, "expanded", Py_BuildValue("i", value));
	}

	enum mapping_enum {
		mapping_LINEAR = 0,
		mapping_CURVE = 1,
	};

	/** Getter: Select the mapping type */
	mapping_enum mapping() { /* not implemented */ throw NULL; }
	/** Setter: Select the mapping type */
	void mapping(mapping_enum value) { /* not implemented */ }

	/** Getter: Invert the fade-out direction of the linear mapping */
	bool invert() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "invert")) == 1;
	}

	/** Setter: Invert the fade-out direction of the linear mapping */
	void invert(bool value) {
		PyObject_SetAttrString(pyobjref, "invert", Py_BuildValue("i", value));
	}

	/** Getter: Curve used for the curve mapping */
	CurveMapping curve() {
		/* not implemented */ throw NULL;
	}

	/** Getter: Lower bound of the input range the mapping is applied */
	float range_min() { /* not implemented */ throw NULL; }
	/** Setter: Lower bound of the input range the mapping is applied */
	void range_min(float value) {
		PyObject_SetAttrString(pyobjref, "range_min", Py_BuildValue("f", value));
	}

	/** Getter: Upper bound of the input range the mapping is applied */
	float range_max() { /* not implemented */ throw NULL; }
	/** Setter: Upper bound of the input range the mapping is applied */
	void range_max(float value) {
		PyObject_SetAttrString(pyobjref, "range_max", Py_BuildValue("f", value));
	}

	/** Getter: Minimum output value of the mapping */
	float value_min() { /* not implemented */ throw NULL; }
	/** Setter: Minimum output value of the mapping */
	void value_min(float value) {
		PyObject_SetAttrString(pyobjref, "value_min", Py_BuildValue("f", value));
	}

	/** Getter: Maximum output value of the mapping */
	float value_max() { /* not implemented */ throw NULL; }
	/** Setter: Maximum output value of the mapping */
	void value_max(float value) {
		PyObject_SetAttrString(pyobjref, "value_max", Py_BuildValue("f", value));
	}

	/** Getter: Target object from which the distance is measured */
	Object target();

};

/**************** Material ****************/

/**
 * Change line thickness based on a material attribute
 */
class LineStyleThicknessModifier_Material : public LineStyleThicknessModifier {
public:
	LineStyleThicknessModifier_Material(PyObject* pyobj) : LineStyleThicknessModifier(pyobj) {}

	LineStyleThicknessModifier_Material() : LineStyleThicknessModifier(0)
	{
		// not implemented
	}

	enum type_enum {
		type_ALONG_STROKE = 1,
		type_CALLIGRAPHY = 13,
		type_DISTANCE_FROM_CAMERA = 2,
		type_DISTANCE_FROM_OBJECT = 3,
		type_MATERIAL = 4,
	};

	/** Getter: Type of the modifier */
	type_enum type() { /* not implemented */ throw NULL; }
	/** Setter: Type of the modifier */
	void type(type_enum value) { /* not implemented */ }

	/** Getter: Name of the modifier */
	std::string name() { /* not implemented */ throw NULL; }
	/** Setter: Name of the modifier */
	void name(const std::string& value) { /* not implemented */ }

	enum blend_enum {
		blend_MIX = 0,
		blend_ADD = 1,
		blend_SUBTRACT = 3,
		blend_MULTIPLY = 2,
		blend_DIVIDE = 4,
		blend_DIFFERENCE = 5,
		blend_MININUM = 6,
		blend_MAXIMUM = 7,
	};

	/** Getter: Specify how the modifier value is blended into the base value */
	blend_enum blend() { /* not implemented */ throw NULL; }
	/** Setter: Specify how the modifier value is blended into the base value */
	void blend(blend_enum value) { /* not implemented */ }

	/** Getter: Influence factor by which the modifier changes the property */
	float influence() { /* not implemented */ throw NULL; }
	/** Setter: Influence factor by which the modifier changes the property */
	void influence(float value) {
		PyObject_SetAttrString(pyobjref, "influence", Py_BuildValue("f", value));
	}

	/** Getter: Enable or disable this modifier during stroke rendering */
	bool use() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use")) == 1;
	}

	/** Setter: Enable or disable this modifier during stroke rendering */
	void use(bool value) {
		PyObject_SetAttrString(pyobjref, "use", Py_BuildValue("i", value));
	}

	/** Getter: True if the modifier tab is expanded */
	bool expanded() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "expanded")) == 1;
	}

	/** Setter: True if the modifier tab is expanded */
	void expanded(bool value) {
		PyObject_SetAttrString(pyobjref, "expanded", Py_BuildValue("i", value));
	}

	enum material_attribute_enum {
		material_attribute_LINE = 11,
		material_attribute_LINE_R = 12,
		material_attribute_LINE_G = 13,
		material_attribute_LINE_B = 14,
		material_attribute_LINE_A = 15,
		material_attribute_DIFF = 1,
		material_attribute_DIFF_R = 2,
		material_attribute_DIFF_G = 3,
		material_attribute_DIFF_B = 4,
		material_attribute_SPEC = 5,
		material_attribute_SPEC_R = 6,
		material_attribute_SPEC_G = 7,
		material_attribute_SPEC_B = 8,
		material_attribute_SPEC_HARD = 9,
		material_attribute_ALPHA = 10,
	};

	/** Getter: Specify which material attribute is used */
	material_attribute_enum material_attribute() { /* not implemented */ throw NULL; }
	/** Setter: Specify which material attribute is used */
	void material_attribute(material_attribute_enum value) { /* not implemented */ }

	enum mapping_enum {
		mapping_LINEAR = 0,
		mapping_CURVE = 1,
	};

	/** Getter: Select the mapping type */
	mapping_enum mapping() { /* not implemented */ throw NULL; }
	/** Setter: Select the mapping type */
	void mapping(mapping_enum value) { /* not implemented */ }

	/** Getter: Invert the fade-out direction of the linear mapping */
	bool invert() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "invert")) == 1;
	}

	/** Setter: Invert the fade-out direction of the linear mapping */
	void invert(bool value) {
		PyObject_SetAttrString(pyobjref, "invert", Py_BuildValue("i", value));
	}

	/** Getter: Curve used for the curve mapping */
	CurveMapping curve() {
		/* not implemented */ throw NULL;
	}

	/** Getter: Minimum output value of the mapping */
	float value_min() { /* not implemented */ throw NULL; }
	/** Setter: Minimum output value of the mapping */
	void value_min(float value) {
		PyObject_SetAttrString(pyobjref, "value_min", Py_BuildValue("f", value));
	}

	/** Getter: Maximum output value of the mapping */
	float value_max() { /* not implemented */ throw NULL; }
	/** Setter: Maximum output value of the mapping */
	void value_max(float value) {
		PyObject_SetAttrString(pyobjref, "value_max", Py_BuildValue("f", value));
	}

};

/**************** Calligraphy ****************/

/**
 * Change line thickness so that stroke looks like made with a calligraphic pen
 */
class LineStyleThicknessModifier_Calligraphy : public LineStyleThicknessModifier {
public:
	LineStyleThicknessModifier_Calligraphy(PyObject* pyobj) : LineStyleThicknessModifier(pyobj) {}

	LineStyleThicknessModifier_Calligraphy() : LineStyleThicknessModifier(0)
	{
		// not implemented
	}

	enum type_enum {
		type_ALONG_STROKE = 1,
		type_CALLIGRAPHY = 13,
		type_DISTANCE_FROM_CAMERA = 2,
		type_DISTANCE_FROM_OBJECT = 3,
		type_MATERIAL = 4,
	};

	/** Getter: Type of the modifier */
	type_enum type() { /* not implemented */ throw NULL; }
	/** Setter: Type of the modifier */
	void type(type_enum value) { /* not implemented */ }

	/** Getter: Name of the modifier */
	std::string name() { /* not implemented */ throw NULL; }
	/** Setter: Name of the modifier */
	void name(const std::string& value) { /* not implemented */ }

	enum blend_enum {
		blend_MIX = 0,
		blend_ADD = 1,
		blend_SUBTRACT = 3,
		blend_MULTIPLY = 2,
		blend_DIVIDE = 4,
		blend_DIFFERENCE = 5,
		blend_MININUM = 6,
		blend_MAXIMUM = 7,
	};

	/** Getter: Specify how the modifier value is blended into the base value */
	blend_enum blend() { /* not implemented */ throw NULL; }
	/** Setter: Specify how the modifier value is blended into the base value */
	void blend(blend_enum value) { /* not implemented */ }

	/** Getter: Influence factor by which the modifier changes the property */
	float influence() { /* not implemented */ throw NULL; }
	/** Setter: Influence factor by which the modifier changes the property */
	void influence(float value) {
		PyObject_SetAttrString(pyobjref, "influence", Py_BuildValue("f", value));
	}

	/** Getter: Enable or disable this modifier during stroke rendering */
	bool use() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use")) == 1;
	}

	/** Setter: Enable or disable this modifier during stroke rendering */
	void use(bool value) {
		PyObject_SetAttrString(pyobjref, "use", Py_BuildValue("i", value));
	}

	/** Getter: True if the modifier tab is expanded */
	bool expanded() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "expanded")) == 1;
	}

	/** Setter: True if the modifier tab is expanded */
	void expanded(bool value) {
		PyObject_SetAttrString(pyobjref, "expanded", Py_BuildValue("i", value));
	}

	/** Getter: Angle of the main direction */
	float orientation() { /* not implemented */ throw NULL; }
	/** Setter: Angle of the main direction */
	void orientation(float value) {
		PyObject_SetAttrString(pyobjref, "orientation", Py_BuildValue("f", value));
	}

	/** Getter: Minimum thickness in the direction perpendicular to the main direction */
	float thickness_min() { /* not implemented */ throw NULL; }
	/** Setter: Minimum thickness in the direction perpendicular to the main direction */
	void thickness_min(float value) {
		PyObject_SetAttrString(pyobjref, "thickness_min", Py_BuildValue("f", value));
	}

	/** Getter: Maximum thickness in the main direction */
	float thickness_max() { /* not implemented */ throw NULL; }
	/** Setter: Maximum thickness in the main direction */
	void thickness_max(float value) {
		PyObject_SetAttrString(pyobjref, "thickness_max", Py_BuildValue("f", value));
	}

};

/**************** Line Style Geometry Modifier ****************/

/**
 * Base type to define stroke geometry modifiers
 */
class LineStyleGeometryModifier : public LineStyleModifier {
public:
	LineStyleGeometryModifier(PyObject* pyobj) : LineStyleModifier(pyobj) {}

	LineStyleGeometryModifier() : LineStyleModifier(0)
	{
		// not implemented
	}

};

/**************** Sampling ****************/

/**
 * Specify a new sampling value that determines the resolution of stroke polylines
 */
class LineStyleGeometryModifier_Sampling : public LineStyleGeometryModifier {
public:
	LineStyleGeometryModifier_Sampling(PyObject* pyobj) : LineStyleGeometryModifier(pyobj) {}

	LineStyleGeometryModifier_Sampling() : LineStyleGeometryModifier(0)
	{
		// not implemented
	}

	enum type_enum {
		type_2D_OFFSET = 17,
		type_2D_TRANSFORM = 18,
		type_BACKBONE_STRETCHER = 11,
		type_BEZIER_CURVE = 6,
		type_BLUEPRINT = 16,
		type_GUIDING_LINES = 15,
		type_PERLIN_NOISE_1D = 9,
		type_PERLIN_NOISE_2D = 10,
		type_POLYGONIZATION = 14,
		type_SAMPLING = 5,
		type_SINUS_DISPLACEMENT = 7,
		type_SPATIAL_NOISE = 8,
		type_TIP_REMOVER = 12,
	};

	/** Getter: Type of the modifier */
	type_enum type() { /* not implemented */ throw NULL; }
	/** Setter: Type of the modifier */
	void type(type_enum value) { /* not implemented */ }

	/** Getter: Name of the modifier */
	std::string name() { /* not implemented */ throw NULL; }
	/** Setter: Name of the modifier */
	void name(const std::string& value) { /* not implemented */ }

	/** Getter: Enable or disable this modifier during stroke rendering */
	bool use() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use")) == 1;
	}

	/** Setter: Enable or disable this modifier during stroke rendering */
	void use(bool value) {
		PyObject_SetAttrString(pyobjref, "use", Py_BuildValue("i", value));
	}

	/** Getter: True if the modifier tab is expanded */
	bool expanded() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "expanded")) == 1;
	}

	/** Setter: True if the modifier tab is expanded */
	void expanded(bool value) {
		PyObject_SetAttrString(pyobjref, "expanded", Py_BuildValue("i", value));
	}

	/** Getter: New sampling value to be used for subsequent modifiers */
	float sampling() { /* not implemented */ throw NULL; }
	/** Setter: New sampling value to be used for subsequent modifiers */
	void sampling(float value) {
		PyObject_SetAttrString(pyobjref, "sampling", Py_BuildValue("f", value));
	}

};

/**************** Bezier Curve ****************/

/**
 * Replace stroke backbone geometry by a Bezier curve approximation of the original backbone geometry
 */
class LineStyleGeometryModifier_BezierCurve : public LineStyleGeometryModifier {
public:
	LineStyleGeometryModifier_BezierCurve(PyObject* pyobj) : LineStyleGeometryModifier(pyobj) {}

	LineStyleGeometryModifier_BezierCurve() : LineStyleGeometryModifier(0)
	{
		// not implemented
	}

	enum type_enum {
		type_2D_OFFSET = 17,
		type_2D_TRANSFORM = 18,
		type_BACKBONE_STRETCHER = 11,
		type_BEZIER_CURVE = 6,
		type_BLUEPRINT = 16,
		type_GUIDING_LINES = 15,
		type_PERLIN_NOISE_1D = 9,
		type_PERLIN_NOISE_2D = 10,
		type_POLYGONIZATION = 14,
		type_SAMPLING = 5,
		type_SINUS_DISPLACEMENT = 7,
		type_SPATIAL_NOISE = 8,
		type_TIP_REMOVER = 12,
	};

	/** Getter: Type of the modifier */
	type_enum type() { /* not implemented */ throw NULL; }
	/** Setter: Type of the modifier */
	void type(type_enum value) { /* not implemented */ }

	/** Getter: Name of the modifier */
	std::string name() { /* not implemented */ throw NULL; }
	/** Setter: Name of the modifier */
	void name(const std::string& value) { /* not implemented */ }

	/** Getter: Enable or disable this modifier during stroke rendering */
	bool use() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use")) == 1;
	}

	/** Setter: Enable or disable this modifier during stroke rendering */
	void use(bool value) {
		PyObject_SetAttrString(pyobjref, "use", Py_BuildValue("i", value));
	}

	/** Getter: True if the modifier tab is expanded */
	bool expanded() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "expanded")) == 1;
	}

	/** Setter: True if the modifier tab is expanded */
	void expanded(bool value) {
		PyObject_SetAttrString(pyobjref, "expanded", Py_BuildValue("i", value));
	}

	/** Getter: Maximum distance allowed between the new Bezier curve and the original backbone geometry */
	float error() { /* not implemented */ throw NULL; }
	/** Setter: Maximum distance allowed between the new Bezier curve and the original backbone geometry */
	void error(float value) {
		PyObject_SetAttrString(pyobjref, "error", Py_BuildValue("f", value));
	}

};

/**************** Sinus Displacement ****************/

/**
 * Add sinus displacement to stroke backbone geometry
 */
class LineStyleGeometryModifier_SinusDisplacement : public LineStyleGeometryModifier {
public:
	LineStyleGeometryModifier_SinusDisplacement(PyObject* pyobj) : LineStyleGeometryModifier(pyobj) {}

	LineStyleGeometryModifier_SinusDisplacement() : LineStyleGeometryModifier(0)
	{
		// not implemented
	}

	enum type_enum {
		type_2D_OFFSET = 17,
		type_2D_TRANSFORM = 18,
		type_BACKBONE_STRETCHER = 11,
		type_BEZIER_CURVE = 6,
		type_BLUEPRINT = 16,
		type_GUIDING_LINES = 15,
		type_PERLIN_NOISE_1D = 9,
		type_PERLIN_NOISE_2D = 10,
		type_POLYGONIZATION = 14,
		type_SAMPLING = 5,
		type_SINUS_DISPLACEMENT = 7,
		type_SPATIAL_NOISE = 8,
		type_TIP_REMOVER = 12,
	};

	/** Getter: Type of the modifier */
	type_enum type() { /* not implemented */ throw NULL; }
	/** Setter: Type of the modifier */
	void type(type_enum value) { /* not implemented */ }

	/** Getter: Name of the modifier */
	std::string name() { /* not implemented */ throw NULL; }
	/** Setter: Name of the modifier */
	void name(const std::string& value) { /* not implemented */ }

	/** Getter: Enable or disable this modifier during stroke rendering */
	bool use() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use")) == 1;
	}

	/** Setter: Enable or disable this modifier during stroke rendering */
	void use(bool value) {
		PyObject_SetAttrString(pyobjref, "use", Py_BuildValue("i", value));
	}

	/** Getter: True if the modifier tab is expanded */
	bool expanded() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "expanded")) == 1;
	}

	/** Setter: True if the modifier tab is expanded */
	void expanded(bool value) {
		PyObject_SetAttrString(pyobjref, "expanded", Py_BuildValue("i", value));
	}

	/** Getter: Wavelength of the sinus displacement */
	float wavelength() { /* not implemented */ throw NULL; }
	/** Setter: Wavelength of the sinus displacement */
	void wavelength(float value) {
		PyObject_SetAttrString(pyobjref, "wavelength", Py_BuildValue("f", value));
	}

	/** Getter: Amplitude of the sinus displacement */
	float amplitude() { /* not implemented */ throw NULL; }
	/** Setter: Amplitude of the sinus displacement */
	void amplitude(float value) {
		PyObject_SetAttrString(pyobjref, "amplitude", Py_BuildValue("f", value));
	}

	/** Getter: Phase of the sinus displacement */
	float phase() { /* not implemented */ throw NULL; }
	/** Setter: Phase of the sinus displacement */
	void phase(float value) {
		PyObject_SetAttrString(pyobjref, "phase", Py_BuildValue("f", value));
	}

};

/**************** Spatial Noise ****************/

/**
 * Add spatial noise to stroke backbone geometry
 */
class LineStyleGeometryModifier_SpatialNoise : public LineStyleGeometryModifier {
public:
	LineStyleGeometryModifier_SpatialNoise(PyObject* pyobj) : LineStyleGeometryModifier(pyobj) {}

	LineStyleGeometryModifier_SpatialNoise() : LineStyleGeometryModifier(0)
	{
		// not implemented
	}

	enum type_enum {
		type_2D_OFFSET = 17,
		type_2D_TRANSFORM = 18,
		type_BACKBONE_STRETCHER = 11,
		type_BEZIER_CURVE = 6,
		type_BLUEPRINT = 16,
		type_GUIDING_LINES = 15,
		type_PERLIN_NOISE_1D = 9,
		type_PERLIN_NOISE_2D = 10,
		type_POLYGONIZATION = 14,
		type_SAMPLING = 5,
		type_SINUS_DISPLACEMENT = 7,
		type_SPATIAL_NOISE = 8,
		type_TIP_REMOVER = 12,
	};

	/** Getter: Type of the modifier */
	type_enum type() { /* not implemented */ throw NULL; }
	/** Setter: Type of the modifier */
	void type(type_enum value) { /* not implemented */ }

	/** Getter: Name of the modifier */
	std::string name() { /* not implemented */ throw NULL; }
	/** Setter: Name of the modifier */
	void name(const std::string& value) { /* not implemented */ }

	/** Getter: Enable or disable this modifier during stroke rendering */
	bool use() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use")) == 1;
	}

	/** Setter: Enable or disable this modifier during stroke rendering */
	void use(bool value) {
		PyObject_SetAttrString(pyobjref, "use", Py_BuildValue("i", value));
	}

	/** Getter: True if the modifier tab is expanded */
	bool expanded() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "expanded")) == 1;
	}

	/** Setter: True if the modifier tab is expanded */
	void expanded(bool value) {
		PyObject_SetAttrString(pyobjref, "expanded", Py_BuildValue("i", value));
	}

	/** Getter: Amplitude of the spatial noise */
	float amplitude() { /* not implemented */ throw NULL; }
	/** Setter: Amplitude of the spatial noise */
	void amplitude(float value) {
		PyObject_SetAttrString(pyobjref, "amplitude", Py_BuildValue("f", value));
	}

	/** Getter: Scale of the spatial noise */
	float scale() { /* not implemented */ throw NULL; }
	/** Setter: Scale of the spatial noise */
	void scale(float value) {
		PyObject_SetAttrString(pyobjref, "scale", Py_BuildValue("f", value));
	}

	/** Getter: Number of octaves (i.e., the amount of detail of the spatial noise) */
	int octaves() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "octaves"));
	}

	/** Setter: Number of octaves (i.e., the amount of detail of the spatial noise) */
	void octaves(int value) {
		PyObject_SetAttrString(pyobjref, "octaves", Py_BuildValue("i", value));
	}

	/** Getter: If true, the spatial noise is smooth */
	bool smooth() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "smooth")) == 1;
	}

	/** Setter: If true, the spatial noise is smooth */
	void smooth(bool value) {
		PyObject_SetAttrString(pyobjref, "smooth", Py_BuildValue("i", value));
	}

	/** Getter: If true, the spatial noise does not show any coherence */
	bool use_pure_random() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_pure_random")) == 1;
	}

	/** Setter: If true, the spatial noise does not show any coherence */
	void use_pure_random(bool value) {
		PyObject_SetAttrString(pyobjref, "use_pure_random", Py_BuildValue("i", value));
	}

};

/**************** Perlin Noise 1D ****************/

/**
 * Add one-dimensional Perlin noise to stroke backbone geometry
 */
class LineStyleGeometryModifier_PerlinNoise1D : public LineStyleGeometryModifier {
public:
	LineStyleGeometryModifier_PerlinNoise1D(PyObject* pyobj) : LineStyleGeometryModifier(pyobj) {}

	LineStyleGeometryModifier_PerlinNoise1D() : LineStyleGeometryModifier(0)
	{
		// not implemented
	}

	enum type_enum {
		type_2D_OFFSET = 17,
		type_2D_TRANSFORM = 18,
		type_BACKBONE_STRETCHER = 11,
		type_BEZIER_CURVE = 6,
		type_BLUEPRINT = 16,
		type_GUIDING_LINES = 15,
		type_PERLIN_NOISE_1D = 9,
		type_PERLIN_NOISE_2D = 10,
		type_POLYGONIZATION = 14,
		type_SAMPLING = 5,
		type_SINUS_DISPLACEMENT = 7,
		type_SPATIAL_NOISE = 8,
		type_TIP_REMOVER = 12,
	};

	/** Getter: Type of the modifier */
	type_enum type() { /* not implemented */ throw NULL; }
	/** Setter: Type of the modifier */
	void type(type_enum value) { /* not implemented */ }

	/** Getter: Name of the modifier */
	std::string name() { /* not implemented */ throw NULL; }
	/** Setter: Name of the modifier */
	void name(const std::string& value) { /* not implemented */ }

	/** Getter: Enable or disable this modifier during stroke rendering */
	bool use() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use")) == 1;
	}

	/** Setter: Enable or disable this modifier during stroke rendering */
	void use(bool value) {
		PyObject_SetAttrString(pyobjref, "use", Py_BuildValue("i", value));
	}

	/** Getter: True if the modifier tab is expanded */
	bool expanded() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "expanded")) == 1;
	}

	/** Setter: True if the modifier tab is expanded */
	void expanded(bool value) {
		PyObject_SetAttrString(pyobjref, "expanded", Py_BuildValue("i", value));
	}

	/** Getter: Frequency of the Perlin noise */
	float frequency() { /* not implemented */ throw NULL; }
	/** Setter: Frequency of the Perlin noise */
	void frequency(float value) {
		PyObject_SetAttrString(pyobjref, "frequency", Py_BuildValue("f", value));
	}

	/** Getter: Amplitude of the Perlin noise */
	float amplitude() { /* not implemented */ throw NULL; }
	/** Setter: Amplitude of the Perlin noise */
	void amplitude(float value) {
		PyObject_SetAttrString(pyobjref, "amplitude", Py_BuildValue("f", value));
	}

	/** Getter: Number of octaves (i.e., the amount of detail of the Perlin noise) */
	int octaves() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "octaves"));
	}

	/** Setter: Number of octaves (i.e., the amount of detail of the Perlin noise) */
	void octaves(int value) {
		PyObject_SetAttrString(pyobjref, "octaves", Py_BuildValue("i", value));
	}

	/** Getter: Displacement direction */
	float angle() { /* not implemented */ throw NULL; }
	/** Setter: Displacement direction */
	void angle(float value) {
		PyObject_SetAttrString(pyobjref, "angle", Py_BuildValue("f", value));
	}

	/** Getter: Seed for random number generation (if negative, time is used as a seed instead) */
	int seed() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "seed"));
	}

	/** Setter: Seed for random number generation (if negative, time is used as a seed instead) */
	void seed(int value) {
		PyObject_SetAttrString(pyobjref, "seed", Py_BuildValue("i", value));
	}

};

/**************** Perlin Noise 2D ****************/

/**
 * Add two-dimensional Perlin noise to stroke backbone geometry
 */
class LineStyleGeometryModifier_PerlinNoise2D : public LineStyleGeometryModifier {
public:
	LineStyleGeometryModifier_PerlinNoise2D(PyObject* pyobj) : LineStyleGeometryModifier(pyobj) {}

	LineStyleGeometryModifier_PerlinNoise2D() : LineStyleGeometryModifier(0)
	{
		// not implemented
	}

	enum type_enum {
		type_2D_OFFSET = 17,
		type_2D_TRANSFORM = 18,
		type_BACKBONE_STRETCHER = 11,
		type_BEZIER_CURVE = 6,
		type_BLUEPRINT = 16,
		type_GUIDING_LINES = 15,
		type_PERLIN_NOISE_1D = 9,
		type_PERLIN_NOISE_2D = 10,
		type_POLYGONIZATION = 14,
		type_SAMPLING = 5,
		type_SINUS_DISPLACEMENT = 7,
		type_SPATIAL_NOISE = 8,
		type_TIP_REMOVER = 12,
	};

	/** Getter: Type of the modifier */
	type_enum type() { /* not implemented */ throw NULL; }
	/** Setter: Type of the modifier */
	void type(type_enum value) { /* not implemented */ }

	/** Getter: Name of the modifier */
	std::string name() { /* not implemented */ throw NULL; }
	/** Setter: Name of the modifier */
	void name(const std::string& value) { /* not implemented */ }

	/** Getter: Enable or disable this modifier during stroke rendering */
	bool use() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use")) == 1;
	}

	/** Setter: Enable or disable this modifier during stroke rendering */
	void use(bool value) {
		PyObject_SetAttrString(pyobjref, "use", Py_BuildValue("i", value));
	}

	/** Getter: True if the modifier tab is expanded */
	bool expanded() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "expanded")) == 1;
	}

	/** Setter: True if the modifier tab is expanded */
	void expanded(bool value) {
		PyObject_SetAttrString(pyobjref, "expanded", Py_BuildValue("i", value));
	}

	/** Getter: Frequency of the Perlin noise */
	float frequency() { /* not implemented */ throw NULL; }
	/** Setter: Frequency of the Perlin noise */
	void frequency(float value) {
		PyObject_SetAttrString(pyobjref, "frequency", Py_BuildValue("f", value));
	}

	/** Getter: Amplitude of the Perlin noise */
	float amplitude() { /* not implemented */ throw NULL; }
	/** Setter: Amplitude of the Perlin noise */
	void amplitude(float value) {
		PyObject_SetAttrString(pyobjref, "amplitude", Py_BuildValue("f", value));
	}

	/** Getter: Number of octaves (i.e., the amount of detail of the Perlin noise) */
	int octaves() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "octaves"));
	}

	/** Setter: Number of octaves (i.e., the amount of detail of the Perlin noise) */
	void octaves(int value) {
		PyObject_SetAttrString(pyobjref, "octaves", Py_BuildValue("i", value));
	}

	/** Getter: Displacement direction */
	float angle() { /* not implemented */ throw NULL; }
	/** Setter: Displacement direction */
	void angle(float value) {
		PyObject_SetAttrString(pyobjref, "angle", Py_BuildValue("f", value));
	}

	/** Getter: Seed for random number generation (if negative, time is used as a seed instead) */
	int seed() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "seed"));
	}

	/** Setter: Seed for random number generation (if negative, time is used as a seed instead) */
	void seed(int value) {
		PyObject_SetAttrString(pyobjref, "seed", Py_BuildValue("i", value));
	}

};

/**************** Backbone Stretcher ****************/

/**
 * Stretch the beginning and the end of stroke backbone
 */
class LineStyleGeometryModifier_BackboneStretcher : public LineStyleGeometryModifier {
public:
	LineStyleGeometryModifier_BackboneStretcher(PyObject* pyobj) : LineStyleGeometryModifier(pyobj) {}

	LineStyleGeometryModifier_BackboneStretcher() : LineStyleGeometryModifier(0)
	{
		// not implemented
	}

	enum type_enum {
		type_2D_OFFSET = 17,
		type_2D_TRANSFORM = 18,
		type_BACKBONE_STRETCHER = 11,
		type_BEZIER_CURVE = 6,
		type_BLUEPRINT = 16,
		type_GUIDING_LINES = 15,
		type_PERLIN_NOISE_1D = 9,
		type_PERLIN_NOISE_2D = 10,
		type_POLYGONIZATION = 14,
		type_SAMPLING = 5,
		type_SINUS_DISPLACEMENT = 7,
		type_SPATIAL_NOISE = 8,
		type_TIP_REMOVER = 12,
	};

	/** Getter: Type of the modifier */
	type_enum type() { /* not implemented */ throw NULL; }
	/** Setter: Type of the modifier */
	void type(type_enum value) { /* not implemented */ }

	/** Getter: Name of the modifier */
	std::string name() { /* not implemented */ throw NULL; }
	/** Setter: Name of the modifier */
	void name(const std::string& value) { /* not implemented */ }

	/** Getter: Enable or disable this modifier during stroke rendering */
	bool use() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use")) == 1;
	}

	/** Setter: Enable or disable this modifier during stroke rendering */
	void use(bool value) {
		PyObject_SetAttrString(pyobjref, "use", Py_BuildValue("i", value));
	}

	/** Getter: True if the modifier tab is expanded */
	bool expanded() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "expanded")) == 1;
	}

	/** Setter: True if the modifier tab is expanded */
	void expanded(bool value) {
		PyObject_SetAttrString(pyobjref, "expanded", Py_BuildValue("i", value));
	}

	/** Getter: Amount of backbone stretching */
	float backbone_length() { /* not implemented */ throw NULL; }
	/** Setter: Amount of backbone stretching */
	void backbone_length(float value) {
		PyObject_SetAttrString(pyobjref, "backbone_length", Py_BuildValue("f", value));
	}

};

/**************** Tip Remover ****************/

/**
 * Remove a piece of stroke at the beginning and the end of stroke backbone
 */
class LineStyleGeometryModifier_TipRemover : public LineStyleGeometryModifier {
public:
	LineStyleGeometryModifier_TipRemover(PyObject* pyobj) : LineStyleGeometryModifier(pyobj) {}

	LineStyleGeometryModifier_TipRemover() : LineStyleGeometryModifier(0)
	{
		// not implemented
	}

	enum type_enum {
		type_2D_OFFSET = 17,
		type_2D_TRANSFORM = 18,
		type_BACKBONE_STRETCHER = 11,
		type_BEZIER_CURVE = 6,
		type_BLUEPRINT = 16,
		type_GUIDING_LINES = 15,
		type_PERLIN_NOISE_1D = 9,
		type_PERLIN_NOISE_2D = 10,
		type_POLYGONIZATION = 14,
		type_SAMPLING = 5,
		type_SINUS_DISPLACEMENT = 7,
		type_SPATIAL_NOISE = 8,
		type_TIP_REMOVER = 12,
	};

	/** Getter: Type of the modifier */
	type_enum type() { /* not implemented */ throw NULL; }
	/** Setter: Type of the modifier */
	void type(type_enum value) { /* not implemented */ }

	/** Getter: Name of the modifier */
	std::string name() { /* not implemented */ throw NULL; }
	/** Setter: Name of the modifier */
	void name(const std::string& value) { /* not implemented */ }

	/** Getter: Enable or disable this modifier during stroke rendering */
	bool use() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use")) == 1;
	}

	/** Setter: Enable or disable this modifier during stroke rendering */
	void use(bool value) {
		PyObject_SetAttrString(pyobjref, "use", Py_BuildValue("i", value));
	}

	/** Getter: True if the modifier tab is expanded */
	bool expanded() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "expanded")) == 1;
	}

	/** Setter: True if the modifier tab is expanded */
	void expanded(bool value) {
		PyObject_SetAttrString(pyobjref, "expanded", Py_BuildValue("i", value));
	}

	/** Getter: Length of tips to be removed */
	float tip_length() { /* not implemented */ throw NULL; }
	/** Setter: Length of tips to be removed */
	void tip_length(float value) {
		PyObject_SetAttrString(pyobjref, "tip_length", Py_BuildValue("f", value));
	}

};

/**************** Polygonalization ****************/

/**
 * Modify the stroke geometry so that it looks more 'polygonal'
 */
class LineStyleGeometryModifier_Polygonalization : public LineStyleGeometryModifier {
public:
	LineStyleGeometryModifier_Polygonalization(PyObject* pyobj) : LineStyleGeometryModifier(pyobj) {}

	LineStyleGeometryModifier_Polygonalization() : LineStyleGeometryModifier(0)
	{
		// not implemented
	}

	enum type_enum {
		type_2D_OFFSET = 17,
		type_2D_TRANSFORM = 18,
		type_BACKBONE_STRETCHER = 11,
		type_BEZIER_CURVE = 6,
		type_BLUEPRINT = 16,
		type_GUIDING_LINES = 15,
		type_PERLIN_NOISE_1D = 9,
		type_PERLIN_NOISE_2D = 10,
		type_POLYGONIZATION = 14,
		type_SAMPLING = 5,
		type_SINUS_DISPLACEMENT = 7,
		type_SPATIAL_NOISE = 8,
		type_TIP_REMOVER = 12,
	};

	/** Getter: Type of the modifier */
	type_enum type() { /* not implemented */ throw NULL; }
	/** Setter: Type of the modifier */
	void type(type_enum value) { /* not implemented */ }

	/** Getter: Name of the modifier */
	std::string name() { /* not implemented */ throw NULL; }
	/** Setter: Name of the modifier */
	void name(const std::string& value) { /* not implemented */ }

	/** Getter: Enable or disable this modifier during stroke rendering */
	bool use() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use")) == 1;
	}

	/** Setter: Enable or disable this modifier during stroke rendering */
	void use(bool value) {
		PyObject_SetAttrString(pyobjref, "use", Py_BuildValue("i", value));
	}

	/** Getter: True if the modifier tab is expanded */
	bool expanded() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "expanded")) == 1;
	}

	/** Setter: True if the modifier tab is expanded */
	void expanded(bool value) {
		PyObject_SetAttrString(pyobjref, "expanded", Py_BuildValue("i", value));
	}

	/** Getter: Maximum distance between the original stroke and its polygonal approximation */
	float error() { /* not implemented */ throw NULL; }
	/** Setter: Maximum distance between the original stroke and its polygonal approximation */
	void error(float value) {
		PyObject_SetAttrString(pyobjref, "error", Py_BuildValue("f", value));
	}

};

/**************** Guiding Lines ****************/

/**
 * Modify the stroke geometry so that it corresponds to its main direction line
 */
class LineStyleGeometryModifier_GuidingLines : public LineStyleGeometryModifier {
public:
	LineStyleGeometryModifier_GuidingLines(PyObject* pyobj) : LineStyleGeometryModifier(pyobj) {}

	LineStyleGeometryModifier_GuidingLines() : LineStyleGeometryModifier(0)
	{
		// not implemented
	}

	enum type_enum {
		type_2D_OFFSET = 17,
		type_2D_TRANSFORM = 18,
		type_BACKBONE_STRETCHER = 11,
		type_BEZIER_CURVE = 6,
		type_BLUEPRINT = 16,
		type_GUIDING_LINES = 15,
		type_PERLIN_NOISE_1D = 9,
		type_PERLIN_NOISE_2D = 10,
		type_POLYGONIZATION = 14,
		type_SAMPLING = 5,
		type_SINUS_DISPLACEMENT = 7,
		type_SPATIAL_NOISE = 8,
		type_TIP_REMOVER = 12,
	};

	/** Getter: Type of the modifier */
	type_enum type() { /* not implemented */ throw NULL; }
	/** Setter: Type of the modifier */
	void type(type_enum value) { /* not implemented */ }

	/** Getter: Name of the modifier */
	std::string name() { /* not implemented */ throw NULL; }
	/** Setter: Name of the modifier */
	void name(const std::string& value) { /* not implemented */ }

	/** Getter: Enable or disable this modifier during stroke rendering */
	bool use() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use")) == 1;
	}

	/** Setter: Enable or disable this modifier during stroke rendering */
	void use(bool value) {
		PyObject_SetAttrString(pyobjref, "use", Py_BuildValue("i", value));
	}

	/** Getter: True if the modifier tab is expanded */
	bool expanded() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "expanded")) == 1;
	}

	/** Setter: True if the modifier tab is expanded */
	void expanded(bool value) {
		PyObject_SetAttrString(pyobjref, "expanded", Py_BuildValue("i", value));
	}

	/** Getter: Displacement that is applied to the main direction line along its normal */
	float offset() { /* not implemented */ throw NULL; }
	/** Setter: Displacement that is applied to the main direction line along its normal */
	void offset(float value) {
		PyObject_SetAttrString(pyobjref, "offset", Py_BuildValue("f", value));
	}

};

/**************** Blueprint ****************/

/**
 * Produce a blueprint using circular, elliptic, and square contour strokes
 */
class LineStyleGeometryModifier_Blueprint : public LineStyleGeometryModifier {
public:
	LineStyleGeometryModifier_Blueprint(PyObject* pyobj) : LineStyleGeometryModifier(pyobj) {}

	LineStyleGeometryModifier_Blueprint() : LineStyleGeometryModifier(0)
	{
		// not implemented
	}

	enum type_enum {
		type_2D_OFFSET = 17,
		type_2D_TRANSFORM = 18,
		type_BACKBONE_STRETCHER = 11,
		type_BEZIER_CURVE = 6,
		type_BLUEPRINT = 16,
		type_GUIDING_LINES = 15,
		type_PERLIN_NOISE_1D = 9,
		type_PERLIN_NOISE_2D = 10,
		type_POLYGONIZATION = 14,
		type_SAMPLING = 5,
		type_SINUS_DISPLACEMENT = 7,
		type_SPATIAL_NOISE = 8,
		type_TIP_REMOVER = 12,
	};

	/** Getter: Type of the modifier */
	type_enum type() { /* not implemented */ throw NULL; }
	/** Setter: Type of the modifier */
	void type(type_enum value) { /* not implemented */ }

	/** Getter: Name of the modifier */
	std::string name() { /* not implemented */ throw NULL; }
	/** Setter: Name of the modifier */
	void name(const std::string& value) { /* not implemented */ }

	/** Getter: Enable or disable this modifier during stroke rendering */
	bool use() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use")) == 1;
	}

	/** Setter: Enable or disable this modifier during stroke rendering */
	void use(bool value) {
		PyObject_SetAttrString(pyobjref, "use", Py_BuildValue("i", value));
	}

	/** Getter: True if the modifier tab is expanded */
	bool expanded() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "expanded")) == 1;
	}

	/** Setter: True if the modifier tab is expanded */
	void expanded(bool value) {
		PyObject_SetAttrString(pyobjref, "expanded", Py_BuildValue("i", value));
	}

	enum shape_enum {
		shape_CIRCLES = 1,
		shape_ELLIPSES = 2,
		shape_SQUARES = 4,
	};

	/** Getter: Select the shape of blueprint contour strokes */
	shape_enum shape() { /* not implemented */ throw NULL; }
	/** Setter: Select the shape of blueprint contour strokes */
	void shape(shape_enum value) { /* not implemented */ }

	/** Getter: Number of rounds in contour strokes */
	int rounds() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "rounds"));
	}

	/** Setter: Number of rounds in contour strokes */
	void rounds(int value) {
		PyObject_SetAttrString(pyobjref, "rounds", Py_BuildValue("i", value));
	}

	/** Getter: Amount of backbone stretching */
	float backbone_length() { /* not implemented */ throw NULL; }
	/** Setter: Amount of backbone stretching */
	void backbone_length(float value) {
		PyObject_SetAttrString(pyobjref, "backbone_length", Py_BuildValue("f", value));
	}

	/** Getter: Randomness of the radius */
	int random_radius() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "random_radius"));
	}

	/** Setter: Randomness of the radius */
	void random_radius(int value) {
		PyObject_SetAttrString(pyobjref, "random_radius", Py_BuildValue("i", value));
	}

	/** Getter: Randomness of the center */
	int random_center() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "random_center"));
	}

	/** Setter: Randomness of the center */
	void random_center(int value) {
		PyObject_SetAttrString(pyobjref, "random_center", Py_BuildValue("i", value));
	}

	/** Getter: Randomness of the backbone stretching */
	int random_backbone() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "random_backbone"));
	}

	/** Setter: Randomness of the backbone stretching */
	void random_backbone(int value) {
		PyObject_SetAttrString(pyobjref, "random_backbone", Py_BuildValue("i", value));
	}

};

/**************** 2D Offset ****************/

/**
 * Add two-dimensional offsets to stroke backbone geometry
 */
class LineStyleGeometryModifier_2DOffset : public LineStyleGeometryModifier {
public:
	LineStyleGeometryModifier_2DOffset(PyObject* pyobj) : LineStyleGeometryModifier(pyobj) {}

	LineStyleGeometryModifier_2DOffset() : LineStyleGeometryModifier(0)
	{
		// not implemented
	}

	enum type_enum {
		type_2D_OFFSET = 17,
		type_2D_TRANSFORM = 18,
		type_BACKBONE_STRETCHER = 11,
		type_BEZIER_CURVE = 6,
		type_BLUEPRINT = 16,
		type_GUIDING_LINES = 15,
		type_PERLIN_NOISE_1D = 9,
		type_PERLIN_NOISE_2D = 10,
		type_POLYGONIZATION = 14,
		type_SAMPLING = 5,
		type_SINUS_DISPLACEMENT = 7,
		type_SPATIAL_NOISE = 8,
		type_TIP_REMOVER = 12,
	};

	/** Getter: Type of the modifier */
	type_enum type() { /* not implemented */ throw NULL; }
	/** Setter: Type of the modifier */
	void type(type_enum value) { /* not implemented */ }

	/** Getter: Name of the modifier */
	std::string name() { /* not implemented */ throw NULL; }
	/** Setter: Name of the modifier */
	void name(const std::string& value) { /* not implemented */ }

	/** Getter: Enable or disable this modifier during stroke rendering */
	bool use() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use")) == 1;
	}

	/** Setter: Enable or disable this modifier during stroke rendering */
	void use(bool value) {
		PyObject_SetAttrString(pyobjref, "use", Py_BuildValue("i", value));
	}

	/** Getter: True if the modifier tab is expanded */
	bool expanded() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "expanded")) == 1;
	}

	/** Setter: True if the modifier tab is expanded */
	void expanded(bool value) {
		PyObject_SetAttrString(pyobjref, "expanded", Py_BuildValue("i", value));
	}

	/** Getter: Displacement that is applied from the beginning of the stroke */
	float start() { /* not implemented */ throw NULL; }
	/** Setter: Displacement that is applied from the beginning of the stroke */
	void start(float value) {
		PyObject_SetAttrString(pyobjref, "start", Py_BuildValue("f", value));
	}

	/** Getter: Displacement that is applied from the end of the stroke */
	float end() { /* not implemented */ throw NULL; }
	/** Setter: Displacement that is applied from the end of the stroke */
	void end(float value) {
		PyObject_SetAttrString(pyobjref, "end", Py_BuildValue("f", value));
	}

	/** Getter: Displacement that is applied to the X coordinates of stroke vertices */
	float x() { /* not implemented */ throw NULL; }
	/** Setter: Displacement that is applied to the X coordinates of stroke vertices */
	void x(float value) {
		PyObject_SetAttrString(pyobjref, "x", Py_BuildValue("f", value));
	}

	/** Getter: Displacement that is applied to the Y coordinates of stroke vertices */
	float y() { /* not implemented */ throw NULL; }
	/** Setter: Displacement that is applied to the Y coordinates of stroke vertices */
	void y(float value) {
		PyObject_SetAttrString(pyobjref, "y", Py_BuildValue("f", value));
	}

};

/**************** 2D Transform ****************/

/**
 * Apply two-dimensional scaling and rotation to stroke backbone geometry
 */
class LineStyleGeometryModifier_2DTransform : public LineStyleGeometryModifier {
public:
	LineStyleGeometryModifier_2DTransform(PyObject* pyobj) : LineStyleGeometryModifier(pyobj) {}

	LineStyleGeometryModifier_2DTransform() : LineStyleGeometryModifier(0)
	{
		// not implemented
	}

	enum type_enum {
		type_2D_OFFSET = 17,
		type_2D_TRANSFORM = 18,
		type_BACKBONE_STRETCHER = 11,
		type_BEZIER_CURVE = 6,
		type_BLUEPRINT = 16,
		type_GUIDING_LINES = 15,
		type_PERLIN_NOISE_1D = 9,
		type_PERLIN_NOISE_2D = 10,
		type_POLYGONIZATION = 14,
		type_SAMPLING = 5,
		type_SINUS_DISPLACEMENT = 7,
		type_SPATIAL_NOISE = 8,
		type_TIP_REMOVER = 12,
	};

	/** Getter: Type of the modifier */
	type_enum type() { /* not implemented */ throw NULL; }
	/** Setter: Type of the modifier */
	void type(type_enum value) { /* not implemented */ }

	/** Getter: Name of the modifier */
	std::string name() { /* not implemented */ throw NULL; }
	/** Setter: Name of the modifier */
	void name(const std::string& value) { /* not implemented */ }

	/** Getter: Enable or disable this modifier during stroke rendering */
	bool use() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use")) == 1;
	}

	/** Setter: Enable or disable this modifier during stroke rendering */
	void use(bool value) {
		PyObject_SetAttrString(pyobjref, "use", Py_BuildValue("i", value));
	}

	/** Getter: True if the modifier tab is expanded */
	bool expanded() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "expanded")) == 1;
	}

	/** Setter: True if the modifier tab is expanded */
	void expanded(bool value) {
		PyObject_SetAttrString(pyobjref, "expanded", Py_BuildValue("i", value));
	}

	enum pivot_enum {
		pivot_CENTER = 1,
		pivot_START = 2,
		pivot_END = 3,
		pivot_PARAM = 4,
		pivot_ABSOLUTE = 5,
	};

	/** Getter: Pivot of scaling and rotation operations */
	pivot_enum pivot() { /* not implemented */ throw NULL; }
	/** Setter: Pivot of scaling and rotation operations */
	void pivot(pivot_enum value) { /* not implemented */ }

	/** Getter: Scaling factor that is applied along the X axis */
	float scale_x() { /* not implemented */ throw NULL; }
	/** Setter: Scaling factor that is applied along the X axis */
	void scale_x(float value) {
		PyObject_SetAttrString(pyobjref, "scale_x", Py_BuildValue("f", value));
	}

	/** Getter: Scaling factor that is applied along the Y axis */
	float scale_y() { /* not implemented */ throw NULL; }
	/** Setter: Scaling factor that is applied along the Y axis */
	void scale_y(float value) {
		PyObject_SetAttrString(pyobjref, "scale_y", Py_BuildValue("f", value));
	}

	/** Getter: Rotation angle */
	float angle() { /* not implemented */ throw NULL; }
	/** Setter: Rotation angle */
	void angle(float value) {
		PyObject_SetAttrString(pyobjref, "angle", Py_BuildValue("f", value));
	}

	/** Getter: Pivot in terms of the stroke point parameter u (0 <= u <= 1) */
	float pivot_u() { /* not implemented */ throw NULL; }
	/** Setter: Pivot in terms of the stroke point parameter u (0 <= u <= 1) */
	void pivot_u(float value) {
		PyObject_SetAttrString(pyobjref, "pivot_u", Py_BuildValue("f", value));
	}

	/** Getter: 2D X coordinate of the absolute pivot */
	float pivot_x() { /* not implemented */ throw NULL; }
	/** Setter: 2D X coordinate of the absolute pivot */
	void pivot_x(float value) {
		PyObject_SetAttrString(pyobjref, "pivot_x", Py_BuildValue("f", value));
	}

	/** Getter: 2D Y coordinate of the absolute pivot */
	float pivot_y() { /* not implemented */ throw NULL; }
	/** Setter: 2D Y coordinate of the absolute pivot */
	void pivot_y(float value) {
		PyObject_SetAttrString(pyobjref, "pivot_y", Py_BuildValue("f", value));
	}

};

/**************** Freestyle Line Style ****************/

/**
 * Freestyle line style, reusable by multiple line sets
 */
class FreestyleLineStyle : public ID {
public:
	FreestyleLineStyle(PyObject* pyobj) : ID(pyobj) {}

	FreestyleLineStyle() : ID(0)
	{
		// not implemented
	}

	/** Getter: Texture slots defining the mapping and influence of textures */
	std::map<std::string, LineStyleTextureSlot> texture_slots();
	/** Setter: Texture slots defining the mapping and influence of textures */
	void texture_slots(std::map<std::string, LineStyleTextureSlot> value);

	/** Getter: Active texture slot being displayed */
	Texture active_texture() {
		/* not implemented */ throw NULL;
	}

	/** Getter: Index of active texture slot */
	int active_texture_index() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "active_texture_index"));
	}

	/** Setter: Index of active texture slot */
	void active_texture_index(int value) {
		PyObject_SetAttrString(pyobjref, "active_texture_index", Py_BuildValue("i", value));
	}

	enum panel_enum {
		panel_STROKES = 1,
		panel_COLOR = 2,
		panel_ALPHA = 3,
		panel_THICKNESS = 4,
		panel_GEOMETRY = 5,
		panel_TEXTURE = 6,
	};

	/** Getter: Select the property panel to be shown */
	panel_enum panel() { /* not implemented */ throw NULL; }
	/** Setter: Select the property panel to be shown */
	void panel(panel_enum value) { /* not implemented */ }

	/** Getter: Base line color, possibly modified by line color modifiers */
	std::array<float, 3> color() {
		// TODO: MISSING DEREF! USE #DEFINE!
		PyObject *seqval = PyObject_GetAttrString(pyobjref, "color");
		std::array<float, 3> resarr;
		for (int i = 0; i < 3; i++)
			resarr[i] = (float)PyFloat_AsDouble(PySequence_GetItem(seqval, i));
		return resarr;
	}

	/** Setter: Base line color, possibly modified by line color modifiers */
	void color(float values[3]) { /* not implemented */ }

	/** Getter: Base alpha transparency, possibly modified by alpha transparency modifiers */
	float alpha() { /* not implemented */ throw NULL; }
	/** Setter: Base alpha transparency, possibly modified by alpha transparency modifiers */
	void alpha(float value) {
		PyObject_SetAttrString(pyobjref, "alpha", Py_BuildValue("f", value));
	}

	/** Getter: Base line thickness, possibly modified by line thickness modifiers */
	float thickness() { /* not implemented */ throw NULL; }
	/** Setter: Base line thickness, possibly modified by line thickness modifiers */
	void thickness(float value) {
		PyObject_SetAttrString(pyobjref, "thickness", Py_BuildValue("f", value));
	}

	enum thickness_position_enum {
		thickness_position_CENTER = 1,
		thickness_position_INSIDE = 2,
		thickness_position_OUTSIDE = 3,
		thickness_position_RELATIVE = 4,
	};

	/** Getter: Thickness position of silhouettes and border edges (applicable when plain chaining is used with the Same Object option) */
	thickness_position_enum thickness_position() { /* not implemented */ throw NULL; }
	/** Setter: Thickness position of silhouettes and border edges (applicable when plain chaining is used with the Same Object option) */
	void thickness_position(thickness_position_enum value) { /* not implemented */ }

	/** Getter: A number between 0 (inside) and 1 (outside) specifying the relative position of stroke thickness */
	float thickness_ratio() { /* not implemented */ throw NULL; }
	/** Setter: A number between 0 (inside) and 1 (outside) specifying the relative position of stroke thickness */
	void thickness_ratio(float value) {
		PyObject_SetAttrString(pyobjref, "thickness_ratio", Py_BuildValue("f", value));
	}

	/** Getter: List of line color modifiers */
	std::map<std::string, LineStyleColorModifier> color_modifiers() {
		// TODO: MISSING DEREF! USE #DEFINE!
		PyObject *seqval = PyObject_GetAttrString(pyobjref, "color_modifiers");
		PyObject *seqkeys = PyObject_CallMethod(seqval, "keys", NULL);
		std::map<std::string, LineStyleColorModifier> resmap;
		for (int i = 0; i < PySequence_Length(seqval); i++) {
			PyObject *keyobj = PySequence_GetItem(seqkeys, i);
			std::string key = PyBytes_AsString(PyUnicode_AsASCIIString(keyobj));
			LineStyleColorModifier value = LineStyleColorModifier(PySequence_GetItem(seqval, i));
			resmap.insert(std::pair<std::string,LineStyleColorModifier>(key, value));
		}
		return resmap;
	}

	/** Setter: List of line color modifiers */
	void color_modifiers(std::map<std::string, LineStyleColorModifier> value) { /* not implemented */ }

	/** Getter: List of alpha transparency modifiers */
	std::map<std::string, LineStyleAlphaModifier> alpha_modifiers() {
		// TODO: MISSING DEREF! USE #DEFINE!
		PyObject *seqval = PyObject_GetAttrString(pyobjref, "alpha_modifiers");
		PyObject *seqkeys = PyObject_CallMethod(seqval, "keys", NULL);
		std::map<std::string, LineStyleAlphaModifier> resmap;
		for (int i = 0; i < PySequence_Length(seqval); i++) {
			PyObject *keyobj = PySequence_GetItem(seqkeys, i);
			std::string key = PyBytes_AsString(PyUnicode_AsASCIIString(keyobj));
			LineStyleAlphaModifier value = LineStyleAlphaModifier(PySequence_GetItem(seqval, i));
			resmap.insert(std::pair<std::string,LineStyleAlphaModifier>(key, value));
		}
		return resmap;
	}

	/** Setter: List of alpha transparency modifiers */
	void alpha_modifiers(std::map<std::string, LineStyleAlphaModifier> value) { /* not implemented */ }

	/** Getter: List of line thickness modifiers */
	std::map<std::string, LineStyleThicknessModifier> thickness_modifiers() {
		// TODO: MISSING DEREF! USE #DEFINE!
		PyObject *seqval = PyObject_GetAttrString(pyobjref, "thickness_modifiers");
		PyObject *seqkeys = PyObject_CallMethod(seqval, "keys", NULL);
		std::map<std::string, LineStyleThicknessModifier> resmap;
		for (int i = 0; i < PySequence_Length(seqval); i++) {
			PyObject *keyobj = PySequence_GetItem(seqkeys, i);
			std::string key = PyBytes_AsString(PyUnicode_AsASCIIString(keyobj));
			LineStyleThicknessModifier value = LineStyleThicknessModifier(PySequence_GetItem(seqval, i));
			resmap.insert(std::pair<std::string,LineStyleThicknessModifier>(key, value));
		}
		return resmap;
	}

	/** Setter: List of line thickness modifiers */
	void thickness_modifiers(std::map<std::string, LineStyleThicknessModifier> value) { /* not implemented */ }

	/** Getter: List of stroke geometry modifiers */
	std::map<std::string, LineStyleGeometryModifier> geometry_modifiers() {
		// TODO: MISSING DEREF! USE #DEFINE!
		PyObject *seqval = PyObject_GetAttrString(pyobjref, "geometry_modifiers");
		PyObject *seqkeys = PyObject_CallMethod(seqval, "keys", NULL);
		std::map<std::string, LineStyleGeometryModifier> resmap;
		for (int i = 0; i < PySequence_Length(seqval); i++) {
			PyObject *keyobj = PySequence_GetItem(seqkeys, i);
			std::string key = PyBytes_AsString(PyUnicode_AsASCIIString(keyobj));
			LineStyleGeometryModifier value = LineStyleGeometryModifier(PySequence_GetItem(seqval, i));
			resmap.insert(std::pair<std::string,LineStyleGeometryModifier>(key, value));
		}
		return resmap;
	}

	/** Setter: List of stroke geometry modifiers */
	void geometry_modifiers(std::map<std::string, LineStyleGeometryModifier> value) { /* not implemented */ }

	/** Getter: Enable chaining of feature edges */
	bool use_chaining() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_chaining")) == 1;
	}

	/** Setter: Enable chaining of feature edges */
	void use_chaining(bool value) {
		PyObject_SetAttrString(pyobjref, "use_chaining", Py_BuildValue("i", value));
	}

	enum chaining_enum {
		chaining_PLAIN = 1,
		chaining_SKETCHY = 2,
	};

	/** Getter: Select the way how feature edges are jointed to form chains */
	chaining_enum chaining() { /* not implemented */ throw NULL; }
	/** Setter: Select the way how feature edges are jointed to form chains */
	void chaining(chaining_enum value) { /* not implemented */ }

	/** Getter: Number of rounds in a sketchy multiple touch */
	int rounds() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "rounds"));
	}

	/** Setter: Number of rounds in a sketchy multiple touch */
	void rounds(int value) {
		PyObject_SetAttrString(pyobjref, "rounds", Py_BuildValue("i", value));
	}

	/** Getter: If true, only feature edges of the same object are joined */
	bool use_same_object() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_same_object")) == 1;
	}

	/** Setter: If true, only feature edges of the same object are joined */
	void use_same_object(bool value) {
		PyObject_SetAttrString(pyobjref, "use_same_object", Py_BuildValue("i", value));
	}

	/** Getter: Enable chain splitting by curvilinear 2D length */
	bool use_split_length() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_split_length")) == 1;
	}

	/** Setter: Enable chain splitting by curvilinear 2D length */
	void use_split_length(bool value) {
		PyObject_SetAttrString(pyobjref, "use_split_length", Py_BuildValue("i", value));
	}

	/** Getter: Curvilinear 2D length for chain splitting */
	float split_length() { /* not implemented */ throw NULL; }
	/** Setter: Curvilinear 2D length for chain splitting */
	void split_length(float value) {
		PyObject_SetAttrString(pyobjref, "split_length", Py_BuildValue("f", value));
	}

	/** Getter: Split chains at points with angles smaller than the minimum 2D angle */
	bool use_angle_min() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_angle_min")) == 1;
	}

	/** Setter: Split chains at points with angles smaller than the minimum 2D angle */
	void use_angle_min(bool value) {
		PyObject_SetAttrString(pyobjref, "use_angle_min", Py_BuildValue("i", value));
	}

	/** Getter: Minimum 2D angle for splitting chains */
	float angle_min() { /* not implemented */ throw NULL; }
	/** Setter: Minimum 2D angle for splitting chains */
	void angle_min(float value) {
		PyObject_SetAttrString(pyobjref, "angle_min", Py_BuildValue("f", value));
	}

	/** Getter: Split chains at points with angles larger than the maximum 2D angle */
	bool use_angle_max() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_angle_max")) == 1;
	}

	/** Setter: Split chains at points with angles larger than the maximum 2D angle */
	void use_angle_max(bool value) {
		PyObject_SetAttrString(pyobjref, "use_angle_max", Py_BuildValue("i", value));
	}

	/** Getter: Maximum 2D angle for splitting chains */
	float angle_max() { /* not implemented */ throw NULL; }
	/** Setter: Maximum 2D angle for splitting chains */
	void angle_max(float value) {
		PyObject_SetAttrString(pyobjref, "angle_max", Py_BuildValue("f", value));
	}

	/** Getter: Enable the selection of chains by a minimum 2D length */
	bool use_length_min() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_length_min")) == 1;
	}

	/** Setter: Enable the selection of chains by a minimum 2D length */
	void use_length_min(bool value) {
		PyObject_SetAttrString(pyobjref, "use_length_min", Py_BuildValue("i", value));
	}

	/** Getter: Minimum curvilinear 2D length for the selection of chains */
	float length_min() { /* not implemented */ throw NULL; }
	/** Setter: Minimum curvilinear 2D length for the selection of chains */
	void length_min(float value) {
		PyObject_SetAttrString(pyobjref, "length_min", Py_BuildValue("f", value));
	}

	/** Getter: Enable the selection of chains by a maximum 2D length */
	bool use_length_max() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_length_max")) == 1;
	}

	/** Setter: Enable the selection of chains by a maximum 2D length */
	void use_length_max(bool value) {
		PyObject_SetAttrString(pyobjref, "use_length_max", Py_BuildValue("i", value));
	}

	/** Getter: Maximum curvilinear 2D length for the selection of chains */
	float length_max() { /* not implemented */ throw NULL; }
	/** Setter: Maximum curvilinear 2D length for the selection of chains */
	void length_max(float value) {
		PyObject_SetAttrString(pyobjref, "length_max", Py_BuildValue("f", value));
	}

	/** Getter: Enable the selection of first N chains */
	bool use_chain_count() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_chain_count")) == 1;
	}

	/** Setter: Enable the selection of first N chains */
	void use_chain_count(bool value) {
		PyObject_SetAttrString(pyobjref, "use_chain_count", Py_BuildValue("i", value));
	}

	/** Getter: Chain count for the selection of first N chains */
	int chain_count() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "chain_count"));
	}

	/** Setter: Chain count for the selection of first N chains */
	void chain_count(int value) {
		PyObject_SetAttrString(pyobjref, "chain_count", Py_BuildValue("i", value));
	}

	/** Getter: Enable chain splitting by dashed line patterns */
	bool use_split_pattern() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_split_pattern")) == 1;
	}

	/** Setter: Enable chain splitting by dashed line patterns */
	void use_split_pattern(bool value) {
		PyObject_SetAttrString(pyobjref, "use_split_pattern", Py_BuildValue("i", value));
	}

	/** Getter: Length of the 1st dash for splitting */
	int split_dash1() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "split_dash1"));
	}

	/** Setter: Length of the 1st dash for splitting */
	void split_dash1(int value) {
		PyObject_SetAttrString(pyobjref, "split_dash1", Py_BuildValue("i", value));
	}

	/** Getter: Length of the 1st gap for splitting */
	int split_gap1() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "split_gap1"));
	}

	/** Setter: Length of the 1st gap for splitting */
	void split_gap1(int value) {
		PyObject_SetAttrString(pyobjref, "split_gap1", Py_BuildValue("i", value));
	}

	/** Getter: Length of the 2nd dash for splitting */
	int split_dash2() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "split_dash2"));
	}

	/** Setter: Length of the 2nd dash for splitting */
	void split_dash2(int value) {
		PyObject_SetAttrString(pyobjref, "split_dash2", Py_BuildValue("i", value));
	}

	/** Getter: Length of the 2nd gap for splitting */
	int split_gap2() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "split_gap2"));
	}

	/** Setter: Length of the 2nd gap for splitting */
	void split_gap2(int value) {
		PyObject_SetAttrString(pyobjref, "split_gap2", Py_BuildValue("i", value));
	}

	/** Getter: Length of the 3rd dash for splitting */
	int split_dash3() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "split_dash3"));
	}

	/** Setter: Length of the 3rd dash for splitting */
	void split_dash3(int value) {
		PyObject_SetAttrString(pyobjref, "split_dash3", Py_BuildValue("i", value));
	}

	/** Getter: Length of the 3rd gap for splitting */
	int split_gap3() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "split_gap3"));
	}

	/** Setter: Length of the 3rd gap for splitting */
	void split_gap3(int value) {
		PyObject_SetAttrString(pyobjref, "split_gap3", Py_BuildValue("i", value));
	}

	/** Getter: If true, chains of feature edges are split at material boundaries */
	bool material_boundary() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "material_boundary")) == 1;
	}

	/** Setter: If true, chains of feature edges are split at material boundaries */
	void material_boundary(bool value) {
		PyObject_SetAttrString(pyobjref, "material_boundary", Py_BuildValue("i", value));
	}

	/** Getter: Arrange the stacking order of strokes */
	bool use_sorting() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_sorting")) == 1;
	}

	/** Setter: Arrange the stacking order of strokes */
	void use_sorting(bool value) {
		PyObject_SetAttrString(pyobjref, "use_sorting", Py_BuildValue("i", value));
	}

	enum sort_key_enum {
		sort_key_DISTANCE_FROM_CAMERA = 1,
		sort_key_2D_LENGTH = 2,
		sort_key_PROJECTED_X = 3,
		sort_key_PROJECTED_Y = 4,
	};

	/** Getter: Select the sort key to determine the stacking order of chains */
	sort_key_enum sort_key() { /* not implemented */ throw NULL; }
	/** Setter: Select the sort key to determine the stacking order of chains */
	void sort_key(sort_key_enum value) { /* not implemented */ }

	enum sort_order_enum {
		sort_order_DEFAULT = 0,
		sort_order_REVERSE = 4096,
	};

	/** Getter: Select the sort order */
	sort_order_enum sort_order() { /* not implemented */ throw NULL; }
	/** Setter: Select the sort order */
	void sort_order(sort_order_enum value) { /* not implemented */ }

	enum integration_type_enum {
		integration_type_MEAN = 1,
		integration_type_MIN = 2,
		integration_type_MAX = 3,
		integration_type_FIRST = 4,
		integration_type_LAST = 5,
	};

	/** Getter: Select the way how the sort key is computed for each chain */
	integration_type_enum integration_type() { /* not implemented */ throw NULL; }
	/** Setter: Select the way how the sort key is computed for each chain */
	void integration_type(integration_type_enum value) { /* not implemented */ }

	/** Getter: Enable or disable dashed line */
	bool use_dashed_line() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_dashed_line")) == 1;
	}

	/** Setter: Enable or disable dashed line */
	void use_dashed_line(bool value) {
		PyObject_SetAttrString(pyobjref, "use_dashed_line", Py_BuildValue("i", value));
	}

	enum caps_enum {
		caps_BUTT = 1,
		caps_ROUND = 2,
		caps_SQUARE = 3,
	};

	/** Getter: Select the shape of both ends of strokes */
	caps_enum caps() { /* not implemented */ throw NULL; }
	/** Setter: Select the shape of both ends of strokes */
	void caps(caps_enum value) { /* not implemented */ }

	/** Getter: Length of the 1st dash for dashed lines */
	int dash1() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "dash1"));
	}

	/** Setter: Length of the 1st dash for dashed lines */
	void dash1(int value) {
		PyObject_SetAttrString(pyobjref, "dash1", Py_BuildValue("i", value));
	}

	/** Getter: Length of the 1st gap for dashed lines */
	int gap1() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "gap1"));
	}

	/** Setter: Length of the 1st gap for dashed lines */
	void gap1(int value) {
		PyObject_SetAttrString(pyobjref, "gap1", Py_BuildValue("i", value));
	}

	/** Getter: Length of the 2nd dash for dashed lines */
	int dash2() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "dash2"));
	}

	/** Setter: Length of the 2nd dash for dashed lines */
	void dash2(int value) {
		PyObject_SetAttrString(pyobjref, "dash2", Py_BuildValue("i", value));
	}

	/** Getter: Length of the 2nd gap for dashed lines */
	int gap2() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "gap2"));
	}

	/** Setter: Length of the 2nd gap for dashed lines */
	void gap2(int value) {
		PyObject_SetAttrString(pyobjref, "gap2", Py_BuildValue("i", value));
	}

	/** Getter: Length of the 3rd dash for dashed lines */
	int dash3() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "dash3"));
	}

	/** Setter: Length of the 3rd dash for dashed lines */
	void dash3(int value) {
		PyObject_SetAttrString(pyobjref, "dash3", Py_BuildValue("i", value));
	}

	/** Getter: Length of the 3rd gap for dashed lines */
	int gap3() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "gap3"));
	}

	/** Setter: Length of the 3rd gap for dashed lines */
	void gap3(int value) {
		PyObject_SetAttrString(pyobjref, "gap3", Py_BuildValue("i", value));
	}

	/** Getter: Enable or disable textured strokes */
	bool use_texture() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_texture")) == 1;
	}

	/** Setter: Enable or disable textured strokes */
	void use_texture(bool value) {
		PyObject_SetAttrString(pyobjref, "use_texture", Py_BuildValue("i", value));
	}

	/** Getter: Spacing for textures along stroke length */
	float texture_spacing() { /* not implemented */ throw NULL; }
	/** Setter: Spacing for textures along stroke length */
	void texture_spacing(float value) {
		PyObject_SetAttrString(pyobjref, "texture_spacing", Py_BuildValue("f", value));
	}

	/** Getter: Node tree for node-based shaders */
	NodeTree node_tree();

	/** Getter: Use shader nodes for the line style */
	bool use_nodes() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_nodes")) == 1;
	}

	/** Setter: Use shader nodes for the line style */
	void use_nodes(bool value) {
		PyObject_SetAttrString(pyobjref, "use_nodes", Py_BuildValue("i", value));
	}

};

/**************** LineStyle Texture Slot ****************/

/**
 * Texture slot for textures in a LineStyle datablock
 */
class LineStyleTextureSlot : public TextureSlot {
public:
	LineStyleTextureSlot(PyObject* pyobj) : TextureSlot(pyobj) {}

	LineStyleTextureSlot() : TextureSlot(0)
	{
		// not implemented
	}

	enum mapping_x_enum {
		mapping_x_NONE = 0,
		mapping_x_X = 1,
		mapping_x_Y = 2,
		mapping_x_Z = 3,
	};

	/** Getter:  */
	mapping_x_enum mapping_x() { /* not implemented */ throw NULL; }
	/** Setter:  */
	void mapping_x(mapping_x_enum value) { /* not implemented */ }

	enum mapping_y_enum {
		mapping_y_NONE = 0,
		mapping_y_X = 1,
		mapping_y_Y = 2,
		mapping_y_Z = 3,
	};

	/** Getter:  */
	mapping_y_enum mapping_y() { /* not implemented */ throw NULL; }
	/** Setter:  */
	void mapping_y(mapping_y_enum value) { /* not implemented */ }

	enum mapping_z_enum {
		mapping_z_NONE = 0,
		mapping_z_X = 1,
		mapping_z_Y = 2,
		mapping_z_Z = 3,
	};

	/** Getter:  */
	mapping_z_enum mapping_z() { /* not implemented */ throw NULL; }
	/** Setter:  */
	void mapping_z(mapping_z_enum value) { /* not implemented */ }

	enum mapping_enum {
		mapping_FLAT = 0,
		mapping_CUBE = 1,
		mapping_TUBE = 2,
		mapping_SPHERE = 3,
	};

	/** Getter:  */
	mapping_enum mapping() { /* not implemented */ throw NULL; }
	/** Setter:  */
	void mapping(mapping_enum value) { /* not implemented */ }

	/** Getter: The texture affects basic color of the stroke */
	bool use_map_color_diffuse() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_map_color_diffuse")) == 1;
	}

	/** Setter: The texture affects basic color of the stroke */
	void use_map_color_diffuse(bool value) {
		PyObject_SetAttrString(pyobjref, "use_map_color_diffuse", Py_BuildValue("i", value));
	}

	/** Getter: The texture affects the alpha value */
	bool use_map_alpha() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_map_alpha")) == 1;
	}

	/** Setter: The texture affects the alpha value */
	void use_map_alpha(bool value) {
		PyObject_SetAttrString(pyobjref, "use_map_alpha", Py_BuildValue("i", value));
	}

	/** Getter: Lower half of the texture is for tips of the stroke */
	bool use_tips() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_tips")) == 1;
	}

	/** Setter: Lower half of the texture is for tips of the stroke */
	void use_tips(bool value) {
		PyObject_SetAttrString(pyobjref, "use_tips", Py_BuildValue("i", value));
	}

	enum texture_coords_enum {
		texture_coords_WINDOW = 1024,
		texture_coords_GLOBAL = 8,
		texture_coords_ALONG_STROKE = 16,
		texture_coords_ORCO = 1,
	};

	/** Getter: Texture coordinates used to map the texture onto the background */
	texture_coords_enum texture_coords() { /* not implemented */ throw NULL; }
	/** Setter: Texture coordinates used to map the texture onto the background */
	void texture_coords(texture_coords_enum value) { /* not implemented */ }

	/** Getter: Amount texture affects alpha */
	float alpha_factor() { /* not implemented */ throw NULL; }
	/** Setter: Amount texture affects alpha */
	void alpha_factor(float value) {
		PyObject_SetAttrString(pyobjref, "alpha_factor", Py_BuildValue("f", value));
	}

	/** Getter: Amount texture affects diffuse color */
	float diffuse_color_factor() { /* not implemented */ throw NULL; }
	/** Setter: Amount texture affects diffuse color */
	void diffuse_color_factor(float value) {
		PyObject_SetAttrString(pyobjref, "diffuse_color_factor", Py_BuildValue("f", value));
	}

};

/**************** Blendfile Data ****************/

/**
 * Main data structure representing a .blend file and all its datablocks
 */
class BlendData : public pyUniplug {
public:
	BlendData(PyObject* pyobj) : pyUniplug(pyobj) {}

	BlendData() : pyUniplug(0)
	{
		// not implemented
	}

	/** Getter: Path to the .blend file */
	std::string filepath() { /* not implemented */ throw NULL; }
	/** Setter: Path to the .blend file */
	void filepath(const std::string& value) { /* not implemented */ }

	/** Getter: Have recent edits been saved to disk */
	bool is_dirty() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "is_dirty")) == 1;
	}

	/** Setter: Have recent edits been saved to disk */
	void is_dirty(bool value) {
		PyObject_SetAttrString(pyobjref, "is_dirty", Py_BuildValue("i", value));
	}

	/** Getter: Has the current session been saved to disk as a .blend file */
	bool is_saved() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "is_saved")) == 1;
	}

	/** Setter: Has the current session been saved to disk as a .blend file */
	void is_saved(bool value) {
		PyObject_SetAttrString(pyobjref, "is_saved", Py_BuildValue("i", value));
	}

	/** Getter: Automatically pack all external data into .blend file */
	bool use_autopack() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_autopack")) == 1;
	}

	/** Setter: Automatically pack all external data into .blend file */
	void use_autopack(bool value) {
		PyObject_SetAttrString(pyobjref, "use_autopack", Py_BuildValue("i", value));
	}

	/** Getter: Version of the blender the .blend was saved with */
	std::array<int, 3> version() {
		// TODO: MISSING DEREF! USE #DEFINE!
		PyObject *seqval = PyObject_GetAttrString(pyobjref, "version");
		std::array<int, 3> resarr;
		for (int i = 0; i < 3; i++)
			resarr[i] = PyLong_AsLong(PySequence_GetItem(seqval, i));
		return resarr;
	}

	/** Setter: Version of the blender the .blend was saved with */
	void version(int values[3]) { /* not implemented */ }

	/** Getter: Camera datablocks */
	std::map<std::string, Camera> cameras() {
		// TODO: MISSING DEREF! USE #DEFINE!
		PyObject *seqval = PyObject_GetAttrString(pyobjref, "cameras");
		PyObject *seqkeys = PyObject_CallMethod(seqval, "keys", NULL);
		std::map<std::string, Camera> resmap;
		for (int i = 0; i < PySequence_Length(seqval); i++) {
			PyObject *keyobj = PySequence_GetItem(seqkeys, i);
			std::string key = PyBytes_AsString(PyUnicode_AsASCIIString(keyobj));
			Camera value = Camera(PySequence_GetItem(seqval, i));
			resmap.insert(std::pair<std::string,Camera>(key, value));
		}
		return resmap;
	}

	/** Setter: Camera datablocks */
	void cameras(std::map<std::string, Camera> value) { /* not implemented */ }

	/** Getter: Scene datablocks */
	std::map<std::string, Scene> scenes();
	/** Setter: Scene datablocks */
	void scenes(std::map<std::string, Scene> value);

	/** Getter: Object datablocks */
	std::map<std::string, Object> objects();
	/** Setter: Object datablocks */
	void objects(std::map<std::string, Object> value);

	/** Getter: Material datablocks */
	std::map<std::string, Material> materials();
	/** Setter: Material datablocks */
	void materials(std::map<std::string, Material> value);

	/** Getter: Node group datablocks */
	std::map<std::string, NodeTree> node_groups();
	/** Setter: Node group datablocks */
	void node_groups(std::map<std::string, NodeTree> value);

	/** Getter: Mesh datablocks */
	std::map<std::string, Mesh> meshes();
	/** Setter: Mesh datablocks */
	void meshes(std::map<std::string, Mesh> value);

	/** Getter: Lamp datablocks */
	std::map<std::string, Lamp> lamps() {
		// TODO: MISSING DEREF! USE #DEFINE!
		PyObject *seqval = PyObject_GetAttrString(pyobjref, "lamps");
		PyObject *seqkeys = PyObject_CallMethod(seqval, "keys", NULL);
		std::map<std::string, Lamp> resmap;
		for (int i = 0; i < PySequence_Length(seqval); i++) {
			PyObject *keyobj = PySequence_GetItem(seqkeys, i);
			std::string key = PyBytes_AsString(PyUnicode_AsASCIIString(keyobj));
			Lamp value = Lamp(PySequence_GetItem(seqval, i));
			resmap.insert(std::pair<std::string,Lamp>(key, value));
		}
		return resmap;
	}

	/** Setter: Lamp datablocks */
	void lamps(std::map<std::string, Lamp> value) { /* not implemented */ }

	/** Getter: Library datablocks */
	std::map<std::string, Library> libraries() {
		// TODO: MISSING DEREF! USE #DEFINE!
		PyObject *seqval = PyObject_GetAttrString(pyobjref, "libraries");
		PyObject *seqkeys = PyObject_CallMethod(seqval, "keys", NULL);
		std::map<std::string, Library> resmap;
		for (int i = 0; i < PySequence_Length(seqval); i++) {
			PyObject *keyobj = PySequence_GetItem(seqkeys, i);
			std::string key = PyBytes_AsString(PyUnicode_AsASCIIString(keyobj));
			Library value = Library(PySequence_GetItem(seqval, i));
			resmap.insert(std::pair<std::string,Library>(key, value));
		}
		return resmap;
	}

	/** Setter: Library datablocks */
	void libraries(std::map<std::string, Library> value) { /* not implemented */ }

	/** Getter: Screen datablocks */
	std::map<std::string, Screen> screens();
	/** Setter: Screen datablocks */
	void screens(std::map<std::string, Screen> value);

	/** Getter: Window manager datablocks */
	std::map<std::string, WindowManager> window_managers();
	/** Setter: Window manager datablocks */
	void window_managers(std::map<std::string, WindowManager> value);

	/** Getter: Image datablocks */
	std::map<std::string, Image> images() {
		// TODO: MISSING DEREF! USE #DEFINE!
		PyObject *seqval = PyObject_GetAttrString(pyobjref, "images");
		PyObject *seqkeys = PyObject_CallMethod(seqval, "keys", NULL);
		std::map<std::string, Image> resmap;
		for (int i = 0; i < PySequence_Length(seqval); i++) {
			PyObject *keyobj = PySequence_GetItem(seqkeys, i);
			std::string key = PyBytes_AsString(PyUnicode_AsASCIIString(keyobj));
			Image value = Image(PySequence_GetItem(seqval, i));
			resmap.insert(std::pair<std::string,Image>(key, value));
		}
		return resmap;
	}

	/** Setter: Image datablocks */
	void images(std::map<std::string, Image> value) { /* not implemented */ }

	/** Getter: Lattice datablocks */
	std::map<std::string, Lattice> lattices() {
		// TODO: MISSING DEREF! USE #DEFINE!
		PyObject *seqval = PyObject_GetAttrString(pyobjref, "lattices");
		PyObject *seqkeys = PyObject_CallMethod(seqval, "keys", NULL);
		std::map<std::string, Lattice> resmap;
		for (int i = 0; i < PySequence_Length(seqval); i++) {
			PyObject *keyobj = PySequence_GetItem(seqkeys, i);
			std::string key = PyBytes_AsString(PyUnicode_AsASCIIString(keyobj));
			Lattice value = Lattice(PySequence_GetItem(seqval, i));
			resmap.insert(std::pair<std::string,Lattice>(key, value));
		}
		return resmap;
	}

	/** Setter: Lattice datablocks */
	void lattices(std::map<std::string, Lattice> value) { /* not implemented */ }

	/** Getter: Curve datablocks */
	std::map<std::string, Curve> curves() {
		// TODO: MISSING DEREF! USE #DEFINE!
		PyObject *seqval = PyObject_GetAttrString(pyobjref, "curves");
		PyObject *seqkeys = PyObject_CallMethod(seqval, "keys", NULL);
		std::map<std::string, Curve> resmap;
		for (int i = 0; i < PySequence_Length(seqval); i++) {
			PyObject *keyobj = PySequence_GetItem(seqkeys, i);
			std::string key = PyBytes_AsString(PyUnicode_AsASCIIString(keyobj));
			Curve value = Curve(PySequence_GetItem(seqval, i));
			resmap.insert(std::pair<std::string,Curve>(key, value));
		}
		return resmap;
	}

	/** Setter: Curve datablocks */
	void curves(std::map<std::string, Curve> value) { /* not implemented */ }

	/** Getter: Metaball datablocks */
	std::map<std::string, MetaBall> metaballs();
	/** Setter: Metaball datablocks */
	void metaballs(std::map<std::string, MetaBall> value);

	/** Getter: Vector font datablocks */
	std::map<std::string, VectorFont> fonts();
	/** Setter: Vector font datablocks */
	void fonts(std::map<std::string, VectorFont> value);

	/** Getter: Texture datablocks */
	std::map<std::string, Texture> textures() {
		// TODO: MISSING DEREF! USE #DEFINE!
		PyObject *seqval = PyObject_GetAttrString(pyobjref, "textures");
		PyObject *seqkeys = PyObject_CallMethod(seqval, "keys", NULL);
		std::map<std::string, Texture> resmap;
		for (int i = 0; i < PySequence_Length(seqval); i++) {
			PyObject *keyobj = PySequence_GetItem(seqkeys, i);
			std::string key = PyBytes_AsString(PyUnicode_AsASCIIString(keyobj));
			Texture value = Texture(PySequence_GetItem(seqval, i));
			resmap.insert(std::pair<std::string,Texture>(key, value));
		}
		return resmap;
	}

	/** Setter: Texture datablocks */
	void textures(std::map<std::string, Texture> value) { /* not implemented */ }

	/** Getter: Brush datablocks */
	std::map<std::string, Brush> brushes() {
		// TODO: MISSING DEREF! USE #DEFINE!
		PyObject *seqval = PyObject_GetAttrString(pyobjref, "brushes");
		PyObject *seqkeys = PyObject_CallMethod(seqval, "keys", NULL);
		std::map<std::string, Brush> resmap;
		for (int i = 0; i < PySequence_Length(seqval); i++) {
			PyObject *keyobj = PySequence_GetItem(seqkeys, i);
			std::string key = PyBytes_AsString(PyUnicode_AsASCIIString(keyobj));
			Brush value = Brush(PySequence_GetItem(seqval, i));
			resmap.insert(std::pair<std::string,Brush>(key, value));
		}
		return resmap;
	}

	/** Setter: Brush datablocks */
	void brushes(std::map<std::string, Brush> value) { /* not implemented */ }

	/** Getter: World datablocks */
	std::map<std::string, World> worlds();
	/** Setter: World datablocks */
	void worlds(std::map<std::string, World> value);

	/** Getter: Group datablocks */
	std::map<std::string, Group> groups() {
		// TODO: MISSING DEREF! USE #DEFINE!
		PyObject *seqval = PyObject_GetAttrString(pyobjref, "groups");
		PyObject *seqkeys = PyObject_CallMethod(seqval, "keys", NULL);
		std::map<std::string, Group> resmap;
		for (int i = 0; i < PySequence_Length(seqval); i++) {
			PyObject *keyobj = PySequence_GetItem(seqkeys, i);
			std::string key = PyBytes_AsString(PyUnicode_AsASCIIString(keyobj));
			Group value = Group(PySequence_GetItem(seqval, i));
			resmap.insert(std::pair<std::string,Group>(key, value));
		}
		return resmap;
	}

	/** Setter: Group datablocks */
	void groups(std::map<std::string, Group> value) { /* not implemented */ }

	/** Getter: Shape Key datablocks */
	std::map<std::string, Key> shape_keys() {
		// TODO: MISSING DEREF! USE #DEFINE!
		PyObject *seqval = PyObject_GetAttrString(pyobjref, "shape_keys");
		PyObject *seqkeys = PyObject_CallMethod(seqval, "keys", NULL);
		std::map<std::string, Key> resmap;
		for (int i = 0; i < PySequence_Length(seqval); i++) {
			PyObject *keyobj = PySequence_GetItem(seqkeys, i);
			std::string key = PyBytes_AsString(PyUnicode_AsASCIIString(keyobj));
			Key value = Key(PySequence_GetItem(seqval, i));
			resmap.insert(std::pair<std::string,Key>(key, value));
		}
		return resmap;
	}

	/** Setter: Shape Key datablocks */
	void shape_keys(std::map<std::string, Key> value) { /* not implemented */ }

	/** Getter: Script datablocks (DEPRECATED) */
	std::map<std::string, ID> scripts() {
		// TODO: MISSING DEREF! USE #DEFINE!
		PyObject *seqval = PyObject_GetAttrString(pyobjref, "scripts");
		PyObject *seqkeys = PyObject_CallMethod(seqval, "keys", NULL);
		std::map<std::string, ID> resmap;
		for (int i = 0; i < PySequence_Length(seqval); i++) {
			PyObject *keyobj = PySequence_GetItem(seqkeys, i);
			std::string key = PyBytes_AsString(PyUnicode_AsASCIIString(keyobj));
			ID value = ID(PySequence_GetItem(seqval, i));
			resmap.insert(std::pair<std::string,ID>(key, value));
		}
		return resmap;
	}

	/** Setter: Script datablocks (DEPRECATED) */
	void scripts(std::map<std::string, ID> value) { /* not implemented */ }

	/** Getter: Text datablocks */
	std::map<std::string, Text> texts();
	/** Setter: Text datablocks */
	void texts(std::map<std::string, Text> value);

	/** Getter: Speaker datablocks */
	std::map<std::string, Speaker> speakers();
	/** Setter: Speaker datablocks */
	void speakers(std::map<std::string, Speaker> value);

	/** Getter: Sound datablocks */
	std::map<std::string, Sound> sounds();
	/** Setter: Sound datablocks */
	void sounds(std::map<std::string, Sound> value);

	/** Getter: Armature datablocks */
	std::map<std::string, Armature> armatures() {
		// TODO: MISSING DEREF! USE #DEFINE!
		PyObject *seqval = PyObject_GetAttrString(pyobjref, "armatures");
		PyObject *seqkeys = PyObject_CallMethod(seqval, "keys", NULL);
		std::map<std::string, Armature> resmap;
		for (int i = 0; i < PySequence_Length(seqval); i++) {
			PyObject *keyobj = PySequence_GetItem(seqkeys, i);
			std::string key = PyBytes_AsString(PyUnicode_AsASCIIString(keyobj));
			Armature value = Armature(PySequence_GetItem(seqval, i));
			resmap.insert(std::pair<std::string,Armature>(key, value));
		}
		return resmap;
	}

	/** Setter: Armature datablocks */
	void armatures(std::map<std::string, Armature> value) { /* not implemented */ }

	/** Getter: Action datablocks */
	std::map<std::string, Action> actions() {
		// TODO: MISSING DEREF! USE #DEFINE!
		PyObject *seqval = PyObject_GetAttrString(pyobjref, "actions");
		PyObject *seqkeys = PyObject_CallMethod(seqval, "keys", NULL);
		std::map<std::string, Action> resmap;
		for (int i = 0; i < PySequence_Length(seqval); i++) {
			PyObject *keyobj = PySequence_GetItem(seqkeys, i);
			std::string key = PyBytes_AsString(PyUnicode_AsASCIIString(keyobj));
			Action value = Action(PySequence_GetItem(seqval, i));
			resmap.insert(std::pair<std::string,Action>(key, value));
		}
		return resmap;
	}

	/** Setter: Action datablocks */
	void actions(std::map<std::string, Action> value) { /* not implemented */ }

	/** Getter: Particle datablocks */
	std::map<std::string, ParticleSettings> particles();
	/** Setter: Particle datablocks */
	void particles(std::map<std::string, ParticleSettings> value);

	/** Getter: Palette datablocks */
	std::map<std::string, Palette> palettes();
	/** Setter: Palette datablocks */
	void palettes(std::map<std::string, Palette> value);

	/** Getter: Grease Pencil datablocks */
	std::map<std::string, GreasePencil> grease_pencil() {
		// TODO: MISSING DEREF! USE #DEFINE!
		PyObject *seqval = PyObject_GetAttrString(pyobjref, "grease_pencil");
		PyObject *seqkeys = PyObject_CallMethod(seqval, "keys", NULL);
		std::map<std::string, GreasePencil> resmap;
		for (int i = 0; i < PySequence_Length(seqval); i++) {
			PyObject *keyobj = PySequence_GetItem(seqkeys, i);
			std::string key = PyBytes_AsString(PyUnicode_AsASCIIString(keyobj));
			GreasePencil value = GreasePencil(PySequence_GetItem(seqval, i));
			resmap.insert(std::pair<std::string,GreasePencil>(key, value));
		}
		return resmap;
	}

	/** Setter: Grease Pencil datablocks */
	void grease_pencil(std::map<std::string, GreasePencil> value) { /* not implemented */ }

	/** Getter: Movie Clip datablocks */
	std::map<std::string, MovieClip> movieclips();
	/** Setter: Movie Clip datablocks */
	void movieclips(std::map<std::string, MovieClip> value);

	/** Getter: Masks datablocks */
	std::map<std::string, Mask> masks();
	/** Setter: Masks datablocks */
	void masks(std::map<std::string, Mask> value);

	/** Getter: Line Style datablocks */
	std::map<std::string, FreestyleLineStyle> linestyles() {
		// TODO: MISSING DEREF! USE #DEFINE!
		PyObject *seqval = PyObject_GetAttrString(pyobjref, "linestyles");
		PyObject *seqkeys = PyObject_CallMethod(seqval, "keys", NULL);
		std::map<std::string, FreestyleLineStyle> resmap;
		for (int i = 0; i < PySequence_Length(seqval); i++) {
			PyObject *keyobj = PySequence_GetItem(seqkeys, i);
			std::string key = PyBytes_AsString(PyUnicode_AsASCIIString(keyobj));
			FreestyleLineStyle value = FreestyleLineStyle(PySequence_GetItem(seqval, i));
			resmap.insert(std::pair<std::string,FreestyleLineStyle>(key, value));
		}
		return resmap;
	}

	/** Setter: Line Style datablocks */
	void linestyles(std::map<std::string, FreestyleLineStyle> value) { /* not implemented */ }

};

/**************** Material ****************/

/**
 * Material datablock to define the appearance of geometric objects for rendering
 */
class Material : public ID {
public:
	Material(PyObject* pyobj) : ID(pyobj) {}

	Material() : ID(0)
	{
		// not implemented
	}

	enum type_enum {
		type_SURFACE = 0,
		type_WIRE = 3,
		type_VOLUME = 2,
		type_HALO = 1,
	};

	/** Getter: Material type defining how the object is rendered */
	type_enum type() { /* not implemented */ throw NULL; }
	/** Setter: Material type defining how the object is rendered */
	void type(type_enum value) { /* not implemented */ }

	/** Getter: Render material as transparent */
	bool use_transparency() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_transparency")) == 1;
	}

	/** Setter: Render material as transparent */
	void use_transparency(bool value) {
		PyObject_SetAttrString(pyobjref, "use_transparency", Py_BuildValue("i", value));
	}

	enum transparency_method_enum {
		transparency_method_MASK = 0,
		transparency_method_Z_TRANSPARENCY = 64,
		transparency_method_RAYTRACE = 131072,
	};

	/** Getter: Method to use for rendering transparency */
	transparency_method_enum transparency_method() { /* not implemented */ throw NULL; }
	/** Setter: Method to use for rendering transparency */
	void transparency_method(transparency_method_enum value) { /* not implemented */ }

	enum preview_render_type_enum {
		preview_render_type_FLAT = 0,
		preview_render_type_SPHERE = 1,
		preview_render_type_CUBE = 2,
		preview_render_type_MONKEY = 3,
		preview_render_type_HAIR = 10,
		preview_render_type_SPHERE_A = 4,
	};

	/** Getter: Type of preview render */
	preview_render_type_enum preview_render_type() { /* not implemented */ throw NULL; }
	/** Setter: Type of preview render */
	void preview_render_type(preview_render_type_enum value) { /* not implemented */ }

	/** Getter: Amount of global ambient color the material receives */
	float ambient() { /* not implemented */ throw NULL; }
	/** Setter: Amount of global ambient color the material receives */
	void ambient(float value) {
		PyObject_SetAttrString(pyobjref, "ambient", Py_BuildValue("f", value));
	}

	/** Getter: Amount of light to emit */
	float emit() { /* not implemented */ throw NULL; }
	/** Setter: Amount of light to emit */
	void emit(float value) {
		PyObject_SetAttrString(pyobjref, "emit", Py_BuildValue("f", value));
	}

	/** Getter: Amount of diffuse shading on the back side */
	float translucency() { /* not implemented */ throw NULL; }
	/** Setter: Amount of diffuse shading on the back side */
	void translucency(float value) {
		PyObject_SetAttrString(pyobjref, "translucency", Py_BuildValue("f", value));
	}

	/** Getter: Use cubic interpolation for diffuse values, for smoother transitions */
	bool use_cubic() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_cubic")) == 1;
	}

	/** Setter: Use cubic interpolation for diffuse values, for smoother transitions */
	void use_cubic(bool value) {
		PyObject_SetAttrString(pyobjref, "use_cubic", Py_BuildValue("i", value));
	}

	/** Getter: Modulate the result with a per-object color */
	bool use_object_color() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_object_color")) == 1;
	}

	/** Setter: Modulate the result with a per-object color */
	void use_object_color(bool value) {
		PyObject_SetAttrString(pyobjref, "use_object_color", Py_BuildValue("i", value));
	}

	/** Getter: Shadow raytracing bias to prevent terminator problems on shadow boundary */
	float shadow_ray_bias() { /* not implemented */ throw NULL; }
	/** Setter: Shadow raytracing bias to prevent terminator problems on shadow boundary */
	void shadow_ray_bias(float value) {
		PyObject_SetAttrString(pyobjref, "shadow_ray_bias", Py_BuildValue("f", value));
	}

	/** Getter: Factor to multiply shadow buffer bias with (0 is ignore) */
	float shadow_buffer_bias() { /* not implemented */ throw NULL; }
	/** Setter: Factor to multiply shadow buffer bias with (0 is ignore) */
	void shadow_buffer_bias(float value) {
		PyObject_SetAttrString(pyobjref, "shadow_buffer_bias", Py_BuildValue("f", value));
	}

	/** Getter: Shadow casting alpha, in use for Irregular and Deep shadow buffer */
	float shadow_cast_alpha() { /* not implemented */ throw NULL; }
	/** Setter: Shadow casting alpha, in use for Irregular and Deep shadow buffer */
	void shadow_cast_alpha(float value) {
		PyObject_SetAttrString(pyobjref, "shadow_cast_alpha", Py_BuildValue("f", value));
	}

	/** Getter: Limit lighting to lamps in this Group */
	Group light_group() {
		/* not implemented */ throw NULL;
	}

	/** Getter: Index number for the IndexMA render pass */
	int pass_index() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "pass_index"));
	}

	/** Setter: Index number for the IndexMA render pass */
	void pass_index(int value) {
		PyObject_SetAttrString(pyobjref, "pass_index", Py_BuildValue("i", value));
	}

	/** Getter: Material uses the light group exclusively - these lamps are excluded from other scene lighting */
	bool use_light_group_exclusive() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_light_group_exclusive")) == 1;
	}

	/** Setter: Material uses the light group exclusively - these lamps are excluded from other scene lighting */
	void use_light_group_exclusive(bool value) {
		PyObject_SetAttrString(pyobjref, "use_light_group_exclusive", Py_BuildValue("i", value));
	}

	/** Getter: When linked in, material uses local light group with the same name */
	bool use_light_group_local() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_light_group_local")) == 1;
	}

	/** Setter: When linked in, material uses local light group with the same name */
	void use_light_group_local(bool value) {
		PyObject_SetAttrString(pyobjref, "use_light_group_local", Py_BuildValue("i", value));
	}

	/** Getter: Include this material and geometry that uses it in raytracing calculations */
	bool use_raytrace() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_raytrace")) == 1;
	}

	/** Setter: Include this material and geometry that uses it in raytracing calculations */
	void use_raytrace(bool value) {
		PyObject_SetAttrString(pyobjref, "use_raytrace", Py_BuildValue("i", value));
	}

	/** Getter: Allow this material to receive shadows */
	bool use_shadows() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_shadows")) == 1;
	}

	/** Setter: Allow this material to receive shadows */
	void use_shadows(bool value) {
		PyObject_SetAttrString(pyobjref, "use_shadows", Py_BuildValue("i", value));
	}

	/** Getter: Make this material insensitive to light or shadow */
	bool use_shadeless() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_shadeless")) == 1;
	}

	/** Setter: Make this material insensitive to light or shadow */
	void use_shadeless(bool value) {
		PyObject_SetAttrString(pyobjref, "use_shadeless", Py_BuildValue("i", value));
	}

	/** Getter: Add vertex colors as additional lighting */
	bool use_vertex_color_light() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_vertex_color_light")) == 1;
	}

	/** Setter: Add vertex colors as additional lighting */
	void use_vertex_color_light(bool value) {
		PyObject_SetAttrString(pyobjref, "use_vertex_color_light", Py_BuildValue("i", value));
	}

	/** Getter: Replace object base color with vertex colors (multiply with 'texture face' face assigned textures) */
	bool use_vertex_color_paint() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_vertex_color_paint")) == 1;
	}

	/** Setter: Replace object base color with vertex colors (multiply with 'texture face' face assigned textures) */
	void use_vertex_color_paint(bool value) {
		PyObject_SetAttrString(pyobjref, "use_vertex_color_paint", Py_BuildValue("i", value));
	}

	/** Getter: Render material's faces with an inverted Z buffer (scanline only) */
	bool invert_z() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "invert_z")) == 1;
	}

	/** Setter: Render material's faces with an inverted Z buffer (scanline only) */
	void invert_z(bool value) {
		PyObject_SetAttrString(pyobjref, "invert_z", Py_BuildValue("i", value));
	}

	/** Getter: Give faces an artificial offset in the Z buffer for Z transparency */
	float offset_z() { /* not implemented */ throw NULL; }
	/** Setter: Give faces an artificial offset in the Z buffer for Z transparency */
	void offset_z(float value) {
		PyObject_SetAttrString(pyobjref, "offset_z", Py_BuildValue("f", value));
	}

	/** Getter: Render this material with zero alpha, with sky background in place (scanline only) */
	bool use_sky() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_sky")) == 1;
	}

	/** Setter: Render this material with zero alpha, with sky background in place (scanline only) */
	void use_sky(bool value) {
		PyObject_SetAttrString(pyobjref, "use_sky", Py_BuildValue("i", value));
	}

	/** Getter: Render shadows as the material's alpha value, making the material transparent except for shadowed areas */
	bool use_only_shadow() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_only_shadow")) == 1;
	}

	/** Setter: Render shadows as the material's alpha value, making the material transparent except for shadowed areas */
	void use_only_shadow(bool value) {
		PyObject_SetAttrString(pyobjref, "use_only_shadow", Py_BuildValue("i", value));
	}

	enum shadow_only_type_enum {
		shadow_only_type_SHADOW_ONLY_OLD = 0,
		shadow_only_type_SHADOW_ONLY = 1,
		shadow_only_type_SHADOW_ONLY_SHADED = 2,
	};

	/** Getter: How to draw shadows */
	shadow_only_type_enum shadow_only_type() { /* not implemented */ throw NULL; }
	/** Setter: How to draw shadows */
	void shadow_only_type(shadow_only_type_enum value) { /* not implemented */ }

	/** Getter: Replace the object's base color with color from UV map image textures */
	bool use_face_texture() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_face_texture")) == 1;
	}

	/** Setter: Replace the object's base color with color from UV map image textures */
	void use_face_texture(bool value) {
		PyObject_SetAttrString(pyobjref, "use_face_texture", Py_BuildValue("i", value));
	}

	/** Getter: Replace the object's base alpha value with alpha from UV map image textures */
	bool use_face_texture_alpha() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_face_texture_alpha")) == 1;
	}

	/** Setter: Replace the object's base alpha value with alpha from UV map image textures */
	void use_face_texture_alpha(bool value) {
		PyObject_SetAttrString(pyobjref, "use_face_texture_alpha", Py_BuildValue("i", value));
	}

	/** Getter: Allow this material to cast shadows */
	bool use_cast_shadows() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_cast_shadows")) == 1;
	}

	/** Setter: Allow this material to cast shadows */
	void use_cast_shadows(bool value) {
		PyObject_SetAttrString(pyobjref, "use_cast_shadows", Py_BuildValue("i", value));
	}

	/** Getter: Make objects with this material appear invisible (not rendered), only casting shadows */
	bool use_cast_shadows_only() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_cast_shadows_only")) == 1;
	}

	/** Setter: Make objects with this material appear invisible (not rendered), only casting shadows */
	void use_cast_shadows_only(bool value) {
		PyObject_SetAttrString(pyobjref, "use_cast_shadows_only", Py_BuildValue("i", value));
	}

	/** Getter: Use mist with this material (in world settings) */
	bool use_mist() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_mist")) == 1;
	}

	/** Setter: Use mist with this material (in world settings) */
	void use_mist(bool value) {
		PyObject_SetAttrString(pyobjref, "use_mist", Py_BuildValue("i", value));
	}

	/** Getter: Allow this object to receive transparent shadows cast through other objects */
	bool use_transparent_shadows() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_transparent_shadows")) == 1;
	}

	/** Setter: Allow this object to receive transparent shadows cast through other objects */
	void use_transparent_shadows(bool value) {
		PyObject_SetAttrString(pyobjref, "use_transparent_shadows", Py_BuildValue("i", value));
	}

	/** Getter: Prevent raytraced shadow errors on surfaces with smooth shaded normals (terminator problem) */
	bool use_ray_shadow_bias() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_ray_shadow_bias")) == 1;
	}

	/** Setter: Prevent raytraced shadow errors on surfaces with smooth shaded normals (terminator problem) */
	void use_ray_shadow_bias(bool value) {
		PyObject_SetAttrString(pyobjref, "use_ray_shadow_bias", Py_BuildValue("i", value));
	}

	/** Getter: Force this material to render full shading/textures for all anti-aliasing samples */
	bool use_full_oversampling() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_full_oversampling")) == 1;
	}

	/** Setter: Force this material to render full shading/textures for all anti-aliasing samples */
	void use_full_oversampling(bool value) {
		PyObject_SetAttrString(pyobjref, "use_full_oversampling", Py_BuildValue("i", value));
	}

	/** Getter: Allow this material to cast shadows from shadow buffer lamps */
	bool use_cast_buffer_shadows() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_cast_buffer_shadows")) == 1;
	}

	/** Setter: Allow this material to cast shadows from shadow buffer lamps */
	void use_cast_buffer_shadows(bool value) {
		PyObject_SetAttrString(pyobjref, "use_cast_buffer_shadows", Py_BuildValue("i", value));
	}

	/** Getter: Allow this material to cast shadows when using approximate ambient occlusion */
	bool use_cast_approximate() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_cast_approximate")) == 1;
	}

	/** Setter: Allow this material to cast shadows when using approximate ambient occlusion */
	void use_cast_approximate(bool value) {
		PyObject_SetAttrString(pyobjref, "use_cast_approximate", Py_BuildValue("i", value));
	}

	/** Getter: Use the material's tangent vector instead of the normal for shading - for anisotropic shading effects */
	bool use_tangent_shading() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_tangent_shading")) == 1;
	}

	/** Setter: Use the material's tangent vector instead of the normal for shading - for anisotropic shading effects */
	void use_tangent_shading(bool value) {
		PyObject_SetAttrString(pyobjref, "use_tangent_shading", Py_BuildValue("i", value));
	}

	/** Getter: Use to ensure UV interpolation is correct for camera projections (use with UV project modifier) */
	bool use_uv_project() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_uv_project")) == 1;
	}

	/** Setter: Use to ensure UV interpolation is correct for camera projections (use with UV project modifier) */
	void use_uv_project(bool value) {
		PyObject_SetAttrString(pyobjref, "use_uv_project", Py_BuildValue("i", value));
	}

	/** Getter: Raytraced reflection settings for the material */
	MaterialRaytraceMirror raytrace_mirror();

	/** Getter: Raytraced transparency settings for the material */
	MaterialRaytraceTransparency raytrace_transparency();

	/** Getter: Volume settings for the material */
	MaterialVolume volume();

	/** Getter: Halo settings for the material */
	MaterialHalo halo();

	/** Getter: Subsurface scattering settings for the material */
	MaterialSubsurfaceScattering subsurface_scattering();

	/** Getter: Strand settings for the material */
	MaterialStrand strand();

	/** Getter: Game physics settings */
	MaterialPhysics physics();

	/** Getter: Game material settings */
	MaterialGameSettings game_settings();

	/** Getter: Node tree for node based materials */
	NodeTree node_tree();

	/** Getter: Use shader nodes to render the material */
	bool use_nodes() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_nodes")) == 1;
	}

	/** Setter: Use shader nodes to render the material */
	void use_nodes(bool value) {
		PyObject_SetAttrString(pyobjref, "use_nodes", Py_BuildValue("i", value));
	}

	/** Getter: Active node material */
	Material active_node_material() {
		/* not implemented */ throw NULL;
	}

	/** Getter: Animation data for this datablock */
	AnimData animation_data() {
		/* not implemented */ throw NULL;
	}

	/** Getter: Texture slots defining the mapping and influence of textures */
	std::map<std::string, MaterialTextureSlot> texture_slots();
	/** Setter: Texture slots defining the mapping and influence of textures */
	void texture_slots(std::map<std::string, MaterialTextureSlot> value);

	/** Getter: Active texture slot being displayed */
	Texture active_texture() {
		/* not implemented */ throw NULL;
	}

	/** Getter: Index of active texture slot */
	int active_texture_index() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "active_texture_index"));
	}

	/** Setter: Index of active texture slot */
	void active_texture_index(int value) {
		PyObject_SetAttrString(pyobjref, "active_texture_index", Py_BuildValue("i", value));
	}

	/** Getter: Texture images used for texture painting */
	std::map<std::string, Image> texture_paint_images() {
		// TODO: MISSING DEREF! USE #DEFINE!
		PyObject *seqval = PyObject_GetAttrString(pyobjref, "texture_paint_images");
		PyObject *seqkeys = PyObject_CallMethod(seqval, "keys", NULL);
		std::map<std::string, Image> resmap;
		for (int i = 0; i < PySequence_Length(seqval); i++) {
			PyObject *keyobj = PySequence_GetItem(seqkeys, i);
			std::string key = PyBytes_AsString(PyUnicode_AsASCIIString(keyobj));
			Image value = Image(PySequence_GetItem(seqval, i));
			resmap.insert(std::pair<std::string,Image>(key, value));
		}
		return resmap;
	}

	/** Setter: Texture images used for texture painting */
	void texture_paint_images(std::map<std::string, Image> value) { /* not implemented */ }

	/** Getter: Texture slots defining the mapping and influence of textures */
	std::map<std::string, TexPaintSlot> texture_paint_slots();
	/** Setter: Texture slots defining the mapping and influence of textures */
	void texture_paint_slots(std::map<std::string, TexPaintSlot> value);

	/** Getter: Index of active texture paint slot */
	int paint_active_slot() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "paint_active_slot"));
	}

	/** Setter: Index of active texture paint slot */
	void paint_active_slot(int value) {
		PyObject_SetAttrString(pyobjref, "paint_active_slot", Py_BuildValue("i", value));
	}

	/** Getter: Index of clone texture paint slot */
	int paint_clone_slot() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "paint_clone_slot"));
	}

	/** Setter: Index of clone texture paint slot */
	void paint_clone_slot(int value) {
		PyObject_SetAttrString(pyobjref, "paint_clone_slot", Py_BuildValue("i", value));
	}

	/** Getter: Enable/Disable each texture */
	std::array<bool, 18> use_textures() {
		// TODO: MISSING DEREF! USE #DEFINE!
		PyObject *seqval = PyObject_GetAttrString(pyobjref, "use_textures");
		std::array<bool, 18> resarr;
		for (int i = 0; i < 18; i++)
			resarr[i] = PyLong_AsLong(PySequence_GetItem(seqval, i)) == 1;
		return resarr;
	}

	/** Setter: Enable/Disable each texture */
	void use_textures(bool values[18]) { /* not implemented */ }

	/** Getter: Diffuse color of the material */
	std::array<float, 3> diffuse_color() {
		// TODO: MISSING DEREF! USE #DEFINE!
		PyObject *seqval = PyObject_GetAttrString(pyobjref, "diffuse_color");
		std::array<float, 3> resarr;
		for (int i = 0; i < 3; i++)
			resarr[i] = (float)PyFloat_AsDouble(PySequence_GetItem(seqval, i));
		return resarr;
	}

	/** Setter: Diffuse color of the material */
	void diffuse_color(float values[3]) { /* not implemented */ }

	/** Getter: Specular color of the material */
	std::array<float, 3> specular_color() {
		// TODO: MISSING DEREF! USE #DEFINE!
		PyObject *seqval = PyObject_GetAttrString(pyobjref, "specular_color");
		std::array<float, 3> resarr;
		for (int i = 0; i < 3; i++)
			resarr[i] = (float)PyFloat_AsDouble(PySequence_GetItem(seqval, i));
		return resarr;
	}

	/** Setter: Specular color of the material */
	void specular_color(float values[3]) { /* not implemented */ }

	/** Getter: Mirror color of the material */
	std::array<float, 3> mirror_color() {
		// TODO: MISSING DEREF! USE #DEFINE!
		PyObject *seqval = PyObject_GetAttrString(pyobjref, "mirror_color");
		std::array<float, 3> resarr;
		for (int i = 0; i < 3; i++)
			resarr[i] = (float)PyFloat_AsDouble(PySequence_GetItem(seqval, i));
		return resarr;
	}

	/** Setter: Mirror color of the material */
	void mirror_color(float values[3]) { /* not implemented */ }

	/** Getter: Alpha transparency of the material */
	float alpha() { /* not implemented */ throw NULL; }
	/** Setter: Alpha transparency of the material */
	void alpha(float value) {
		PyObject_SetAttrString(pyobjref, "alpha", Py_BuildValue("f", value));
	}

	/** Getter: Alpha transparency for specular areas */
	float specular_alpha() { /* not implemented */ throw NULL; }
	/** Setter: Alpha transparency for specular areas */
	void specular_alpha(float value) {
		PyObject_SetAttrString(pyobjref, "specular_alpha", Py_BuildValue("f", value));
	}

	/** Getter: Toggle diffuse ramp operations */
	bool use_diffuse_ramp() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_diffuse_ramp")) == 1;
	}

	/** Setter: Toggle diffuse ramp operations */
	void use_diffuse_ramp(bool value) {
		PyObject_SetAttrString(pyobjref, "use_diffuse_ramp", Py_BuildValue("i", value));
	}

	/** Getter: Color ramp used to affect diffuse shading */
	ColorRamp diffuse_ramp() {
		/* not implemented */ throw NULL;
	}

	/** Getter: Toggle specular ramp operations */
	bool use_specular_ramp() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_specular_ramp")) == 1;
	}

	/** Setter: Toggle specular ramp operations */
	void use_specular_ramp(bool value) {
		PyObject_SetAttrString(pyobjref, "use_specular_ramp", Py_BuildValue("i", value));
	}

	/** Getter: Color ramp used to affect specular shading */
	ColorRamp specular_ramp() {
		/* not implemented */ throw NULL;
	}

	enum diffuse_ramp_blend_enum {
		diffuse_ramp_blend_MIX = 0,
		diffuse_ramp_blend_ADD = 1,
		diffuse_ramp_blend_MULTIPLY = 2,
		diffuse_ramp_blend_SUBTRACT = 3,
		diffuse_ramp_blend_SCREEN = 4,
		diffuse_ramp_blend_DIVIDE = 5,
		diffuse_ramp_blend_DIFFERENCE = 6,
		diffuse_ramp_blend_DARKEN = 7,
		diffuse_ramp_blend_LIGHTEN = 8,
		diffuse_ramp_blend_OVERLAY = 9,
		diffuse_ramp_blend_DODGE = 10,
		diffuse_ramp_blend_BURN = 11,
		diffuse_ramp_blend_HUE = 12,
		diffuse_ramp_blend_SATURATION = 13,
		diffuse_ramp_blend_VALUE = 14,
		diffuse_ramp_blend_COLOR = 15,
		diffuse_ramp_blend_SOFT_LIGHT = 16,
		diffuse_ramp_blend_LINEAR_LIGHT = 17,
	};

	/** Getter: Blending method of the ramp and the diffuse color */
	diffuse_ramp_blend_enum diffuse_ramp_blend() { /* not implemented */ throw NULL; }
	/** Setter: Blending method of the ramp and the diffuse color */
	void diffuse_ramp_blend(diffuse_ramp_blend_enum value) { /* not implemented */ }

	enum specular_ramp_blend_enum {
		specular_ramp_blend_MIX = 0,
		specular_ramp_blend_ADD = 1,
		specular_ramp_blend_MULTIPLY = 2,
		specular_ramp_blend_SUBTRACT = 3,
		specular_ramp_blend_SCREEN = 4,
		specular_ramp_blend_DIVIDE = 5,
		specular_ramp_blend_DIFFERENCE = 6,
		specular_ramp_blend_DARKEN = 7,
		specular_ramp_blend_LIGHTEN = 8,
		specular_ramp_blend_OVERLAY = 9,
		specular_ramp_blend_DODGE = 10,
		specular_ramp_blend_BURN = 11,
		specular_ramp_blend_HUE = 12,
		specular_ramp_blend_SATURATION = 13,
		specular_ramp_blend_VALUE = 14,
		specular_ramp_blend_COLOR = 15,
		specular_ramp_blend_SOFT_LIGHT = 16,
		specular_ramp_blend_LINEAR_LIGHT = 17,
	};

	/** Getter: Blending method of the ramp and the specular color */
	specular_ramp_blend_enum specular_ramp_blend() { /* not implemented */ throw NULL; }
	/** Setter: Blending method of the ramp and the specular color */
	void specular_ramp_blend(specular_ramp_blend_enum value) { /* not implemented */ }

	enum diffuse_ramp_input_enum {
		diffuse_ramp_input_SHADER = 0,
		diffuse_ramp_input_ENERGY = 1,
		diffuse_ramp_input_NORMAL = 2,
		diffuse_ramp_input_RESULT = 3,
	};

	/** Getter: How the ramp maps on the surface */
	diffuse_ramp_input_enum diffuse_ramp_input() { /* not implemented */ throw NULL; }
	/** Setter: How the ramp maps on the surface */
	void diffuse_ramp_input(diffuse_ramp_input_enum value) { /* not implemented */ }

	enum specular_ramp_input_enum {
		specular_ramp_input_SHADER = 0,
		specular_ramp_input_ENERGY = 1,
		specular_ramp_input_NORMAL = 2,
		specular_ramp_input_RESULT = 3,
	};

	/** Getter: How the ramp maps on the surface */
	specular_ramp_input_enum specular_ramp_input() { /* not implemented */ throw NULL; }
	/** Setter: How the ramp maps on the surface */
	void specular_ramp_input(specular_ramp_input_enum value) { /* not implemented */ }

	/** Getter: Blending factor (also uses alpha in Colorband) */
	float diffuse_ramp_factor() { /* not implemented */ throw NULL; }
	/** Setter: Blending factor (also uses alpha in Colorband) */
	void diffuse_ramp_factor(float value) {
		PyObject_SetAttrString(pyobjref, "diffuse_ramp_factor", Py_BuildValue("f", value));
	}

	/** Getter: Blending factor (also uses alpha in Colorband) */
	float specular_ramp_factor() { /* not implemented */ throw NULL; }
	/** Setter: Blending factor (also uses alpha in Colorband) */
	void specular_ramp_factor(float value) {
		PyObject_SetAttrString(pyobjref, "specular_ramp_factor", Py_BuildValue("f", value));
	}

	/** Getter: Line color used for Freestyle line rendering */
	std::array<float, 4> line_color() {
		// TODO: MISSING DEREF! USE #DEFINE!
		PyObject *seqval = PyObject_GetAttrString(pyobjref, "line_color");
		std::array<float, 4> resarr;
		for (int i = 0; i < 4; i++)
			resarr[i] = (float)PyFloat_AsDouble(PySequence_GetItem(seqval, i));
		return resarr;
	}

	/** Setter: Line color used for Freestyle line rendering */
	void line_color(float values[4]) { /* not implemented */ }

	/** Getter: The line color of a higher priority is used at material boundaries */
	int line_priority() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "line_priority"));
	}

	/** Setter: The line color of a higher priority is used at material boundaries */
	void line_priority(int value) {
		PyObject_SetAttrString(pyobjref, "line_priority", Py_BuildValue("i", value));
	}

	enum diffuse_shader_enum {
		diffuse_shader_LAMBERT = 0,
		diffuse_shader_OREN_NAYAR = 1,
		diffuse_shader_TOON = 2,
		diffuse_shader_MINNAERT = 3,
		diffuse_shader_FRESNEL = 4,
	};

	/** Getter:  */
	diffuse_shader_enum diffuse_shader() { /* not implemented */ throw NULL; }
	/** Setter:  */
	void diffuse_shader(diffuse_shader_enum value) { /* not implemented */ }

	/** Getter: Amount of diffuse reflection */
	float diffuse_intensity() { /* not implemented */ throw NULL; }
	/** Setter: Amount of diffuse reflection */
	void diffuse_intensity(float value) {
		PyObject_SetAttrString(pyobjref, "diffuse_intensity", Py_BuildValue("f", value));
	}

	/** Getter: Oren-Nayar Roughness */
	float roughness() { /* not implemented */ throw NULL; }
	/** Setter: Oren-Nayar Roughness */
	void roughness(float value) {
		PyObject_SetAttrString(pyobjref, "roughness", Py_BuildValue("f", value));
	}

	/** Getter: Size of diffuse toon area */
	float diffuse_toon_size() { /* not implemented */ throw NULL; }
	/** Setter: Size of diffuse toon area */
	void diffuse_toon_size(float value) {
		PyObject_SetAttrString(pyobjref, "diffuse_toon_size", Py_BuildValue("f", value));
	}

	/** Getter: Smoothness of diffuse toon area */
	float diffuse_toon_smooth() { /* not implemented */ throw NULL; }
	/** Setter: Smoothness of diffuse toon area */
	void diffuse_toon_smooth(float value) {
		PyObject_SetAttrString(pyobjref, "diffuse_toon_smooth", Py_BuildValue("f", value));
	}

	/** Getter: Power of Fresnel */
	float diffuse_fresnel() { /* not implemented */ throw NULL; }
	/** Setter: Power of Fresnel */
	void diffuse_fresnel(float value) {
		PyObject_SetAttrString(pyobjref, "diffuse_fresnel", Py_BuildValue("f", value));
	}

	/** Getter: Blending factor of Fresnel */
	float diffuse_fresnel_factor() { /* not implemented */ throw NULL; }
	/** Setter: Blending factor of Fresnel */
	void diffuse_fresnel_factor(float value) {
		PyObject_SetAttrString(pyobjref, "diffuse_fresnel_factor", Py_BuildValue("f", value));
	}

	/** Getter: Minnaert darkness */
	float darkness() { /* not implemented */ throw NULL; }
	/** Setter: Minnaert darkness */
	void darkness(float value) {
		PyObject_SetAttrString(pyobjref, "darkness", Py_BuildValue("f", value));
	}

	enum specular_shader_enum {
		specular_shader_COOKTORR = 0,
		specular_shader_PHONG = 1,
		specular_shader_BLINN = 2,
		specular_shader_TOON = 3,
		specular_shader_WARDISO = 4,
	};

	/** Getter:  */
	specular_shader_enum specular_shader() { /* not implemented */ throw NULL; }
	/** Setter:  */
	void specular_shader(specular_shader_enum value) { /* not implemented */ }

	/** Getter: How intense (bright) the specular reflection is */
	float specular_intensity() { /* not implemented */ throw NULL; }
	/** Setter: How intense (bright) the specular reflection is */
	void specular_intensity(float value) {
		PyObject_SetAttrString(pyobjref, "specular_intensity", Py_BuildValue("f", value));
	}

	/** Getter: How hard (sharp) the specular reflection is */
	int specular_hardness() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "specular_hardness"));
	}

	/** Setter: How hard (sharp) the specular reflection is */
	void specular_hardness(int value) {
		PyObject_SetAttrString(pyobjref, "specular_hardness", Py_BuildValue("i", value));
	}

	/** Getter: Specular index of refraction */
	float specular_ior() { /* not implemented */ throw NULL; }
	/** Setter: Specular index of refraction */
	void specular_ior(float value) {
		PyObject_SetAttrString(pyobjref, "specular_ior", Py_BuildValue("f", value));
	}

	/** Getter: Size of specular toon area */
	float specular_toon_size() { /* not implemented */ throw NULL; }
	/** Setter: Size of specular toon area */
	void specular_toon_size(float value) {
		PyObject_SetAttrString(pyobjref, "specular_toon_size", Py_BuildValue("f", value));
	}

	/** Getter: Smoothness of specular toon area */
	float specular_toon_smooth() { /* not implemented */ throw NULL; }
	/** Setter: Smoothness of specular toon area */
	void specular_toon_smooth(float value) {
		PyObject_SetAttrString(pyobjref, "specular_toon_smooth", Py_BuildValue("f", value));
	}

	/** Getter: The standard deviation of surface slope */
	float specular_slope() { /* not implemented */ throw NULL; }
	/** Setter: The standard deviation of surface slope */
	void specular_slope(float value) {
		PyObject_SetAttrString(pyobjref, "specular_slope", Py_BuildValue("f", value));
	}

};

/**************** Texture Paint Slot ****************/

/**
 * Slot that contains information about texture painting
 */
class TexPaintSlot : public pyUniplug {
public:
	TexPaintSlot(PyObject* pyobj) : pyUniplug(pyobj) {}

	TexPaintSlot() : pyUniplug(0)
	{
		// not implemented
	}

	/** Getter: Name of UV map */
	std::string uv_layer() { /* not implemented */ throw NULL; }
	/** Setter: Name of UV map */
	void uv_layer(const std::string& value) { /* not implemented */ }

	/** Getter: Index of MTex slot in the material */
	int index() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "index"));
	}

	/** Setter: Index of MTex slot in the material */
	void index(int value) {
		PyObject_SetAttrString(pyobjref, "index", Py_BuildValue("i", value));
	}

};

/**************** Material Raytrace Mirror ****************/

/**
 * Raytraced reflection settings for a Material datablock
 */
class MaterialRaytraceMirror : public pyUniplug {
public:
	MaterialRaytraceMirror(PyObject* pyobj) : pyUniplug(pyobj) {}

	MaterialRaytraceMirror() : pyUniplug(0)
	{
		// not implemented
	}

	/** Getter: Enable raytraced reflections */
	bool use() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use")) == 1;
	}

	/** Setter: Enable raytraced reflections */
	void use(bool value) {
		PyObject_SetAttrString(pyobjref, "use", Py_BuildValue("i", value));
	}

	/** Getter: Amount of mirror reflection for raytrace */
	float reflect_factor() { /* not implemented */ throw NULL; }
	/** Setter: Amount of mirror reflection for raytrace */
	void reflect_factor(float value) {
		PyObject_SetAttrString(pyobjref, "reflect_factor", Py_BuildValue("f", value));
	}

	/** Getter: Power of Fresnel for mirror reflection */
	float fresnel() { /* not implemented */ throw NULL; }
	/** Setter: Power of Fresnel for mirror reflection */
	void fresnel(float value) {
		PyObject_SetAttrString(pyobjref, "fresnel", Py_BuildValue("f", value));
	}

	/** Getter: Blending factor for Fresnel */
	float fresnel_factor() { /* not implemented */ throw NULL; }
	/** Setter: Blending factor for Fresnel */
	void fresnel_factor(float value) {
		PyObject_SetAttrString(pyobjref, "fresnel_factor", Py_BuildValue("f", value));
	}

	/** Getter: The shininess of the reflection (values < 1.0 give diffuse, blurry reflections) */
	float gloss_factor() { /* not implemented */ throw NULL; }
	/** Setter: The shininess of the reflection (values < 1.0 give diffuse, blurry reflections) */
	void gloss_factor(float value) {
		PyObject_SetAttrString(pyobjref, "gloss_factor", Py_BuildValue("f", value));
	}

	/** Getter: The shape of the reflection, from 0.0 (circular) to 1.0 (fully stretched along the tangent */
	float gloss_anisotropic() { /* not implemented */ throw NULL; }
	/** Setter: The shape of the reflection, from 0.0 (circular) to 1.0 (fully stretched along the tangent */
	void gloss_anisotropic(float value) {
		PyObject_SetAttrString(pyobjref, "gloss_anisotropic", Py_BuildValue("f", value));
	}

	/** Getter: Number of cone samples averaged for blurry reflections */
	int gloss_samples() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "gloss_samples"));
	}

	/** Setter: Number of cone samples averaged for blurry reflections */
	void gloss_samples(int value) {
		PyObject_SetAttrString(pyobjref, "gloss_samples", Py_BuildValue("i", value));
	}

	/** Getter: Threshold for adaptive sampling (if a sample contributes less than this amount [as a percentage], sampling is stopped) */
	float gloss_threshold() { /* not implemented */ throw NULL; }
	/** Setter: Threshold for adaptive sampling (if a sample contributes less than this amount [as a percentage], sampling is stopped) */
	void gloss_threshold(float value) {
		PyObject_SetAttrString(pyobjref, "gloss_threshold", Py_BuildValue("f", value));
	}

	/** Getter: Maximum allowed number of light inter-reflections */
	int depth() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "depth"));
	}

	/** Setter: Maximum allowed number of light inter-reflections */
	void depth(int value) {
		PyObject_SetAttrString(pyobjref, "depth", Py_BuildValue("i", value));
	}

	/** Getter: Maximum distance of reflected rays (reflections further than this range fade to sky color or material color) */
	float distance() { /* not implemented */ throw NULL; }
	/** Setter: Maximum distance of reflected rays (reflections further than this range fade to sky color or material color) */
	void distance(float value) {
		PyObject_SetAttrString(pyobjref, "distance", Py_BuildValue("f", value));
	}

	enum fade_to_enum {
		fade_to_FADE_TO_SKY = 0,
		fade_to_FADE_TO_MATERIAL = 1,
	};

	/** Getter: The color that rays with no intersection within the Max Distance take (material color can be best for indoor scenes, sky color for outdoor) */
	fade_to_enum fade_to() { /* not implemented */ throw NULL; }
	/** Setter: The color that rays with no intersection within the Max Distance take (material color can be best for indoor scenes, sky color for outdoor) */
	void fade_to(fade_to_enum value) { /* not implemented */ }

};

/**************** Material Raytrace Transparency ****************/

/**
 * Raytraced refraction settings for a Material datablock
 */
class MaterialRaytraceTransparency : public pyUniplug {
public:
	MaterialRaytraceTransparency(PyObject* pyobj) : pyUniplug(pyobj) {}

	MaterialRaytraceTransparency() : pyUniplug(0)
	{
		// not implemented
	}

	/** Getter: Angular index of refraction for raytraced refraction */
	float ior() { /* not implemented */ throw NULL; }
	/** Setter: Angular index of refraction for raytraced refraction */
	void ior(float value) {
		PyObject_SetAttrString(pyobjref, "ior", Py_BuildValue("f", value));
	}

	/** Getter: Power of Fresnel for transparency (Ray or ZTransp) */
	float fresnel() { /* not implemented */ throw NULL; }
	/** Setter: Power of Fresnel for transparency (Ray or ZTransp) */
	void fresnel(float value) {
		PyObject_SetAttrString(pyobjref, "fresnel", Py_BuildValue("f", value));
	}

	/** Getter: Blending factor for Fresnel */
	float fresnel_factor() { /* not implemented */ throw NULL; }
	/** Setter: Blending factor for Fresnel */
	void fresnel_factor(float value) {
		PyObject_SetAttrString(pyobjref, "fresnel_factor", Py_BuildValue("f", value));
	}

	/** Getter: The clarity of the refraction. Values < 1.0 give diffuse, blurry refractions */
	float gloss_factor() { /* not implemented */ throw NULL; }
	/** Setter: The clarity of the refraction. Values < 1.0 give diffuse, blurry refractions */
	void gloss_factor(float value) {
		PyObject_SetAttrString(pyobjref, "gloss_factor", Py_BuildValue("f", value));
	}

	/** Getter: Number of cone samples averaged for blurry refractions */
	int gloss_samples() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "gloss_samples"));
	}

	/** Setter: Number of cone samples averaged for blurry refractions */
	void gloss_samples(int value) {
		PyObject_SetAttrString(pyobjref, "gloss_samples", Py_BuildValue("i", value));
	}

	/** Getter: Threshold for adaptive sampling. If a sample contributes less than this amount (as a percentage), sampling is stopped */
	float gloss_threshold() { /* not implemented */ throw NULL; }
	/** Setter: Threshold for adaptive sampling. If a sample contributes less than this amount (as a percentage), sampling is stopped */
	void gloss_threshold(float value) {
		PyObject_SetAttrString(pyobjref, "gloss_threshold", Py_BuildValue("f", value));
	}

	/** Getter: Maximum allowed number of light inter-refractions */
	int depth() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "depth"));
	}

	/** Setter: Maximum allowed number of light inter-refractions */
	void depth(int value) {
		PyObject_SetAttrString(pyobjref, "depth", Py_BuildValue("i", value));
	}

	/** Getter: Amount to blend in the material's diffuse color in raytraced transparency (simulating absorption) */
	float filter() { /* not implemented */ throw NULL; }
	/** Setter: Amount to blend in the material's diffuse color in raytraced transparency (simulating absorption) */
	void filter(float value) {
		PyObject_SetAttrString(pyobjref, "filter", Py_BuildValue("f", value));
	}

	/** Getter: Maximum depth for light to travel through the transparent material before becoming fully filtered (0.0 is disabled) */
	float depth_max() { /* not implemented */ throw NULL; }
	/** Setter: Maximum depth for light to travel through the transparent material before becoming fully filtered (0.0 is disabled) */
	void depth_max(float value) {
		PyObject_SetAttrString(pyobjref, "depth_max", Py_BuildValue("f", value));
	}

	/** Getter: Falloff power for transmissivity filter effect (1.0 is linear) */
	float falloff() { /* not implemented */ throw NULL; }
	/** Setter: Falloff power for transmissivity filter effect (1.0 is linear) */
	void falloff(float value) {
		PyObject_SetAttrString(pyobjref, "falloff", Py_BuildValue("f", value));
	}

};

/**************** Material Volume ****************/

/**
 * Volume rendering settings for a Material datablock
 */
class MaterialVolume : public pyUniplug {
public:
	MaterialVolume(PyObject* pyobj) : pyUniplug(pyobj) {}

	MaterialVolume() : pyUniplug(0)
	{
		// not implemented
	}

	enum step_method_enum {
		step_method_RANDOMIZED = 0,
		step_method_CONSTANT = 1,
	};

	/** Getter: Method of calculating the steps through the volume */
	step_method_enum step_method() { /* not implemented */ throw NULL; }
	/** Setter: Method of calculating the steps through the volume */
	void step_method(step_method_enum value) { /* not implemented */ }

	/** Getter: Distance between subsequent volume depth samples */
	float step_size() { /* not implemented */ throw NULL; }
	/** Setter: Distance between subsequent volume depth samples */
	void step_size(float value) {
		PyObject_SetAttrString(pyobjref, "step_size", Py_BuildValue("f", value));
	}

	enum light_method_enum {
		light_method_SHADELESS = 0,
		light_method_SHADOWED = 2,
		light_method_SHADED = 1,
		light_method_MULTIPLE_SCATTERING = 3,
		light_method_SHADED_PLUS_MULTIPLE_SCATTERING = 4,
	};

	/** Getter: Method of shading, attenuating, and scattering light through the volume */
	light_method_enum light_method() { /* not implemented */ throw NULL; }
	/** Setter: Method of shading, attenuating, and scattering light through the volume */
	void light_method(light_method_enum value) { /* not implemented */ }

	/** Getter: Receive shadows from sources outside the volume (temporary) */
	bool use_external_shadows() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_external_shadows")) == 1;
	}

	/** Setter: Receive shadows from sources outside the volume (temporary) */
	void use_external_shadows(bool value) {
		PyObject_SetAttrString(pyobjref, "use_external_shadows", Py_BuildValue("i", value));
	}

	/** Getter: Pre-calculate the shading information into a voxel grid, speeds up shading at slightly less accuracy */
	bool use_light_cache() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_light_cache")) == 1;
	}

	/** Setter: Pre-calculate the shading information into a voxel grid, speeds up shading at slightly less accuracy */
	void use_light_cache(bool value) {
		PyObject_SetAttrString(pyobjref, "use_light_cache", Py_BuildValue("i", value));
	}

	/** Getter: Resolution of the voxel grid, low resolutions are faster, high resolutions use more memory */
	int cache_resolution() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "cache_resolution"));
	}

	/** Setter: Resolution of the voxel grid, low resolutions are faster, high resolutions use more memory */
	void cache_resolution(int value) {
		PyObject_SetAttrString(pyobjref, "cache_resolution", Py_BuildValue("i", value));
	}

	/** Getter: Diffusion factor, the strength of the blurring effect */
	float ms_diffusion() { /* not implemented */ throw NULL; }
	/** Setter: Diffusion factor, the strength of the blurring effect */
	void ms_diffusion(float value) {
		PyObject_SetAttrString(pyobjref, "ms_diffusion", Py_BuildValue("f", value));
	}

	/** Getter: Proportional distance over which the light is diffused */
	float ms_spread() { /* not implemented */ throw NULL; }
	/** Setter: Proportional distance over which the light is diffused */
	void ms_spread(float value) {
		PyObject_SetAttrString(pyobjref, "ms_spread", Py_BuildValue("f", value));
	}

	/** Getter: Multiplier for multiple scattered light energy */
	float ms_intensity() { /* not implemented */ throw NULL; }
	/** Setter: Multiplier for multiple scattered light energy */
	void ms_intensity(float value) {
		PyObject_SetAttrString(pyobjref, "ms_intensity", Py_BuildValue("f", value));
	}

	/** Getter: Stop ray marching early if transmission drops below this luminance - higher values give speedups in dense volumes at the expense of accuracy */
	float depth_threshold() { /* not implemented */ throw NULL; }
	/** Setter: Stop ray marching early if transmission drops below this luminance - higher values give speedups in dense volumes at the expense of accuracy */
	void depth_threshold(float value) {
		PyObject_SetAttrString(pyobjref, "depth_threshold", Py_BuildValue("f", value));
	}

	/** Getter: The base density of the volume */
	float density() { /* not implemented */ throw NULL; }
	/** Setter: The base density of the volume */
	void density(float value) {
		PyObject_SetAttrString(pyobjref, "density", Py_BuildValue("f", value));
	}

	/** Getter: Multiplier for the material's density */
	float density_scale() { /* not implemented */ throw NULL; }
	/** Setter: Multiplier for the material's density */
	void density_scale(float value) {
		PyObject_SetAttrString(pyobjref, "density_scale", Py_BuildValue("f", value));
	}

	/** Getter: Amount of light that gets scattered out by the volume - the more out-scattering, the shallower the light will penetrate */
	float scattering() { /* not implemented */ throw NULL; }
	/** Setter: Amount of light that gets scattered out by the volume - the more out-scattering, the shallower the light will penetrate */
	void scattering(float value) {
		PyObject_SetAttrString(pyobjref, "scattering", Py_BuildValue("f", value));
	}

	/** Getter: Result color of the volume, after other light has been scattered/absorbed */
	std::array<float, 3> transmission_color() {
		// TODO: MISSING DEREF! USE #DEFINE!
		PyObject *seqval = PyObject_GetAttrString(pyobjref, "transmission_color");
		std::array<float, 3> resarr;
		for (int i = 0; i < 3; i++)
			resarr[i] = (float)PyFloat_AsDouble(PySequence_GetItem(seqval, i));
		return resarr;
	}

	/** Setter: Result color of the volume, after other light has been scattered/absorbed */
	void transmission_color(float values[3]) { /* not implemented */ }

	/** Getter: Color of light scattered out of the volume (does not affect transmission) */
	std::array<float, 3> reflection_color() {
		// TODO: MISSING DEREF! USE #DEFINE!
		PyObject *seqval = PyObject_GetAttrString(pyobjref, "reflection_color");
		std::array<float, 3> resarr;
		for (int i = 0; i < 3; i++)
			resarr[i] = (float)PyFloat_AsDouble(PySequence_GetItem(seqval, i));
		return resarr;
	}

	/** Setter: Color of light scattered out of the volume (does not affect transmission) */
	void reflection_color(float values[3]) { /* not implemented */ }

	/** Getter: Multiplier to make out-scattered light brighter or darker (non-physically correct) */
	float reflection() { /* not implemented */ throw NULL; }
	/** Setter: Multiplier to make out-scattered light brighter or darker (non-physically correct) */
	void reflection(float value) {
		PyObject_SetAttrString(pyobjref, "reflection", Py_BuildValue("f", value));
	}

	/** Getter: Color of emitted light */
	std::array<float, 3> emission_color() {
		// TODO: MISSING DEREF! USE #DEFINE!
		PyObject *seqval = PyObject_GetAttrString(pyobjref, "emission_color");
		std::array<float, 3> resarr;
		for (int i = 0; i < 3; i++)
			resarr[i] = (float)PyFloat_AsDouble(PySequence_GetItem(seqval, i));
		return resarr;
	}

	/** Setter: Color of emitted light */
	void emission_color(float values[3]) { /* not implemented */ }

	/** Getter: Amount of light that gets emitted by the volume */
	float emission() { /* not implemented */ throw NULL; }
	/** Setter: Amount of light that gets emitted by the volume */
	void emission(float value) {
		PyObject_SetAttrString(pyobjref, "emission", Py_BuildValue("f", value));
	}

	/** Getter: Back scattering (-1.0) to Forward scattering (1.0) and the range in between */
	float asymmetry() { /* not implemented */ throw NULL; }
	/** Setter: Back scattering (-1.0) to Forward scattering (1.0) and the range in between */
	void asymmetry(float value) {
		PyObject_SetAttrString(pyobjref, "asymmetry", Py_BuildValue("f", value));
	}

};

/**************** Material Halo ****************/

/**
 * Halo particle effect settings for a Material datablock
 */
class MaterialHalo : public pyUniplug {
public:
	MaterialHalo(PyObject* pyobj) : pyUniplug(pyobj) {}

	MaterialHalo() : pyUniplug(0)
	{
		// not implemented
	}

	/** Getter: Dimension of the halo */
	float size() { /* not implemented */ throw NULL; }
	/** Setter: Dimension of the halo */
	void size(float value) {
		PyObject_SetAttrString(pyobjref, "size", Py_BuildValue("f", value));
	}

	/** Getter: Hardness of the halo */
	int hardness() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "hardness"));
	}

	/** Setter: Hardness of the halo */
	void hardness(int value) {
		PyObject_SetAttrString(pyobjref, "hardness", Py_BuildValue("i", value));
	}

	/** Getter: Strength of the add effect */
	float add() { /* not implemented */ throw NULL; }
	/** Setter: Strength of the add effect */
	void add(float value) {
		PyObject_SetAttrString(pyobjref, "add", Py_BuildValue("f", value));
	}

	/** Getter: Number of rings rendered over the halo */
	int ring_count() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "ring_count"));
	}

	/** Setter: Number of rings rendered over the halo */
	void ring_count(int value) {
		PyObject_SetAttrString(pyobjref, "ring_count", Py_BuildValue("i", value));
	}

	/** Getter: Number of star shaped lines rendered over the halo */
	int line_count() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "line_count"));
	}

	/** Setter: Number of star shaped lines rendered over the halo */
	void line_count(int value) {
		PyObject_SetAttrString(pyobjref, "line_count", Py_BuildValue("i", value));
	}

	/** Getter: Number of points on the star shaped halo */
	int star_tip_count() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "star_tip_count"));
	}

	/** Setter: Number of points on the star shaped halo */
	void star_tip_count(int value) {
		PyObject_SetAttrString(pyobjref, "star_tip_count", Py_BuildValue("i", value));
	}

	/** Getter: Randomize ring dimension and line location */
	int seed() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "seed"));
	}

	/** Setter: Randomize ring dimension and line location */
	void seed(int value) {
		PyObject_SetAttrString(pyobjref, "seed", Py_BuildValue("i", value));
	}

	/** Getter: Render halo as a lens flare */
	bool use_flare_mode() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_flare_mode")) == 1;
	}

	/** Setter: Render halo as a lens flare */
	void use_flare_mode(bool value) {
		PyObject_SetAttrString(pyobjref, "use_flare_mode", Py_BuildValue("i", value));
	}

	/** Getter: Factor by which the flare is larger than the halo */
	float flare_size() { /* not implemented */ throw NULL; }
	/** Setter: Factor by which the flare is larger than the halo */
	void flare_size(float value) {
		PyObject_SetAttrString(pyobjref, "flare_size", Py_BuildValue("f", value));
	}

	/** Getter: Dimension of the sub-flares, dots and circles */
	float flare_subflare_size() { /* not implemented */ throw NULL; }
	/** Setter: Dimension of the sub-flares, dots and circles */
	void flare_subflare_size(float value) {
		PyObject_SetAttrString(pyobjref, "flare_subflare_size", Py_BuildValue("f", value));
	}

	/** Getter: Give the flare extra strength */
	float flare_boost() { /* not implemented */ throw NULL; }
	/** Setter: Give the flare extra strength */
	void flare_boost(float value) {
		PyObject_SetAttrString(pyobjref, "flare_boost", Py_BuildValue("f", value));
	}

	/** Getter: Offset in the flare seed table */
	int flare_seed() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "flare_seed"));
	}

	/** Setter: Offset in the flare seed table */
	void flare_seed(int value) {
		PyObject_SetAttrString(pyobjref, "flare_seed", Py_BuildValue("i", value));
	}

	/** Getter: Number of sub-flares */
	int flare_subflare_count() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "flare_subflare_count"));
	}

	/** Setter: Number of sub-flares */
	void flare_subflare_count(int value) {
		PyObject_SetAttrString(pyobjref, "flare_subflare_count", Py_BuildValue("i", value));
	}

	/** Getter: Render rings over halo */
	bool use_ring() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_ring")) == 1;
	}

	/** Setter: Render rings over halo */
	void use_ring(bool value) {
		PyObject_SetAttrString(pyobjref, "use_ring", Py_BuildValue("i", value));
	}

	/** Getter: Render star shaped lines over halo */
	bool use_lines() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_lines")) == 1;
	}

	/** Setter: Render star shaped lines over halo */
	void use_lines(bool value) {
		PyObject_SetAttrString(pyobjref, "use_lines", Py_BuildValue("i", value));
	}

	/** Getter: Render halo as a star */
	bool use_star() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_star")) == 1;
	}

	/** Setter: Render halo as a star */
	void use_star(bool value) {
		PyObject_SetAttrString(pyobjref, "use_star", Py_BuildValue("i", value));
	}

	/** Getter: Give halo a texture */
	bool use_texture() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_texture")) == 1;
	}

	/** Setter: Give halo a texture */
	void use_texture(bool value) {
		PyObject_SetAttrString(pyobjref, "use_texture", Py_BuildValue("i", value));
	}

	/** Getter: Use the vertex normal to specify the dimension of the halo */
	bool use_vertex_normal() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_vertex_normal")) == 1;
	}

	/** Setter: Use the vertex normal to specify the dimension of the halo */
	void use_vertex_normal(bool value) {
		PyObject_SetAttrString(pyobjref, "use_vertex_normal", Py_BuildValue("i", value));
	}

	/** Getter: Use extreme alpha */
	bool use_extreme_alpha() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_extreme_alpha")) == 1;
	}

	/** Setter: Use extreme alpha */
	void use_extreme_alpha(bool value) {
		PyObject_SetAttrString(pyobjref, "use_extreme_alpha", Py_BuildValue("i", value));
	}

	/** Getter: Let halo receive light and shadows from external objects */
	bool use_shaded() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_shaded")) == 1;
	}

	/** Setter: Let halo receive light and shadows from external objects */
	void use_shaded(bool value) {
		PyObject_SetAttrString(pyobjref, "use_shaded", Py_BuildValue("i", value));
	}

	/** Getter: Soften the edges of halos at intersections with other geometry */
	bool use_soft() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_soft")) == 1;
	}

	/** Setter: Soften the edges of halos at intersections with other geometry */
	void use_soft(bool value) {
		PyObject_SetAttrString(pyobjref, "use_soft", Py_BuildValue("i", value));
	}

};

/**************** Material Subsurface Scattering ****************/

/**
 * Diffuse subsurface scattering settings for a Material datablock
 */
class MaterialSubsurfaceScattering : public pyUniplug {
public:
	MaterialSubsurfaceScattering(PyObject* pyobj) : pyUniplug(pyobj) {}

	MaterialSubsurfaceScattering() : pyUniplug(0)
	{
		// not implemented
	}

	/** Getter: Mean red/green/blue scattering path length */
	std::array<float, 3> radius() {
		// TODO: MISSING DEREF! USE #DEFINE!
		PyObject *seqval = PyObject_GetAttrString(pyobjref, "radius");
		std::array<float, 3> resarr;
		for (int i = 0; i < 3; i++)
			resarr[i] = (float)PyFloat_AsDouble(PySequence_GetItem(seqval, i));
		return resarr;
	}

	/** Setter: Mean red/green/blue scattering path length */
	void radius(float values[3]) { /* not implemented */ }

	/** Getter: Scattering color */
	std::array<float, 3> color() {
		// TODO: MISSING DEREF! USE #DEFINE!
		PyObject *seqval = PyObject_GetAttrString(pyobjref, "color");
		std::array<float, 3> resarr;
		for (int i = 0; i < 3; i++)
			resarr[i] = (float)PyFloat_AsDouble(PySequence_GetItem(seqval, i));
		return resarr;
	}

	/** Setter: Scattering color */
	void color(float values[3]) { /* not implemented */ }

	/** Getter: Error tolerance (low values are slower and higher quality) */
	float error_threshold() { /* not implemented */ throw NULL; }
	/** Setter: Error tolerance (low values are slower and higher quality) */
	void error_threshold(float value) {
		PyObject_SetAttrString(pyobjref, "error_threshold", Py_BuildValue("f", value));
	}

	/** Getter: Object scale factor */
	float scale() { /* not implemented */ throw NULL; }
	/** Setter: Object scale factor */
	void scale(float value) {
		PyObject_SetAttrString(pyobjref, "scale", Py_BuildValue("f", value));
	}

	/** Getter: Index of refraction (higher values are denser) */
	float ior() { /* not implemented */ throw NULL; }
	/** Setter: Index of refraction (higher values are denser) */
	void ior(float value) {
		PyObject_SetAttrString(pyobjref, "ior", Py_BuildValue("f", value));
	}

	/** Getter: Blend factor for SSS colors */
	float color_factor() { /* not implemented */ throw NULL; }
	/** Setter: Blend factor for SSS colors */
	void color_factor(float value) {
		PyObject_SetAttrString(pyobjref, "color_factor", Py_BuildValue("f", value));
	}

	/** Getter: Texture scattering blend factor */
	float texture_factor() { /* not implemented */ throw NULL; }
	/** Setter: Texture scattering blend factor */
	void texture_factor(float value) {
		PyObject_SetAttrString(pyobjref, "texture_factor", Py_BuildValue("f", value));
	}

	/** Getter: Front scattering weight */
	float front() { /* not implemented */ throw NULL; }
	/** Setter: Front scattering weight */
	void front(float value) {
		PyObject_SetAttrString(pyobjref, "front", Py_BuildValue("f", value));
	}

	/** Getter: Back scattering weight */
	float back() { /* not implemented */ throw NULL; }
	/** Setter: Back scattering weight */
	void back(float value) {
		PyObject_SetAttrString(pyobjref, "back", Py_BuildValue("f", value));
	}

	/** Getter: Enable diffuse subsurface scattering effects in a material */
	bool use() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use")) == 1;
	}

	/** Setter: Enable diffuse subsurface scattering effects in a material */
	void use(bool value) {
		PyObject_SetAttrString(pyobjref, "use", Py_BuildValue("i", value));
	}

};

/**************** Material Texture Slot ****************/

/**
 * Texture slot for textures in a Material datablock
 */
class MaterialTextureSlot : public TextureSlot {
public:
	MaterialTextureSlot(PyObject* pyobj) : TextureSlot(pyobj) {}

	MaterialTextureSlot() : TextureSlot(0)
	{
		// not implemented
	}

	enum texture_coords_enum {
		texture_coords_GLOBAL = 8,
		texture_coords_OBJECT = 32,
		texture_coords_UV = 16,
		texture_coords_ORCO = 1,
		texture_coords_STRAND = 8192,
		texture_coords_WINDOW = 1024,
		texture_coords_NORMAL = 4,
		texture_coords_REFLECTION = 2,
		texture_coords_STRESS = 16384,
		texture_coords_TANGENT = 4096,
	};

	/** Getter:  */
	texture_coords_enum texture_coords() { /* not implemented */ throw NULL; }
	/** Setter:  */
	void texture_coords(texture_coords_enum value) { /* not implemented */ }

	/** Getter: Object to use for mapping with Object texture coordinates */
	Object object_value();

	/** Getter: UV map to use for mapping with UV texture coordinates */
	std::string uv_layer() { /* not implemented */ throw NULL; }
	/** Setter: UV map to use for mapping with UV texture coordinates */
	void uv_layer(const std::string& value) { /* not implemented */ }

	/** Getter: Dupli's instanced from verts, faces or particles, inherit texture coordinate from their parent */
	bool use_from_dupli() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_from_dupli")) == 1;
	}

	/** Setter: Dupli's instanced from verts, faces or particles, inherit texture coordinate from their parent */
	void use_from_dupli(bool value) {
		PyObject_SetAttrString(pyobjref, "use_from_dupli", Py_BuildValue("i", value));
	}

	/** Getter: Map coordinates in object bounds */
	bool use_map_to_bounds() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_map_to_bounds")) == 1;
	}

	/** Setter: Map coordinates in object bounds */
	void use_map_to_bounds(bool value) {
		PyObject_SetAttrString(pyobjref, "use_map_to_bounds", Py_BuildValue("i", value));
	}

	/** Getter: Dupli's derive their object coordinates from the original object's transformation */
	bool use_from_original() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_from_original")) == 1;
	}

	/** Setter: Dupli's derive their object coordinates from the original object's transformation */
	void use_from_original(bool value) {
		PyObject_SetAttrString(pyobjref, "use_from_original", Py_BuildValue("i", value));
	}

	/** Getter: The texture affects basic color of the material */
	bool use_map_color_diffuse() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_map_color_diffuse")) == 1;
	}

	/** Setter: The texture affects basic color of the material */
	void use_map_color_diffuse(bool value) {
		PyObject_SetAttrString(pyobjref, "use_map_color_diffuse", Py_BuildValue("i", value));
	}

	/** Getter: The texture affects the rendered normal */
	bool use_map_normal() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_map_normal")) == 1;
	}

	/** Setter: The texture affects the rendered normal */
	void use_map_normal(bool value) {
		PyObject_SetAttrString(pyobjref, "use_map_normal", Py_BuildValue("i", value));
	}

	/** Getter: The texture affects the specularity color */
	bool use_map_color_spec() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_map_color_spec")) == 1;
	}

	/** Setter: The texture affects the specularity color */
	void use_map_color_spec(bool value) {
		PyObject_SetAttrString(pyobjref, "use_map_color_spec", Py_BuildValue("i", value));
	}

	/** Getter: The texture affects the mirror color */
	bool use_map_mirror() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_map_mirror")) == 1;
	}

	/** Setter: The texture affects the mirror color */
	void use_map_mirror(bool value) {
		PyObject_SetAttrString(pyobjref, "use_map_mirror", Py_BuildValue("i", value));
	}

	/** Getter: The texture affects the value of diffuse reflectivity */
	bool use_map_diffuse() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_map_diffuse")) == 1;
	}

	/** Setter: The texture affects the value of diffuse reflectivity */
	void use_map_diffuse(bool value) {
		PyObject_SetAttrString(pyobjref, "use_map_diffuse", Py_BuildValue("i", value));
	}

	/** Getter: The texture affects the value of specular reflectivity */
	bool use_map_specular() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_map_specular")) == 1;
	}

	/** Setter: The texture affects the value of specular reflectivity */
	void use_map_specular(bool value) {
		PyObject_SetAttrString(pyobjref, "use_map_specular", Py_BuildValue("i", value));
	}

	/** Getter: The texture affects the value of ambient */
	bool use_map_ambient() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_map_ambient")) == 1;
	}

	/** Setter: The texture affects the value of ambient */
	void use_map_ambient(bool value) {
		PyObject_SetAttrString(pyobjref, "use_map_ambient", Py_BuildValue("i", value));
	}

	/** Getter: The texture affects the hardness value */
	bool use_map_hardness() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_map_hardness")) == 1;
	}

	/** Setter: The texture affects the hardness value */
	void use_map_hardness(bool value) {
		PyObject_SetAttrString(pyobjref, "use_map_hardness", Py_BuildValue("i", value));
	}

	/** Getter: The texture affects the ray-mirror value */
	bool use_map_raymir() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_map_raymir")) == 1;
	}

	/** Setter: The texture affects the ray-mirror value */
	void use_map_raymir(bool value) {
		PyObject_SetAttrString(pyobjref, "use_map_raymir", Py_BuildValue("i", value));
	}

	/** Getter: The texture affects the alpha value */
	bool use_map_alpha() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_map_alpha")) == 1;
	}

	/** Setter: The texture affects the alpha value */
	void use_map_alpha(bool value) {
		PyObject_SetAttrString(pyobjref, "use_map_alpha", Py_BuildValue("i", value));
	}

	/** Getter: The texture affects the emit value */
	bool use_map_emit() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_map_emit")) == 1;
	}

	/** Setter: The texture affects the emit value */
	void use_map_emit(bool value) {
		PyObject_SetAttrString(pyobjref, "use_map_emit", Py_BuildValue("i", value));
	}

	/** Getter: The texture affects the translucency value */
	bool use_map_translucency() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_map_translucency")) == 1;
	}

	/** Setter: The texture affects the translucency value */
	void use_map_translucency(bool value) {
		PyObject_SetAttrString(pyobjref, "use_map_translucency", Py_BuildValue("i", value));
	}

	/** Getter: Let the texture displace the surface */
	bool use_map_displacement() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_map_displacement")) == 1;
	}

	/** Setter: Let the texture displace the surface */
	void use_map_displacement(bool value) {
		PyObject_SetAttrString(pyobjref, "use_map_displacement", Py_BuildValue("i", value));
	}

	/** Getter: Let the texture warp texture coordinates of next channels */
	bool use_map_warp() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_map_warp")) == 1;
	}

	/** Setter: Let the texture warp texture coordinates of next channels */
	void use_map_warp(bool value) {
		PyObject_SetAttrString(pyobjref, "use_map_warp", Py_BuildValue("i", value));
	}

	enum mapping_x_enum {
		mapping_x_NONE = 0,
		mapping_x_X = 1,
		mapping_x_Y = 2,
		mapping_x_Z = 3,
	};

	/** Getter:  */
	mapping_x_enum mapping_x() { /* not implemented */ throw NULL; }
	/** Setter:  */
	void mapping_x(mapping_x_enum value) { /* not implemented */ }

	enum mapping_y_enum {
		mapping_y_NONE = 0,
		mapping_y_X = 1,
		mapping_y_Y = 2,
		mapping_y_Z = 3,
	};

	/** Getter:  */
	mapping_y_enum mapping_y() { /* not implemented */ throw NULL; }
	/** Setter:  */
	void mapping_y(mapping_y_enum value) { /* not implemented */ }

	enum mapping_z_enum {
		mapping_z_NONE = 0,
		mapping_z_X = 1,
		mapping_z_Y = 2,
		mapping_z_Z = 3,
	};

	/** Getter:  */
	mapping_z_enum mapping_z() { /* not implemented */ throw NULL; }
	/** Setter:  */
	void mapping_z(mapping_z_enum value) { /* not implemented */ }

	enum mapping_enum {
		mapping_FLAT = 0,
		mapping_CUBE = 1,
		mapping_TUBE = 2,
		mapping_SPHERE = 3,
	};

	/** Getter:  */
	mapping_enum mapping() { /* not implemented */ throw NULL; }
	/** Setter:  */
	void mapping(mapping_enum value) { /* not implemented */ }

	enum normal_map_space_enum {
		normal_map_space_CAMERA = 0,
		normal_map_space_WORLD = 1,
		normal_map_space_OBJECT = 2,
		normal_map_space_TANGENT = 3,
	};

	/** Getter: Set space of normal map image */
	normal_map_space_enum normal_map_space() { /* not implemented */ throw NULL; }
	/** Setter: Set space of normal map image */
	void normal_map_space(normal_map_space_enum value) { /* not implemented */ }

	/** Getter: Amount texture affects normal values */
	float normal_factor() { /* not implemented */ throw NULL; }
	/** Setter: Amount texture affects normal values */
	void normal_factor(float value) {
		PyObject_SetAttrString(pyobjref, "normal_factor", Py_BuildValue("f", value));
	}

	/** Getter: Amount texture displaces the surface */
	float displacement_factor() { /* not implemented */ throw NULL; }
	/** Setter: Amount texture displaces the surface */
	void displacement_factor(float value) {
		PyObject_SetAttrString(pyobjref, "displacement_factor", Py_BuildValue("f", value));
	}

	/** Getter: Amount texture affects texture coordinates of next channels */
	float warp_factor() { /* not implemented */ throw NULL; }
	/** Setter: Amount texture affects texture coordinates of next channels */
	void warp_factor(float value) {
		PyObject_SetAttrString(pyobjref, "warp_factor", Py_BuildValue("f", value));
	}

	/** Getter: Amount texture affects specular color */
	float specular_color_factor() { /* not implemented */ throw NULL; }
	/** Setter: Amount texture affects specular color */
	void specular_color_factor(float value) {
		PyObject_SetAttrString(pyobjref, "specular_color_factor", Py_BuildValue("f", value));
	}

	/** Getter: Amount texture affects diffuse color */
	float diffuse_color_factor() { /* not implemented */ throw NULL; }
	/** Setter: Amount texture affects diffuse color */
	void diffuse_color_factor(float value) {
		PyObject_SetAttrString(pyobjref, "diffuse_color_factor", Py_BuildValue("f", value));
	}

	/** Getter: Amount texture affects mirror color */
	float mirror_factor() { /* not implemented */ throw NULL; }
	/** Setter: Amount texture affects mirror color */
	void mirror_factor(float value) {
		PyObject_SetAttrString(pyobjref, "mirror_factor", Py_BuildValue("f", value));
	}

	/** Getter: Amount texture affects alpha */
	float alpha_factor() { /* not implemented */ throw NULL; }
	/** Setter: Amount texture affects alpha */
	void alpha_factor(float value) {
		PyObject_SetAttrString(pyobjref, "alpha_factor", Py_BuildValue("f", value));
	}

	/** Getter: Amount texture affects diffuse reflectivity */
	float diffuse_factor() { /* not implemented */ throw NULL; }
	/** Setter: Amount texture affects diffuse reflectivity */
	void diffuse_factor(float value) {
		PyObject_SetAttrString(pyobjref, "diffuse_factor", Py_BuildValue("f", value));
	}

	/** Getter: Amount texture affects specular reflectivity */
	float specular_factor() { /* not implemented */ throw NULL; }
	/** Setter: Amount texture affects specular reflectivity */
	void specular_factor(float value) {
		PyObject_SetAttrString(pyobjref, "specular_factor", Py_BuildValue("f", value));
	}

	/** Getter: Amount texture affects emission */
	float emit_factor() { /* not implemented */ throw NULL; }
	/** Setter: Amount texture affects emission */
	void emit_factor(float value) {
		PyObject_SetAttrString(pyobjref, "emit_factor", Py_BuildValue("f", value));
	}

	/** Getter: Amount texture affects hardness */
	float hardness_factor() { /* not implemented */ throw NULL; }
	/** Setter: Amount texture affects hardness */
	void hardness_factor(float value) {
		PyObject_SetAttrString(pyobjref, "hardness_factor", Py_BuildValue("f", value));
	}

	/** Getter: Amount texture affects ray mirror */
	float raymir_factor() { /* not implemented */ throw NULL; }
	/** Setter: Amount texture affects ray mirror */
	void raymir_factor(float value) {
		PyObject_SetAttrString(pyobjref, "raymir_factor", Py_BuildValue("f", value));
	}

	/** Getter: Amount texture affects translucency */
	float translucency_factor() { /* not implemented */ throw NULL; }
	/** Setter: Amount texture affects translucency */
	void translucency_factor(float value) {
		PyObject_SetAttrString(pyobjref, "translucency_factor", Py_BuildValue("f", value));
	}

	/** Getter: Amount texture affects ambient */
	float ambient_factor() { /* not implemented */ throw NULL; }
	/** Setter: Amount texture affects ambient */
	void ambient_factor(float value) {
		PyObject_SetAttrString(pyobjref, "ambient_factor", Py_BuildValue("f", value));
	}

	/** Getter: The texture affects the color of emission */
	bool use_map_color_emission() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_map_color_emission")) == 1;
	}

	/** Setter: The texture affects the color of emission */
	void use_map_color_emission(bool value) {
		PyObject_SetAttrString(pyobjref, "use_map_color_emission", Py_BuildValue("i", value));
	}

	/** Getter: The texture affects the color of scattered light */
	bool use_map_color_reflection() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_map_color_reflection")) == 1;
	}

	/** Setter: The texture affects the color of scattered light */
	void use_map_color_reflection(bool value) {
		PyObject_SetAttrString(pyobjref, "use_map_color_reflection", Py_BuildValue("i", value));
	}

	/** Getter: The texture affects the result color after other light has been scattered/absorbed */
	bool use_map_color_transmission() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_map_color_transmission")) == 1;
	}

	/** Setter: The texture affects the result color after other light has been scattered/absorbed */
	void use_map_color_transmission(bool value) {
		PyObject_SetAttrString(pyobjref, "use_map_color_transmission", Py_BuildValue("i", value));
	}

	/** Getter: The texture affects the volume's density */
	bool use_map_density() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_map_density")) == 1;
	}

	/** Setter: The texture affects the volume's density */
	void use_map_density(bool value) {
		PyObject_SetAttrString(pyobjref, "use_map_density", Py_BuildValue("i", value));
	}

	/** Getter: The texture affects the volume's emission */
	bool use_map_emission() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_map_emission")) == 1;
	}

	/** Setter: The texture affects the volume's emission */
	void use_map_emission(bool value) {
		PyObject_SetAttrString(pyobjref, "use_map_emission", Py_BuildValue("i", value));
	}

	/** Getter: The texture affects the volume's scattering */
	bool use_map_scatter() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_map_scatter")) == 1;
	}

	/** Setter: The texture affects the volume's scattering */
	void use_map_scatter(bool value) {
		PyObject_SetAttrString(pyobjref, "use_map_scatter", Py_BuildValue("i", value));
	}

	/** Getter: The texture affects the reflected light's brightness */
	bool use_map_reflect() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_map_reflect")) == 1;
	}

	/** Setter: The texture affects the reflected light's brightness */
	void use_map_reflect(bool value) {
		PyObject_SetAttrString(pyobjref, "use_map_reflect", Py_BuildValue("i", value));
	}

	/** Getter: Amount texture affects emission color */
	float emission_color_factor() { /* not implemented */ throw NULL; }
	/** Setter: Amount texture affects emission color */
	void emission_color_factor(float value) {
		PyObject_SetAttrString(pyobjref, "emission_color_factor", Py_BuildValue("f", value));
	}

	/** Getter: Amount texture affects color of out-scattered light */
	float reflection_color_factor() { /* not implemented */ throw NULL; }
	/** Setter: Amount texture affects color of out-scattered light */
	void reflection_color_factor(float value) {
		PyObject_SetAttrString(pyobjref, "reflection_color_factor", Py_BuildValue("f", value));
	}

	/** Getter: Amount texture affects result color after light has been scattered/absorbed */
	float transmission_color_factor() { /* not implemented */ throw NULL; }
	/** Setter: Amount texture affects result color after light has been scattered/absorbed */
	void transmission_color_factor(float value) {
		PyObject_SetAttrString(pyobjref, "transmission_color_factor", Py_BuildValue("f", value));
	}

	/** Getter: Amount texture affects density */
	float density_factor() { /* not implemented */ throw NULL; }
	/** Setter: Amount texture affects density */
	void density_factor(float value) {
		PyObject_SetAttrString(pyobjref, "density_factor", Py_BuildValue("f", value));
	}

	/** Getter: Amount texture affects emission */
	float emission_factor() { /* not implemented */ throw NULL; }
	/** Setter: Amount texture affects emission */
	void emission_factor(float value) {
		PyObject_SetAttrString(pyobjref, "emission_factor", Py_BuildValue("f", value));
	}

	/** Getter: Amount texture affects scattering */
	float scattering_factor() { /* not implemented */ throw NULL; }
	/** Setter: Amount texture affects scattering */
	void scattering_factor(float value) {
		PyObject_SetAttrString(pyobjref, "scattering_factor", Py_BuildValue("f", value));
	}

	/** Getter: Amount texture affects brightness of out-scattered light */
	float reflection_factor() { /* not implemented */ throw NULL; }
	/** Setter: Amount texture affects brightness of out-scattered light */
	void reflection_factor(float value) {
		PyObject_SetAttrString(pyobjref, "reflection_factor", Py_BuildValue("f", value));
	}

	/** Getter: Enable this material texture slot */
	bool use() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use")) == 1;
	}

	/** Setter: Enable this material texture slot */
	void use(bool value) {
		PyObject_SetAttrString(pyobjref, "use", Py_BuildValue("i", value));
	}

	enum bump_method_enum {
		bump_method_BUMP_ORIGINAL = 0,
		bump_method_BUMP_COMPATIBLE = 128,
		bump_method_BUMP_LOW_QUALITY = 256,
		bump_method_BUMP_MEDIUM_QUALITY = 512,
		bump_method_BUMP_BEST_QUALITY = 8192,
	};

	/** Getter: Method to use for bump mapping */
	bump_method_enum bump_method() { /* not implemented */ throw NULL; }
	/** Setter: Method to use for bump mapping */
	void bump_method(bump_method_enum value) { /* not implemented */ }

	enum bump_objectspace_enum {
		bump_objectspace_BUMP_VIEWSPACE = 0,
		bump_objectspace_BUMP_OBJECTSPACE = 1024,
		bump_objectspace_BUMP_TEXTURESPACE = 2048,
	};

	/** Getter: Space to apply bump mapping in */
	bump_objectspace_enum bump_objectspace() { /* not implemented */ throw NULL; }
	/** Setter: Space to apply bump mapping in */
	void bump_objectspace(bump_objectspace_enum value) { /* not implemented */ }

};

/**************** Material Strand ****************/

/**
 * Strand settings for a Material datablock
 */
class MaterialStrand : public pyUniplug {
public:
	MaterialStrand(PyObject* pyobj) : pyUniplug(pyobj) {}

	MaterialStrand() : pyUniplug(0)
	{
		// not implemented
	}

	/** Getter: Use direction of strands as normal for tangent-shading */
	bool use_tangent_shading() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_tangent_shading")) == 1;
	}

	/** Setter: Use direction of strands as normal for tangent-shading */
	void use_tangent_shading(bool value) {
		PyObject_SetAttrString(pyobjref, "use_tangent_shading", Py_BuildValue("i", value));
	}

	/** Getter: Make diffuse shading more similar to shading the surface */
	bool use_surface_diffuse() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_surface_diffuse")) == 1;
	}

	/** Setter: Make diffuse shading more similar to shading the surface */
	void use_surface_diffuse(bool value) {
		PyObject_SetAttrString(pyobjref, "use_surface_diffuse", Py_BuildValue("i", value));
	}

	/** Getter: Worldspace distance over which to blend in the surface normal */
	float blend_distance() { /* not implemented */ throw NULL; }
	/** Setter: Worldspace distance over which to blend in the surface normal */
	void blend_distance(float value) {
		PyObject_SetAttrString(pyobjref, "blend_distance", Py_BuildValue("f", value));
	}

	/** Getter: Use Blender units for widths instead of pixels */
	bool use_blender_units() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_blender_units")) == 1;
	}

	/** Setter: Use Blender units for widths instead of pixels */
	void use_blender_units(bool value) {
		PyObject_SetAttrString(pyobjref, "use_blender_units", Py_BuildValue("i", value));
	}

	/** Getter: Start size of strands in pixels or Blender units */
	float root_size() { /* not implemented */ throw NULL; }
	/** Setter: Start size of strands in pixels or Blender units */
	void root_size(float value) {
		PyObject_SetAttrString(pyobjref, "root_size", Py_BuildValue("f", value));
	}

	/** Getter: End size of strands in pixels or Blender units */
	float tip_size() { /* not implemented */ throw NULL; }
	/** Setter: End size of strands in pixels or Blender units */
	void tip_size(float value) {
		PyObject_SetAttrString(pyobjref, "tip_size", Py_BuildValue("f", value));
	}

	/** Getter: Minimum size of strands in pixels */
	float size_min() { /* not implemented */ throw NULL; }
	/** Setter: Minimum size of strands in pixels */
	void size_min(float value) {
		PyObject_SetAttrString(pyobjref, "size_min", Py_BuildValue("f", value));
	}

	/** Getter: Positive values make strands rounder, negative ones make strands spiky */
	float shape() { /* not implemented */ throw NULL; }
	/** Setter: Positive values make strands rounder, negative ones make strands spiky */
	void shape(float value) {
		PyObject_SetAttrString(pyobjref, "shape", Py_BuildValue("f", value));
	}

	/** Getter: Transparency along the width of the strand */
	float width_fade() { /* not implemented */ throw NULL; }
	/** Setter: Transparency along the width of the strand */
	void width_fade(float value) {
		PyObject_SetAttrString(pyobjref, "width_fade", Py_BuildValue("f", value));
	}

	/** Getter: Name of UV map to override */
	std::string uv_layer() { /* not implemented */ throw NULL; }
	/** Setter: Name of UV map to override */
	void uv_layer(const std::string& value) { /* not implemented */ }

};

/**************** Material Physics ****************/

/**
 * Physics settings for a Material datablock
 */
class MaterialPhysics : public pyUniplug {
public:
	MaterialPhysics(PyObject* pyobj) : pyUniplug(pyobj) {}

	MaterialPhysics() : pyUniplug(0)
	{
		// not implemented
	}

	/** Getter: Coulomb friction coefficient, when inside the physics distance area */
	float friction() { /* not implemented */ throw NULL; }
	/** Setter: Coulomb friction coefficient, when inside the physics distance area */
	void friction(float value) {
		PyObject_SetAttrString(pyobjref, "friction", Py_BuildValue("f", value));
	}

	/** Getter: Elasticity of collisions */
	float elasticity() { /* not implemented */ throw NULL; }
	/** Setter: Elasticity of collisions */
	void elasticity(float value) {
		PyObject_SetAttrString(pyobjref, "elasticity", Py_BuildValue("f", value));
	}

	/** Getter: Align dynamic game objects along the surface normal, when inside the physics distance area */
	bool use_fh_normal() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_fh_normal")) == 1;
	}

	/** Setter: Align dynamic game objects along the surface normal, when inside the physics distance area */
	void use_fh_normal(bool value) {
		PyObject_SetAttrString(pyobjref, "use_fh_normal", Py_BuildValue("i", value));
	}

	/** Getter: Upward spring force, when inside the physics distance area */
	float fh_force() { /* not implemented */ throw NULL; }
	/** Setter: Upward spring force, when inside the physics distance area */
	void fh_force(float value) {
		PyObject_SetAttrString(pyobjref, "fh_force", Py_BuildValue("f", value));
	}

	/** Getter: Distance of the physics area */
	float fh_distance() { /* not implemented */ throw NULL; }
	/** Setter: Distance of the physics area */
	void fh_distance(float value) {
		PyObject_SetAttrString(pyobjref, "fh_distance", Py_BuildValue("f", value));
	}

	/** Getter: Damping of the spring force, when inside the physics distance area */
	float fh_damping() { /* not implemented */ throw NULL; }
	/** Setter: Damping of the spring force, when inside the physics distance area */
	void fh_damping(float value) {
		PyObject_SetAttrString(pyobjref, "fh_damping", Py_BuildValue("f", value));
	}

};

/**************** Material Game Settings ****************/

/**
 * Game Engine settings for a Material datablock
 */
class MaterialGameSettings : public pyUniplug {
public:
	MaterialGameSettings(PyObject* pyobj) : pyUniplug(pyobj) {}

	MaterialGameSettings() : pyUniplug(0)
	{
		// not implemented
	}

	/** Getter: Hide Back of the face in Game Engine  */
	bool use_backface_culling() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_backface_culling")) == 1;
	}

	/** Setter: Hide Back of the face in Game Engine  */
	void use_backface_culling(bool value) {
		PyObject_SetAttrString(pyobjref, "use_backface_culling", Py_BuildValue("i", value));
	}

	/** Getter: Use material as text in Game Engine  */
	bool text() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "text")) == 1;
	}

	/** Setter: Use material as text in Game Engine  */
	void text(bool value) {
		PyObject_SetAttrString(pyobjref, "text", Py_BuildValue("i", value));
	}

	/** Getter: Make face invisible */
	bool invisible() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "invisible")) == 1;
	}

	/** Setter: Make face invisible */
	void invisible(bool value) {
		PyObject_SetAttrString(pyobjref, "invisible", Py_BuildValue("i", value));
	}

	enum alpha_blend_enum {
		alpha_blend_OPAQUE = 0,
		alpha_blend_ADD = 1,
		alpha_blend_CLIP = 4,
		alpha_blend_ALPHA = 2,
		alpha_blend_ALPHA_SORT = 8,
	};

	/** Getter: Blend Mode for Transparent Faces */
	alpha_blend_enum alpha_blend() { /* not implemented */ throw NULL; }
	/** Setter: Blend Mode for Transparent Faces */
	void alpha_blend(alpha_blend_enum value) { /* not implemented */ }

	enum face_orientation_enum {
		face_orientation_NORMAL = 0,
		face_orientation_HALO = 512,
		face_orientation_BILLBOARD = 1024,
		face_orientation_SHADOW = 2048,
	};

	/** Getter: Especial face orientation options */
	face_orientation_enum face_orientation() { /* not implemented */ throw NULL; }
	/** Setter: Especial face orientation options */
	void face_orientation(face_orientation_enum value) { /* not implemented */ }

	/** Getter: Use physics properties of materials  */
	bool physics() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "physics")) == 1;
	}

	/** Setter: Use physics properties of materials  */
	void physics(bool value) {
		PyObject_SetAttrString(pyobjref, "physics", Py_BuildValue("i", value));
	}

};

/**************** Mesh ****************/

/**
 * Mesh datablock defining geometric surfaces
 */
class Mesh : public ID {
public:
	Mesh(PyObject* pyobj) : ID(pyobj) {}

	Mesh() : ID(0)
	{
		// not implemented
	}

	/** Getter: Vertices of the mesh */
	std::map<std::string, MeshVertex> vertices();
	/** Setter: Vertices of the mesh */
	void vertices(std::map<std::string, MeshVertex> value);

	/** Getter: Edges of the mesh */
	std::map<std::string, MeshEdge> edges();
	/** Setter: Edges of the mesh */
	void edges(std::map<std::string, MeshEdge> value);

	/** Getter: Tessellated faces of the mesh (derived from polygons) */
	std::map<std::string, MeshTessFace> tessfaces();
	/** Setter: Tessellated faces of the mesh (derived from polygons) */
	void tessfaces(std::map<std::string, MeshTessFace> value);

	/** Getter: Loops of the mesh (polygon corners) */
	std::map<std::string, MeshLoop> loops();
	/** Setter: Loops of the mesh (polygon corners) */
	void loops(std::map<std::string, MeshLoop> value);

	/** Getter: Polygons of the mesh */
	std::map<std::string, MeshPolygon> polygons();
	/** Setter: Polygons of the mesh */
	void polygons(std::map<std::string, MeshPolygon> value);

	/** Getter: Use another mesh for texture indices (vertex indices must be aligned) */
	Mesh texture_mesh() {
		/* not implemented */ throw NULL;
	}

	/** Getter: All UV loop layers */
	std::map<std::string, MeshUVLoopLayer> uv_layers();
	/** Setter: All UV loop layers */
	void uv_layers(std::map<std::string, MeshUVLoopLayer> value);

	/** Getter: UV loop layer to be used as cloning source */
	MeshUVLoopLayer uv_layer_clone();

	/** Getter: Clone UV loop layer index */
	int uv_layer_clone_index() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "uv_layer_clone_index"));
	}

	/** Setter: Clone UV loop layer index */
	void uv_layer_clone_index(int value) {
		PyObject_SetAttrString(pyobjref, "uv_layer_clone_index", Py_BuildValue("i", value));
	}

	/** Getter: UV loop layer to mask the painted area */
	MeshUVLoopLayer uv_layer_stencil();

	/** Getter: Mask UV loop layer index */
	int uv_layer_stencil_index() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "uv_layer_stencil_index"));
	}

	/** Setter: Mask UV loop layer index */
	void uv_layer_stencil_index(int value) {
		PyObject_SetAttrString(pyobjref, "uv_layer_stencil_index", Py_BuildValue("i", value));
	}

	/** Getter: All UV maps for tessellated faces (read-only, for use by renderers) */
	std::map<std::string, MeshTextureFaceLayer> tessface_uv_textures();
	/** Setter: All UV maps for tessellated faces (read-only, for use by renderers) */
	void tessface_uv_textures(std::map<std::string, MeshTextureFaceLayer> value);

	/** Getter: All UV maps */
	std::map<std::string, MeshTexturePolyLayer> uv_textures();
	/** Setter: All UV maps */
	void uv_textures(std::map<std::string, MeshTexturePolyLayer> value);

	/** Getter: UV map to be used as cloning source */
	MeshTexturePolyLayer uv_texture_clone();

	/** Getter: Clone UV map index */
	int uv_texture_clone_index() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "uv_texture_clone_index"));
	}

	/** Setter: Clone UV map index */
	void uv_texture_clone_index(int value) {
		PyObject_SetAttrString(pyobjref, "uv_texture_clone_index", Py_BuildValue("i", value));
	}

	/** Getter: UV map to mask the painted area */
	MeshTexturePolyLayer uv_texture_stencil();

	/** Getter: Mask UV map index */
	int uv_texture_stencil_index() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "uv_texture_stencil_index"));
	}

	/** Setter: Mask UV map index */
	void uv_texture_stencil_index(int value) {
		PyObject_SetAttrString(pyobjref, "uv_texture_stencil_index", Py_BuildValue("i", value));
	}

	/** Getter: All tessellated face colors (read-only, for use by renderers) */
	std::map<std::string, MeshColorLayer> tessface_vertex_colors();
	/** Setter: All tessellated face colors (read-only, for use by renderers) */
	void tessface_vertex_colors(std::map<std::string, MeshColorLayer> value);

	/** Getter: All vertex colors */
	std::map<std::string, MeshLoopColorLayer> vertex_colors();
	/** Setter: All vertex colors */
	void vertex_colors(std::map<std::string, MeshLoopColorLayer> value);

	/** Getter:  */
	std::map<std::string, MeshVertexFloatPropertyLayer> vertex_layers_float();
	/** Setter:  */
	void vertex_layers_float(std::map<std::string, MeshVertexFloatPropertyLayer> value);

	/** Getter:  */
	std::map<std::string, MeshVertexIntPropertyLayer> vertex_layers_int();
	/** Setter:  */
	void vertex_layers_int(std::map<std::string, MeshVertexIntPropertyLayer> value);

	/** Getter:  */
	std::map<std::string, MeshVertexStringPropertyLayer> vertex_layers_string();
	/** Setter:  */
	void vertex_layers_string(std::map<std::string, MeshVertexStringPropertyLayer> value);

	/** Getter:  */
	std::map<std::string, MeshPolygonFloatPropertyLayer> polygon_layers_float();
	/** Setter:  */
	void polygon_layers_float(std::map<std::string, MeshPolygonFloatPropertyLayer> value);

	/** Getter:  */
	std::map<std::string, MeshPolygonIntPropertyLayer> polygon_layers_int();
	/** Setter:  */
	void polygon_layers_int(std::map<std::string, MeshPolygonIntPropertyLayer> value);

	/** Getter:  */
	std::map<std::string, MeshPolygonStringPropertyLayer> polygon_layers_string();
	/** Setter:  */
	void polygon_layers_string(std::map<std::string, MeshPolygonStringPropertyLayer> value);

	/** Getter: All skin vertices */
	std::map<std::string, MeshSkinVertexLayer> skin_vertices();
	/** Setter: All skin vertices */
	void skin_vertices(std::map<std::string, MeshSkinVertexLayer> value);

	/** Getter: Vertex paint mask */
	std::map<std::string, MeshPaintMaskLayer> vertex_paint_masks();
	/** Setter: Vertex paint mask */
	void vertex_paint_masks(std::map<std::string, MeshPaintMaskLayer> value);

	/** Getter: Auto smooth (based on smooth/sharp faces/edges and angle between faces), or use custom split normals data if available */
	bool use_auto_smooth() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_auto_smooth")) == 1;
	}

	/** Setter: Auto smooth (based on smooth/sharp faces/edges and angle between faces), or use custom split normals data if available */
	void use_auto_smooth(bool value) {
		PyObject_SetAttrString(pyobjref, "use_auto_smooth", Py_BuildValue("i", value));
	}

	/** Getter: Maximum angle between face normals that will be considered as smooth (unused if custom split normals data are available) */
	float auto_smooth_angle() { /* not implemented */ throw NULL; }
	/** Setter: Maximum angle between face normals that will be considered as smooth (unused if custom split normals data are available) */
	void auto_smooth_angle(float value) {
		PyObject_SetAttrString(pyobjref, "auto_smooth_angle", Py_BuildValue("f", value));
	}

	/** Getter: True if there are custom split normals data in this mesh */
	bool has_custom_normals() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "has_custom_normals")) == 1;
	}

	/** Setter: True if there are custom split normals data in this mesh */
	void has_custom_normals(bool value) {
		PyObject_SetAttrString(pyobjref, "has_custom_normals", Py_BuildValue("i", value));
	}

	/** Getter: Render/display the mesh with double or single sided lighting */
	bool show_double_sided() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "show_double_sided")) == 1;
	}

	/** Setter: Render/display the mesh with double or single sided lighting */
	void show_double_sided(bool value) {
		PyObject_SetAttrString(pyobjref, "show_double_sided", Py_BuildValue("i", value));
	}

	/** Getter: Derive texture coordinates from another mesh */
	Mesh texco_mesh() {
		/* not implemented */ throw NULL;
	}

	/** Getter:  */
	Key shape_keys() {
		/* not implemented */ throw NULL;
	}

	/** Getter: Adjust active object's texture space automatically when transforming object */
	bool use_auto_texspace() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_auto_texspace")) == 1;
	}

	/** Setter: Adjust active object's texture space automatically when transforming object */
	void use_auto_texspace(bool value) {
		PyObject_SetAttrString(pyobjref, "use_auto_texspace", Py_BuildValue("i", value));
	}

	/** Getter: Display selected edges using highlights in the 3D view and UV editor */
	bool show_edges() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "show_edges")) == 1;
	}

	/** Setter: Display selected edges using highlights in the 3D view and UV editor */
	void show_edges(bool value) {
		PyObject_SetAttrString(pyobjref, "show_edges", Py_BuildValue("i", value));
	}

	/** Getter: Display all faces as shades in the 3D view and UV editor */
	bool show_faces() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "show_faces")) == 1;
	}

	/** Setter: Display all faces as shades in the 3D view and UV editor */
	void show_faces(bool value) {
		PyObject_SetAttrString(pyobjref, "show_faces", Py_BuildValue("i", value));
	}

	/** Getter: Display face normals as lines */
	bool show_normal_face() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "show_normal_face")) == 1;
	}

	/** Setter: Display face normals as lines */
	void show_normal_face(bool value) {
		PyObject_SetAttrString(pyobjref, "show_normal_face", Py_BuildValue("i", value));
	}

	/** Getter: Display vertex-per-face normals as lines */
	bool show_normal_loop() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "show_normal_loop")) == 1;
	}

	/** Setter: Display vertex-per-face normals as lines */
	void show_normal_loop(bool value) {
		PyObject_SetAttrString(pyobjref, "show_normal_loop", Py_BuildValue("i", value));
	}

	/** Getter: Display vertex normals as lines */
	bool show_normal_vertex() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "show_normal_vertex")) == 1;
	}

	/** Setter: Display vertex normals as lines */
	void show_normal_vertex(bool value) {
		PyObject_SetAttrString(pyobjref, "show_normal_vertex", Py_BuildValue("i", value));
	}

	/** Getter: Draw weights in editmode */
	bool show_weight() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "show_weight")) == 1;
	}

	/** Setter: Draw weights in editmode */
	void show_weight(bool value) {
		PyObject_SetAttrString(pyobjref, "show_weight", Py_BuildValue("i", value));
	}

	/** Getter: Display creases created for subsurf weighting */
	bool show_edge_crease() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "show_edge_crease")) == 1;
	}

	/** Setter: Display creases created for subsurf weighting */
	void show_edge_crease(bool value) {
		PyObject_SetAttrString(pyobjref, "show_edge_crease", Py_BuildValue("i", value));
	}

	/** Getter: Display weights created for the Bevel modifier */
	bool show_edge_bevel_weight() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "show_edge_bevel_weight")) == 1;
	}

	/** Setter: Display weights created for the Bevel modifier */
	void show_edge_bevel_weight(bool value) {
		PyObject_SetAttrString(pyobjref, "show_edge_bevel_weight", Py_BuildValue("i", value));
	}

	/** Getter: Display UV unwrapping seams */
	bool show_edge_seams() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "show_edge_seams")) == 1;
	}

	/** Setter: Display UV unwrapping seams */
	void show_edge_seams(bool value) {
		PyObject_SetAttrString(pyobjref, "show_edge_seams", Py_BuildValue("i", value));
	}

	/** Getter: Display sharp edges, used with the EdgeSplit modifier */
	bool show_edge_sharp() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "show_edge_sharp")) == 1;
	}

	/** Setter: Display sharp edges, used with the EdgeSplit modifier */
	void show_edge_sharp(bool value) {
		PyObject_SetAttrString(pyobjref, "show_edge_sharp", Py_BuildValue("i", value));
	}

	/** Getter: Display Freestyle edge marks, used with the Freestyle renderer */
	bool show_freestyle_edge_marks() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "show_freestyle_edge_marks")) == 1;
	}

	/** Setter: Display Freestyle edge marks, used with the Freestyle renderer */
	void show_freestyle_edge_marks(bool value) {
		PyObject_SetAttrString(pyobjref, "show_freestyle_edge_marks", Py_BuildValue("i", value));
	}

	/** Getter: Display Freestyle face marks, used with the Freestyle renderer */
	bool show_freestyle_face_marks() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "show_freestyle_face_marks")) == 1;
	}

	/** Setter: Display Freestyle face marks, used with the Freestyle renderer */
	void show_freestyle_face_marks(bool value) {
		PyObject_SetAttrString(pyobjref, "show_freestyle_face_marks", Py_BuildValue("i", value));
	}

	/** Getter: Display statistical information about the mesh */
	bool show_statvis() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "show_statvis")) == 1;
	}

	/** Setter: Display statistical information about the mesh */
	void show_statvis(bool value) {
		PyObject_SetAttrString(pyobjref, "show_statvis", Py_BuildValue("i", value));
	}

	/** Getter: Display selected edge lengths, using global values when set in the transform panel */
	bool show_extra_edge_length() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "show_extra_edge_length")) == 1;
	}

	/** Setter: Display selected edge lengths, using global values when set in the transform panel */
	void show_extra_edge_length(bool value) {
		PyObject_SetAttrString(pyobjref, "show_extra_edge_length", Py_BuildValue("i", value));
	}

	/** Getter: Display selected edge angle, using global values when set in the transform panel */
	bool show_extra_edge_angle() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "show_extra_edge_angle")) == 1;
	}

	/** Setter: Display selected edge angle, using global values when set in the transform panel */
	void show_extra_edge_angle(bool value) {
		PyObject_SetAttrString(pyobjref, "show_extra_edge_angle", Py_BuildValue("i", value));
	}

	/** Getter: Display the angles in the selected edges, using global values when set in the transform panel */
	bool show_extra_face_angle() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "show_extra_face_angle")) == 1;
	}

	/** Setter: Display the angles in the selected edges, using global values when set in the transform panel */
	void show_extra_face_angle(bool value) {
		PyObject_SetAttrString(pyobjref, "show_extra_face_angle", Py_BuildValue("i", value));
	}

	/** Getter: Display the area of selected faces, using global values when set in the transform panel */
	bool show_extra_face_area() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "show_extra_face_area")) == 1;
	}

	/** Setter: Display the area of selected faces, using global values when set in the transform panel */
	void show_extra_face_area(bool value) {
		PyObject_SetAttrString(pyobjref, "show_extra_face_area", Py_BuildValue("i", value));
	}

	/** Getter: Display the index numbers of selected vertices, edges, and faces */
	bool show_extra_indices() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "show_extra_indices")) == 1;
	}

	/** Setter: Display the index numbers of selected vertices, edges, and faces */
	void show_extra_indices(bool value) {
		PyObject_SetAttrString(pyobjref, "show_extra_indices", Py_BuildValue("i", value));
	}

	/** Getter: X Axis mirror editing */
	bool use_mirror_x() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_mirror_x")) == 1;
	}

	/** Setter: X Axis mirror editing */
	void use_mirror_x(bool value) {
		PyObject_SetAttrString(pyobjref, "use_mirror_x", Py_BuildValue("i", value));
	}

	/** Getter: Use topology based mirroring (for when both sides of mesh have matching, unique topology) */
	bool use_mirror_topology() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_mirror_topology")) == 1;
	}

	/** Setter: Use topology based mirroring (for when both sides of mesh have matching, unique topology) */
	void use_mirror_topology(bool value) {
		PyObject_SetAttrString(pyobjref, "use_mirror_topology", Py_BuildValue("i", value));
	}

	/** Getter: Face selection masking for painting */
	bool use_paint_mask() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_paint_mask")) == 1;
	}

	/** Setter: Face selection masking for painting */
	void use_paint_mask(bool value) {
		PyObject_SetAttrString(pyobjref, "use_paint_mask", Py_BuildValue("i", value));
	}

	/** Getter: Vertex selection masking for painting (weight paint only) */
	bool use_paint_mask_vertex() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_paint_mask_vertex")) == 1;
	}

	/** Setter: Vertex selection masking for painting (weight paint only) */
	void use_paint_mask_vertex(bool value) {
		PyObject_SetAttrString(pyobjref, "use_paint_mask_vertex", Py_BuildValue("i", value));
	}

	/** Getter:  */
	bool use_customdata_vertex_bevel() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_customdata_vertex_bevel")) == 1;
	}

	/** Setter:  */
	void use_customdata_vertex_bevel(bool value) {
		PyObject_SetAttrString(pyobjref, "use_customdata_vertex_bevel", Py_BuildValue("i", value));
	}

	/** Getter:  */
	bool use_customdata_edge_bevel() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_customdata_edge_bevel")) == 1;
	}

	/** Setter:  */
	void use_customdata_edge_bevel(bool value) {
		PyObject_SetAttrString(pyobjref, "use_customdata_edge_bevel", Py_BuildValue("i", value));
	}

	/** Getter:  */
	bool use_customdata_edge_crease() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_customdata_edge_crease")) == 1;
	}

	/** Setter:  */
	void use_customdata_edge_crease(bool value) {
		PyObject_SetAttrString(pyobjref, "use_customdata_edge_crease", Py_BuildValue("i", value));
	}

	/** Getter: Selected vertex count in editmode */
	int total_vert_sel() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "total_vert_sel"));
	}

	/** Setter: Selected vertex count in editmode */
	void total_vert_sel(int value) {
		PyObject_SetAttrString(pyobjref, "total_vert_sel", Py_BuildValue("i", value));
	}

	/** Getter: Selected edge count in editmode */
	int total_edge_sel() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "total_edge_sel"));
	}

	/** Setter: Selected edge count in editmode */
	void total_edge_sel(int value) {
		PyObject_SetAttrString(pyobjref, "total_edge_sel", Py_BuildValue("i", value));
	}

	/** Getter: Selected face count in editmode */
	int total_face_sel() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "total_face_sel"));
	}

	/** Setter: Selected face count in editmode */
	void total_face_sel(int value) {
		PyObject_SetAttrString(pyobjref, "total_face_sel", Py_BuildValue("i", value));
	}

	/** Getter: True when used in editmode */
	bool is_editmode() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "is_editmode")) == 1;
	}

	/** Setter: True when used in editmode */
	void is_editmode(bool value) {
		PyObject_SetAttrString(pyobjref, "is_editmode", Py_BuildValue("i", value));
	}

	/** Getter: Animation data for this datablock */
	AnimData animation_data() {
		/* not implemented */ throw NULL;
	}

	/** Getter: Adjust active object's texture space automatically when transforming object */
	bool auto_texspace() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "auto_texspace")) == 1;
	}

	/** Setter: Adjust active object's texture space automatically when transforming object */
	void auto_texspace(bool value) {
		PyObject_SetAttrString(pyobjref, "auto_texspace", Py_BuildValue("i", value));
	}

	/** Getter: Texture space location */
	std::array<float, 3> texspace_location() {
		// TODO: MISSING DEREF! USE #DEFINE!
		PyObject *seqval = PyObject_GetAttrString(pyobjref, "texspace_location");
		std::array<float, 3> resarr;
		for (int i = 0; i < 3; i++)
			resarr[i] = (float)PyFloat_AsDouble(PySequence_GetItem(seqval, i));
		return resarr;
	}

	/** Setter: Texture space location */
	void texspace_location(float values[3]) { /* not implemented */ }

	/** Getter: Texture space size */
	std::array<float, 3> texspace_size() {
		// TODO: MISSING DEREF! USE #DEFINE!
		PyObject *seqval = PyObject_GetAttrString(pyobjref, "texspace_size");
		std::array<float, 3> resarr;
		for (int i = 0; i < 3; i++)
			resarr[i] = (float)PyFloat_AsDouble(PySequence_GetItem(seqval, i));
		return resarr;
	}

	/** Setter: Texture space size */
	void texspace_size(float values[3]) { /* not implemented */ }

	/** Getter:  */
	std::map<std::string, Material> materials() {
		// TODO: MISSING DEREF! USE #DEFINE!
		PyObject *seqval = PyObject_GetAttrString(pyobjref, "materials");
		PyObject *seqkeys = PyObject_CallMethod(seqval, "keys", NULL);
		std::map<std::string, Material> resmap;
		for (int i = 0; i < PySequence_Length(seqval); i++) {
			PyObject *keyobj = PySequence_GetItem(seqkeys, i);
			std::string key = PyBytes_AsString(PyUnicode_AsASCIIString(keyobj));
			Material value = Material(PySequence_GetItem(seqval, i));
			resmap.insert(std::pair<std::string,Material>(key, value));
		}
		return resmap;
	}

	/** Setter:  */
	void materials(std::map<std::string, Material> value) { /* not implemented */ }

	/**
	 * Transform mesh vertices by a matrix
	 * @param Matrix
	 * @param Transform Shape Keys
	 */
	void transform(float matrix[16], bool shape_keys = false)
	{
		// not implemented
	}

	/**
	 * Calculate vertex normals
	 */
	void calc_normals()
	{
		// not implemented
	}

	/**
	 * Empty split vertex normals
	 */
	void create_normals_split()
	{
		// not implemented
	}

	/**
	 * Calculate split vertex normals, which preserve sharp edges
	 */
	void calc_normals_split()
	{
		// not implemented
	}

	/**
	 * Free split vertex normals
	 */
	void free_normals_split()
	{
		// not implemented
	}

	/**
	 * Compute tangents and bitangent signs, to be used together with the split normals to get a complete tangent space for normal mapping (split normals are also computed if not yet present)
	 * @param Name of the UV map to use for tangent space computation
	 */
	void calc_tangents(const std::string uvmap = NULL)
	{
		// not implemented
	}

	/**
	 * Free tangents
	 */
	void free_tangents()
	{
		// not implemented
	}

	/**
	 * Calculate face tessellation (supports editmode too)
	 * @param Free data used by polygons and loops. WARNING: This destructive operation removes regular faces, only used on temporary mesh data-blocks to reduce memory footprint of render engines and export scripts
	 */
	void calc_tessface(bool free_mpoly = false)
	{
		// not implemented
	}

	/**
	 * Container for the output of calc_smooth_groups()
	 */
	struct calc_smooth_groups_result {
		int poly_groups;	/**< Smooth Groups */
		int groups;	/**< Total number of groups */
	};

	/**
	 * Calculate smooth groups from sharp edges
	 * @param Produce bitflags groups instead of simple numeric values
	 * @return A calc_smooth_groups_result struct containing the output of this function
	 */
	calc_smooth_groups_result calc_smooth_groups(bool use_bitflags = false)
	{
		// not implemented
		return calc_smooth_groups_result();
	}

	/**
	 * Define custom split normals of this mesh (use zero-vectors to keep auto ones)
	 * @param Normals
	 */
	void normals_split_custom_set(int normals_len, float normals)
	{
		// not implemented
	}

	/**
	 * Define custom split normals of this mesh, from vertices' normals (use zero-vectors to keep auto ones)
	 * @param Normals
	 */
	void normals_split_custom_set_from_vertices(int normals_len, float normals)
	{
		// not implemented
	}

	/**
	 * Function: update
	 * @param Force recalculation of edges
	 * @param Force recalculation of tessellation faces
	 */
	void update(bool calc_edges = false, bool calc_tessface = false)
	{
		// not implemented
	}

	/**
	 * Function: unit_test_compare
	 * @param Mesh to compare to
	 * @return String description of result of comparison
	 */
	const std::string unit_test_compare(Mesh mesh)
	{
		// not implemented
		throw NULL;
	}

	/**
	 * Validate geometry, return True when the mesh has had invalid geometry corrected/removed
	 * @param Output information about the errors found
	 * @param Remove temp/cached custom-data layers, like e.g. normals...
	 * @return 
	 */
	bool validate(bool verbose = false, bool clean_customdata = true)
	{
		// not implemented
		return true;
	}

	/**
	 * Validate material indices of polygons, return True when the mesh has had invalid indices corrected (to default 0)
	 * @return 
	 */
	bool validate_material_indices()
	{
		// not implemented
		return true;
	}

};

/**************** Mesh Skin Vertex Layer ****************/

/**
 * Per-vertex skin data for use with the Skin modifier
 */
class MeshSkinVertexLayer : public pyUniplug {
public:
	MeshSkinVertexLayer(PyObject* pyobj) : pyUniplug(pyobj) {}

	MeshSkinVertexLayer() : pyUniplug(0)
	{
		// not implemented
	}

	/** Getter: Name of skin layer */
	std::string name() { /* not implemented */ throw NULL; }
	/** Setter: Name of skin layer */
	void name(const std::string& value) { /* not implemented */ }

	/** Getter:  */
	std::map<std::string, MeshSkinVertex> data();
	/** Setter:  */
	void data(std::map<std::string, MeshSkinVertex> value);

};

/**************** Skin Vertex ****************/

/**
 * Per-vertex skin data for use with the Skin modifier
 */
class MeshSkinVertex : public pyUniplug {
public:
	MeshSkinVertex(PyObject* pyobj) : pyUniplug(pyobj) {}

	MeshSkinVertex() : pyUniplug(0)
	{
		// not implemented
	}

	/** Getter: Radius of the skin */
	std::array<float, 2> radius() {
		// TODO: MISSING DEREF! USE #DEFINE!
		PyObject *seqval = PyObject_GetAttrString(pyobjref, "radius");
		std::array<float, 2> resarr;
		for (int i = 0; i < 2; i++)
			resarr[i] = (float)PyFloat_AsDouble(PySequence_GetItem(seqval, i));
		return resarr;
	}

	/** Setter: Radius of the skin */
	void radius(float values[2]) { /* not implemented */ }

	/** Getter: Vertex is a root for rotation calculations and armature generation */
	bool use_root() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_root")) == 1;
	}

	/** Setter: Vertex is a root for rotation calculations and armature generation */
	void use_root(bool value) {
		PyObject_SetAttrString(pyobjref, "use_root", Py_BuildValue("i", value));
	}

	/** Getter: If vertex has multiple adjacent edges, it is hulled to them directly */
	bool use_loose() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_loose")) == 1;
	}

	/** Setter: If vertex has multiple adjacent edges, it is hulled to them directly */
	void use_loose(bool value) {
		PyObject_SetAttrString(pyobjref, "use_loose", Py_BuildValue("i", value));
	}

};

/**************** Mesh Paint Mask Layer ****************/

/**
 * Per-vertex paint mask data
 */
class MeshPaintMaskLayer : public pyUniplug {
public:
	MeshPaintMaskLayer(PyObject* pyobj) : pyUniplug(pyobj) {}

	MeshPaintMaskLayer() : pyUniplug(0)
	{
		// not implemented
	}

	/** Getter:  */
	std::map<std::string, MeshPaintMaskProperty> data();
	/** Setter:  */
	void data(std::map<std::string, MeshPaintMaskProperty> value);

};

/**************** Mesh Paint Mask Property ****************/

/**
 * Floating point paint mask value
 */
class MeshPaintMaskProperty : public pyUniplug {
public:
	MeshPaintMaskProperty(PyObject* pyobj) : pyUniplug(pyobj) {}

	MeshPaintMaskProperty() : pyUniplug(0)
	{
		// not implemented
	}

	/** Getter:  */
	float value() { /* not implemented */ throw NULL; }
	/** Setter:  */
	void value(float value) {
		PyObject_SetAttrString(pyobjref, "value", Py_BuildValue("f", value));
	}

};

/**************** Mesh Vertex ****************/

/**
 * Vertex in a Mesh datablock
 */
class MeshVertex : public pyUniplug {
public:
	MeshVertex(PyObject* pyobj) : pyUniplug(pyobj) {}

	MeshVertex() : pyUniplug(0)
	{
		// not implemented
	}

	/** Getter:  */
	std::array<float, 3> co() {
		// TODO: MISSING DEREF! USE #DEFINE!
		PyObject *seqval = PyObject_GetAttrString(pyobjref, "co");
		std::array<float, 3> resarr;
		for (int i = 0; i < 3; i++)
			resarr[i] = (float)PyFloat_AsDouble(PySequence_GetItem(seqval, i));
		return resarr;
	}

	/** Setter:  */
	void co(float values[3]) { /* not implemented */ }

	/** Getter: Vertex Normal */
	std::array<float, 3> normal() {
		// TODO: MISSING DEREF! USE #DEFINE!
		PyObject *seqval = PyObject_GetAttrString(pyobjref, "normal");
		std::array<float, 3> resarr;
		for (int i = 0; i < 3; i++)
			resarr[i] = (float)PyFloat_AsDouble(PySequence_GetItem(seqval, i));
		return resarr;
	}

	/** Setter: Vertex Normal */
	void normal(float values[3]) { /* not implemented */ }

	/** Getter:  */
	bool select() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "select")) == 1;
	}

	/** Setter:  */
	void select(bool value) {
		PyObject_SetAttrString(pyobjref, "select", Py_BuildValue("i", value));
	}

	/** Getter:  */
	bool hide() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "hide")) == 1;
	}

	/** Setter:  */
	void hide(bool value) {
		PyObject_SetAttrString(pyobjref, "hide", Py_BuildValue("i", value));
	}

	/** Getter: Weight used by the Bevel modifier 'Only Vertices' option */
	float bevel_weight() { /* not implemented */ throw NULL; }
	/** Setter: Weight used by the Bevel modifier 'Only Vertices' option */
	void bevel_weight(float value) {
		PyObject_SetAttrString(pyobjref, "bevel_weight", Py_BuildValue("f", value));
	}

	/** Getter: Weights for the vertex groups this vertex is member of */
	std::map<std::string, VertexGroupElement> groups();
	/** Setter: Weights for the vertex groups this vertex is member of */
	void groups(std::map<std::string, VertexGroupElement> value);

	/** Getter: Index of this vertex */
	int index() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "index"));
	}

	/** Setter: Index of this vertex */
	void index(int value) {
		PyObject_SetAttrString(pyobjref, "index", Py_BuildValue("i", value));
	}

	/** Getter: For meshes with modifiers applied, the coordinate of the vertex with no deforming modifiers applied, as used for generated texture coordinates */
	std::array<float, 3> undeformed_co() {
		// TODO: MISSING DEREF! USE #DEFINE!
		PyObject *seqval = PyObject_GetAttrString(pyobjref, "undeformed_co");
		std::array<float, 3> resarr;
		for (int i = 0; i < 3; i++)
			resarr[i] = (float)PyFloat_AsDouble(PySequence_GetItem(seqval, i));
		return resarr;
	}

	/** Setter: For meshes with modifiers applied, the coordinate of the vertex with no deforming modifiers applied, as used for generated texture coordinates */
	void undeformed_co(float values[3]) { /* not implemented */ }

};

/**************** Vertex Group Element ****************/

/**
 * Weight value of a vertex in a vertex group
 */
class VertexGroupElement : public pyUniplug {
public:
	VertexGroupElement(PyObject* pyobj) : pyUniplug(pyobj) {}

	VertexGroupElement() : pyUniplug(0)
	{
		// not implemented
	}

	/** Getter:  */
	int group() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "group"));
	}

	/** Setter:  */
	void group(int value) {
		PyObject_SetAttrString(pyobjref, "group", Py_BuildValue("i", value));
	}

	/** Getter: Vertex Weight */
	float weight() { /* not implemented */ throw NULL; }
	/** Setter: Vertex Weight */
	void weight(float value) {
		PyObject_SetAttrString(pyobjref, "weight", Py_BuildValue("f", value));
	}

};

/**************** Mesh Edge ****************/

/**
 * Edge in a Mesh datablock
 */
class MeshEdge : public pyUniplug {
public:
	MeshEdge(PyObject* pyobj) : pyUniplug(pyobj) {}

	MeshEdge() : pyUniplug(0)
	{
		// not implemented
	}

	/** Getter: Vertex indices */
	std::array<int, 2> vertices() {
		// TODO: MISSING DEREF! USE #DEFINE!
		PyObject *seqval = PyObject_GetAttrString(pyobjref, "vertices");
		std::array<int, 2> resarr;
		for (int i = 0; i < 2; i++)
			resarr[i] = PyLong_AsLong(PySequence_GetItem(seqval, i));
		return resarr;
	}

	/** Setter: Vertex indices */
	void vertices(int values[2]) { /* not implemented */ }

	/** Getter: Weight used by the Subsurf modifier for creasing */
	float crease() { /* not implemented */ throw NULL; }
	/** Setter: Weight used by the Subsurf modifier for creasing */
	void crease(float value) {
		PyObject_SetAttrString(pyobjref, "crease", Py_BuildValue("f", value));
	}

	/** Getter: Weight used by the Bevel modifier */
	float bevel_weight() { /* not implemented */ throw NULL; }
	/** Setter: Weight used by the Bevel modifier */
	void bevel_weight(float value) {
		PyObject_SetAttrString(pyobjref, "bevel_weight", Py_BuildValue("f", value));
	}

	/** Getter:  */
	bool select() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "select")) == 1;
	}

	/** Setter:  */
	void select(bool value) {
		PyObject_SetAttrString(pyobjref, "select", Py_BuildValue("i", value));
	}

	/** Getter:  */
	bool hide() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "hide")) == 1;
	}

	/** Setter:  */
	void hide(bool value) {
		PyObject_SetAttrString(pyobjref, "hide", Py_BuildValue("i", value));
	}

	/** Getter: Seam edge for UV unwrapping */
	bool use_seam() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_seam")) == 1;
	}

	/** Setter: Seam edge for UV unwrapping */
	void use_seam(bool value) {
		PyObject_SetAttrString(pyobjref, "use_seam", Py_BuildValue("i", value));
	}

	/** Getter: Sharp edge for the EdgeSplit modifier */
	bool use_edge_sharp() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_edge_sharp")) == 1;
	}

	/** Setter: Sharp edge for the EdgeSplit modifier */
	void use_edge_sharp(bool value) {
		PyObject_SetAttrString(pyobjref, "use_edge_sharp", Py_BuildValue("i", value));
	}

	/** Getter: Loose edge */
	bool is_loose() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "is_loose")) == 1;
	}

	/** Setter: Loose edge */
	void is_loose(bool value) {
		PyObject_SetAttrString(pyobjref, "is_loose", Py_BuildValue("i", value));
	}

	/** Getter: Edge mark for Freestyle line rendering */
	bool use_freestyle_mark() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_freestyle_mark")) == 1;
	}

	/** Setter: Edge mark for Freestyle line rendering */
	void use_freestyle_mark(bool value) {
		PyObject_SetAttrString(pyobjref, "use_freestyle_mark", Py_BuildValue("i", value));
	}

	/** Getter: Index of this edge */
	int index() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "index"));
	}

	/** Setter: Index of this edge */
	void index(int value) {
		PyObject_SetAttrString(pyobjref, "index", Py_BuildValue("i", value));
	}

};

/**************** Mesh TessFace ****************/

/**
 * TessFace in a Mesh datablock
 */
class MeshTessFace : public pyUniplug {
public:
	MeshTessFace(PyObject* pyobj) : pyUniplug(pyobj) {}

	MeshTessFace() : pyUniplug(0)
	{
		// not implemented
	}

	/** Getter: Vertex indices */
	std::array<int, 4> vertices() {
		// TODO: MISSING DEREF! USE #DEFINE!
		PyObject *seqval = PyObject_GetAttrString(pyobjref, "vertices");
		std::array<int, 4> resarr;
		for (int i = 0; i < 4; i++)
			resarr[i] = PyLong_AsLong(PySequence_GetItem(seqval, i));
		return resarr;
	}

	/** Setter: Vertex indices */
	void vertices(int values[4]) { /* not implemented */ }

	/** Getter: Fixed size vertex indices array */
	std::array<int, 4> vertices_raw() {
		// TODO: MISSING DEREF! USE #DEFINE!
		PyObject *seqval = PyObject_GetAttrString(pyobjref, "vertices_raw");
		std::array<int, 4> resarr;
		for (int i = 0; i < 4; i++)
			resarr[i] = PyLong_AsLong(PySequence_GetItem(seqval, i));
		return resarr;
	}

	/** Setter: Fixed size vertex indices array */
	void vertices_raw(int values[4]) { /* not implemented */ }

	/** Getter:  */
	int material_index() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "material_index"));
	}

	/** Setter:  */
	void material_index(int value) {
		PyObject_SetAttrString(pyobjref, "material_index", Py_BuildValue("i", value));
	}

	/** Getter:  */
	bool select() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "select")) == 1;
	}

	/** Setter:  */
	void select(bool value) {
		PyObject_SetAttrString(pyobjref, "select", Py_BuildValue("i", value));
	}

	/** Getter:  */
	bool hide() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "hide")) == 1;
	}

	/** Setter:  */
	void hide(bool value) {
		PyObject_SetAttrString(pyobjref, "hide", Py_BuildValue("i", value));
	}

	/** Getter:  */
	bool use_smooth() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_smooth")) == 1;
	}

	/** Setter:  */
	void use_smooth(bool value) {
		PyObject_SetAttrString(pyobjref, "use_smooth", Py_BuildValue("i", value));
	}

	/** Getter: Local space unit length normal vector for this face */
	std::array<float, 3> normal() {
		// TODO: MISSING DEREF! USE #DEFINE!
		PyObject *seqval = PyObject_GetAttrString(pyobjref, "normal");
		std::array<float, 3> resarr;
		for (int i = 0; i < 3; i++)
			resarr[i] = (float)PyFloat_AsDouble(PySequence_GetItem(seqval, i));
		return resarr;
	}

	/** Setter: Local space unit length normal vector for this face */
	void normal(float values[3]) { /* not implemented */ }

	/** Getter: Local space unit length split normals vectors of the vertices of this face (must be computed beforehand using calc_normals_split or calc_tangents, and then calc_tessface) */
	std::array<float, 12> split_normals() {
		// TODO: MISSING DEREF! USE #DEFINE!
		PyObject *seqval = PyObject_GetAttrString(pyobjref, "split_normals");
		std::array<float, 12> resarr;
		for (int i = 0; i < 12; i++)
			resarr[i] = (float)PyFloat_AsDouble(PySequence_GetItem(seqval, i));
		return resarr;
	}

	/** Setter: Local space unit length split normals vectors of the vertices of this face (must be computed beforehand using calc_normals_split or calc_tangents, and then calc_tessface) */
	void split_normals(float values[12]) { /* not implemented */ }

	/** Getter: Read only area of this face */
	float area() { /* not implemented */ throw NULL; }
	/** Setter: Read only area of this face */
	void area(float value) {
		PyObject_SetAttrString(pyobjref, "area", Py_BuildValue("f", value));
	}

	/** Getter: Index of this face */
	int index() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "index"));
	}

	/** Setter: Index of this face */
	void index(int value) {
		PyObject_SetAttrString(pyobjref, "index", Py_BuildValue("i", value));
	}

};

/**************** Mesh Loop ****************/

/**
 * Loop in a Mesh datablock
 */
class MeshLoop : public pyUniplug {
public:
	MeshLoop(PyObject* pyobj) : pyUniplug(pyobj) {}

	MeshLoop() : pyUniplug(0)
	{
		// not implemented
	}

	/** Getter: Vertex index */
	int vertex_index() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "vertex_index"));
	}

	/** Setter: Vertex index */
	void vertex_index(int value) {
		PyObject_SetAttrString(pyobjref, "vertex_index", Py_BuildValue("i", value));
	}

	/** Getter: Edge index */
	int edge_index() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "edge_index"));
	}

	/** Setter: Edge index */
	void edge_index(int value) {
		PyObject_SetAttrString(pyobjref, "edge_index", Py_BuildValue("i", value));
	}

	/** Getter: Index of this loop */
	int index() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "index"));
	}

	/** Setter: Index of this loop */
	void index(int value) {
		PyObject_SetAttrString(pyobjref, "index", Py_BuildValue("i", value));
	}

	/** Getter: Local space unit length split normal vector of this vertex for this polygon (must be computed beforehand using calc_normals_split or calc_tangents) */
	std::array<float, 3> normal() {
		// TODO: MISSING DEREF! USE #DEFINE!
		PyObject *seqval = PyObject_GetAttrString(pyobjref, "normal");
		std::array<float, 3> resarr;
		for (int i = 0; i < 3; i++)
			resarr[i] = (float)PyFloat_AsDouble(PySequence_GetItem(seqval, i));
		return resarr;
	}

	/** Setter: Local space unit length split normal vector of this vertex for this polygon (must be computed beforehand using calc_normals_split or calc_tangents) */
	void normal(float values[3]) { /* not implemented */ }

	/** Getter: Local space unit length tangent vector of this vertex for this polygon (must be computed beforehand using calc_tangents) */
	std::array<float, 3> tangent() {
		// TODO: MISSING DEREF! USE #DEFINE!
		PyObject *seqval = PyObject_GetAttrString(pyobjref, "tangent");
		std::array<float, 3> resarr;
		for (int i = 0; i < 3; i++)
			resarr[i] = (float)PyFloat_AsDouble(PySequence_GetItem(seqval, i));
		return resarr;
	}

	/** Setter: Local space unit length tangent vector of this vertex for this polygon (must be computed beforehand using calc_tangents) */
	void tangent(float values[3]) { /* not implemented */ }

	/** Getter: Sign of the bitangent vector of this vertex for this polygon (must be computed beforehand using calc_tangents, bitangent = bitangent_sign * cross(normal, tangent)) */
	float bitangent_sign() { /* not implemented */ throw NULL; }
	/** Setter: Sign of the bitangent vector of this vertex for this polygon (must be computed beforehand using calc_tangents, bitangent = bitangent_sign * cross(normal, tangent)) */
	void bitangent_sign(float value) {
		PyObject_SetAttrString(pyobjref, "bitangent_sign", Py_BuildValue("f", value));
	}

	/** Getter: Bitangent vector of this vertex for this polygon (must be computed beforehand using calc_tangents, *use it only if really needed*, slower access than bitangent_sign) */
	std::array<float, 3> bitangent() {
		// TODO: MISSING DEREF! USE #DEFINE!
		PyObject *seqval = PyObject_GetAttrString(pyobjref, "bitangent");
		std::array<float, 3> resarr;
		for (int i = 0; i < 3; i++)
			resarr[i] = (float)PyFloat_AsDouble(PySequence_GetItem(seqval, i));
		return resarr;
	}

	/** Setter: Bitangent vector of this vertex for this polygon (must be computed beforehand using calc_tangents, *use it only if really needed*, slower access than bitangent_sign) */
	void bitangent(float values[3]) { /* not implemented */ }

};

/**************** Mesh Polygon ****************/

/**
 * Polygon in a Mesh datablock
 */
class MeshPolygon : public pyUniplug {
public:
	MeshPolygon(PyObject* pyobj) : pyUniplug(pyobj) {}

	MeshPolygon() : pyUniplug(0)
	{
		// not implemented
	}

	/** Getter: Vertex indices */
	std::array<int, 3> vertices() {
		// TODO: MISSING DEREF! USE #DEFINE!
		PyObject *seqval = PyObject_GetAttrString(pyobjref, "vertices");
		std::array<int, 3> resarr;
		for (int i = 0; i < 3; i++)
			resarr[i] = PyLong_AsLong(PySequence_GetItem(seqval, i));
		return resarr;
	}

	/** Setter: Vertex indices */
	void vertices(int values[3]) { /* not implemented */ }

	/** Getter: Index of the first loop of this polygon */
	int loop_start() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "loop_start"));
	}

	/** Setter: Index of the first loop of this polygon */
	void loop_start(int value) {
		PyObject_SetAttrString(pyobjref, "loop_start", Py_BuildValue("i", value));
	}

	/** Getter: Number of loops used by this polygon */
	int loop_total() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "loop_total"));
	}

	/** Setter: Number of loops used by this polygon */
	void loop_total(int value) {
		PyObject_SetAttrString(pyobjref, "loop_total", Py_BuildValue("i", value));
	}

	/** Getter:  */
	int material_index() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "material_index"));
	}

	/** Setter:  */
	void material_index(int value) {
		PyObject_SetAttrString(pyobjref, "material_index", Py_BuildValue("i", value));
	}

	/** Getter:  */
	bool select() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "select")) == 1;
	}

	/** Setter:  */
	void select(bool value) {
		PyObject_SetAttrString(pyobjref, "select", Py_BuildValue("i", value));
	}

	/** Getter:  */
	bool hide() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "hide")) == 1;
	}

	/** Setter:  */
	void hide(bool value) {
		PyObject_SetAttrString(pyobjref, "hide", Py_BuildValue("i", value));
	}

	/** Getter:  */
	bool use_smooth() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_smooth")) == 1;
	}

	/** Setter:  */
	void use_smooth(bool value) {
		PyObject_SetAttrString(pyobjref, "use_smooth", Py_BuildValue("i", value));
	}

	/** Getter: Face mark for Freestyle line rendering */
	bool use_freestyle_mark() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_freestyle_mark")) == 1;
	}

	/** Setter: Face mark for Freestyle line rendering */
	void use_freestyle_mark(bool value) {
		PyObject_SetAttrString(pyobjref, "use_freestyle_mark", Py_BuildValue("i", value));
	}

	/** Getter: Local space unit length normal vector for this polygon */
	std::array<float, 3> normal() {
		// TODO: MISSING DEREF! USE #DEFINE!
		PyObject *seqval = PyObject_GetAttrString(pyobjref, "normal");
		std::array<float, 3> resarr;
		for (int i = 0; i < 3; i++)
			resarr[i] = (float)PyFloat_AsDouble(PySequence_GetItem(seqval, i));
		return resarr;
	}

	/** Setter: Local space unit length normal vector for this polygon */
	void normal(float values[3]) { /* not implemented */ }

	/** Getter: Center of this polygon */
	std::array<float, 3> center() {
		// TODO: MISSING DEREF! USE #DEFINE!
		PyObject *seqval = PyObject_GetAttrString(pyobjref, "center");
		std::array<float, 3> resarr;
		for (int i = 0; i < 3; i++)
			resarr[i] = (float)PyFloat_AsDouble(PySequence_GetItem(seqval, i));
		return resarr;
	}

	/** Setter: Center of this polygon */
	void center(float values[3]) { /* not implemented */ }

	/** Getter: Read only area of this polygon */
	float area() { /* not implemented */ throw NULL; }
	/** Setter: Read only area of this polygon */
	void area(float value) {
		PyObject_SetAttrString(pyobjref, "area", Py_BuildValue("f", value));
	}

	/** Getter: Index of this polygon */
	int index() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "index"));
	}

	/** Setter: Index of this polygon */
	void index(int value) {
		PyObject_SetAttrString(pyobjref, "index", Py_BuildValue("i", value));
	}

};

/**************** MeshUVLoopLayer ****************/

/**
 * 
 */
class MeshUVLoopLayer : public pyUniplug {
public:
	MeshUVLoopLayer(PyObject* pyobj) : pyUniplug(pyobj) {}

	MeshUVLoopLayer() : pyUniplug(0)
	{
		// not implemented
	}

	/** Getter:  */
	std::map<std::string, MeshUVLoop> data();
	/** Setter:  */
	void data(std::map<std::string, MeshUVLoop> value);

	/** Getter: Name of UV map */
	std::string name() { /* not implemented */ throw NULL; }
	/** Setter: Name of UV map */
	void name(const std::string& value) { /* not implemented */ }

};

/**************** MeshUVLoop ****************/

/**
 * 
 */
class MeshUVLoop : public pyUniplug {
public:
	MeshUVLoop(PyObject* pyobj) : pyUniplug(pyobj) {}

	MeshUVLoop() : pyUniplug(0)
	{
		// not implemented
	}

	/** Getter:  */
	std::array<float, 2> uv() {
		// TODO: MISSING DEREF! USE #DEFINE!
		PyObject *seqval = PyObject_GetAttrString(pyobjref, "uv");
		std::array<float, 2> resarr;
		for (int i = 0; i < 2; i++)
			resarr[i] = (float)PyFloat_AsDouble(PySequence_GetItem(seqval, i));
		return resarr;
	}

	/** Setter:  */
	void uv(float values[2]) { /* not implemented */ }

	/** Getter:  */
	bool pin_uv() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "pin_uv")) == 1;
	}

	/** Setter:  */
	void pin_uv(bool value) {
		PyObject_SetAttrString(pyobjref, "pin_uv", Py_BuildValue("i", value));
	}

	/** Getter:  */
	bool select() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "select")) == 1;
	}

	/** Setter:  */
	void select(bool value) {
		PyObject_SetAttrString(pyobjref, "select", Py_BuildValue("i", value));
	}

	/** Getter:  */
	bool select_edge() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "select_edge")) == 1;
	}

	/** Setter:  */
	void select_edge(bool value) {
		PyObject_SetAttrString(pyobjref, "select_edge", Py_BuildValue("i", value));
	}

};

/**************** Mesh UV Map ****************/

/**
 * UV map with assigned image textures in a Mesh datablock
 */
class MeshTextureFaceLayer : public pyUniplug {
public:
	MeshTextureFaceLayer(PyObject* pyobj) : pyUniplug(pyobj) {}

	MeshTextureFaceLayer() : pyUniplug(0)
	{
		// not implemented
	}

	/** Getter: Name of UV map */
	std::string name() { /* not implemented */ throw NULL; }
	/** Setter: Name of UV map */
	void name(const std::string& value) { /* not implemented */ }

	/** Getter: Set the map as active for display and editing */
	bool active() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "active")) == 1;
	}

	/** Setter: Set the map as active for display and editing */
	void active(bool value) {
		PyObject_SetAttrString(pyobjref, "active", Py_BuildValue("i", value));
	}

	/** Getter: Set the map as active for rendering */
	bool active_render() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "active_render")) == 1;
	}

	/** Setter: Set the map as active for rendering */
	void active_render(bool value) {
		PyObject_SetAttrString(pyobjref, "active_render", Py_BuildValue("i", value));
	}

	/** Getter: Set the map as active for cloning */
	bool active_clone() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "active_clone")) == 1;
	}

	/** Setter: Set the map as active for cloning */
	void active_clone(bool value) {
		PyObject_SetAttrString(pyobjref, "active_clone", Py_BuildValue("i", value));
	}

	/** Getter:  */
	std::map<std::string, MeshTextureFace> data();
	/** Setter:  */
	void data(std::map<std::string, MeshTextureFace> value);

};

/**************** Mesh UV Map Face ****************/

/**
 * UV map and image texture for a face
 */
class MeshTextureFace : public pyUniplug {
public:
	MeshTextureFace(PyObject* pyobj) : pyUniplug(pyobj) {}

	MeshTextureFace() : pyUniplug(0)
	{
		// not implemented
	}

	/** Getter:  */
	Image image() {
		/* not implemented */ throw NULL;
	}

	/** Getter:  */
	std::array<float, 2> uv1() {
		// TODO: MISSING DEREF! USE #DEFINE!
		PyObject *seqval = PyObject_GetAttrString(pyobjref, "uv1");
		std::array<float, 2> resarr;
		for (int i = 0; i < 2; i++)
			resarr[i] = (float)PyFloat_AsDouble(PySequence_GetItem(seqval, i));
		return resarr;
	}

	/** Setter:  */
	void uv1(float values[2]) { /* not implemented */ }

	/** Getter:  */
	std::array<float, 2> uv2() {
		// TODO: MISSING DEREF! USE #DEFINE!
		PyObject *seqval = PyObject_GetAttrString(pyobjref, "uv2");
		std::array<float, 2> resarr;
		for (int i = 0; i < 2; i++)
			resarr[i] = (float)PyFloat_AsDouble(PySequence_GetItem(seqval, i));
		return resarr;
	}

	/** Setter:  */
	void uv2(float values[2]) { /* not implemented */ }

	/** Getter:  */
	std::array<float, 2> uv3() {
		// TODO: MISSING DEREF! USE #DEFINE!
		PyObject *seqval = PyObject_GetAttrString(pyobjref, "uv3");
		std::array<float, 2> resarr;
		for (int i = 0; i < 2; i++)
			resarr[i] = (float)PyFloat_AsDouble(PySequence_GetItem(seqval, i));
		return resarr;
	}

	/** Setter:  */
	void uv3(float values[2]) { /* not implemented */ }

	/** Getter:  */
	std::array<float, 2> uv4() {
		// TODO: MISSING DEREF! USE #DEFINE!
		PyObject *seqval = PyObject_GetAttrString(pyobjref, "uv4");
		std::array<float, 2> resarr;
		for (int i = 0; i < 2; i++)
			resarr[i] = (float)PyFloat_AsDouble(PySequence_GetItem(seqval, i));
		return resarr;
	}

	/** Setter:  */
	void uv4(float values[2]) { /* not implemented */ }

	/** Getter:  */
	std::array<float, 8> uv() {
		// TODO: MISSING DEREF! USE #DEFINE!
		PyObject *seqval = PyObject_GetAttrString(pyobjref, "uv");
		std::array<float, 8> resarr;
		for (int i = 0; i < 8; i++)
			resarr[i] = (float)PyFloat_AsDouble(PySequence_GetItem(seqval, i));
		return resarr;
	}

	/** Setter:  */
	void uv(float values[8]) { /* not implemented */ }

	/** Getter: Fixed size UV coordinates array */
	std::array<float, 8> uv_raw() {
		// TODO: MISSING DEREF! USE #DEFINE!
		PyObject *seqval = PyObject_GetAttrString(pyobjref, "uv_raw");
		std::array<float, 8> resarr;
		for (int i = 0; i < 8; i++)
			resarr[i] = (float)PyFloat_AsDouble(PySequence_GetItem(seqval, i));
		return resarr;
	}

	/** Setter: Fixed size UV coordinates array */
	void uv_raw(float values[8]) { /* not implemented */ }

};

/**************** Mesh UV Map ****************/

/**
 * UV map with assigned image textures in a Mesh datablock
 */
class MeshTexturePolyLayer : public pyUniplug {
public:
	MeshTexturePolyLayer(PyObject* pyobj) : pyUniplug(pyobj) {}

	MeshTexturePolyLayer() : pyUniplug(0)
	{
		// not implemented
	}

	/** Getter: Name of UV map */
	std::string name() { /* not implemented */ throw NULL; }
	/** Setter: Name of UV map */
	void name(const std::string& value) { /* not implemented */ }

	/** Getter: Set the map as active for display and editing */
	bool active() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "active")) == 1;
	}

	/** Setter: Set the map as active for display and editing */
	void active(bool value) {
		PyObject_SetAttrString(pyobjref, "active", Py_BuildValue("i", value));
	}

	/** Getter: Set the map as active for rendering */
	bool active_render() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "active_render")) == 1;
	}

	/** Setter: Set the map as active for rendering */
	void active_render(bool value) {
		PyObject_SetAttrString(pyobjref, "active_render", Py_BuildValue("i", value));
	}

	/** Getter: Set the map as active for cloning */
	bool active_clone() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "active_clone")) == 1;
	}

	/** Setter: Set the map as active for cloning */
	void active_clone(bool value) {
		PyObject_SetAttrString(pyobjref, "active_clone", Py_BuildValue("i", value));
	}

	/** Getter:  */
	std::map<std::string, MeshTexturePoly> data();
	/** Setter:  */
	void data(std::map<std::string, MeshTexturePoly> value);

};

/**************** Mesh UV Map Face ****************/

/**
 * UV map and image texture for a face
 */
class MeshTexturePoly : public pyUniplug {
public:
	MeshTexturePoly(PyObject* pyobj) : pyUniplug(pyobj) {}

	MeshTexturePoly() : pyUniplug(0)
	{
		// not implemented
	}

	/** Getter:  */
	Image image() {
		/* not implemented */ throw NULL;
	}

};

/**************** Mesh Vertex Color Layer ****************/

/**
 * Layer of vertex colors in a Mesh datablock
 */
class MeshColorLayer : public pyUniplug {
public:
	MeshColorLayer(PyObject* pyobj) : pyUniplug(pyobj) {}

	MeshColorLayer() : pyUniplug(0)
	{
		// not implemented
	}

	/** Getter: Name of Vertex color layer */
	std::string name() { /* not implemented */ throw NULL; }
	/** Setter: Name of Vertex color layer */
	void name(const std::string& value) { /* not implemented */ }

	/** Getter: Sets the layer as active for display and editing */
	bool active() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "active")) == 1;
	}

	/** Setter: Sets the layer as active for display and editing */
	void active(bool value) {
		PyObject_SetAttrString(pyobjref, "active", Py_BuildValue("i", value));
	}

	/** Getter: Sets the layer as active for rendering */
	bool active_render() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "active_render")) == 1;
	}

	/** Setter: Sets the layer as active for rendering */
	void active_render(bool value) {
		PyObject_SetAttrString(pyobjref, "active_render", Py_BuildValue("i", value));
	}

	/** Getter:  */
	std::map<std::string, MeshColor> data();
	/** Setter:  */
	void data(std::map<std::string, MeshColor> value);

};

/**************** Mesh Vertex Color ****************/

/**
 * Vertex colors for a face in a Mesh
 */
class MeshColor : public pyUniplug {
public:
	MeshColor(PyObject* pyobj) : pyUniplug(pyobj) {}

	MeshColor() : pyUniplug(0)
	{
		// not implemented
	}

	/** Getter:  */
	std::array<float, 3> color1() {
		// TODO: MISSING DEREF! USE #DEFINE!
		PyObject *seqval = PyObject_GetAttrString(pyobjref, "color1");
		std::array<float, 3> resarr;
		for (int i = 0; i < 3; i++)
			resarr[i] = (float)PyFloat_AsDouble(PySequence_GetItem(seqval, i));
		return resarr;
	}

	/** Setter:  */
	void color1(float values[3]) { /* not implemented */ }

	/** Getter:  */
	std::array<float, 3> color2() {
		// TODO: MISSING DEREF! USE #DEFINE!
		PyObject *seqval = PyObject_GetAttrString(pyobjref, "color2");
		std::array<float, 3> resarr;
		for (int i = 0; i < 3; i++)
			resarr[i] = (float)PyFloat_AsDouble(PySequence_GetItem(seqval, i));
		return resarr;
	}

	/** Setter:  */
	void color2(float values[3]) { /* not implemented */ }

	/** Getter:  */
	std::array<float, 3> color3() {
		// TODO: MISSING DEREF! USE #DEFINE!
		PyObject *seqval = PyObject_GetAttrString(pyobjref, "color3");
		std::array<float, 3> resarr;
		for (int i = 0; i < 3; i++)
			resarr[i] = (float)PyFloat_AsDouble(PySequence_GetItem(seqval, i));
		return resarr;
	}

	/** Setter:  */
	void color3(float values[3]) { /* not implemented */ }

	/** Getter:  */
	std::array<float, 3> color4() {
		// TODO: MISSING DEREF! USE #DEFINE!
		PyObject *seqval = PyObject_GetAttrString(pyobjref, "color4");
		std::array<float, 3> resarr;
		for (int i = 0; i < 3; i++)
			resarr[i] = (float)PyFloat_AsDouble(PySequence_GetItem(seqval, i));
		return resarr;
	}

	/** Setter:  */
	void color4(float values[3]) { /* not implemented */ }

};

/**************** Mesh Vertex Color Layer ****************/

/**
 * Layer of vertex colors in a Mesh datablock
 */
class MeshLoopColorLayer : public pyUniplug {
public:
	MeshLoopColorLayer(PyObject* pyobj) : pyUniplug(pyobj) {}

	MeshLoopColorLayer() : pyUniplug(0)
	{
		// not implemented
	}

	/** Getter: Name of Vertex color layer */
	std::string name() { /* not implemented */ throw NULL; }
	/** Setter: Name of Vertex color layer */
	void name(const std::string& value) { /* not implemented */ }

	/** Getter: Sets the layer as active for display and editing */
	bool active() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "active")) == 1;
	}

	/** Setter: Sets the layer as active for display and editing */
	void active(bool value) {
		PyObject_SetAttrString(pyobjref, "active", Py_BuildValue("i", value));
	}

	/** Getter: Sets the layer as active for rendering */
	bool active_render() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "active_render")) == 1;
	}

	/** Setter: Sets the layer as active for rendering */
	void active_render(bool value) {
		PyObject_SetAttrString(pyobjref, "active_render", Py_BuildValue("i", value));
	}

	/** Getter:  */
	std::map<std::string, MeshLoopColor> data();
	/** Setter:  */
	void data(std::map<std::string, MeshLoopColor> value);

};

/**************** Mesh Vertex Color ****************/

/**
 * Vertex loop colors in a Mesh
 */
class MeshLoopColor : public pyUniplug {
public:
	MeshLoopColor(PyObject* pyobj) : pyUniplug(pyobj) {}

	MeshLoopColor() : pyUniplug(0)
	{
		// not implemented
	}

	/** Getter:  */
	std::array<float, 3> color() {
		// TODO: MISSING DEREF! USE #DEFINE!
		PyObject *seqval = PyObject_GetAttrString(pyobjref, "color");
		std::array<float, 3> resarr;
		for (int i = 0; i < 3; i++)
			resarr[i] = (float)PyFloat_AsDouble(PySequence_GetItem(seqval, i));
		return resarr;
	}

	/** Setter:  */
	void color(float values[3]) { /* not implemented */ }

};

/**************** Mesh Vertex Float Property Layer ****************/

/**
 * User defined layer of floating point number values
 */
class MeshVertexFloatPropertyLayer : public pyUniplug {
public:
	MeshVertexFloatPropertyLayer(PyObject* pyobj) : pyUniplug(pyobj) {}

	MeshVertexFloatPropertyLayer() : pyUniplug(0)
	{
		// not implemented
	}

	/** Getter:  */
	std::string name() { /* not implemented */ throw NULL; }
	/** Setter:  */
	void name(const std::string& value) { /* not implemented */ }

	/** Getter:  */
	std::map<std::string, MeshVertexFloatProperty> data();
	/** Setter:  */
	void data(std::map<std::string, MeshVertexFloatProperty> value);

};

/**************** Mesh Vertex Float Property ****************/

/**
 * User defined floating point number value in a float properties layer
 */
class MeshVertexFloatProperty : public pyUniplug {
public:
	MeshVertexFloatProperty(PyObject* pyobj) : pyUniplug(pyobj) {}

	MeshVertexFloatProperty() : pyUniplug(0)
	{
		// not implemented
	}

	/** Getter:  */
	float value() { /* not implemented */ throw NULL; }
	/** Setter:  */
	void value(float value) {
		PyObject_SetAttrString(pyobjref, "value", Py_BuildValue("f", value));
	}

};

/**************** Mesh Polygon Float Property Layer ****************/

/**
 * User defined layer of floating point number values
 */
class MeshPolygonFloatPropertyLayer : public pyUniplug {
public:
	MeshPolygonFloatPropertyLayer(PyObject* pyobj) : pyUniplug(pyobj) {}

	MeshPolygonFloatPropertyLayer() : pyUniplug(0)
	{
		// not implemented
	}

	/** Getter:  */
	std::string name() { /* not implemented */ throw NULL; }
	/** Setter:  */
	void name(const std::string& value) { /* not implemented */ }

	/** Getter:  */
	std::map<std::string, MeshPolygonFloatProperty> data();
	/** Setter:  */
	void data(std::map<std::string, MeshPolygonFloatProperty> value);

};

/**************** Mesh Polygon Float Property ****************/

/**
 * User defined floating point number value in a float properties layer
 */
class MeshPolygonFloatProperty : public pyUniplug {
public:
	MeshPolygonFloatProperty(PyObject* pyobj) : pyUniplug(pyobj) {}

	MeshPolygonFloatProperty() : pyUniplug(0)
	{
		// not implemented
	}

	/** Getter:  */
	float value() { /* not implemented */ throw NULL; }
	/** Setter:  */
	void value(float value) {
		PyObject_SetAttrString(pyobjref, "value", Py_BuildValue("f", value));
	}

};

/**************** Mesh Vertex Int Property Layer ****************/

/**
 * User defined layer of integer number values
 */
class MeshVertexIntPropertyLayer : public pyUniplug {
public:
	MeshVertexIntPropertyLayer(PyObject* pyobj) : pyUniplug(pyobj) {}

	MeshVertexIntPropertyLayer() : pyUniplug(0)
	{
		// not implemented
	}

	/** Getter:  */
	std::string name() { /* not implemented */ throw NULL; }
	/** Setter:  */
	void name(const std::string& value) { /* not implemented */ }

	/** Getter:  */
	std::map<std::string, MeshVertexIntProperty> data();
	/** Setter:  */
	void data(std::map<std::string, MeshVertexIntProperty> value);

};

/**************** Mesh Vertex Int Property ****************/

/**
 * User defined integer number value in an integer properties layer
 */
class MeshVertexIntProperty : public pyUniplug {
public:
	MeshVertexIntProperty(PyObject* pyobj) : pyUniplug(pyobj) {}

	MeshVertexIntProperty() : pyUniplug(0)
	{
		// not implemented
	}

	/** Getter:  */
	int value() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "value"));
	}

	/** Setter:  */
	void value(int value) {
		PyObject_SetAttrString(pyobjref, "value", Py_BuildValue("i", value));
	}

};

/**************** Mesh Polygon Int Property Layer ****************/

/**
 * User defined layer of integer number values
 */
class MeshPolygonIntPropertyLayer : public pyUniplug {
public:
	MeshPolygonIntPropertyLayer(PyObject* pyobj) : pyUniplug(pyobj) {}

	MeshPolygonIntPropertyLayer() : pyUniplug(0)
	{
		// not implemented
	}

	/** Getter:  */
	std::string name() { /* not implemented */ throw NULL; }
	/** Setter:  */
	void name(const std::string& value) { /* not implemented */ }

	/** Getter:  */
	std::map<std::string, MeshPolygonIntProperty> data();
	/** Setter:  */
	void data(std::map<std::string, MeshPolygonIntProperty> value);

};

/**************** Mesh Polygon Int Property ****************/

/**
 * User defined integer number value in an integer properties layer
 */
class MeshPolygonIntProperty : public pyUniplug {
public:
	MeshPolygonIntProperty(PyObject* pyobj) : pyUniplug(pyobj) {}

	MeshPolygonIntProperty() : pyUniplug(0)
	{
		// not implemented
	}

	/** Getter:  */
	int value() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "value"));
	}

	/** Setter:  */
	void value(int value) {
		PyObject_SetAttrString(pyobjref, "value", Py_BuildValue("i", value));
	}

};

/**************** Mesh Vertex String Property Layer ****************/

/**
 * User defined layer of string text values
 */
class MeshVertexStringPropertyLayer : public pyUniplug {
public:
	MeshVertexStringPropertyLayer(PyObject* pyobj) : pyUniplug(pyobj) {}

	MeshVertexStringPropertyLayer() : pyUniplug(0)
	{
		// not implemented
	}

	/** Getter:  */
	std::string name() { /* not implemented */ throw NULL; }
	/** Setter:  */
	void name(const std::string& value) { /* not implemented */ }

	/** Getter:  */
	std::map<std::string, MeshVertexStringProperty> data();
	/** Setter:  */
	void data(std::map<std::string, MeshVertexStringProperty> value);

};

/**************** Mesh Vertex String Property ****************/

/**
 * User defined string text value in a string properties layer
 */
class MeshVertexStringProperty : public pyUniplug {
public:
	MeshVertexStringProperty(PyObject* pyobj) : pyUniplug(pyobj) {}

	MeshVertexStringProperty() : pyUniplug(0)
	{
		// not implemented
	}

	/** Getter:  */
	std::string value() { /* not implemented */ throw NULL; }
	/** Setter:  */
	void value(const std::string& value) { /* not implemented */ }

};

/**************** Mesh Polygon String Property Layer ****************/

/**
 * User defined layer of string text values
 */
class MeshPolygonStringPropertyLayer : public pyUniplug {
public:
	MeshPolygonStringPropertyLayer(PyObject* pyobj) : pyUniplug(pyobj) {}

	MeshPolygonStringPropertyLayer() : pyUniplug(0)
	{
		// not implemented
	}

	/** Getter:  */
	std::string name() { /* not implemented */ throw NULL; }
	/** Setter:  */
	void name(const std::string& value) { /* not implemented */ }

	/** Getter:  */
	std::map<std::string, MeshPolygonStringProperty> data();
	/** Setter:  */
	void data(std::map<std::string, MeshPolygonStringProperty> value);

};

/**************** Mesh Polygon String Property ****************/

/**
 * User defined string text value in a string properties layer
 */
class MeshPolygonStringProperty : public pyUniplug {
public:
	MeshPolygonStringProperty(PyObject* pyobj) : pyUniplug(pyobj) {}

	MeshPolygonStringProperty() : pyUniplug(0)
	{
		// not implemented
	}

	/** Getter:  */
	std::string value() { /* not implemented */ throw NULL; }
	/** Setter:  */
	void value(const std::string& value) { /* not implemented */ }

};

/**************** Meta Element ****************/

/**
 * Blobby element in a Metaball datablock
 */
class MetaElement : public pyUniplug {
public:
	MetaElement(PyObject* pyobj) : pyUniplug(pyobj) {}

	MetaElement() : pyUniplug(0)
	{
		// not implemented
	}

	enum type_enum {
		type_BALL = 0,
		type_CAPSULE = 4,
		type_PLANE = 5,
		type_ELLIPSOID = 6,
		type_CUBE = 7,
	};

	/** Getter: Metaball types */
	type_enum type() { /* not implemented */ throw NULL; }
	/** Setter: Metaball types */
	void type(type_enum value) { /* not implemented */ }

	/** Getter:  */
	std::array<float, 3> co() {
		// TODO: MISSING DEREF! USE #DEFINE!
		PyObject *seqval = PyObject_GetAttrString(pyobjref, "co");
		std::array<float, 3> resarr;
		for (int i = 0; i < 3; i++)
			resarr[i] = (float)PyFloat_AsDouble(PySequence_GetItem(seqval, i));
		return resarr;
	}

	/** Setter:  */
	void co(float values[3]) { /* not implemented */ }

	/** Getter: Normalized quaternion rotation */
	std::array<float, 4> rotation() {
		// TODO: MISSING DEREF! USE #DEFINE!
		PyObject *seqval = PyObject_GetAttrString(pyobjref, "rotation");
		std::array<float, 4> resarr;
		for (int i = 0; i < 4; i++)
			resarr[i] = (float)PyFloat_AsDouble(PySequence_GetItem(seqval, i));
		return resarr;
	}

	/** Setter: Normalized quaternion rotation */
	void rotation(float values[4]) { /* not implemented */ }

	/** Getter:  */
	float radius() { /* not implemented */ throw NULL; }
	/** Setter:  */
	void radius(float value) {
		PyObject_SetAttrString(pyobjref, "radius", Py_BuildValue("f", value));
	}

	/** Getter: Size of element, use of components depends on element type */
	float size_x() { /* not implemented */ throw NULL; }
	/** Setter: Size of element, use of components depends on element type */
	void size_x(float value) {
		PyObject_SetAttrString(pyobjref, "size_x", Py_BuildValue("f", value));
	}

	/** Getter: Size of element, use of components depends on element type */
	float size_y() { /* not implemented */ throw NULL; }
	/** Setter: Size of element, use of components depends on element type */
	void size_y(float value) {
		PyObject_SetAttrString(pyobjref, "size_y", Py_BuildValue("f", value));
	}

	/** Getter: Size of element, use of components depends on element type */
	float size_z() { /* not implemented */ throw NULL; }
	/** Setter: Size of element, use of components depends on element type */
	void size_z(float value) {
		PyObject_SetAttrString(pyobjref, "size_z", Py_BuildValue("f", value));
	}

	/** Getter: Stiffness defines how much of the element to fill */
	float stiffness() { /* not implemented */ throw NULL; }
	/** Setter: Stiffness defines how much of the element to fill */
	void stiffness(float value) {
		PyObject_SetAttrString(pyobjref, "stiffness", Py_BuildValue("f", value));
	}

	/** Getter: Set metaball as negative one */
	bool use_negative() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_negative")) == 1;
	}

	/** Setter: Set metaball as negative one */
	void use_negative(bool value) {
		PyObject_SetAttrString(pyobjref, "use_negative", Py_BuildValue("i", value));
	}

	/** Getter: Hide element */
	bool hide() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "hide")) == 1;
	}

	/** Setter: Hide element */
	void hide(bool value) {
		PyObject_SetAttrString(pyobjref, "hide", Py_BuildValue("i", value));
	}

};

/**************** MetaBall ****************/

/**
 * Metaball datablock to defined blobby surfaces
 */
class MetaBall : public ID {
public:
	MetaBall(PyObject* pyobj) : ID(pyobj) {}

	MetaBall() : ID(0)
	{
		// not implemented
	}

	/** Getter: Meta elements */
	std::map<std::string, MetaElement> elements() {
		// TODO: MISSING DEREF! USE #DEFINE!
		PyObject *seqval = PyObject_GetAttrString(pyobjref, "elements");
		PyObject *seqkeys = PyObject_CallMethod(seqval, "keys", NULL);
		std::map<std::string, MetaElement> resmap;
		for (int i = 0; i < PySequence_Length(seqval); i++) {
			PyObject *keyobj = PySequence_GetItem(seqkeys, i);
			std::string key = PyBytes_AsString(PyUnicode_AsASCIIString(keyobj));
			MetaElement value = MetaElement(PySequence_GetItem(seqval, i));
			resmap.insert(std::pair<std::string,MetaElement>(key, value));
		}
		return resmap;
	}

	/** Setter: Meta elements */
	void elements(std::map<std::string, MetaElement> value) { /* not implemented */ }

	enum update_method_enum {
		update_method_UPDATE_ALWAYS = 0,
		update_method_HALFRES = 1,
		update_method_FAST = 2,
		update_method_NEVER = 3,
	};

	/** Getter: Metaball edit update behavior */
	update_method_enum update_method() { /* not implemented */ throw NULL; }
	/** Setter: Metaball edit update behavior */
	void update_method(update_method_enum value) { /* not implemented */ }

	/** Getter: Polygonization resolution in the 3D viewport */
	float resolution() { /* not implemented */ throw NULL; }
	/** Setter: Polygonization resolution in the 3D viewport */
	void resolution(float value) {
		PyObject_SetAttrString(pyobjref, "resolution", Py_BuildValue("f", value));
	}

	/** Getter: Polygonization resolution in rendering */
	float render_resolution() { /* not implemented */ throw NULL; }
	/** Setter: Polygonization resolution in rendering */
	void render_resolution(float value) {
		PyObject_SetAttrString(pyobjref, "render_resolution", Py_BuildValue("f", value));
	}

	/** Getter: Influence of meta elements */
	float threshold() { /* not implemented */ throw NULL; }
	/** Setter: Influence of meta elements */
	void threshold(float value) {
		PyObject_SetAttrString(pyobjref, "threshold", Py_BuildValue("f", value));
	}

	/** Getter: Adjust active object's texture space automatically when transforming object */
	bool use_auto_texspace() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_auto_texspace")) == 1;
	}

	/** Setter: Adjust active object's texture space automatically when transforming object */
	void use_auto_texspace(bool value) {
		PyObject_SetAttrString(pyobjref, "use_auto_texspace", Py_BuildValue("i", value));
	}

	/** Getter: Texture space location */
	std::array<float, 3> texspace_location() {
		// TODO: MISSING DEREF! USE #DEFINE!
		PyObject *seqval = PyObject_GetAttrString(pyobjref, "texspace_location");
		std::array<float, 3> resarr;
		for (int i = 0; i < 3; i++)
			resarr[i] = (float)PyFloat_AsDouble(PySequence_GetItem(seqval, i));
		return resarr;
	}

	/** Setter: Texture space location */
	void texspace_location(float values[3]) { /* not implemented */ }

	/** Getter: Texture space size */
	std::array<float, 3> texspace_size() {
		// TODO: MISSING DEREF! USE #DEFINE!
		PyObject *seqval = PyObject_GetAttrString(pyobjref, "texspace_size");
		std::array<float, 3> resarr;
		for (int i = 0; i < 3; i++)
			resarr[i] = (float)PyFloat_AsDouble(PySequence_GetItem(seqval, i));
		return resarr;
	}

	/** Setter: Texture space size */
	void texspace_size(float values[3]) { /* not implemented */ }

	/** Getter:  */
	std::map<std::string, Material> materials() {
		// TODO: MISSING DEREF! USE #DEFINE!
		PyObject *seqval = PyObject_GetAttrString(pyobjref, "materials");
		PyObject *seqkeys = PyObject_CallMethod(seqval, "keys", NULL);
		std::map<std::string, Material> resmap;
		for (int i = 0; i < PySequence_Length(seqval); i++) {
			PyObject *keyobj = PySequence_GetItem(seqkeys, i);
			std::string key = PyBytes_AsString(PyUnicode_AsASCIIString(keyobj));
			Material value = Material(PySequence_GetItem(seqval, i));
			resmap.insert(std::pair<std::string,Material>(key, value));
		}
		return resmap;
	}

	/** Setter:  */
	void materials(std::map<std::string, Material> value) { /* not implemented */ }

	/** Getter: True when used in editmode */
	bool is_editmode() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "is_editmode")) == 1;
	}

	/** Setter: True when used in editmode */
	void is_editmode(bool value) {
		PyObject_SetAttrString(pyobjref, "is_editmode", Py_BuildValue("i", value));
	}

	/** Getter: Animation data for this datablock */
	AnimData animation_data() {
		/* not implemented */ throw NULL;
	}

	/**
	 * Transform meta elements by a matrix
	 * @param Matrix
	 */
	void transform(float matrix[16])
	{
		// not implemented
	}

};

/**************** Modifier ****************/

/**
 * Modifier affecting the geometry data of an object
 */
class Modifier : public pyUniplug {
public:
	Modifier(PyObject* pyobj) : pyUniplug(pyobj) {}

	Modifier() : pyUniplug(0)
	{
		// not implemented
	}

	/** Getter: Modifier name */
	std::string name() { /* not implemented */ throw NULL; }
	/** Setter: Modifier name */
	void name(const std::string& value) { /* not implemented */ }

	enum type_enum {
		type_DATA_TRANSFER = 49,
		type_MESH_CACHE = 46,
		type_NORMAL_EDIT = 50,
		type_UV_PROJECT = 15,
		type_UV_WARP = 45,
		type_VERTEX_WEIGHT_EDIT = 36,
		type_VERTEX_WEIGHT_MIX = 37,
		type_VERTEX_WEIGHT_PROXIMITY = 38,
		type_ARRAY = 12,
		type_BEVEL = 24,
		type_BOOLEAN = 11,
		type_BUILD = 4,
		type_DECIMATE = 6,
		type_EDGE_SPLIT = 13,
		type_MASK = 27,
		type_MIRROR = 5,
		type_MULTIRES = 29,
		type_REMESH = 41,
		type_SCREW = 34,
		type_SKIN = 42,
		type_SOLIDIFY = 33,
		type_SUBSURF = 1,
		type_TRIANGULATE = 44,
		type_WIREFRAME = 48,
		type_ARMATURE = 8,
		type_CAST = 17,
		type_CORRECTIVE_SMOOTH = 51,
		type_CURVE = 3,
		type_DISPLACE = 14,
		type_HOOK = 9,
		type_LAPLACIANSMOOTH = 43,
		type_LAPLACIANDEFORM = 47,
		type_LATTICE = 2,
		type_MESH_DEFORM = 18,
		type_SHRINKWRAP = 25,
		type_SIMPLE_DEFORM = 28,
		type_SMOOTH = 16,
		type_WARP = 35,
		type_WAVE = 7,
		type_CLOTH = 22,
		type_COLLISION = 23,
		type_DYNAMIC_PAINT = 40,
		type_EXPLODE = 21,
		type_FLUID_SIMULATION = 26,
		type_OCEAN = 39,
		type_PARTICLE_INSTANCE = 20,
		type_PARTICLE_SYSTEM = 19,
		type_SMOKE = 31,
		type_SOFT_BODY = 10,
		type_SURFACE = 30,
	};

	/** Getter:  */
	type_enum type() { /* not implemented */ throw NULL; }
	/** Setter:  */
	void type(type_enum value) { /* not implemented */ }

	/** Getter: Display modifier in viewport */
	bool show_viewport() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "show_viewport")) == 1;
	}

	/** Setter: Display modifier in viewport */
	void show_viewport(bool value) {
		PyObject_SetAttrString(pyobjref, "show_viewport", Py_BuildValue("i", value));
	}

	/** Getter: Use modifier during render */
	bool show_render() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "show_render")) == 1;
	}

	/** Setter: Use modifier during render */
	void show_render(bool value) {
		PyObject_SetAttrString(pyobjref, "show_render", Py_BuildValue("i", value));
	}

	/** Getter: Display modifier in Edit mode */
	bool show_in_editmode() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "show_in_editmode")) == 1;
	}

	/** Setter: Display modifier in Edit mode */
	void show_in_editmode(bool value) {
		PyObject_SetAttrString(pyobjref, "show_in_editmode", Py_BuildValue("i", value));
	}

	/** Getter: Adjust edit cage to modifier result */
	bool show_on_cage() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "show_on_cage")) == 1;
	}

	/** Setter: Adjust edit cage to modifier result */
	void show_on_cage(bool value) {
		PyObject_SetAttrString(pyobjref, "show_on_cage", Py_BuildValue("i", value));
	}

	/** Getter: Set modifier expanded in the user interface */
	bool show_expanded() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "show_expanded")) == 1;
	}

	/** Setter: Set modifier expanded in the user interface */
	void show_expanded(bool value) {
		PyObject_SetAttrString(pyobjref, "show_expanded", Py_BuildValue("i", value));
	}

	/** Getter: Apply this and all preceding deformation modifiers on splines' points rather than on filled curve/surface */
	bool use_apply_on_spline() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_apply_on_spline")) == 1;
	}

	/** Setter: Apply this and all preceding deformation modifiers on splines' points rather than on filled curve/surface */
	void use_apply_on_spline(bool value) {
		PyObject_SetAttrString(pyobjref, "use_apply_on_spline", Py_BuildValue("i", value));
	}

};

/**************** Subsurf Modifier ****************/

/**
 * Subdivision surface modifier
 */
class SubsurfModifier : public Modifier {
public:
	SubsurfModifier(PyObject* pyobj) : Modifier(pyobj) {}

	SubsurfModifier() : Modifier(0)
	{
		// not implemented
	}

	enum subdivision_type_enum {
		subdivision_type_CATMULL_CLARK = 0,
		subdivision_type_SIMPLE = 1,
	};

	/** Getter: Select type of subdivision algorithm */
	subdivision_type_enum subdivision_type() { /* not implemented */ throw NULL; }
	/** Setter: Select type of subdivision algorithm */
	void subdivision_type(subdivision_type_enum value) { /* not implemented */ }

	/** Getter: Number of subdivisions to perform */
	int levels() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "levels"));
	}

	/** Setter: Number of subdivisions to perform */
	void levels(int value) {
		PyObject_SetAttrString(pyobjref, "levels", Py_BuildValue("i", value));
	}

	/** Getter: Number of subdivisions to perform when rendering */
	int render_levels() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "render_levels"));
	}

	/** Setter: Number of subdivisions to perform when rendering */
	void render_levels(int value) {
		PyObject_SetAttrString(pyobjref, "render_levels", Py_BuildValue("i", value));
	}

	/** Getter: Skip drawing/rendering of interior subdivided edges */
	bool show_only_control_edges() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "show_only_control_edges")) == 1;
	}

	/** Setter: Skip drawing/rendering of interior subdivided edges */
	void show_only_control_edges(bool value) {
		PyObject_SetAttrString(pyobjref, "show_only_control_edges", Py_BuildValue("i", value));
	}

	/** Getter: Use subsurf to subdivide UVs */
	bool use_subsurf_uv() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_subsurf_uv")) == 1;
	}

	/** Setter: Use subsurf to subdivide UVs */
	void use_subsurf_uv(bool value) {
		PyObject_SetAttrString(pyobjref, "use_subsurf_uv", Py_BuildValue("i", value));
	}

};

/**************** Lattice Modifier ****************/

/**
 * Lattice deformation modifier
 */
class LatticeModifier : public Modifier {
public:
	LatticeModifier(PyObject* pyobj) : Modifier(pyobj) {}

	LatticeModifier() : Modifier(0)
	{
		// not implemented
	}

	/** Getter: Lattice object to deform with */
	Object object_value();

	/** Getter: Name of Vertex Group which determines influence of modifier per point */
	std::string vertex_group() { /* not implemented */ throw NULL; }
	/** Setter: Name of Vertex Group which determines influence of modifier per point */
	void vertex_group(const std::string& value) { /* not implemented */ }

	/** Getter: Strength of modifier effect */
	float strength() { /* not implemented */ throw NULL; }
	/** Setter: Strength of modifier effect */
	void strength(float value) {
		PyObject_SetAttrString(pyobjref, "strength", Py_BuildValue("f", value));
	}

};

/**************** Curve Modifier ****************/

/**
 * Curve deformation modifier
 */
class CurveModifier : public Modifier {
public:
	CurveModifier(PyObject* pyobj) : Modifier(pyobj) {}

	CurveModifier() : Modifier(0)
	{
		// not implemented
	}

	/** Getter: Curve object to deform with */
	Object object_value();

	/** Getter: Name of Vertex Group which determines influence of modifier per point */
	std::string vertex_group() { /* not implemented */ throw NULL; }
	/** Setter: Name of Vertex Group which determines influence of modifier per point */
	void vertex_group(const std::string& value) { /* not implemented */ }

	enum deform_axis_enum {
		deform_axis_POS_X = 1,
		deform_axis_POS_Y = 2,
		deform_axis_POS_Z = 3,
		deform_axis_NEG_X = 4,
		deform_axis_NEG_Y = 5,
		deform_axis_NEG_Z = 6,
	};

	/** Getter: The axis that the curve deforms along */
	deform_axis_enum deform_axis() { /* not implemented */ throw NULL; }
	/** Setter: The axis that the curve deforms along */
	void deform_axis(deform_axis_enum value) { /* not implemented */ }

};

/**************** Build Modifier ****************/

/**
 * Build effect modifier
 */
class BuildModifier : public Modifier {
public:
	BuildModifier(PyObject* pyobj) : Modifier(pyobj) {}

	BuildModifier() : Modifier(0)
	{
		// not implemented
	}

	/** Getter: Start frame of the effect */
	float frame_start() { /* not implemented */ throw NULL; }
	/** Setter: Start frame of the effect */
	void frame_start(float value) {
		PyObject_SetAttrString(pyobjref, "frame_start", Py_BuildValue("f", value));
	}

	/** Getter: Total time the build effect requires */
	float frame_duration() { /* not implemented */ throw NULL; }
	/** Setter: Total time the build effect requires */
	void frame_duration(float value) {
		PyObject_SetAttrString(pyobjref, "frame_duration", Py_BuildValue("f", value));
	}

	/** Getter: Deconstruct the mesh instead of building it */
	bool use_reverse() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_reverse")) == 1;
	}

	/** Setter: Deconstruct the mesh instead of building it */
	void use_reverse(bool value) {
		PyObject_SetAttrString(pyobjref, "use_reverse", Py_BuildValue("i", value));
	}

	/** Getter: Randomize the faces or edges during build */
	bool use_random_order() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_random_order")) == 1;
	}

	/** Setter: Randomize the faces or edges during build */
	void use_random_order(bool value) {
		PyObject_SetAttrString(pyobjref, "use_random_order", Py_BuildValue("i", value));
	}

	/** Getter: Seed for random if used */
	int seed() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "seed"));
	}

	/** Setter: Seed for random if used */
	void seed(int value) {
		PyObject_SetAttrString(pyobjref, "seed", Py_BuildValue("i", value));
	}

};

/**************** Mirror Modifier ****************/

/**
 * Mirroring modifier
 */
class MirrorModifier : public Modifier {
public:
	MirrorModifier(PyObject* pyobj) : Modifier(pyobj) {}

	MirrorModifier() : Modifier(0)
	{
		// not implemented
	}

	/** Getter: Enable X axis mirror */
	bool use_x() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_x")) == 1;
	}

	/** Setter: Enable X axis mirror */
	void use_x(bool value) {
		PyObject_SetAttrString(pyobjref, "use_x", Py_BuildValue("i", value));
	}

	/** Getter: Enable Y axis mirror */
	bool use_y() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_y")) == 1;
	}

	/** Setter: Enable Y axis mirror */
	void use_y(bool value) {
		PyObject_SetAttrString(pyobjref, "use_y", Py_BuildValue("i", value));
	}

	/** Getter: Enable Z axis mirror */
	bool use_z() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_z")) == 1;
	}

	/** Setter: Enable Z axis mirror */
	void use_z(bool value) {
		PyObject_SetAttrString(pyobjref, "use_z", Py_BuildValue("i", value));
	}

	/** Getter: Prevent vertices from going through the mirror during transform */
	bool use_clip() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_clip")) == 1;
	}

	/** Setter: Prevent vertices from going through the mirror during transform */
	void use_clip(bool value) {
		PyObject_SetAttrString(pyobjref, "use_clip", Py_BuildValue("i", value));
	}

	/** Getter: Mirror vertex groups (e.g. .R->.L) */
	bool use_mirror_vertex_groups() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_mirror_vertex_groups")) == 1;
	}

	/** Setter: Mirror vertex groups (e.g. .R->.L) */
	void use_mirror_vertex_groups(bool value) {
		PyObject_SetAttrString(pyobjref, "use_mirror_vertex_groups", Py_BuildValue("i", value));
	}

	/** Getter: Merge vertices within the merge threshold */
	bool use_mirror_merge() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_mirror_merge")) == 1;
	}

	/** Setter: Merge vertices within the merge threshold */
	void use_mirror_merge(bool value) {
		PyObject_SetAttrString(pyobjref, "use_mirror_merge", Py_BuildValue("i", value));
	}

	/** Getter: Mirror the U texture coordinate around the 0.5 point */
	bool use_mirror_u() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_mirror_u")) == 1;
	}

	/** Setter: Mirror the U texture coordinate around the 0.5 point */
	void use_mirror_u(bool value) {
		PyObject_SetAttrString(pyobjref, "use_mirror_u", Py_BuildValue("i", value));
	}

	/** Getter: Mirror the V texture coordinate around the 0.5 point */
	bool use_mirror_v() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_mirror_v")) == 1;
	}

	/** Setter: Mirror the V texture coordinate around the 0.5 point */
	void use_mirror_v(bool value) {
		PyObject_SetAttrString(pyobjref, "use_mirror_v", Py_BuildValue("i", value));
	}

	/** Getter: Distance within which mirrored vertices are merged */
	float merge_threshold() { /* not implemented */ throw NULL; }
	/** Setter: Distance within which mirrored vertices are merged */
	void merge_threshold(float value) {
		PyObject_SetAttrString(pyobjref, "merge_threshold", Py_BuildValue("f", value));
	}

	/** Getter: Object to use as mirror */
	Object mirror_object();

};

/**************** Decimate Modifier ****************/

/**
 * Decimation modifier
 */
class DecimateModifier : public Modifier {
public:
	DecimateModifier(PyObject* pyobj) : Modifier(pyobj) {}

	DecimateModifier() : Modifier(0)
	{
		// not implemented
	}

	enum decimate_type_enum {
		decimate_type_COLLAPSE = 0,
		decimate_type_UNSUBDIV = 1,
		decimate_type_DISSOLVE = 2,
	};

	/** Getter:  */
	decimate_type_enum decimate_type() { /* not implemented */ throw NULL; }
	/** Setter:  */
	void decimate_type(decimate_type_enum value) { /* not implemented */ }

	/** Getter: Ratio of triangles to reduce to (collapse only) */
	float ratio() { /* not implemented */ throw NULL; }
	/** Setter: Ratio of triangles to reduce to (collapse only) */
	void ratio(float value) {
		PyObject_SetAttrString(pyobjref, "ratio", Py_BuildValue("f", value));
	}

	/** Getter: Number of times reduce the geometry (unsubdivide only) */
	int iterations() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "iterations"));
	}

	/** Setter: Number of times reduce the geometry (unsubdivide only) */
	void iterations(int value) {
		PyObject_SetAttrString(pyobjref, "iterations", Py_BuildValue("i", value));
	}

	/** Getter: Only dissolve angles below this (planar only) */
	float angle_limit() { /* not implemented */ throw NULL; }
	/** Setter: Only dissolve angles below this (planar only) */
	void angle_limit(float value) {
		PyObject_SetAttrString(pyobjref, "angle_limit", Py_BuildValue("f", value));
	}

	/** Getter: Vertex group name (collapse only) */
	std::string vertex_group() { /* not implemented */ throw NULL; }
	/** Setter: Vertex group name (collapse only) */
	void vertex_group(const std::string& value) { /* not implemented */ }

	/** Getter: Invert vertex group influence (collapse only) */
	bool invert_vertex_group() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "invert_vertex_group")) == 1;
	}

	/** Setter: Invert vertex group influence (collapse only) */
	void invert_vertex_group(bool value) {
		PyObject_SetAttrString(pyobjref, "invert_vertex_group", Py_BuildValue("i", value));
	}

	/** Getter: Keep triangulated faces resulting from decimation (collapse only) */
	bool use_collapse_triangulate() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_collapse_triangulate")) == 1;
	}

	/** Setter: Keep triangulated faces resulting from decimation (collapse only) */
	void use_collapse_triangulate(bool value) {
		PyObject_SetAttrString(pyobjref, "use_collapse_triangulate", Py_BuildValue("i", value));
	}

	/** Getter: Dissolve all vertices inbetween face boundaries (planar only) */
	bool use_dissolve_boundaries() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_dissolve_boundaries")) == 1;
	}

	/** Setter: Dissolve all vertices inbetween face boundaries (planar only) */
	void use_dissolve_boundaries(bool value) {
		PyObject_SetAttrString(pyobjref, "use_dissolve_boundaries", Py_BuildValue("i", value));
	}

	enum delimit_enum {
		delimit_NORMAL = 1,
		delimit_MATERIAL = 2,
		delimit_SEAM = 4,
		delimit_SHARP = 8,
		delimit_UV = 16,
	};

	/** Getter: Limit merging geometry */
	delimit_enum delimit() { /* not implemented */ throw NULL; }
	/** Setter: Limit merging geometry */
	void delimit(delimit_enum value) { /* not implemented */ }

	/** Getter: The current number of faces in the decimated mesh */
	int face_count() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "face_count"));
	}

	/** Setter: The current number of faces in the decimated mesh */
	void face_count(int value) {
		PyObject_SetAttrString(pyobjref, "face_count", Py_BuildValue("i", value));
	}

};

/**************** Wave Modifier ****************/

/**
 * Wave effect modifier
 */
class WaveModifier : public Modifier {
public:
	WaveModifier(PyObject* pyobj) : Modifier(pyobj) {}

	WaveModifier() : Modifier(0)
	{
		// not implemented
	}

	/** Getter: X axis motion */
	bool use_x() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_x")) == 1;
	}

	/** Setter: X axis motion */
	void use_x(bool value) {
		PyObject_SetAttrString(pyobjref, "use_x", Py_BuildValue("i", value));
	}

	/** Getter: Y axis motion */
	bool use_y() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_y")) == 1;
	}

	/** Setter: Y axis motion */
	void use_y(bool value) {
		PyObject_SetAttrString(pyobjref, "use_y", Py_BuildValue("i", value));
	}

	/** Getter: Cyclic wave effect */
	bool use_cyclic() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_cyclic")) == 1;
	}

	/** Setter: Cyclic wave effect */
	void use_cyclic(bool value) {
		PyObject_SetAttrString(pyobjref, "use_cyclic", Py_BuildValue("i", value));
	}

	/** Getter: Displace along normals */
	bool use_normal() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_normal")) == 1;
	}

	/** Setter: Displace along normals */
	void use_normal(bool value) {
		PyObject_SetAttrString(pyobjref, "use_normal", Py_BuildValue("i", value));
	}

	/** Getter: Enable displacement along the X normal */
	bool use_normal_x() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_normal_x")) == 1;
	}

	/** Setter: Enable displacement along the X normal */
	void use_normal_x(bool value) {
		PyObject_SetAttrString(pyobjref, "use_normal_x", Py_BuildValue("i", value));
	}

	/** Getter: Enable displacement along the Y normal */
	bool use_normal_y() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_normal_y")) == 1;
	}

	/** Setter: Enable displacement along the Y normal */
	void use_normal_y(bool value) {
		PyObject_SetAttrString(pyobjref, "use_normal_y", Py_BuildValue("i", value));
	}

	/** Getter: Enable displacement along the Z normal */
	bool use_normal_z() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_normal_z")) == 1;
	}

	/** Setter: Enable displacement along the Z normal */
	void use_normal_z(bool value) {
		PyObject_SetAttrString(pyobjref, "use_normal_z", Py_BuildValue("i", value));
	}

	/** Getter: Either the starting frame (for positive speed) or ending frame (for negative speed.) */
	float time_offset() { /* not implemented */ throw NULL; }
	/** Setter: Either the starting frame (for positive speed) or ending frame (for negative speed.) */
	void time_offset(float value) {
		PyObject_SetAttrString(pyobjref, "time_offset", Py_BuildValue("f", value));
	}

	/** Getter: Lifetime of the wave in frames, zero means infinite */
	float lifetime() { /* not implemented */ throw NULL; }
	/** Setter: Lifetime of the wave in frames, zero means infinite */
	void lifetime(float value) {
		PyObject_SetAttrString(pyobjref, "lifetime", Py_BuildValue("f", value));
	}

	/** Getter: Number of frames in which the wave damps out after it dies */
	float damping_time() { /* not implemented */ throw NULL; }
	/** Setter: Number of frames in which the wave damps out after it dies */
	void damping_time(float value) {
		PyObject_SetAttrString(pyobjref, "damping_time", Py_BuildValue("f", value));
	}

	/** Getter: Distance after which it fades out */
	float falloff_radius() { /* not implemented */ throw NULL; }
	/** Setter: Distance after which it fades out */
	void falloff_radius(float value) {
		PyObject_SetAttrString(pyobjref, "falloff_radius", Py_BuildValue("f", value));
	}

	/** Getter: X coordinate of the start position */
	float start_position_x() { /* not implemented */ throw NULL; }
	/** Setter: X coordinate of the start position */
	void start_position_x(float value) {
		PyObject_SetAttrString(pyobjref, "start_position_x", Py_BuildValue("f", value));
	}

	/** Getter: Y coordinate of the start position */
	float start_position_y() { /* not implemented */ throw NULL; }
	/** Setter: Y coordinate of the start position */
	void start_position_y(float value) {
		PyObject_SetAttrString(pyobjref, "start_position_y", Py_BuildValue("f", value));
	}

	/** Getter: Object which defines the wave center */
	Object start_position_object();

	/** Getter: Vertex group name for modulating the wave */
	std::string vertex_group() { /* not implemented */ throw NULL; }
	/** Setter: Vertex group name for modulating the wave */
	void vertex_group(const std::string& value) { /* not implemented */ }

	/** Getter: Speed of the wave, towards the starting point when negative */
	float speed() { /* not implemented */ throw NULL; }
	/** Setter: Speed of the wave, towards the starting point when negative */
	void speed(float value) {
		PyObject_SetAttrString(pyobjref, "speed", Py_BuildValue("f", value));
	}

	/** Getter: Height of the wave */
	float height() { /* not implemented */ throw NULL; }
	/** Setter: Height of the wave */
	void height(float value) {
		PyObject_SetAttrString(pyobjref, "height", Py_BuildValue("f", value));
	}

	/** Getter: Distance between the waves */
	float width() { /* not implemented */ throw NULL; }
	/** Setter: Distance between the waves */
	void width(float value) {
		PyObject_SetAttrString(pyobjref, "width", Py_BuildValue("f", value));
	}

	/** Getter: Distance between the top and the base of a wave, the higher the value, the more narrow the wave */
	float narrowness() { /* not implemented */ throw NULL; }
	/** Setter: Distance between the top and the base of a wave, the higher the value, the more narrow the wave */
	void narrowness(float value) {
		PyObject_SetAttrString(pyobjref, "narrowness", Py_BuildValue("f", value));
	}

	/** Getter:  */
	Texture texture() {
		/* not implemented */ throw NULL;
	}

	enum texture_coords_enum {
		texture_coords_LOCAL = 0,
		texture_coords_GLOBAL = 1,
		texture_coords_OBJECT = 2,
		texture_coords_UV = 3,
	};

	/** Getter:  */
	texture_coords_enum texture_coords() { /* not implemented */ throw NULL; }
	/** Setter:  */
	void texture_coords(texture_coords_enum value) { /* not implemented */ }

	/** Getter: UV map name */
	std::string uv_layer() { /* not implemented */ throw NULL; }
	/** Setter: UV map name */
	void uv_layer(const std::string& value) { /* not implemented */ }

	/** Getter: Object to set the texture coordinates */
	Object texture_coords_object();

};

/**************** Armature Modifier ****************/

/**
 * Armature deformation modifier
 */
class ArmatureModifier : public Modifier {
public:
	ArmatureModifier(PyObject* pyobj) : Modifier(pyobj) {}

	ArmatureModifier() : Modifier(0)
	{
		// not implemented
	}

	/** Getter: Armature object to deform with */
	Object object_value();

	/** Getter: Bind Bone envelopes to armature modifier */
	bool use_bone_envelopes() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_bone_envelopes")) == 1;
	}

	/** Setter: Bind Bone envelopes to armature modifier */
	void use_bone_envelopes(bool value) {
		PyObject_SetAttrString(pyobjref, "use_bone_envelopes", Py_BuildValue("i", value));
	}

	/** Getter: Bind vertex groups to armature modifier */
	bool use_vertex_groups() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_vertex_groups")) == 1;
	}

	/** Setter: Bind vertex groups to armature modifier */
	void use_vertex_groups(bool value) {
		PyObject_SetAttrString(pyobjref, "use_vertex_groups", Py_BuildValue("i", value));
	}

	/** Getter: Deform rotation interpolation with quaternions */
	bool use_deform_preserve_volume() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_deform_preserve_volume")) == 1;
	}

	/** Setter: Deform rotation interpolation with quaternions */
	void use_deform_preserve_volume(bool value) {
		PyObject_SetAttrString(pyobjref, "use_deform_preserve_volume", Py_BuildValue("i", value));
	}

	/** Getter: Use same input as previous modifier, and mix results using overall vgroup */
	bool use_multi_modifier() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_multi_modifier")) == 1;
	}

	/** Setter: Use same input as previous modifier, and mix results using overall vgroup */
	void use_multi_modifier(bool value) {
		PyObject_SetAttrString(pyobjref, "use_multi_modifier", Py_BuildValue("i", value));
	}

	/** Getter: Name of Vertex Group which determines influence of modifier per point */
	std::string vertex_group() { /* not implemented */ throw NULL; }
	/** Setter: Name of Vertex Group which determines influence of modifier per point */
	void vertex_group(const std::string& value) { /* not implemented */ }

	/** Getter: Invert vertex group influence */
	bool invert_vertex_group() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "invert_vertex_group")) == 1;
	}

	/** Setter: Invert vertex group influence */
	void invert_vertex_group(bool value) {
		PyObject_SetAttrString(pyobjref, "invert_vertex_group", Py_BuildValue("i", value));
	}

};

/**************** Hook Modifier ****************/

/**
 * Hook modifier to modify the location of vertices
 */
class HookModifier : public Modifier {
public:
	HookModifier(PyObject* pyobj) : Modifier(pyobj) {}

	HookModifier() : Modifier(0)
	{
		// not implemented
	}

	/** Getter: Relative force of the hook */
	float strength() { /* not implemented */ throw NULL; }
	/** Setter: Relative force of the hook */
	void strength(float value) {
		PyObject_SetAttrString(pyobjref, "strength", Py_BuildValue("f", value));
	}

	enum falloff_type_enum {
		falloff_type_NONE = 0,
		falloff_type_CURVE = 1,
		falloff_type_SMOOTH = 3,
		falloff_type_SPHERE = 7,
		falloff_type_ROOT = 4,
		falloff_type_INVERSE_SQUARE = 8,
		falloff_type_SHARP = 2,
		falloff_type_LINEAR = 5,
		falloff_type_CONSTANT = 6,
	};

	/** Getter:  */
	falloff_type_enum falloff_type() { /* not implemented */ throw NULL; }
	/** Setter:  */
	void falloff_type(falloff_type_enum value) { /* not implemented */ }

	/** Getter: If not zero, the distance from the hook where influence ends */
	float falloff_radius() { /* not implemented */ throw NULL; }
	/** Setter: If not zero, the distance from the hook where influence ends */
	void falloff_radius(float value) {
		PyObject_SetAttrString(pyobjref, "falloff_radius", Py_BuildValue("f", value));
	}

	/** Getter: Custom Lamp Falloff Curve */
	CurveMapping falloff_curve() {
		/* not implemented */ throw NULL;
	}

	/** Getter:  */
	std::array<float, 3> center() {
		// TODO: MISSING DEREF! USE #DEFINE!
		PyObject *seqval = PyObject_GetAttrString(pyobjref, "center");
		std::array<float, 3> resarr;
		for (int i = 0; i < 3; i++)
			resarr[i] = (float)PyFloat_AsDouble(PySequence_GetItem(seqval, i));
		return resarr;
	}

	/** Setter:  */
	void center(float values[3]) { /* not implemented */ }

	/** Getter: Parent Object for hook, also recalculates and clears offset */
	Object object_value();

	/** Getter: Name of Parent Bone for hook (if applicable), also recalculates and clears offset */
	std::string subtarget() { /* not implemented */ throw NULL; }
	/** Setter: Name of Parent Bone for hook (if applicable), also recalculates and clears offset */
	void subtarget(const std::string& value) { /* not implemented */ }

	/** Getter: Compensate for non-uniform object scale */
	bool use_falloff_uniform() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_falloff_uniform")) == 1;
	}

	/** Setter: Compensate for non-uniform object scale */
	void use_falloff_uniform(bool value) {
		PyObject_SetAttrString(pyobjref, "use_falloff_uniform", Py_BuildValue("i", value));
	}

	/** Getter: Name of Vertex Group which determines influence of modifier per point */
	std::string vertex_group() { /* not implemented */ throw NULL; }
	/** Setter: Name of Vertex Group which determines influence of modifier per point */
	void vertex_group(const std::string& value) { /* not implemented */ }

};

/**************** Soft Body Modifier ****************/

/**
 * Soft body simulation modifier
 */
class SoftBodyModifier : public Modifier {
public:
	SoftBodyModifier(PyObject* pyobj) : Modifier(pyobj) {}

	SoftBodyModifier() : Modifier(0)
	{
		// not implemented
	}

	/** Getter:  */
	SoftBodySettings settings();

	/** Getter:  */
	PointCache point_cache();

};

/**************** Boolean Modifier ****************/

/**
 * Boolean operations modifier
 */
class BooleanModifier : public Modifier {
public:
	BooleanModifier(PyObject* pyobj) : Modifier(pyobj) {}

	BooleanModifier() : Modifier(0)
	{
		// not implemented
	}

	/** Getter: Mesh object to use for Boolean operation */
	Object object_value();

	enum operation_enum {
		operation_INTERSECT = 0,
		operation_UNION = 1,
		operation_DIFFERENCE = 2,
	};

	/** Getter:  */
	operation_enum operation() { /* not implemented */ throw NULL; }
	/** Setter:  */
	void operation(operation_enum value) { /* not implemented */ }

};

/**************** Array Modifier ****************/

/**
 * Array duplication modifier
 */
class ArrayModifier : public Modifier {
public:
	ArrayModifier(PyObject* pyobj) : Modifier(pyobj) {}

	ArrayModifier() : Modifier(0)
	{
		// not implemented
	}

	enum fit_type_enum {
		fit_type_FIXED_COUNT = 0,
		fit_type_FIT_LENGTH = 1,
		fit_type_FIT_CURVE = 2,
	};

	/** Getter: Array length calculation method */
	fit_type_enum fit_type() { /* not implemented */ throw NULL; }
	/** Setter: Array length calculation method */
	void fit_type(fit_type_enum value) { /* not implemented */ }

	/** Getter: Number of duplicates to make */
	int count() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "count"));
	}

	/** Setter: Number of duplicates to make */
	void count(int value) {
		PyObject_SetAttrString(pyobjref, "count", Py_BuildValue("i", value));
	}

	/** Getter: Length to fit array within */
	float fit_length() { /* not implemented */ throw NULL; }
	/** Setter: Length to fit array within */
	void fit_length(float value) {
		PyObject_SetAttrString(pyobjref, "fit_length", Py_BuildValue("f", value));
	}

	/** Getter: Curve object to fit array length to */
	Object curve();

	/** Getter: Add a constant offset */
	bool use_constant_offset() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_constant_offset")) == 1;
	}

	/** Setter: Add a constant offset */
	void use_constant_offset(bool value) {
		PyObject_SetAttrString(pyobjref, "use_constant_offset", Py_BuildValue("i", value));
	}

	/** Getter: Value for the distance between arrayed items */
	std::array<float, 3> constant_offset_displace() {
		// TODO: MISSING DEREF! USE #DEFINE!
		PyObject *seqval = PyObject_GetAttrString(pyobjref, "constant_offset_displace");
		std::array<float, 3> resarr;
		for (int i = 0; i < 3; i++)
			resarr[i] = (float)PyFloat_AsDouble(PySequence_GetItem(seqval, i));
		return resarr;
	}

	/** Setter: Value for the distance between arrayed items */
	void constant_offset_displace(float values[3]) { /* not implemented */ }

	/** Getter: Add an offset relative to the object's bounding box */
	bool use_relative_offset() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_relative_offset")) == 1;
	}

	/** Setter: Add an offset relative to the object's bounding box */
	void use_relative_offset(bool value) {
		PyObject_SetAttrString(pyobjref, "use_relative_offset", Py_BuildValue("i", value));
	}

	/** Getter: The size of the geometry will determine the distance between arrayed items */
	std::array<float, 3> relative_offset_displace() {
		// TODO: MISSING DEREF! USE #DEFINE!
		PyObject *seqval = PyObject_GetAttrString(pyobjref, "relative_offset_displace");
		std::array<float, 3> resarr;
		for (int i = 0; i < 3; i++)
			resarr[i] = (float)PyFloat_AsDouble(PySequence_GetItem(seqval, i));
		return resarr;
	}

	/** Setter: The size of the geometry will determine the distance between arrayed items */
	void relative_offset_displace(float values[3]) { /* not implemented */ }

	/** Getter: Merge vertices in adjacent duplicates */
	bool use_merge_vertices() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_merge_vertices")) == 1;
	}

	/** Setter: Merge vertices in adjacent duplicates */
	void use_merge_vertices(bool value) {
		PyObject_SetAttrString(pyobjref, "use_merge_vertices", Py_BuildValue("i", value));
	}

	/** Getter: Merge vertices in first and last duplicates */
	bool use_merge_vertices_cap() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_merge_vertices_cap")) == 1;
	}

	/** Setter: Merge vertices in first and last duplicates */
	void use_merge_vertices_cap(bool value) {
		PyObject_SetAttrString(pyobjref, "use_merge_vertices_cap", Py_BuildValue("i", value));
	}

	/** Getter: Limit below which to merge vertices */
	float merge_threshold() { /* not implemented */ throw NULL; }
	/** Setter: Limit below which to merge vertices */
	void merge_threshold(float value) {
		PyObject_SetAttrString(pyobjref, "merge_threshold", Py_BuildValue("f", value));
	}

	/** Getter: Add another object's transformation to the total offset */
	bool use_object_offset() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_object_offset")) == 1;
	}

	/** Setter: Add another object's transformation to the total offset */
	void use_object_offset(bool value) {
		PyObject_SetAttrString(pyobjref, "use_object_offset", Py_BuildValue("i", value));
	}

	/** Getter: Use the location and rotation of another object to determine the distance and rotational change between arrayed items */
	Object offset_object();

	/** Getter: Mesh object to use as a start cap */
	Object start_cap();

	/** Getter: Mesh object to use as an end cap */
	Object end_cap();

};

/**************** EdgeSplit Modifier ****************/

/**
 * Edge splitting modifier to create sharp edges
 */
class EdgeSplitModifier : public Modifier {
public:
	EdgeSplitModifier(PyObject* pyobj) : Modifier(pyobj) {}

	EdgeSplitModifier() : Modifier(0)
	{
		// not implemented
	}

	/** Getter: Angle above which to split edges */
	float split_angle() { /* not implemented */ throw NULL; }
	/** Setter: Angle above which to split edges */
	void split_angle(float value) {
		PyObject_SetAttrString(pyobjref, "split_angle", Py_BuildValue("f", value));
	}

	/** Getter: Split edges with high angle between faces */
	bool use_edge_angle() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_edge_angle")) == 1;
	}

	/** Setter: Split edges with high angle between faces */
	void use_edge_angle(bool value) {
		PyObject_SetAttrString(pyobjref, "use_edge_angle", Py_BuildValue("i", value));
	}

	/** Getter: Split edges that are marked as sharp */
	bool use_edge_sharp() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_edge_sharp")) == 1;
	}

	/** Setter: Split edges that are marked as sharp */
	void use_edge_sharp(bool value) {
		PyObject_SetAttrString(pyobjref, "use_edge_sharp", Py_BuildValue("i", value));
	}

};

/**************** Displace Modifier ****************/

/**
 * Displacement modifier
 */
class DisplaceModifier : public Modifier {
public:
	DisplaceModifier(PyObject* pyobj) : Modifier(pyobj) {}

	DisplaceModifier() : Modifier(0)
	{
		// not implemented
	}

	/** Getter: Name of Vertex Group which determines influence of modifier per point */
	std::string vertex_group() { /* not implemented */ throw NULL; }
	/** Setter: Name of Vertex Group which determines influence of modifier per point */
	void vertex_group(const std::string& value) { /* not implemented */ }

	/** Getter: Material value that gives no displacement */
	float mid_level() { /* not implemented */ throw NULL; }
	/** Setter: Material value that gives no displacement */
	void mid_level(float value) {
		PyObject_SetAttrString(pyobjref, "mid_level", Py_BuildValue("f", value));
	}

	/** Getter: Amount to displace geometry */
	float strength() { /* not implemented */ throw NULL; }
	/** Setter: Amount to displace geometry */
	void strength(float value) {
		PyObject_SetAttrString(pyobjref, "strength", Py_BuildValue("f", value));
	}

	enum direction_enum {
		direction_X = 0,
		direction_Y = 1,
		direction_Z = 2,
		direction_NORMAL = 3,
		direction_RGB_TO_XYZ = 4,
	};

	/** Getter:  */
	direction_enum direction() { /* not implemented */ throw NULL; }
	/** Setter:  */
	void direction(direction_enum value) { /* not implemented */ }

	/** Getter:  */
	Texture texture() {
		/* not implemented */ throw NULL;
	}

	enum texture_coords_enum {
		texture_coords_LOCAL = 0,
		texture_coords_GLOBAL = 1,
		texture_coords_OBJECT = 2,
		texture_coords_UV = 3,
	};

	/** Getter:  */
	texture_coords_enum texture_coords() { /* not implemented */ throw NULL; }
	/** Setter:  */
	void texture_coords(texture_coords_enum value) { /* not implemented */ }

	/** Getter: UV map name */
	std::string uv_layer() { /* not implemented */ throw NULL; }
	/** Setter: UV map name */
	void uv_layer(const std::string& value) { /* not implemented */ }

	/** Getter: Object to set the texture coordinates */
	Object texture_coords_object();

};

/**************** UV Project Modifier ****************/

/**
 * UV projection modifier to set UVs from a projector
 */
class UVProjectModifier : public Modifier {
public:
	UVProjectModifier(PyObject* pyobj) : Modifier(pyobj) {}

	UVProjectModifier() : Modifier(0)
	{
		// not implemented
	}

	/** Getter: UV map name */
	std::string uv_layer() { /* not implemented */ throw NULL; }
	/** Setter: UV map name */
	void uv_layer(const std::string& value) { /* not implemented */ }

	/** Getter: Number of projectors to use */
	int projector_count() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "projector_count"));
	}

	/** Setter: Number of projectors to use */
	void projector_count(int value) {
		PyObject_SetAttrString(pyobjref, "projector_count", Py_BuildValue("i", value));
	}

	/** Getter:  */
	std::map<std::string, UVProjector> projectors();
	/** Setter:  */
	void projectors(std::map<std::string, UVProjector> value);

	/** Getter:  */
	Image image() {
		/* not implemented */ throw NULL;
	}

	/** Getter:  */
	float aspect_x() { /* not implemented */ throw NULL; }
	/** Setter:  */
	void aspect_x(float value) {
		PyObject_SetAttrString(pyobjref, "aspect_x", Py_BuildValue("f", value));
	}

	/** Getter:  */
	float aspect_y() { /* not implemented */ throw NULL; }
	/** Setter:  */
	void aspect_y(float value) {
		PyObject_SetAttrString(pyobjref, "aspect_y", Py_BuildValue("f", value));
	}

	/** Getter:  */
	float scale_x() { /* not implemented */ throw NULL; }
	/** Setter:  */
	void scale_x(float value) {
		PyObject_SetAttrString(pyobjref, "scale_x", Py_BuildValue("f", value));
	}

	/** Getter:  */
	float scale_y() { /* not implemented */ throw NULL; }
	/** Setter:  */
	void scale_y(float value) {
		PyObject_SetAttrString(pyobjref, "scale_y", Py_BuildValue("f", value));
	}

	/** Getter: Override faces' current images with the given image */
	bool use_image_override() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_image_override")) == 1;
	}

	/** Setter: Override faces' current images with the given image */
	void use_image_override(bool value) {
		PyObject_SetAttrString(pyobjref, "use_image_override", Py_BuildValue("i", value));
	}

};

/**************** UVProjector ****************/

/**
 * UV projector used by the UV project modifier
 */
class UVProjector : public pyUniplug {
public:
	UVProjector(PyObject* pyobj) : pyUniplug(pyobj) {}

	UVProjector() : pyUniplug(0)
	{
		// not implemented
	}

	/** Getter: Object to use as projector transform */
	Object object_value();

};

/**************** Smooth Modifier ****************/

/**
 * Smoothing effect modifier
 */
class SmoothModifier : public Modifier {
public:
	SmoothModifier(PyObject* pyobj) : Modifier(pyobj) {}

	SmoothModifier() : Modifier(0)
	{
		// not implemented
	}

	/** Getter: Smooth object along X axis */
	bool use_x() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_x")) == 1;
	}

	/** Setter: Smooth object along X axis */
	void use_x(bool value) {
		PyObject_SetAttrString(pyobjref, "use_x", Py_BuildValue("i", value));
	}

	/** Getter: Smooth object along Y axis */
	bool use_y() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_y")) == 1;
	}

	/** Setter: Smooth object along Y axis */
	void use_y(bool value) {
		PyObject_SetAttrString(pyobjref, "use_y", Py_BuildValue("i", value));
	}

	/** Getter: Smooth object along Z axis */
	bool use_z() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_z")) == 1;
	}

	/** Setter: Smooth object along Z axis */
	void use_z(bool value) {
		PyObject_SetAttrString(pyobjref, "use_z", Py_BuildValue("i", value));
	}

	/** Getter: Strength of modifier effect */
	float factor() { /* not implemented */ throw NULL; }
	/** Setter: Strength of modifier effect */
	void factor(float value) {
		PyObject_SetAttrString(pyobjref, "factor", Py_BuildValue("f", value));
	}

	/** Getter:  */
	int iterations() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "iterations"));
	}

	/** Setter:  */
	void iterations(int value) {
		PyObject_SetAttrString(pyobjref, "iterations", Py_BuildValue("i", value));
	}

	/** Getter: Name of Vertex Group which determines influence of modifier per point */
	std::string vertex_group() { /* not implemented */ throw NULL; }
	/** Setter: Name of Vertex Group which determines influence of modifier per point */
	void vertex_group(const std::string& value) { /* not implemented */ }

};

/**************** Corrective Smooth Modifier ****************/

/**
 * Correct distortion caused by deformation
 */
class CorrectiveSmoothModifier : public Modifier {
public:
	CorrectiveSmoothModifier(PyObject* pyobj) : Modifier(pyobj) {}

	CorrectiveSmoothModifier() : Modifier(0)
	{
		// not implemented
	}

	/** Getter: Smooth factor effect */
	float factor() { /* not implemented */ throw NULL; }
	/** Setter: Smooth factor effect */
	void factor(float value) {
		PyObject_SetAttrString(pyobjref, "factor", Py_BuildValue("f", value));
	}

	/** Getter:  */
	int iterations() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "iterations"));
	}

	/** Setter:  */
	void iterations(int value) {
		PyObject_SetAttrString(pyobjref, "iterations", Py_BuildValue("i", value));
	}

	enum rest_source_enum {
		rest_source_ORCO = 0,
		rest_source_BIND = 1,
	};

	/** Getter: Select the source of rest positions */
	rest_source_enum rest_source() { /* not implemented */ throw NULL; }
	/** Setter: Select the source of rest positions */
	void rest_source(rest_source_enum value) { /* not implemented */ }

	enum smooth_type_enum {
		smooth_type_SIMPLE = 0,
		smooth_type_LENGTH_WEIGHTED = 1,
	};

	/** Getter: Method used for smoothing */
	smooth_type_enum smooth_type() { /* not implemented */ throw NULL; }
	/** Setter: Method used for smoothing */
	void smooth_type(smooth_type_enum value) { /* not implemented */ }

	/** Getter: Invert vertex group influence */
	bool invert_vertex_group() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "invert_vertex_group")) == 1;
	}

	/** Setter: Invert vertex group influence */
	void invert_vertex_group(bool value) {
		PyObject_SetAttrString(pyobjref, "invert_vertex_group", Py_BuildValue("i", value));
	}

	/** Getter: Name of Vertex Group which determines influence of modifier per point */
	std::string vertex_group() { /* not implemented */ throw NULL; }
	/** Setter: Name of Vertex Group which determines influence of modifier per point */
	void vertex_group(const std::string& value) { /* not implemented */ }

	/** Getter:  */
	bool is_bind() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "is_bind")) == 1;
	}

	/** Setter:  */
	void is_bind(bool value) {
		PyObject_SetAttrString(pyobjref, "is_bind", Py_BuildValue("i", value));
	}

	/** Getter: Apply smoothing without reconstructing the surface */
	bool use_only_smooth() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_only_smooth")) == 1;
	}

	/** Setter: Apply smoothing without reconstructing the surface */
	void use_only_smooth(bool value) {
		PyObject_SetAttrString(pyobjref, "use_only_smooth", Py_BuildValue("i", value));
	}

	/** Getter: Excludes boundary vertices from being smoothed */
	bool use_pin_boundary() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_pin_boundary")) == 1;
	}

	/** Setter: Excludes boundary vertices from being smoothed */
	void use_pin_boundary(bool value) {
		PyObject_SetAttrString(pyobjref, "use_pin_boundary", Py_BuildValue("i", value));
	}

};

/**************** Cast Modifier ****************/

/**
 * Modifier to cast to other shapes
 */
class CastModifier : public Modifier {
public:
	CastModifier(PyObject* pyobj) : Modifier(pyobj) {}

	CastModifier() : Modifier(0)
	{
		// not implemented
	}

	enum cast_type_enum {
		cast_type_SPHERE = 0,
		cast_type_CYLINDER = 1,
		cast_type_CUBOID = 2,
	};

	/** Getter: Target object shape */
	cast_type_enum cast_type() { /* not implemented */ throw NULL; }
	/** Setter: Target object shape */
	void cast_type(cast_type_enum value) { /* not implemented */ }

	/** Getter: Control object: if available, its location determines the center of the effect */
	Object object_value();

	/** Getter:  */
	bool use_x() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_x")) == 1;
	}

	/** Setter:  */
	void use_x(bool value) {
		PyObject_SetAttrString(pyobjref, "use_x", Py_BuildValue("i", value));
	}

	/** Getter:  */
	bool use_y() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_y")) == 1;
	}

	/** Setter:  */
	void use_y(bool value) {
		PyObject_SetAttrString(pyobjref, "use_y", Py_BuildValue("i", value));
	}

	/** Getter:  */
	bool use_z() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_z")) == 1;
	}

	/** Setter:  */
	void use_z(bool value) {
		PyObject_SetAttrString(pyobjref, "use_z", Py_BuildValue("i", value));
	}

	/** Getter: Use radius as size of projection shape (0 = auto) */
	bool use_radius_as_size() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_radius_as_size")) == 1;
	}

	/** Setter: Use radius as size of projection shape (0 = auto) */
	void use_radius_as_size(bool value) {
		PyObject_SetAttrString(pyobjref, "use_radius_as_size", Py_BuildValue("i", value));
	}

	/** Getter: Use object transform to control projection shape */
	bool use_transform() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_transform")) == 1;
	}

	/** Setter: Use object transform to control projection shape */
	void use_transform(bool value) {
		PyObject_SetAttrString(pyobjref, "use_transform", Py_BuildValue("i", value));
	}

	/** Getter:  */
	float factor() { /* not implemented */ throw NULL; }
	/** Setter:  */
	void factor(float value) {
		PyObject_SetAttrString(pyobjref, "factor", Py_BuildValue("f", value));
	}

	/** Getter: Only deform vertices within this distance from the center of the effect (leave as 0 for infinite.) */
	float radius() { /* not implemented */ throw NULL; }
	/** Setter: Only deform vertices within this distance from the center of the effect (leave as 0 for infinite.) */
	void radius(float value) {
		PyObject_SetAttrString(pyobjref, "radius", Py_BuildValue("f", value));
	}

	/** Getter: Size of projection shape (leave as 0 for auto) */
	float size() { /* not implemented */ throw NULL; }
	/** Setter: Size of projection shape (leave as 0 for auto) */
	void size(float value) {
		PyObject_SetAttrString(pyobjref, "size", Py_BuildValue("f", value));
	}

	/** Getter: Vertex group name */
	std::string vertex_group() { /* not implemented */ throw NULL; }
	/** Setter: Vertex group name */
	void vertex_group(const std::string& value) { /* not implemented */ }

};

/**************** MeshDeform Modifier ****************/

/**
 * Mesh deformation modifier to deform with other meshes
 */
class MeshDeformModifier : public Modifier {
public:
	MeshDeformModifier(PyObject* pyobj) : Modifier(pyobj) {}

	MeshDeformModifier() : Modifier(0)
	{
		// not implemented
	}

	/** Getter: Mesh object to deform with */
	Object object_value();

	/** Getter: Whether geometry has been bound to control cage */
	bool is_bound() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "is_bound")) == 1;
	}

	/** Setter: Whether geometry has been bound to control cage */
	void is_bound(bool value) {
		PyObject_SetAttrString(pyobjref, "is_bound", Py_BuildValue("i", value));
	}

	/** Getter: Invert vertex group influence */
	bool invert_vertex_group() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "invert_vertex_group")) == 1;
	}

	/** Setter: Invert vertex group influence */
	void invert_vertex_group(bool value) {
		PyObject_SetAttrString(pyobjref, "invert_vertex_group", Py_BuildValue("i", value));
	}

	/** Getter: Vertex group name */
	std::string vertex_group() { /* not implemented */ throw NULL; }
	/** Setter: Vertex group name */
	void vertex_group(const std::string& value) { /* not implemented */ }

	/** Getter: The grid size for binding */
	int precision() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "precision"));
	}

	/** Setter: The grid size for binding */
	void precision(int value) {
		PyObject_SetAttrString(pyobjref, "precision", Py_BuildValue("i", value));
	}

	/** Getter: Recompute binding dynamically on top of other deformers (slower and more memory consuming) */
	bool use_dynamic_bind() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_dynamic_bind")) == 1;
	}

	/** Setter: Recompute binding dynamically on top of other deformers (slower and more memory consuming) */
	void use_dynamic_bind(bool value) {
		PyObject_SetAttrString(pyobjref, "use_dynamic_bind", Py_BuildValue("i", value));
	}

};

/**************** ParticleSystem Modifier ****************/

/**
 * Particle system simulation modifier
 */
class ParticleSystemModifier : public Modifier {
public:
	ParticleSystemModifier(PyObject* pyobj) : Modifier(pyobj) {}

	ParticleSystemModifier() : Modifier(0)
	{
		// not implemented
	}

	/** Getter: Particle System that this modifier controls */
	ParticleSystem particle_system();

};

/**************** ParticleInstance Modifier ****************/

/**
 * Particle system instancing modifier
 */
class ParticleInstanceModifier : public Modifier {
public:
	ParticleInstanceModifier(PyObject* pyobj) : Modifier(pyobj) {}

	ParticleInstanceModifier() : Modifier(0)
	{
		// not implemented
	}

	/** Getter: Object that has the particle system */
	Object object_value();

	/** Getter:  */
	int particle_system_index() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "particle_system_index"));
	}

	/** Setter:  */
	void particle_system_index(int value) {
		PyObject_SetAttrString(pyobjref, "particle_system_index", Py_BuildValue("i", value));
	}

	enum axis_enum {
		axis_X = 0,
		axis_Y = 1,
		axis_Z = 2,
	};

	/** Getter: Pole axis for rotation */
	axis_enum axis() { /* not implemented */ throw NULL; }
	/** Setter: Pole axis for rotation */
	void axis(axis_enum value) { /* not implemented */ }

	/** Getter: Create instances from normal particles */
	bool use_normal() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_normal")) == 1;
	}

	/** Setter: Create instances from normal particles */
	void use_normal(bool value) {
		PyObject_SetAttrString(pyobjref, "use_normal", Py_BuildValue("i", value));
	}

	/** Getter: Create instances from child particles */
	bool use_children() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_children")) == 1;
	}

	/** Setter: Create instances from child particles */
	void use_children(bool value) {
		PyObject_SetAttrString(pyobjref, "use_children", Py_BuildValue("i", value));
	}

	/** Getter: Create instances along particle paths */
	bool use_path() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_path")) == 1;
	}

	/** Setter: Create instances along particle paths */
	void use_path(bool value) {
		PyObject_SetAttrString(pyobjref, "use_path", Py_BuildValue("i", value));
	}

	/** Getter: Show instances when particles are unborn */
	bool show_unborn() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "show_unborn")) == 1;
	}

	/** Setter: Show instances when particles are unborn */
	void show_unborn(bool value) {
		PyObject_SetAttrString(pyobjref, "show_unborn", Py_BuildValue("i", value));
	}

	/** Getter: Show instances when particles are alive */
	bool show_alive() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "show_alive")) == 1;
	}

	/** Setter: Show instances when particles are alive */
	void show_alive(bool value) {
		PyObject_SetAttrString(pyobjref, "show_alive", Py_BuildValue("i", value));
	}

	/** Getter: Show instances when particles are dead */
	bool show_dead() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "show_dead")) == 1;
	}

	/** Setter: Show instances when particles are dead */
	void show_dead(bool value) {
		PyObject_SetAttrString(pyobjref, "show_dead", Py_BuildValue("i", value));
	}

	/** Getter: Don't stretch the object */
	bool use_preserve_shape() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_preserve_shape")) == 1;
	}

	/** Setter: Don't stretch the object */
	void use_preserve_shape(bool value) {
		PyObject_SetAttrString(pyobjref, "use_preserve_shape", Py_BuildValue("i", value));
	}

	/** Getter: Use particle size to scale the instances */
	bool use_size() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_size")) == 1;
	}

	/** Setter: Use particle size to scale the instances */
	void use_size(bool value) {
		PyObject_SetAttrString(pyobjref, "use_size", Py_BuildValue("i", value));
	}

	/** Getter: Position along path */
	float position() { /* not implemented */ throw NULL; }
	/** Setter: Position along path */
	void position(float value) {
		PyObject_SetAttrString(pyobjref, "position", Py_BuildValue("f", value));
	}

	/** Getter: Randomize position along path */
	float random_position() { /* not implemented */ throw NULL; }
	/** Setter: Randomize position along path */
	void random_position(float value) {
		PyObject_SetAttrString(pyobjref, "random_position", Py_BuildValue("f", value));
	}

};

/**************** Explode Modifier ****************/

/**
 * Explosion effect modifier based on a particle system
 */
class ExplodeModifier : public Modifier {
public:
	ExplodeModifier(PyObject* pyobj) : Modifier(pyobj) {}

	ExplodeModifier() : Modifier(0)
	{
		// not implemented
	}

	/** Getter:  */
	std::string vertex_group() { /* not implemented */ throw NULL; }
	/** Setter:  */
	void vertex_group(const std::string& value) { /* not implemented */ }

	/** Getter: Clean vertex group edges */
	float protect() { /* not implemented */ throw NULL; }
	/** Setter: Clean vertex group edges */
	void protect(float value) {
		PyObject_SetAttrString(pyobjref, "protect", Py_BuildValue("f", value));
	}

	/** Getter: Cut face edges for nicer shrapnel */
	bool use_edge_cut() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_edge_cut")) == 1;
	}

	/** Setter: Cut face edges for nicer shrapnel */
	void use_edge_cut(bool value) {
		PyObject_SetAttrString(pyobjref, "use_edge_cut", Py_BuildValue("i", value));
	}

	/** Getter: Show mesh when particles are unborn */
	bool show_unborn() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "show_unborn")) == 1;
	}

	/** Setter: Show mesh when particles are unborn */
	void show_unborn(bool value) {
		PyObject_SetAttrString(pyobjref, "show_unborn", Py_BuildValue("i", value));
	}

	/** Getter: Show mesh when particles are alive */
	bool show_alive() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "show_alive")) == 1;
	}

	/** Setter: Show mesh when particles are alive */
	void show_alive(bool value) {
		PyObject_SetAttrString(pyobjref, "show_alive", Py_BuildValue("i", value));
	}

	/** Getter: Show mesh when particles are dead */
	bool show_dead() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "show_dead")) == 1;
	}

	/** Setter: Show mesh when particles are dead */
	void show_dead(bool value) {
		PyObject_SetAttrString(pyobjref, "show_dead", Py_BuildValue("i", value));
	}

	/** Getter: Use particle size for the shrapnel */
	bool use_size() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_size")) == 1;
	}

	/** Setter: Use particle size for the shrapnel */
	void use_size(bool value) {
		PyObject_SetAttrString(pyobjref, "use_size", Py_BuildValue("i", value));
	}

	/** Getter: UV map to change with particle age */
	std::string particle_uv() { /* not implemented */ throw NULL; }
	/** Setter: UV map to change with particle age */
	void particle_uv(const std::string& value) { /* not implemented */ }

};

/**************** Cloth Modifier ****************/

/**
 * Cloth simulation modifier
 */
class ClothModifier : public Modifier {
public:
	ClothModifier(PyObject* pyobj) : Modifier(pyobj) {}

	ClothModifier() : Modifier(0)
	{
		// not implemented
	}

	/** Getter:  */
	ClothSettings settings() {
		/* not implemented */ throw NULL;
	}

	/** Getter:  */
	ClothCollisionSettings collision_settings() {
		/* not implemented */ throw NULL;
	}

	/** Getter:  */
	ClothSolverResult solver_result() {
		/* not implemented */ throw NULL;
	}

	/** Getter:  */
	PointCache point_cache();

	/** Getter:  */
	std::array<float, 3> hair_grid_min() {
		// TODO: MISSING DEREF! USE #DEFINE!
		PyObject *seqval = PyObject_GetAttrString(pyobjref, "hair_grid_min");
		std::array<float, 3> resarr;
		for (int i = 0; i < 3; i++)
			resarr[i] = (float)PyFloat_AsDouble(PySequence_GetItem(seqval, i));
		return resarr;
	}

	/** Setter:  */
	void hair_grid_min(float values[3]) { /* not implemented */ }

	/** Getter:  */
	std::array<float, 3> hair_grid_max() {
		// TODO: MISSING DEREF! USE #DEFINE!
		PyObject *seqval = PyObject_GetAttrString(pyobjref, "hair_grid_max");
		std::array<float, 3> resarr;
		for (int i = 0; i < 3; i++)
			resarr[i] = (float)PyFloat_AsDouble(PySequence_GetItem(seqval, i));
		return resarr;
	}

	/** Setter:  */
	void hair_grid_max(float values[3]) { /* not implemented */ }

	/** Getter:  */
	std::array<int, 3> hair_grid_resolution() {
		// TODO: MISSING DEREF! USE #DEFINE!
		PyObject *seqval = PyObject_GetAttrString(pyobjref, "hair_grid_resolution");
		std::array<int, 3> resarr;
		for (int i = 0; i < 3; i++)
			resarr[i] = PyLong_AsLong(PySequence_GetItem(seqval, i));
		return resarr;
	}

	/** Setter:  */
	void hair_grid_resolution(int values[3]) { /* not implemented */ }

};

/**************** Collision Modifier ****************/

/**
 * Collision modifier defining modifier stack position used for collision
 */
class CollisionModifier : public Modifier {
public:
	CollisionModifier(PyObject* pyobj) : Modifier(pyobj) {}

	CollisionModifier() : Modifier(0)
	{
		// not implemented
	}

	/** Getter:  */
	CollisionSettings settings();

};

/**************** Bevel Modifier ****************/

/**
 * Bevel modifier to make edges and vertices more rounded
 */
class BevelModifier : public Modifier {
public:
	BevelModifier(PyObject* pyobj) : Modifier(pyobj) {}

	BevelModifier() : Modifier(0)
	{
		// not implemented
	}

	/** Getter: Bevel value/amount */
	float width() { /* not implemented */ throw NULL; }
	/** Setter: Bevel value/amount */
	void width(float value) {
		PyObject_SetAttrString(pyobjref, "width", Py_BuildValue("f", value));
	}

	/** Getter: Number of segments for round edges/verts */
	int segments() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "segments"));
	}

	/** Setter: Number of segments for round edges/verts */
	void segments(int value) {
		PyObject_SetAttrString(pyobjref, "segments", Py_BuildValue("i", value));
	}

	/** Getter: Bevel verts/corners, not edges */
	bool use_only_vertices() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_only_vertices")) == 1;
	}

	/** Setter: Bevel verts/corners, not edges */
	void use_only_vertices(bool value) {
		PyObject_SetAttrString(pyobjref, "use_only_vertices", Py_BuildValue("i", value));
	}

	enum limit_method_enum {
		limit_method_NONE = 0,
		limit_method_ANGLE = 8,
		limit_method_WEIGHT = 16,
		limit_method_VGROUP = 32,
	};

	/** Getter:  */
	limit_method_enum limit_method() { /* not implemented */ throw NULL; }
	/** Setter:  */
	void limit_method(limit_method_enum value) { /* not implemented */ }

	enum edge_weight_method_enum {
		edge_weight_method_AVERAGE = 0,
		edge_weight_method_SHARPEST = 128,
		edge_weight_method_LARGEST = 256,
	};

	/** Getter: What edge weight to use for weighting a vertex */
	edge_weight_method_enum edge_weight_method() { /* not implemented */ throw NULL; }
	/** Setter: What edge weight to use for weighting a vertex */
	void edge_weight_method(edge_weight_method_enum value) { /* not implemented */ }

	/** Getter: Angle above which to bevel edges */
	float angle_limit() { /* not implemented */ throw NULL; }
	/** Setter: Angle above which to bevel edges */
	void angle_limit(float value) {
		PyObject_SetAttrString(pyobjref, "angle_limit", Py_BuildValue("f", value));
	}

	/** Getter: Vertex group name */
	std::string vertex_group() { /* not implemented */ throw NULL; }
	/** Setter: Vertex group name */
	void vertex_group(const std::string& value) { /* not implemented */ }

	/** Getter: Clamp the width to avoid overlap */
	bool use_clamp_overlap() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_clamp_overlap")) == 1;
	}

	/** Setter: Clamp the width to avoid overlap */
	void use_clamp_overlap(bool value) {
		PyObject_SetAttrString(pyobjref, "use_clamp_overlap", Py_BuildValue("i", value));
	}

	enum offset_type_enum {
		offset_type_OFFSET = 0,
		offset_type_WIDTH = 1,
		offset_type_DEPTH = 2,
		offset_type_PERCENT = 3,
	};

	/** Getter: What distance Width measures */
	offset_type_enum offset_type() { /* not implemented */ throw NULL; }
	/** Setter: What distance Width measures */
	void offset_type(offset_type_enum value) { /* not implemented */ }

	/** Getter: The profile shape (0.5 = round) */
	float profile() { /* not implemented */ throw NULL; }
	/** Setter: The profile shape (0.5 = round) */
	void profile(float value) {
		PyObject_SetAttrString(pyobjref, "profile", Py_BuildValue("f", value));
	}

	/** Getter: Material index of generated faces, -1 for automatic */
	int material() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "material"));
	}

	/** Setter: Material index of generated faces, -1 for automatic */
	void material(int value) {
		PyObject_SetAttrString(pyobjref, "material", Py_BuildValue("i", value));
	}

};

/**************** Shrinkwrap Modifier ****************/

/**
 * Shrink wrapping modifier to shrink wrap and object to a target
 */
class ShrinkwrapModifier : public Modifier {
public:
	ShrinkwrapModifier(PyObject* pyobj) : Modifier(pyobj) {}

	ShrinkwrapModifier() : Modifier(0)
	{
		// not implemented
	}

	enum wrap_method_enum {
		wrap_method_NEAREST_SURFACEPOINT = 0,
		wrap_method_PROJECT = 1,
		wrap_method_NEAREST_VERTEX = 2,
	};

	/** Getter:  */
	wrap_method_enum wrap_method() { /* not implemented */ throw NULL; }
	/** Setter:  */
	void wrap_method(wrap_method_enum value) { /* not implemented */ }

	enum cull_face_enum {
		cull_face_OFF = 0,
		cull_face_FRONT = 8,
		cull_face_BACK = 16,
	};

	/** Getter: Stop vertices from projecting to a face on the target when facing towards/away */
	cull_face_enum cull_face() { /* not implemented */ throw NULL; }
	/** Setter: Stop vertices from projecting to a face on the target when facing towards/away */
	void cull_face(cull_face_enum value) { /* not implemented */ }

	/** Getter: Mesh target to shrink to */
	Object target();

	/** Getter: Additional mesh target to shrink to */
	Object auxiliary_target();

	/** Getter: Vertex group name */
	std::string vertex_group() { /* not implemented */ throw NULL; }
	/** Setter: Vertex group name */
	void vertex_group(const std::string& value) { /* not implemented */ }

	/** Getter: Distance to keep from the target */
	float offset() { /* not implemented */ throw NULL; }
	/** Setter: Distance to keep from the target */
	void offset(float value) {
		PyObject_SetAttrString(pyobjref, "offset", Py_BuildValue("f", value));
	}

	/** Getter: Limit the distance used for projection (zero disables) */
	float project_limit() { /* not implemented */ throw NULL; }
	/** Setter: Limit the distance used for projection (zero disables) */
	void project_limit(float value) {
		PyObject_SetAttrString(pyobjref, "project_limit", Py_BuildValue("f", value));
	}

	/** Getter:  */
	bool use_project_x() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_project_x")) == 1;
	}

	/** Setter:  */
	void use_project_x(bool value) {
		PyObject_SetAttrString(pyobjref, "use_project_x", Py_BuildValue("i", value));
	}

	/** Getter:  */
	bool use_project_y() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_project_y")) == 1;
	}

	/** Setter:  */
	void use_project_y(bool value) {
		PyObject_SetAttrString(pyobjref, "use_project_y", Py_BuildValue("i", value));
	}

	/** Getter:  */
	bool use_project_z() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_project_z")) == 1;
	}

	/** Setter:  */
	void use_project_z(bool value) {
		PyObject_SetAttrString(pyobjref, "use_project_z", Py_BuildValue("i", value));
	}

	/** Getter: Number of subdivisions that must be performed before extracting vertices' positions and normals */
	int subsurf_levels() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "subsurf_levels"));
	}

	/** Setter: Number of subdivisions that must be performed before extracting vertices' positions and normals */
	void subsurf_levels(int value) {
		PyObject_SetAttrString(pyobjref, "subsurf_levels", Py_BuildValue("i", value));
	}

	/** Getter: Allow vertices to move in the negative direction of axis */
	bool use_negative_direction() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_negative_direction")) == 1;
	}

	/** Setter: Allow vertices to move in the negative direction of axis */
	void use_negative_direction(bool value) {
		PyObject_SetAttrString(pyobjref, "use_negative_direction", Py_BuildValue("i", value));
	}

	/** Getter: Allow vertices to move in the positive direction of axis */
	bool use_positive_direction() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_positive_direction")) == 1;
	}

	/** Setter: Allow vertices to move in the positive direction of axis */
	void use_positive_direction(bool value) {
		PyObject_SetAttrString(pyobjref, "use_positive_direction", Py_BuildValue("i", value));
	}

	/** Getter:  */
	bool use_keep_above_surface() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_keep_above_surface")) == 1;
	}

	/** Setter:  */
	void use_keep_above_surface(bool value) {
		PyObject_SetAttrString(pyobjref, "use_keep_above_surface", Py_BuildValue("i", value));
	}

};

/**************** Fluid Simulation Modifier ****************/

/**
 * Fluid simulation modifier
 */
class FluidSimulationModifier : public Modifier {
public:
	FluidSimulationModifier(PyObject* pyobj) : Modifier(pyobj) {}

	FluidSimulationModifier() : Modifier(0)
	{
		// not implemented
	}

	/** Getter: Settings for how this object is used in the fluid simulation */
	FluidSettings settings() {
		/* not implemented */ throw NULL;
	}

};

/**************** Mask Modifier ****************/

/**
 * Mask modifier to hide parts of the mesh
 */
class MaskModifier : public Modifier {
public:
	MaskModifier(PyObject* pyobj) : Modifier(pyobj) {}

	MaskModifier() : Modifier(0)
	{
		// not implemented
	}

	enum mode_enum {
		mode_VERTEX_GROUP = 0,
		mode_ARMATURE = 1,
	};

	/** Getter:  */
	mode_enum mode() { /* not implemented */ throw NULL; }
	/** Setter:  */
	void mode(mode_enum value) { /* not implemented */ }

	/** Getter: Armature to use as source of bones to mask */
	Object armature();

	/** Getter: Vertex group name */
	std::string vertex_group() { /* not implemented */ throw NULL; }
	/** Setter: Vertex group name */
	void vertex_group(const std::string& value) { /* not implemented */ }

	/** Getter: Use vertices that are not part of region defined */
	bool invert_vertex_group() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "invert_vertex_group")) == 1;
	}

	/** Setter: Use vertices that are not part of region defined */
	void invert_vertex_group(bool value) {
		PyObject_SetAttrString(pyobjref, "invert_vertex_group", Py_BuildValue("i", value));
	}

};

/**************** SimpleDeform Modifier ****************/

/**
 * Simple deformation modifier to apply effects such as twisting and bending
 */
class SimpleDeformModifier : public Modifier {
public:
	SimpleDeformModifier(PyObject* pyobj) : Modifier(pyobj) {}

	SimpleDeformModifier() : Modifier(0)
	{
		// not implemented
	}

	enum deform_method_enum {
		deform_method_TWIST = 1,
		deform_method_BEND = 2,
		deform_method_TAPER = 3,
		deform_method_STRETCH = 4,
	};

	/** Getter:  */
	deform_method_enum deform_method() { /* not implemented */ throw NULL; }
	/** Setter:  */
	void deform_method(deform_method_enum value) { /* not implemented */ }

	/** Getter: Vertex group name */
	std::string vertex_group() { /* not implemented */ throw NULL; }
	/** Setter: Vertex group name */
	void vertex_group(const std::string& value) { /* not implemented */ }

	/** Getter: Offset the origin and orientation of the deformation */
	Object origin();

	/** Getter: Amount to deform object */
	float factor() { /* not implemented */ throw NULL; }
	/** Setter: Amount to deform object */
	void factor(float value) {
		PyObject_SetAttrString(pyobjref, "factor", Py_BuildValue("f", value));
	}

	/** Getter: Angle of deformation */
	float angle() { /* not implemented */ throw NULL; }
	/** Setter: Angle of deformation */
	void angle(float value) {
		PyObject_SetAttrString(pyobjref, "angle", Py_BuildValue("f", value));
	}

	/** Getter: Lower/Upper limits for deform */
	std::array<float, 2> limits() {
		// TODO: MISSING DEREF! USE #DEFINE!
		PyObject *seqval = PyObject_GetAttrString(pyobjref, "limits");
		std::array<float, 2> resarr;
		for (int i = 0; i < 2; i++)
			resarr[i] = (float)PyFloat_AsDouble(PySequence_GetItem(seqval, i));
		return resarr;
	}

	/** Setter: Lower/Upper limits for deform */
	void limits(float values[2]) { /* not implemented */ }

	/** Getter: Do not allow deformation along the X axis */
	bool lock_x() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "lock_x")) == 1;
	}

	/** Setter: Do not allow deformation along the X axis */
	void lock_x(bool value) {
		PyObject_SetAttrString(pyobjref, "lock_x", Py_BuildValue("i", value));
	}

	/** Getter: Do not allow deformation along the Y axis */
	bool lock_y() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "lock_y")) == 1;
	}

	/** Setter: Do not allow deformation along the Y axis */
	void lock_y(bool value) {
		PyObject_SetAttrString(pyobjref, "lock_y", Py_BuildValue("i", value));
	}

};

/**************** Warp Modifier ****************/

/**
 * Warp modifier
 */
class WarpModifier : public Modifier {
public:
	WarpModifier(PyObject* pyobj) : Modifier(pyobj) {}

	WarpModifier() : Modifier(0)
	{
		// not implemented
	}

	/** Getter: Object to transform from */
	Object object_from();

	/** Getter: Object to transform to */
	Object object_to();

	/** Getter:  */
	float strength() { /* not implemented */ throw NULL; }
	/** Setter:  */
	void strength(float value) {
		PyObject_SetAttrString(pyobjref, "strength", Py_BuildValue("f", value));
	}

	enum falloff_type_enum {
		falloff_type_NONE = 0,
		falloff_type_CURVE = 1,
		falloff_type_SMOOTH = 3,
		falloff_type_SPHERE = 7,
		falloff_type_ROOT = 4,
		falloff_type_INVERSE_SQUARE = 8,
		falloff_type_SHARP = 2,
		falloff_type_LINEAR = 5,
		falloff_type_CONSTANT = 6,
	};

	/** Getter:  */
	falloff_type_enum falloff_type() { /* not implemented */ throw NULL; }
	/** Setter:  */
	void falloff_type(falloff_type_enum value) { /* not implemented */ }

	/** Getter: Radius to apply */
	float falloff_radius() { /* not implemented */ throw NULL; }
	/** Setter: Radius to apply */
	void falloff_radius(float value) {
		PyObject_SetAttrString(pyobjref, "falloff_radius", Py_BuildValue("f", value));
	}

	/** Getter: Custom Lamp Falloff Curve */
	CurveMapping falloff_curve() {
		/* not implemented */ throw NULL;
	}

	/** Getter: Preserve volume when rotations are used */
	bool use_volume_preserve() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_volume_preserve")) == 1;
	}

	/** Setter: Preserve volume when rotations are used */
	void use_volume_preserve(bool value) {
		PyObject_SetAttrString(pyobjref, "use_volume_preserve", Py_BuildValue("i", value));
	}

	/** Getter: Vertex group name for modulating the deform */
	std::string vertex_group() { /* not implemented */ throw NULL; }
	/** Setter: Vertex group name for modulating the deform */
	void vertex_group(const std::string& value) { /* not implemented */ }

	/** Getter:  */
	Texture texture() {
		/* not implemented */ throw NULL;
	}

	enum texture_coords_enum {
		texture_coords_LOCAL = 0,
		texture_coords_GLOBAL = 1,
		texture_coords_OBJECT = 2,
		texture_coords_UV = 3,
	};

	/** Getter:  */
	texture_coords_enum texture_coords() { /* not implemented */ throw NULL; }
	/** Setter:  */
	void texture_coords(texture_coords_enum value) { /* not implemented */ }

	/** Getter: UV map name */
	std::string uv_layer() { /* not implemented */ throw NULL; }
	/** Setter: UV map name */
	void uv_layer(const std::string& value) { /* not implemented */ }

	/** Getter: Object to set the texture coordinates */
	Object texture_coords_object();

};

/**************** Multires Modifier ****************/

/**
 * Multiresolution mesh modifier
 */
class MultiresModifier : public Modifier {
public:
	MultiresModifier(PyObject* pyobj) : Modifier(pyobj) {}

	MultiresModifier() : Modifier(0)
	{
		// not implemented
	}

	enum subdivision_type_enum {
		subdivision_type_CATMULL_CLARK = 0,
		subdivision_type_SIMPLE = 1,
	};

	/** Getter: Select type of subdivision algorithm */
	subdivision_type_enum subdivision_type() { /* not implemented */ throw NULL; }
	/** Setter: Select type of subdivision algorithm */
	void subdivision_type(subdivision_type_enum value) { /* not implemented */ }

	/** Getter: Number of subdivisions to use in the viewport */
	int levels() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "levels"));
	}

	/** Setter: Number of subdivisions to use in the viewport */
	void levels(int value) {
		PyObject_SetAttrString(pyobjref, "levels", Py_BuildValue("i", value));
	}

	/** Getter: Number of subdivisions to use in sculpt mode */
	int sculpt_levels() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "sculpt_levels"));
	}

	/** Setter: Number of subdivisions to use in sculpt mode */
	void sculpt_levels(int value) {
		PyObject_SetAttrString(pyobjref, "sculpt_levels", Py_BuildValue("i", value));
	}

	/** Getter: The subdivision level visible at render time */
	int render_levels() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "render_levels"));
	}

	/** Setter: The subdivision level visible at render time */
	void render_levels(int value) {
		PyObject_SetAttrString(pyobjref, "render_levels", Py_BuildValue("i", value));
	}

	/** Getter: Number of subdivisions for which displacements are stored */
	int total_levels() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "total_levels"));
	}

	/** Setter: Number of subdivisions for which displacements are stored */
	void total_levels(int value) {
		PyObject_SetAttrString(pyobjref, "total_levels", Py_BuildValue("i", value));
	}

	/** Getter: Store multires displacements outside the .blend file, to save memory */
	bool is_external() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "is_external")) == 1;
	}

	/** Setter: Store multires displacements outside the .blend file, to save memory */
	void is_external(bool value) {
		PyObject_SetAttrString(pyobjref, "is_external", Py_BuildValue("i", value));
	}

	/** Getter: Path to external displacements file */
	std::string filepath() { /* not implemented */ throw NULL; }
	/** Setter: Path to external displacements file */
	void filepath(const std::string& value) { /* not implemented */ }

	/** Getter: Skip drawing/rendering of interior subdivided edges */
	bool show_only_control_edges() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "show_only_control_edges")) == 1;
	}

	/** Setter: Skip drawing/rendering of interior subdivided edges */
	void show_only_control_edges(bool value) {
		PyObject_SetAttrString(pyobjref, "show_only_control_edges", Py_BuildValue("i", value));
	}

	/** Getter: Use subsurf to subdivide UVs */
	bool use_subsurf_uv() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_subsurf_uv")) == 1;
	}

	/** Setter: Use subsurf to subdivide UVs */
	void use_subsurf_uv(bool value) {
		PyObject_SetAttrString(pyobjref, "use_subsurf_uv", Py_BuildValue("i", value));
	}

};

/**************** Surface Modifier ****************/

/**
 * Surface modifier defining modifier stack position used for surface fields
 */
class SurfaceModifier : public Modifier {
public:
	SurfaceModifier(PyObject* pyobj) : Modifier(pyobj) {}

	SurfaceModifier() : Modifier(0)
	{
		// not implemented
	}

};

/**************** Smoke Modifier ****************/

/**
 * Smoke simulation modifier
 */
class SmokeModifier : public Modifier {
public:
	SmokeModifier(PyObject* pyobj) : Modifier(pyobj) {}

	SmokeModifier() : Modifier(0)
	{
		// not implemented
	}

	/** Getter:  */
	SmokeDomainSettings domain_settings();

	/** Getter:  */
	SmokeFlowSettings flow_settings();

	/** Getter:  */
	SmokeCollSettings coll_settings();

	enum smoke_type_enum {
		smoke_type_NONE = 0,
		smoke_type_DOMAIN = 1,
		smoke_type_FLOW = 2,
		smoke_type_COLLISION = 4,
	};

	/** Getter:  */
	smoke_type_enum smoke_type() { /* not implemented */ throw NULL; }
	/** Setter:  */
	void smoke_type(smoke_type_enum value) { /* not implemented */ }

};

/**************** Solidify Modifier ****************/

/**
 * Create a solid skin by extruding, compensating for sharp angles
 */
class SolidifyModifier : public Modifier {
public:
	SolidifyModifier(PyObject* pyobj) : Modifier(pyobj) {}

	SolidifyModifier() : Modifier(0)
	{
		// not implemented
	}

	/** Getter: Thickness of the shell */
	float thickness() { /* not implemented */ throw NULL; }
	/** Setter: Thickness of the shell */
	void thickness(float value) {
		PyObject_SetAttrString(pyobjref, "thickness", Py_BuildValue("f", value));
	}

	/** Getter: Offset clamp based on geometry scale */
	float thickness_clamp() { /* not implemented */ throw NULL; }
	/** Setter: Offset clamp based on geometry scale */
	void thickness_clamp(float value) {
		PyObject_SetAttrString(pyobjref, "thickness_clamp", Py_BuildValue("f", value));
	}

	/** Getter: Thickness factor to use for zero vertex group influence */
	float thickness_vertex_group() { /* not implemented */ throw NULL; }
	/** Setter: Thickness factor to use for zero vertex group influence */
	void thickness_vertex_group(float value) {
		PyObject_SetAttrString(pyobjref, "thickness_vertex_group", Py_BuildValue("f", value));
	}

	/** Getter: Offset the thickness from the center */
	float offset() { /* not implemented */ throw NULL; }
	/** Setter: Offset the thickness from the center */
	void offset(float value) {
		PyObject_SetAttrString(pyobjref, "offset", Py_BuildValue("f", value));
	}

	/** Getter: Assign a crease to inner edges */
	float edge_crease_inner() { /* not implemented */ throw NULL; }
	/** Setter: Assign a crease to inner edges */
	void edge_crease_inner(float value) {
		PyObject_SetAttrString(pyobjref, "edge_crease_inner", Py_BuildValue("f", value));
	}

	/** Getter: Assign a crease to outer edges */
	float edge_crease_outer() { /* not implemented */ throw NULL; }
	/** Setter: Assign a crease to outer edges */
	void edge_crease_outer(float value) {
		PyObject_SetAttrString(pyobjref, "edge_crease_outer", Py_BuildValue("f", value));
	}

	/** Getter: Assign a crease to the edges making up the rim */
	float edge_crease_rim() { /* not implemented */ throw NULL; }
	/** Setter: Assign a crease to the edges making up the rim */
	void edge_crease_rim(float value) {
		PyObject_SetAttrString(pyobjref, "edge_crease_rim", Py_BuildValue("f", value));
	}

	/** Getter: Offset material index of generated faces */
	int material_offset() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "material_offset"));
	}

	/** Setter: Offset material index of generated faces */
	void material_offset(int value) {
		PyObject_SetAttrString(pyobjref, "material_offset", Py_BuildValue("i", value));
	}

	/** Getter: Offset material index of generated rim faces */
	int material_offset_rim() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "material_offset_rim"));
	}

	/** Setter: Offset material index of generated rim faces */
	void material_offset_rim(int value) {
		PyObject_SetAttrString(pyobjref, "material_offset_rim", Py_BuildValue("i", value));
	}

	/** Getter: Vertex group name */
	std::string vertex_group() { /* not implemented */ throw NULL; }
	/** Setter: Vertex group name */
	void vertex_group(const std::string& value) { /* not implemented */ }

	/** Getter: Create edge loops between the inner and outer surfaces on face edges (slow, disable when not needed) */
	bool use_rim() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_rim")) == 1;
	}

	/** Setter: Create edge loops between the inner and outer surfaces on face edges (slow, disable when not needed) */
	void use_rim(bool value) {
		PyObject_SetAttrString(pyobjref, "use_rim", Py_BuildValue("i", value));
	}

	/** Getter: Maintain thickness by adjusting for sharp corners (slow, disable when not needed) */
	bool use_even_offset() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_even_offset")) == 1;
	}

	/** Setter: Maintain thickness by adjusting for sharp corners (slow, disable when not needed) */
	void use_even_offset(bool value) {
		PyObject_SetAttrString(pyobjref, "use_even_offset", Py_BuildValue("i", value));
	}

	/** Getter: Calculate normals which result in more even thickness (slow, disable when not needed) */
	bool use_quality_normals() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_quality_normals")) == 1;
	}

	/** Setter: Calculate normals which result in more even thickness (slow, disable when not needed) */
	void use_quality_normals(bool value) {
		PyObject_SetAttrString(pyobjref, "use_quality_normals", Py_BuildValue("i", value));
	}

	/** Getter: Invert the vertex group influence */
	bool invert_vertex_group() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "invert_vertex_group")) == 1;
	}

	/** Setter: Invert the vertex group influence */
	void invert_vertex_group(bool value) {
		PyObject_SetAttrString(pyobjref, "invert_vertex_group", Py_BuildValue("i", value));
	}

	/** Getter: Invert the face direction */
	bool use_flip_normals() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_flip_normals")) == 1;
	}

	/** Setter: Invert the face direction */
	void use_flip_normals(bool value) {
		PyObject_SetAttrString(pyobjref, "use_flip_normals", Py_BuildValue("i", value));
	}

	/** Getter: Only add the rim to the original data */
	bool use_rim_only() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_rim_only")) == 1;
	}

	/** Setter: Only add the rim to the original data */
	void use_rim_only(bool value) {
		PyObject_SetAttrString(pyobjref, "use_rim_only", Py_BuildValue("i", value));
	}

};

/**************** Screw Modifier ****************/

/**
 * Revolve edges
 */
class ScrewModifier : public Modifier {
public:
	ScrewModifier(PyObject* pyobj) : Modifier(pyobj) {}

	ScrewModifier() : Modifier(0)
	{
		// not implemented
	}

	/** Getter: Object to define the screw axis */
	Object object_value();

	/** Getter: Number of steps in the revolution */
	int steps() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "steps"));
	}

	/** Setter: Number of steps in the revolution */
	void steps(int value) {
		PyObject_SetAttrString(pyobjref, "steps", Py_BuildValue("i", value));
	}

	/** Getter: Number of steps in the revolution */
	int render_steps() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "render_steps"));
	}

	/** Setter: Number of steps in the revolution */
	void render_steps(int value) {
		PyObject_SetAttrString(pyobjref, "render_steps", Py_BuildValue("i", value));
	}

	/** Getter: Number of times to apply the screw operation */
	int iterations() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "iterations"));
	}

	/** Setter: Number of times to apply the screw operation */
	void iterations(int value) {
		PyObject_SetAttrString(pyobjref, "iterations", Py_BuildValue("i", value));
	}

	enum axis_enum {
		axis_X = 0,
		axis_Y = 1,
		axis_Z = 2,
	};

	/** Getter: Screw axis */
	axis_enum axis() { /* not implemented */ throw NULL; }
	/** Setter: Screw axis */
	void axis(axis_enum value) { /* not implemented */ }

	/** Getter: Angle of revolution */
	float angle() { /* not implemented */ throw NULL; }
	/** Setter: Angle of revolution */
	void angle(float value) {
		PyObject_SetAttrString(pyobjref, "angle", Py_BuildValue("f", value));
	}

	/** Getter: Offset the revolution along its axis */
	float screw_offset() { /* not implemented */ throw NULL; }
	/** Setter: Offset the revolution along its axis */
	void screw_offset(float value) {
		PyObject_SetAttrString(pyobjref, "screw_offset", Py_BuildValue("f", value));
	}

	/** Getter: Flip normals of lathed faces */
	bool use_normal_flip() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_normal_flip")) == 1;
	}

	/** Setter: Flip normals of lathed faces */
	void use_normal_flip(bool value) {
		PyObject_SetAttrString(pyobjref, "use_normal_flip", Py_BuildValue("i", value));
	}

	/** Getter: Calculate the order of edges (needed for meshes, but not curves) */
	bool use_normal_calculate() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_normal_calculate")) == 1;
	}

	/** Setter: Calculate the order of edges (needed for meshes, but not curves) */
	void use_normal_calculate(bool value) {
		PyObject_SetAttrString(pyobjref, "use_normal_calculate", Py_BuildValue("i", value));
	}

	/** Getter: Use the distance between the objects to make a screw */
	bool use_object_screw_offset() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_object_screw_offset")) == 1;
	}

	/** Setter: Use the distance between the objects to make a screw */
	void use_object_screw_offset(bool value) {
		PyObject_SetAttrString(pyobjref, "use_object_screw_offset", Py_BuildValue("i", value));
	}

	/** Getter: Output faces with smooth shading rather than flat shaded */
	bool use_smooth_shade() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_smooth_shade")) == 1;
	}

	/** Setter: Output faces with smooth shading rather than flat shaded */
	void use_smooth_shade(bool value) {
		PyObject_SetAttrString(pyobjref, "use_smooth_shade", Py_BuildValue("i", value));
	}

	/** Getter: Stretch the U coordinates between 0-1 when UV's are present */
	bool use_stretch_u() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_stretch_u")) == 1;
	}

	/** Setter: Stretch the U coordinates between 0-1 when UV's are present */
	void use_stretch_u(bool value) {
		PyObject_SetAttrString(pyobjref, "use_stretch_u", Py_BuildValue("i", value));
	}

	/** Getter: Stretch the V coordinates between 0-1 when UV's are present */
	bool use_stretch_v() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_stretch_v")) == 1;
	}

	/** Setter: Stretch the V coordinates between 0-1 when UV's are present */
	void use_stretch_v(bool value) {
		PyObject_SetAttrString(pyobjref, "use_stretch_v", Py_BuildValue("i", value));
	}

};

/**************** UVWarp Modifier ****************/

/**
 * Add target position to uv coordinates
 */
class UVWarpModifier : public Modifier {
public:
	UVWarpModifier(PyObject* pyobj) : Modifier(pyobj) {}

	UVWarpModifier() : Modifier(0)
	{
		// not implemented
	}

	enum axis_u_enum {
		axis_u_X = 0,
		axis_u_Y = 1,
		axis_u_Z = 2,
	};

	/** Getter: Pole axis for rotation */
	axis_u_enum axis_u() { /* not implemented */ throw NULL; }
	/** Setter: Pole axis for rotation */
	void axis_u(axis_u_enum value) { /* not implemented */ }

	enum axis_v_enum {
		axis_v_X = 0,
		axis_v_Y = 1,
		axis_v_Z = 2,
	};

	/** Getter: Pole axis for rotation */
	axis_v_enum axis_v() { /* not implemented */ throw NULL; }
	/** Setter: Pole axis for rotation */
	void axis_v(axis_v_enum value) { /* not implemented */ }

	/** Getter: Center point for rotate/scale */
	std::array<float, 2> center() {
		// TODO: MISSING DEREF! USE #DEFINE!
		PyObject *seqval = PyObject_GetAttrString(pyobjref, "center");
		std::array<float, 2> resarr;
		for (int i = 0; i < 2; i++)
			resarr[i] = (float)PyFloat_AsDouble(PySequence_GetItem(seqval, i));
		return resarr;
	}

	/** Setter: Center point for rotate/scale */
	void center(float values[2]) { /* not implemented */ }

	/** Getter: Object defining offset */
	Object object_from();

	/** Getter: Bone defining offset */
	std::string bone_from() { /* not implemented */ throw NULL; }
	/** Setter: Bone defining offset */
	void bone_from(const std::string& value) { /* not implemented */ }

	/** Getter: Object defining offset */
	Object object_to();

	/** Getter: Bone defining offset */
	std::string bone_to() { /* not implemented */ throw NULL; }
	/** Setter: Bone defining offset */
	void bone_to(const std::string& value) { /* not implemented */ }

	/** Getter: Vertex group name */
	std::string vertex_group() { /* not implemented */ throw NULL; }
	/** Setter: Vertex group name */
	void vertex_group(const std::string& value) { /* not implemented */ }

	/** Getter: UV Layer name */
	std::string uv_layer() { /* not implemented */ throw NULL; }
	/** Setter: UV Layer name */
	void uv_layer(const std::string& value) { /* not implemented */ }

};

/**************** WeightVG Edit Modifier ****************/

/**
 * Edit the weights of vertices in a group
 */
class VertexWeightEditModifier : public Modifier {
public:
	VertexWeightEditModifier(PyObject* pyobj) : Modifier(pyobj) {}

	VertexWeightEditModifier() : Modifier(0)
	{
		// not implemented
	}

	/** Getter: Vertex group name */
	std::string vertex_group() { /* not implemented */ throw NULL; }
	/** Setter: Vertex group name */
	void vertex_group(const std::string& value) { /* not implemented */ }

	enum falloff_type_enum {
		falloff_type_LINEAR = 0,
		falloff_type_CURVE = 1,
		falloff_type_SHARP = 2,
		falloff_type_SMOOTH = 3,
		falloff_type_ROOT = 4,
		falloff_type_ICON_SPHERECURVE = 7,
		falloff_type_RANDOM = 8,
		falloff_type_STEP = 9,
	};

	/** Getter: How weights are mapped to their new values */
	falloff_type_enum falloff_type() { /* not implemented */ throw NULL; }
	/** Setter: How weights are mapped to their new values */
	void falloff_type(falloff_type_enum value) { /* not implemented */ }

	/** Getter: Add vertices with weight over threshold to vgroup */
	bool use_add() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_add")) == 1;
	}

	/** Setter: Add vertices with weight over threshold to vgroup */
	void use_add(bool value) {
		PyObject_SetAttrString(pyobjref, "use_add", Py_BuildValue("i", value));
	}

	/** Getter: Remove vertices with weight below threshold from vgroup */
	bool use_remove() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_remove")) == 1;
	}

	/** Setter: Remove vertices with weight below threshold from vgroup */
	void use_remove(bool value) {
		PyObject_SetAttrString(pyobjref, "use_remove", Py_BuildValue("i", value));
	}

	/** Getter: Default weight a vertex will have if it is not in the vgroup */
	float default_weight() { /* not implemented */ throw NULL; }
	/** Setter: Default weight a vertex will have if it is not in the vgroup */
	void default_weight(float value) {
		PyObject_SetAttrString(pyobjref, "default_weight", Py_BuildValue("f", value));
	}

	/** Getter: Custom mapping curve */
	CurveMapping map_curve() {
		/* not implemented */ throw NULL;
	}

	/** Getter: Lower bound for a vertex's weight to be added to the vgroup */
	float add_threshold() { /* not implemented */ throw NULL; }
	/** Setter: Lower bound for a vertex's weight to be added to the vgroup */
	void add_threshold(float value) {
		PyObject_SetAttrString(pyobjref, "add_threshold", Py_BuildValue("f", value));
	}

	/** Getter: Upper bound for a vertex's weight to be removed from the vgroup */
	float remove_threshold() { /* not implemented */ throw NULL; }
	/** Setter: Upper bound for a vertex's weight to be removed from the vgroup */
	void remove_threshold(float value) {
		PyObject_SetAttrString(pyobjref, "remove_threshold", Py_BuildValue("f", value));
	}

	/** Getter: Global influence of current modifications on vgroup */
	float mask_constant() { /* not implemented */ throw NULL; }
	/** Setter: Global influence of current modifications on vgroup */
	void mask_constant(float value) {
		PyObject_SetAttrString(pyobjref, "mask_constant", Py_BuildValue("f", value));
	}

	/** Getter: Masking vertex group name */
	std::string mask_vertex_group() { /* not implemented */ throw NULL; }
	/** Setter: Masking vertex group name */
	void mask_vertex_group(const std::string& value) { /* not implemented */ }

	/** Getter: Masking texture */
	Texture mask_texture() {
		/* not implemented */ throw NULL;
	}

	enum mask_tex_use_channel_enum {
		mask_tex_use_channel_INT = 1,
		mask_tex_use_channel_RED = 2,
		mask_tex_use_channel_GREEN = 3,
		mask_tex_use_channel_BLUE = 4,
		mask_tex_use_channel_HUE = 5,
		mask_tex_use_channel_SAT = 6,
		mask_tex_use_channel_VAL = 7,
		mask_tex_use_channel_ALPHA = 8,
	};

	/** Getter: Which texture channel to use for masking */
	mask_tex_use_channel_enum mask_tex_use_channel() { /* not implemented */ throw NULL; }
	/** Setter: Which texture channel to use for masking */
	void mask_tex_use_channel(mask_tex_use_channel_enum value) { /* not implemented */ }

	enum mask_tex_mapping_enum {
		mask_tex_mapping_LOCAL = 0,
		mask_tex_mapping_GLOBAL = 1,
		mask_tex_mapping_OBJECT = 2,
		mask_tex_mapping_UV = 3,
	};

	/** Getter: Which texture coordinates to use for mapping */
	mask_tex_mapping_enum mask_tex_mapping() { /* not implemented */ throw NULL; }
	/** Setter: Which texture coordinates to use for mapping */
	void mask_tex_mapping(mask_tex_mapping_enum value) { /* not implemented */ }

	/** Getter: UV map name */
	std::string mask_tex_uv_layer() { /* not implemented */ throw NULL; }
	/** Setter: UV map name */
	void mask_tex_uv_layer(const std::string& value) { /* not implemented */ }

	/** Getter: Which object to take texture coordinates from */
	Object mask_tex_map_object();

};

/**************** WeightVG Mix Modifier ****************/

/**
 * Mix the weights of two vertex groups
 */
class VertexWeightMixModifier : public Modifier {
public:
	VertexWeightMixModifier(PyObject* pyobj) : Modifier(pyobj) {}

	VertexWeightMixModifier() : Modifier(0)
	{
		// not implemented
	}

	/** Getter: First vertex group name */
	std::string vertex_group_a() { /* not implemented */ throw NULL; }
	/** Setter: First vertex group name */
	void vertex_group_a(const std::string& value) { /* not implemented */ }

	/** Getter: Second vertex group name */
	std::string vertex_group_b() { /* not implemented */ throw NULL; }
	/** Setter: Second vertex group name */
	void vertex_group_b(const std::string& value) { /* not implemented */ }

	/** Getter: Default weight a vertex will have if it is not in the first A vgroup */
	float default_weight_a() { /* not implemented */ throw NULL; }
	/** Setter: Default weight a vertex will have if it is not in the first A vgroup */
	void default_weight_a(float value) {
		PyObject_SetAttrString(pyobjref, "default_weight_a", Py_BuildValue("f", value));
	}

	/** Getter: Default weight a vertex will have if it is not in the second B vgroup */
	float default_weight_b() { /* not implemented */ throw NULL; }
	/** Setter: Default weight a vertex will have if it is not in the second B vgroup */
	void default_weight_b(float value) {
		PyObject_SetAttrString(pyobjref, "default_weight_b", Py_BuildValue("f", value));
	}

	enum mix_mode_enum {
		mix_mode_SET = 1,
		mix_mode_ADD = 2,
		mix_mode_SUB = 3,
		mix_mode_MUL = 4,
		mix_mode_DIV = 5,
		mix_mode_DIF = 6,
		mix_mode_AVG = 7,
	};

	/** Getter: How weights from vgroup B affect weights of vgroup A */
	mix_mode_enum mix_mode() { /* not implemented */ throw NULL; }
	/** Setter: How weights from vgroup B affect weights of vgroup A */
	void mix_mode(mix_mode_enum value) { /* not implemented */ }

	enum mix_set_enum {
		mix_set_ALL = 1,
		mix_set_A = 2,
		mix_set_B = 3,
		mix_set_OR = 4,
		mix_set_AND = 5,
	};

	/** Getter: Which vertices should be affected */
	mix_set_enum mix_set() { /* not implemented */ throw NULL; }
	/** Setter: Which vertices should be affected */
	void mix_set(mix_set_enum value) { /* not implemented */ }

	/** Getter: Global influence of current modifications on vgroup */
	float mask_constant() { /* not implemented */ throw NULL; }
	/** Setter: Global influence of current modifications on vgroup */
	void mask_constant(float value) {
		PyObject_SetAttrString(pyobjref, "mask_constant", Py_BuildValue("f", value));
	}

	/** Getter: Masking vertex group name */
	std::string mask_vertex_group() { /* not implemented */ throw NULL; }
	/** Setter: Masking vertex group name */
	void mask_vertex_group(const std::string& value) { /* not implemented */ }

	/** Getter: Masking texture */
	Texture mask_texture() {
		/* not implemented */ throw NULL;
	}

	enum mask_tex_use_channel_enum {
		mask_tex_use_channel_INT = 1,
		mask_tex_use_channel_RED = 2,
		mask_tex_use_channel_GREEN = 3,
		mask_tex_use_channel_BLUE = 4,
		mask_tex_use_channel_HUE = 5,
		mask_tex_use_channel_SAT = 6,
		mask_tex_use_channel_VAL = 7,
		mask_tex_use_channel_ALPHA = 8,
	};

	/** Getter: Which texture channel to use for masking */
	mask_tex_use_channel_enum mask_tex_use_channel() { /* not implemented */ throw NULL; }
	/** Setter: Which texture channel to use for masking */
	void mask_tex_use_channel(mask_tex_use_channel_enum value) { /* not implemented */ }

	enum mask_tex_mapping_enum {
		mask_tex_mapping_LOCAL = 0,
		mask_tex_mapping_GLOBAL = 1,
		mask_tex_mapping_OBJECT = 2,
		mask_tex_mapping_UV = 3,
	};

	/** Getter: Which texture coordinates to use for mapping */
	mask_tex_mapping_enum mask_tex_mapping() { /* not implemented */ throw NULL; }
	/** Setter: Which texture coordinates to use for mapping */
	void mask_tex_mapping(mask_tex_mapping_enum value) { /* not implemented */ }

	/** Getter: UV map name */
	std::string mask_tex_uv_layer() { /* not implemented */ throw NULL; }
	/** Setter: UV map name */
	void mask_tex_uv_layer(const std::string& value) { /* not implemented */ }

	/** Getter: Which object to take texture coordinates from */
	Object mask_tex_map_object();

};

/**************** WeightVG Proximity Modifier ****************/

/**
 * Set the weights of vertices in a group from a target object's distance
 */
class VertexWeightProximityModifier : public Modifier {
public:
	VertexWeightProximityModifier(PyObject* pyobj) : Modifier(pyobj) {}

	VertexWeightProximityModifier() : Modifier(0)
	{
		// not implemented
	}

	/** Getter: Vertex group name */
	std::string vertex_group() { /* not implemented */ throw NULL; }
	/** Setter: Vertex group name */
	void vertex_group(const std::string& value) { /* not implemented */ }

	enum proximity_mode_enum {
		proximity_mode_OBJECT = 1,
		proximity_mode_GEOMETRY = 2,
	};

	/** Getter: Which distances to target object to use */
	proximity_mode_enum proximity_mode() { /* not implemented */ throw NULL; }
	/** Setter: Which distances to target object to use */
	void proximity_mode(proximity_mode_enum value) { /* not implemented */ }

	enum proximity_geometry_enum {
		proximity_geometry_VERTEX = 1,
		proximity_geometry_EDGE = 2,
		proximity_geometry_FACE = 4,
	};

	/** Getter: Use the shortest computed distance to target object's geometry as weight */
	proximity_geometry_enum proximity_geometry() { /* not implemented */ throw NULL; }
	/** Setter: Use the shortest computed distance to target object's geometry as weight */
	void proximity_geometry(proximity_geometry_enum value) { /* not implemented */ }

	/** Getter: Object to calculate vertices distances from */
	Object target();

	/** Getter: Distance mapping to weight 0.0 */
	float min_dist() { /* not implemented */ throw NULL; }
	/** Setter: Distance mapping to weight 0.0 */
	void min_dist(float value) {
		PyObject_SetAttrString(pyobjref, "min_dist", Py_BuildValue("f", value));
	}

	/** Getter: Distance mapping to weight 1.0 */
	float max_dist() { /* not implemented */ throw NULL; }
	/** Setter: Distance mapping to weight 1.0 */
	void max_dist(float value) {
		PyObject_SetAttrString(pyobjref, "max_dist", Py_BuildValue("f", value));
	}

	enum falloff_type_enum {
		falloff_type_LINEAR = 0,
		falloff_type_SHARP = 2,
		falloff_type_SMOOTH = 3,
		falloff_type_ROOT = 4,
		falloff_type_ICON_SPHERECURVE = 7,
		falloff_type_RANDOM = 8,
		falloff_type_STEP = 9,
	};

	/** Getter: How weights are mapped to their new values */
	falloff_type_enum falloff_type() { /* not implemented */ throw NULL; }
	/** Setter: How weights are mapped to their new values */
	void falloff_type(falloff_type_enum value) { /* not implemented */ }

	/** Getter: Global influence of current modifications on vgroup */
	float mask_constant() { /* not implemented */ throw NULL; }
	/** Setter: Global influence of current modifications on vgroup */
	void mask_constant(float value) {
		PyObject_SetAttrString(pyobjref, "mask_constant", Py_BuildValue("f", value));
	}

	/** Getter: Masking vertex group name */
	std::string mask_vertex_group() { /* not implemented */ throw NULL; }
	/** Setter: Masking vertex group name */
	void mask_vertex_group(const std::string& value) { /* not implemented */ }

	/** Getter: Masking texture */
	Texture mask_texture() {
		/* not implemented */ throw NULL;
	}

	enum mask_tex_use_channel_enum {
		mask_tex_use_channel_INT = 1,
		mask_tex_use_channel_RED = 2,
		mask_tex_use_channel_GREEN = 3,
		mask_tex_use_channel_BLUE = 4,
		mask_tex_use_channel_HUE = 5,
		mask_tex_use_channel_SAT = 6,
		mask_tex_use_channel_VAL = 7,
		mask_tex_use_channel_ALPHA = 8,
	};

	/** Getter: Which texture channel to use for masking */
	mask_tex_use_channel_enum mask_tex_use_channel() { /* not implemented */ throw NULL; }
	/** Setter: Which texture channel to use for masking */
	void mask_tex_use_channel(mask_tex_use_channel_enum value) { /* not implemented */ }

	enum mask_tex_mapping_enum {
		mask_tex_mapping_LOCAL = 0,
		mask_tex_mapping_GLOBAL = 1,
		mask_tex_mapping_OBJECT = 2,
		mask_tex_mapping_UV = 3,
	};

	/** Getter: Which texture coordinates to use for mapping */
	mask_tex_mapping_enum mask_tex_mapping() { /* not implemented */ throw NULL; }
	/** Setter: Which texture coordinates to use for mapping */
	void mask_tex_mapping(mask_tex_mapping_enum value) { /* not implemented */ }

	/** Getter: UV map name */
	std::string mask_tex_uv_layer() { /* not implemented */ throw NULL; }
	/** Setter: UV map name */
	void mask_tex_uv_layer(const std::string& value) { /* not implemented */ }

	/** Getter: Which object to take texture coordinates from */
	Object mask_tex_map_object();

};

/**************** Dynamic Paint Modifier ****************/

/**
 * Dynamic Paint modifier
 */
class DynamicPaintModifier : public Modifier {
public:
	DynamicPaintModifier(PyObject* pyobj) : Modifier(pyobj) {}

	DynamicPaintModifier() : Modifier(0)
	{
		// not implemented
	}

	/** Getter:  */
	DynamicPaintCanvasSettings canvas_settings() {
		/* not implemented */ throw NULL;
	}

	/** Getter:  */
	DynamicPaintBrushSettings brush_settings() {
		/* not implemented */ throw NULL;
	}

	enum ui_type_enum {
		ui_type_CANVAS = 1,
		ui_type_BRUSH = 2,
	};

	/** Getter:  */
	ui_type_enum ui_type() { /* not implemented */ throw NULL; }
	/** Setter:  */
	void ui_type(ui_type_enum value) { /* not implemented */ }

};

/**************** Ocean Modifier ****************/

/**
 * Simulate an ocean surface
 */
class OceanModifier : public Modifier {
public:
	OceanModifier(PyObject* pyobj) : Modifier(pyobj) {}

	OceanModifier() : Modifier(0)
	{
		// not implemented
	}

	enum geometry_mode_enum {
		geometry_mode_GENERATE = 0,
		geometry_mode_DISPLACE = 1,
	};

	/** Getter: Method of modifying geometry */
	geometry_mode_enum geometry_mode() { /* not implemented */ throw NULL; }
	/** Setter: Method of modifying geometry */
	void geometry_mode(geometry_mode_enum value) { /* not implemented */ }

	/** Getter: Surface scale factor (does not affect the height of the waves) */
	float size() { /* not implemented */ throw NULL; }
	/** Setter: Surface scale factor (does not affect the height of the waves) */
	void size(float value) {
		PyObject_SetAttrString(pyobjref, "size", Py_BuildValue("f", value));
	}

	/** Getter: Repetitions of the generated surface in X */
	int repeat_x() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "repeat_x"));
	}

	/** Setter: Repetitions of the generated surface in X */
	void repeat_x(int value) {
		PyObject_SetAttrString(pyobjref, "repeat_x", Py_BuildValue("i", value));
	}

	/** Getter: Repetitions of the generated surface in Y */
	int repeat_y() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "repeat_y"));
	}

	/** Setter: Repetitions of the generated surface in Y */
	void repeat_y(int value) {
		PyObject_SetAttrString(pyobjref, "repeat_y", Py_BuildValue("i", value));
	}

	/** Getter: Output normals for bump mapping - disabling can speed up performance if its not needed */
	bool use_normals() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_normals")) == 1;
	}

	/** Setter: Output normals for bump mapping - disabling can speed up performance if its not needed */
	void use_normals(bool value) {
		PyObject_SetAttrString(pyobjref, "use_normals", Py_BuildValue("i", value));
	}

	/** Getter: Generate foam mask as a vertex color channel */
	bool use_foam() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_foam")) == 1;
	}

	/** Setter: Generate foam mask as a vertex color channel */
	void use_foam(bool value) {
		PyObject_SetAttrString(pyobjref, "use_foam", Py_BuildValue("i", value));
	}

	/** Getter: Resolution of the generated surface */
	int resolution() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "resolution"));
	}

	/** Setter: Resolution of the generated surface */
	void resolution(int value) {
		PyObject_SetAttrString(pyobjref, "resolution", Py_BuildValue("i", value));
	}

	/** Getter: Size of the simulation domain (in meters), and of the generated geometry (in BU) */
	int spatial_size() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "spatial_size"));
	}

	/** Setter: Size of the simulation domain (in meters), and of the generated geometry (in BU) */
	void spatial_size(int value) {
		PyObject_SetAttrString(pyobjref, "spatial_size", Py_BuildValue("i", value));
	}

	/** Getter: Wind speed */
	float wind_velocity() { /* not implemented */ throw NULL; }
	/** Setter: Wind speed */
	void wind_velocity(float value) {
		PyObject_SetAttrString(pyobjref, "wind_velocity", Py_BuildValue("f", value));
	}

	/** Getter: Damp reflected waves going in opposite direction to the wind */
	float damping() { /* not implemented */ throw NULL; }
	/** Setter: Damp reflected waves going in opposite direction to the wind */
	void damping(float value) {
		PyObject_SetAttrString(pyobjref, "damping", Py_BuildValue("f", value));
	}

	/** Getter: Shortest allowed wavelength */
	float wave_scale_min() { /* not implemented */ throw NULL; }
	/** Setter: Shortest allowed wavelength */
	void wave_scale_min(float value) {
		PyObject_SetAttrString(pyobjref, "wave_scale_min", Py_BuildValue("f", value));
	}

	/** Getter: How much the waves are aligned to each other */
	float wave_alignment() { /* not implemented */ throw NULL; }
	/** Setter: How much the waves are aligned to each other */
	void wave_alignment(float value) {
		PyObject_SetAttrString(pyobjref, "wave_alignment", Py_BuildValue("f", value));
	}

	/** Getter: Main direction of the waves when they are (partially) aligned */
	float wave_direction() { /* not implemented */ throw NULL; }
	/** Setter: Main direction of the waves when they are (partially) aligned */
	void wave_direction(float value) {
		PyObject_SetAttrString(pyobjref, "wave_direction", Py_BuildValue("f", value));
	}

	/** Getter: Scale of the displacement effect */
	float wave_scale() { /* not implemented */ throw NULL; }
	/** Setter: Scale of the displacement effect */
	void wave_scale(float value) {
		PyObject_SetAttrString(pyobjref, "wave_scale", Py_BuildValue("f", value));
	}

	/** Getter: Depth of the solid ground below the water surface */
	float depth() { /* not implemented */ throw NULL; }
	/** Setter: Depth of the solid ground below the water surface */
	void depth(float value) {
		PyObject_SetAttrString(pyobjref, "depth", Py_BuildValue("f", value));
	}

	/** Getter: Amount of generated foam */
	float foam_coverage() { /* not implemented */ throw NULL; }
	/** Setter: Amount of generated foam */
	void foam_coverage(float value) {
		PyObject_SetAttrString(pyobjref, "foam_coverage", Py_BuildValue("f", value));
	}

	/** Getter: How much foam accumulates over time (baked ocean only) */
	float bake_foam_fade() { /* not implemented */ throw NULL; }
	/** Setter: How much foam accumulates over time (baked ocean only) */
	void bake_foam_fade(float value) {
		PyObject_SetAttrString(pyobjref, "bake_foam_fade", Py_BuildValue("f", value));
	}

	/** Getter: Name of the vertex color layer used for foam */
	std::string foam_layer_name() { /* not implemented */ throw NULL; }
	/** Setter: Name of the vertex color layer used for foam */
	void foam_layer_name(const std::string& value) { /* not implemented */ }

	/** Getter: Choppiness of the wave's crest (adds some horizontal component to the displacement) */
	float choppiness() { /* not implemented */ throw NULL; }
	/** Setter: Choppiness of the wave's crest (adds some horizontal component to the displacement) */
	void choppiness(float value) {
		PyObject_SetAttrString(pyobjref, "choppiness", Py_BuildValue("f", value));
	}

	/** Getter: Current time of the simulation */
	float time() { /* not implemented */ throw NULL; }
	/** Setter: Current time of the simulation */
	void time(float value) {
		PyObject_SetAttrString(pyobjref, "time", Py_BuildValue("f", value));
	}

	/** Getter: Seed of the random generator */
	int random_seed() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "random_seed"));
	}

	/** Setter: Seed of the random generator */
	void random_seed(int value) {
		PyObject_SetAttrString(pyobjref, "random_seed", Py_BuildValue("i", value));
	}

	/** Getter: Start frame of the ocean baking */
	int frame_start() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "frame_start"));
	}

	/** Setter: Start frame of the ocean baking */
	void frame_start(int value) {
		PyObject_SetAttrString(pyobjref, "frame_start", Py_BuildValue("i", value));
	}

	/** Getter: End frame of the ocean baking */
	int frame_end() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "frame_end"));
	}

	/** Setter: End frame of the ocean baking */
	void frame_end(int value) {
		PyObject_SetAttrString(pyobjref, "frame_end", Py_BuildValue("i", value));
	}

	/** Getter: Whether the ocean is using cached data or simulating */
	bool is_cached() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "is_cached")) == 1;
	}

	/** Setter: Whether the ocean is using cached data or simulating */
	void is_cached(bool value) {
		PyObject_SetAttrString(pyobjref, "is_cached", Py_BuildValue("i", value));
	}

	/** Getter: Path to a folder to store external baked images */
	std::string filepath() { /* not implemented */ throw NULL; }
	/** Setter: Path to a folder to store external baked images */
	void filepath(const std::string& value) { /* not implemented */ }

};

/**************** Remesh Modifier ****************/

/**
 * Generate a new surface with regular topology that follows the shape of the input mesh
 */
class RemeshModifier : public Modifier {
public:
	RemeshModifier(PyObject* pyobj) : Modifier(pyobj) {}

	RemeshModifier() : Modifier(0)
	{
		// not implemented
	}

	enum mode_enum {
		mode_BLOCKS = 0,
		mode_SMOOTH = 1,
		mode_SHARP = 2,
	};

	/** Getter:  */
	mode_enum mode() { /* not implemented */ throw NULL; }
	/** Setter:  */
	void mode(mode_enum value) { /* not implemented */ }

	/** Getter: The ratio of the largest dimension of the model over the size of the grid */
	float scale() { /* not implemented */ throw NULL; }
	/** Setter: The ratio of the largest dimension of the model over the size of the grid */
	void scale(float value) {
		PyObject_SetAttrString(pyobjref, "scale", Py_BuildValue("f", value));
	}

	/** Getter: If removing disconnected pieces, minimum size of components to preserve as a ratio of the number of polygons in the largest component */
	float threshold() { /* not implemented */ throw NULL; }
	/** Setter: If removing disconnected pieces, minimum size of components to preserve as a ratio of the number of polygons in the largest component */
	void threshold(float value) {
		PyObject_SetAttrString(pyobjref, "threshold", Py_BuildValue("f", value));
	}

	/** Getter: Resolution of the octree; higher values give finer details */
	int octree_depth() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "octree_depth"));
	}

	/** Setter: Resolution of the octree; higher values give finer details */
	void octree_depth(int value) {
		PyObject_SetAttrString(pyobjref, "octree_depth", Py_BuildValue("i", value));
	}

	/** Getter: Tolerance for outliers; lower values filter noise while higher values will reproduce edges closer to the input */
	float sharpness() { /* not implemented */ throw NULL; }
	/** Setter: Tolerance for outliers; lower values filter noise while higher values will reproduce edges closer to the input */
	void sharpness(float value) {
		PyObject_SetAttrString(pyobjref, "sharpness", Py_BuildValue("f", value));
	}

	/** Getter:  */
	bool use_remove_disconnected() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_remove_disconnected")) == 1;
	}

	/** Setter:  */
	void use_remove_disconnected(bool value) {
		PyObject_SetAttrString(pyobjref, "use_remove_disconnected", Py_BuildValue("i", value));
	}

	/** Getter: Output faces with smooth shading rather than flat shaded */
	bool use_smooth_shade() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_smooth_shade")) == 1;
	}

	/** Setter: Output faces with smooth shading rather than flat shaded */
	void use_smooth_shade(bool value) {
		PyObject_SetAttrString(pyobjref, "use_smooth_shade", Py_BuildValue("i", value));
	}

};

/**************** Skin Modifier ****************/

/**
 * Generate Skin
 */
class SkinModifier : public Modifier {
public:
	SkinModifier(PyObject* pyobj) : Modifier(pyobj) {}

	SkinModifier() : Modifier(0)
	{
		// not implemented
	}

	/** Getter: Smooth complex geometry around branches */
	float branch_smoothing() { /* not implemented */ throw NULL; }
	/** Setter: Smooth complex geometry around branches */
	void branch_smoothing(float value) {
		PyObject_SetAttrString(pyobjref, "branch_smoothing", Py_BuildValue("f", value));
	}

	/** Getter: Output faces with smooth shading rather than flat shaded */
	bool use_smooth_shade() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_smooth_shade")) == 1;
	}

	/** Setter: Output faces with smooth shading rather than flat shaded */
	void use_smooth_shade(bool value) {
		PyObject_SetAttrString(pyobjref, "use_smooth_shade", Py_BuildValue("i", value));
	}

	/** Getter: Avoid making unsymmetrical quads across the X axis */
	bool use_x_symmetry() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_x_symmetry")) == 1;
	}

	/** Setter: Avoid making unsymmetrical quads across the X axis */
	void use_x_symmetry(bool value) {
		PyObject_SetAttrString(pyobjref, "use_x_symmetry", Py_BuildValue("i", value));
	}

	/** Getter: Avoid making unsymmetrical quads across the Y axis */
	bool use_y_symmetry() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_y_symmetry")) == 1;
	}

	/** Setter: Avoid making unsymmetrical quads across the Y axis */
	void use_y_symmetry(bool value) {
		PyObject_SetAttrString(pyobjref, "use_y_symmetry", Py_BuildValue("i", value));
	}

	/** Getter: Avoid making unsymmetrical quads across the Z axis */
	bool use_z_symmetry() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_z_symmetry")) == 1;
	}

	/** Setter: Avoid making unsymmetrical quads across the Z axis */
	void use_z_symmetry(bool value) {
		PyObject_SetAttrString(pyobjref, "use_z_symmetry", Py_BuildValue("i", value));
	}

};

/**************** Laplacian Smooth Modifier ****************/

/**
 * Smoothing effect modifier
 */
class LaplacianSmoothModifier : public Modifier {
public:
	LaplacianSmoothModifier(PyObject* pyobj) : Modifier(pyobj) {}

	LaplacianSmoothModifier() : Modifier(0)
	{
		// not implemented
	}

	/** Getter: Smooth object along X axis */
	bool use_x() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_x")) == 1;
	}

	/** Setter: Smooth object along X axis */
	void use_x(bool value) {
		PyObject_SetAttrString(pyobjref, "use_x", Py_BuildValue("i", value));
	}

	/** Getter: Smooth object along Y axis */
	bool use_y() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_y")) == 1;
	}

	/** Setter: Smooth object along Y axis */
	void use_y(bool value) {
		PyObject_SetAttrString(pyobjref, "use_y", Py_BuildValue("i", value));
	}

	/** Getter: Smooth object along Z axis */
	bool use_z() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_z")) == 1;
	}

	/** Setter: Smooth object along Z axis */
	void use_z(bool value) {
		PyObject_SetAttrString(pyobjref, "use_z", Py_BuildValue("i", value));
	}

	/** Getter: Apply volume preservation after smooth */
	bool use_volume_preserve() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_volume_preserve")) == 1;
	}

	/** Setter: Apply volume preservation after smooth */
	void use_volume_preserve(bool value) {
		PyObject_SetAttrString(pyobjref, "use_volume_preserve", Py_BuildValue("i", value));
	}

	/** Getter: Improve and stabilize the enhanced shape */
	bool use_normalized() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_normalized")) == 1;
	}

	/** Setter: Improve and stabilize the enhanced shape */
	void use_normalized(bool value) {
		PyObject_SetAttrString(pyobjref, "use_normalized", Py_BuildValue("i", value));
	}

	/** Getter: Smooth factor effect */
	float lambda_factor() { /* not implemented */ throw NULL; }
	/** Setter: Smooth factor effect */
	void lambda_factor(float value) {
		PyObject_SetAttrString(pyobjref, "lambda_factor", Py_BuildValue("f", value));
	}

	/** Getter: Lambda factor in border */
	float lambda_border() { /* not implemented */ throw NULL; }
	/** Setter: Lambda factor in border */
	void lambda_border(float value) {
		PyObject_SetAttrString(pyobjref, "lambda_border", Py_BuildValue("f", value));
	}

	/** Getter:  */
	int iterations() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "iterations"));
	}

	/** Setter:  */
	void iterations(int value) {
		PyObject_SetAttrString(pyobjref, "iterations", Py_BuildValue("i", value));
	}

	/** Getter: Name of Vertex Group which determines influence of modifier per point */
	std::string vertex_group() { /* not implemented */ throw NULL; }
	/** Setter: Name of Vertex Group which determines influence of modifier per point */
	void vertex_group(const std::string& value) { /* not implemented */ }

};

/**************** Triangulate Modifier ****************/

/**
 * Triangulate Mesh
 */
class TriangulateModifier : public Modifier {
public:
	TriangulateModifier(PyObject* pyobj) : Modifier(pyobj) {}

	TriangulateModifier() : Modifier(0)
	{
		// not implemented
	}

	enum quad_method_enum {
		quad_method_BEAUTY = 0,
		quad_method_FIXED = 1,
		quad_method_FIXED_ALTERNATE = 2,
		quad_method_SHORTEST_DIAGONAL = 3,
	};

	/** Getter: Method for splitting the quads into triangles */
	quad_method_enum quad_method() { /* not implemented */ throw NULL; }
	/** Setter: Method for splitting the quads into triangles */
	void quad_method(quad_method_enum value) { /* not implemented */ }

	enum ngon_method_enum {
		ngon_method_BEAUTY = 0,
		ngon_method_CLIP = 1,
	};

	/** Getter: Method for splitting the polygons into triangles */
	ngon_method_enum ngon_method() { /* not implemented */ throw NULL; }
	/** Setter: Method for splitting the polygons into triangles */
	void ngon_method(ngon_method_enum value) { /* not implemented */ }

};

/**************** Cache Modifier ****************/

/**
 * Cache Mesh
 */
class MeshCacheModifier : public Modifier {
public:
	MeshCacheModifier(PyObject* pyobj) : Modifier(pyobj) {}

	MeshCacheModifier() : Modifier(0)
	{
		// not implemented
	}

	enum cache_format_enum {
		cache_format_MDD = 1,
		cache_format_PC2 = 2,
	};

	/** Getter:  */
	cache_format_enum cache_format() { /* not implemented */ throw NULL; }
	/** Setter:  */
	void cache_format(cache_format_enum value) { /* not implemented */ }

	enum interpolation_enum {
		interpolation_NONE = 0,
		interpolation_LINEAR = 1,
	};

	/** Getter:  */
	interpolation_enum interpolation() { /* not implemented */ throw NULL; }
	/** Setter:  */
	void interpolation(interpolation_enum value) { /* not implemented */ }

	enum time_mode_enum {
		time_mode_FRAME = 0,
		time_mode_TIME = 1,
		time_mode_FACTOR = 2,
	};

	/** Getter: Method to control playback time */
	time_mode_enum time_mode() { /* not implemented */ throw NULL; }
	/** Setter: Method to control playback time */
	void time_mode(time_mode_enum value) { /* not implemented */ }

	enum play_mode_enum {
		play_mode_SCENE = 0,
		play_mode_CUSTOM = 1,
	};

	/** Getter:  */
	play_mode_enum play_mode() { /* not implemented */ throw NULL; }
	/** Setter:  */
	void play_mode(play_mode_enum value) { /* not implemented */ }

	enum deform_mode_enum {
		deform_mode_OVERWRITE = 0,
		deform_mode_INTEGRATE = 1,
	};

	/** Getter:  */
	deform_mode_enum deform_mode() { /* not implemented */ throw NULL; }
	/** Setter:  */
	void deform_mode(deform_mode_enum value) { /* not implemented */ }

	/** Getter: Path to external displacements file */
	std::string filepath() { /* not implemented */ throw NULL; }
	/** Setter: Path to external displacements file */
	void filepath(const std::string& value) { /* not implemented */ }

	/** Getter: Influence of the deformation */
	float factor() { /* not implemented */ throw NULL; }
	/** Setter: Influence of the deformation */
	void factor(float value) {
		PyObject_SetAttrString(pyobjref, "factor", Py_BuildValue("f", value));
	}

	enum forward_axis_enum {
		forward_axis_POS_X = 0,
		forward_axis_POS_Y = 1,
		forward_axis_POS_Z = 2,
		forward_axis_NEG_X = 3,
		forward_axis_NEG_Y = 4,
		forward_axis_NEG_Z = 5,
	};

	/** Getter:  */
	forward_axis_enum forward_axis() { /* not implemented */ throw NULL; }
	/** Setter:  */
	void forward_axis(forward_axis_enum value) { /* not implemented */ }

	enum up_axis_enum {
		up_axis_POS_X = 0,
		up_axis_POS_Y = 1,
		up_axis_POS_Z = 2,
		up_axis_NEG_X = 3,
		up_axis_NEG_Y = 4,
		up_axis_NEG_Z = 5,
	};

	/** Getter:  */
	up_axis_enum up_axis() { /* not implemented */ throw NULL; }
	/** Setter:  */
	void up_axis(up_axis_enum value) { /* not implemented */ }

	enum flip_axis_enum {
		flip_axis_X = 1,
		flip_axis_Y = 2,
		flip_axis_Z = 4,
	};

	/** Getter:  */
	flip_axis_enum flip_axis() { /* not implemented */ throw NULL; }
	/** Setter:  */
	void flip_axis(flip_axis_enum value) { /* not implemented */ }

	/** Getter: Add this to the start frame */
	float frame_start() { /* not implemented */ throw NULL; }
	/** Setter: Add this to the start frame */
	void frame_start(float value) {
		PyObject_SetAttrString(pyobjref, "frame_start", Py_BuildValue("f", value));
	}

	/** Getter: Evaluation time in seconds */
	float frame_scale() { /* not implemented */ throw NULL; }
	/** Setter: Evaluation time in seconds */
	void frame_scale(float value) {
		PyObject_SetAttrString(pyobjref, "frame_scale", Py_BuildValue("f", value));
	}

	/** Getter: The frame to evaluate (starting at 0) */
	float eval_frame() { /* not implemented */ throw NULL; }
	/** Setter: The frame to evaluate (starting at 0) */
	void eval_frame(float value) {
		PyObject_SetAttrString(pyobjref, "eval_frame", Py_BuildValue("f", value));
	}

	/** Getter: Evaluation time in seconds */
	float eval_time() { /* not implemented */ throw NULL; }
	/** Setter: Evaluation time in seconds */
	void eval_time(float value) {
		PyObject_SetAttrString(pyobjref, "eval_time", Py_BuildValue("f", value));
	}

	/** Getter: Evaluation time in seconds */
	float eval_factor() { /* not implemented */ throw NULL; }
	/** Setter: Evaluation time in seconds */
	void eval_factor(float value) {
		PyObject_SetAttrString(pyobjref, "eval_factor", Py_BuildValue("f", value));
	}

};

/**************** Laplacian Deform Modifier ****************/

/**
 * Mesh deform modifier
 */
class LaplacianDeformModifier : public Modifier {
public:
	LaplacianDeformModifier(PyObject* pyobj) : Modifier(pyobj) {}

	LaplacianDeformModifier() : Modifier(0)
	{
		// not implemented
	}

	/** Getter: Name of Vertex Group which determines Anchors */
	std::string vertex_group() { /* not implemented */ throw NULL; }
	/** Setter: Name of Vertex Group which determines Anchors */
	void vertex_group(const std::string& value) { /* not implemented */ }

	/** Getter:  */
	int iterations() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "iterations"));
	}

	/** Setter:  */
	void iterations(int value) {
		PyObject_SetAttrString(pyobjref, "iterations", Py_BuildValue("i", value));
	}

	/** Getter: Whether geometry has been bound to anchors */
	bool is_bind() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "is_bind")) == 1;
	}

	/** Setter: Whether geometry has been bound to anchors */
	void is_bind(bool value) {
		PyObject_SetAttrString(pyobjref, "is_bind", Py_BuildValue("i", value));
	}

};

/**************** Wireframe Modifier ****************/

/**
 * Wireframe effect modifier
 */
class WireframeModifier : public Modifier {
public:
	WireframeModifier(PyObject* pyobj) : Modifier(pyobj) {}

	WireframeModifier() : Modifier(0)
	{
		// not implemented
	}

	/** Getter: Thickness factor */
	float thickness() { /* not implemented */ throw NULL; }
	/** Setter: Thickness factor */
	void thickness(float value) {
		PyObject_SetAttrString(pyobjref, "thickness", Py_BuildValue("f", value));
	}

	/** Getter: Thickness factor to use for zero vertex group influence */
	float thickness_vertex_group() { /* not implemented */ throw NULL; }
	/** Setter: Thickness factor to use for zero vertex group influence */
	void thickness_vertex_group(float value) {
		PyObject_SetAttrString(pyobjref, "thickness_vertex_group", Py_BuildValue("f", value));
	}

	/** Getter: Offset the thickness from the center */
	float offset() { /* not implemented */ throw NULL; }
	/** Setter: Offset the thickness from the center */
	void offset(float value) {
		PyObject_SetAttrString(pyobjref, "offset", Py_BuildValue("f", value));
	}

	/** Getter: Remove original geometry */
	bool use_replace() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_replace")) == 1;
	}

	/** Setter: Remove original geometry */
	void use_replace(bool value) {
		PyObject_SetAttrString(pyobjref, "use_replace", Py_BuildValue("i", value));
	}

	/** Getter: Support face boundaries */
	bool use_boundary() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_boundary")) == 1;
	}

	/** Setter: Support face boundaries */
	void use_boundary(bool value) {
		PyObject_SetAttrString(pyobjref, "use_boundary", Py_BuildValue("i", value));
	}

	/** Getter: Scale the offset to give more even thickness */
	bool use_even_offset() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_even_offset")) == 1;
	}

	/** Setter: Scale the offset to give more even thickness */
	void use_even_offset(bool value) {
		PyObject_SetAttrString(pyobjref, "use_even_offset", Py_BuildValue("i", value));
	}

	/** Getter: Scale the offset by surrounding geometry */
	bool use_relative_offset() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_relative_offset")) == 1;
	}

	/** Setter: Scale the offset by surrounding geometry */
	void use_relative_offset(bool value) {
		PyObject_SetAttrString(pyobjref, "use_relative_offset", Py_BuildValue("i", value));
	}

	/** Getter: Crease hub edges for improved subsurf */
	bool use_crease() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_crease")) == 1;
	}

	/** Setter: Crease hub edges for improved subsurf */
	void use_crease(bool value) {
		PyObject_SetAttrString(pyobjref, "use_crease", Py_BuildValue("i", value));
	}

	/** Getter: Crease weight (if active) */
	float crease_weight() { /* not implemented */ throw NULL; }
	/** Setter: Crease weight (if active) */
	void crease_weight(float value) {
		PyObject_SetAttrString(pyobjref, "crease_weight", Py_BuildValue("f", value));
	}

	/** Getter: Offset material index of generated faces */
	int material_offset() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "material_offset"));
	}

	/** Setter: Offset material index of generated faces */
	void material_offset(int value) {
		PyObject_SetAttrString(pyobjref, "material_offset", Py_BuildValue("i", value));
	}

	/** Getter: Vertex group name for selecting the affected areas */
	std::string vertex_group() { /* not implemented */ throw NULL; }
	/** Setter: Vertex group name for selecting the affected areas */
	void vertex_group(const std::string& value) { /* not implemented */ }

	/** Getter: Invert vertex group influence */
	bool invert_vertex_group() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "invert_vertex_group")) == 1;
	}

	/** Setter: Invert vertex group influence */
	void invert_vertex_group(bool value) {
		PyObject_SetAttrString(pyobjref, "invert_vertex_group", Py_BuildValue("i", value));
	}

};

/**************** Data Transfer Modifier ****************/

/**
 * Modifier transferring some data from a source mesh
 */
class DataTransferModifier : public Modifier {
public:
	DataTransferModifier(PyObject* pyobj) : Modifier(pyobj) {}

	DataTransferModifier() : Modifier(0)
	{
		// not implemented
	}

	/** Getter: Object to transfer data from */
	Object object_value();

	/** Getter: Evaluate source and destination meshes in their respective object spaces */
	bool use_object_transform() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_object_transform")) == 1;
	}

	/** Setter: Evaluate source and destination meshes in their respective object spaces */
	void use_object_transform(bool value) {
		PyObject_SetAttrString(pyobjref, "use_object_transform", Py_BuildValue("i", value));
	}

	/** Getter: Enable vertex data transfer */
	bool use_vert_data() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_vert_data")) == 1;
	}

	/** Setter: Enable vertex data transfer */
	void use_vert_data(bool value) {
		PyObject_SetAttrString(pyobjref, "use_vert_data", Py_BuildValue("i", value));
	}

	/** Getter: Enable edge data transfer */
	bool use_edge_data() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_edge_data")) == 1;
	}

	/** Setter: Enable edge data transfer */
	void use_edge_data(bool value) {
		PyObject_SetAttrString(pyobjref, "use_edge_data", Py_BuildValue("i", value));
	}

	/** Getter: Enable face corner data transfer */
	bool use_loop_data() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_loop_data")) == 1;
	}

	/** Setter: Enable face corner data transfer */
	void use_loop_data(bool value) {
		PyObject_SetAttrString(pyobjref, "use_loop_data", Py_BuildValue("i", value));
	}

	/** Getter: Enable face data transfer */
	bool use_poly_data() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_poly_data")) == 1;
	}

	/** Setter: Enable face data transfer */
	void use_poly_data(bool value) {
		PyObject_SetAttrString(pyobjref, "use_poly_data", Py_BuildValue("i", value));
	}

	enum data_types_verts_enum {
		data_types_verts_BEVEL_WEIGHT_VERT = 8,
	};

	/** Getter: Which vertex data layers to transfer */
	data_types_verts_enum data_types_verts() { /* not implemented */ throw NULL; }
	/** Setter: Which vertex data layers to transfer */
	void data_types_verts(data_types_verts_enum value) { /* not implemented */ }

	enum data_types_verts_vgroup_enum {
		data_types_verts_vgroup_VGROUP_WEIGHTS = 1,
	};

	/** Getter: Which vertex data layers to transfer */
	data_types_verts_vgroup_enum data_types_verts_vgroup() { /* not implemented */ throw NULL; }
	/** Setter: Which vertex data layers to transfer */
	void data_types_verts_vgroup(data_types_verts_vgroup_enum value) { /* not implemented */ }

	enum data_types_edges_enum {
		data_types_edges_SHARP_EDGE = 256,
		data_types_edges_SEAM = 512,
		data_types_edges_CREASE = 1024,
		data_types_edges_BEVEL_WEIGHT_EDGE = 2048,
		data_types_edges_FREESTYLE_EDGE = 4096,
	};

	/** Getter: Which edge data layers to transfer */
	data_types_edges_enum data_types_edges() { /* not implemented */ throw NULL; }
	/** Setter: Which edge data layers to transfer */
	void data_types_edges(data_types_edges_enum value) { /* not implemented */ }

	enum data_types_loops_enum {
		data_types_loops_CUSTOM_NORMAL = 131072,
	};

	/** Getter: Which face corner data layers to transfer */
	data_types_loops_enum data_types_loops() { /* not implemented */ throw NULL; }
	/** Setter: Which face corner data layers to transfer */
	void data_types_loops(data_types_loops_enum value) { /* not implemented */ }

	enum data_types_loops_vcol_enum {
		data_types_loops_vcol_VCOL = 65536,
	};

	/** Getter: Which face corner data layers to transfer */
	data_types_loops_vcol_enum data_types_loops_vcol() { /* not implemented */ throw NULL; }
	/** Setter: Which face corner data layers to transfer */
	void data_types_loops_vcol(data_types_loops_vcol_enum value) { /* not implemented */ }

	enum data_types_loops_uv_enum {
		data_types_loops_uv_UV = 16777216,
	};

	/** Getter: Which face corner data layers to transfer */
	data_types_loops_uv_enum data_types_loops_uv() { /* not implemented */ throw NULL; }
	/** Setter: Which face corner data layers to transfer */
	void data_types_loops_uv(data_types_loops_uv_enum value) { /* not implemented */ }

	enum data_types_polys_enum {
		data_types_polys_SMOOTH = 33554432,
		data_types_polys_FREESTYLE_FACE = 67108864,
	};

	/** Getter: Which poly data layers to transfer */
	data_types_polys_enum data_types_polys() { /* not implemented */ throw NULL; }
	/** Setter: Which poly data layers to transfer */
	void data_types_polys(data_types_polys_enum value) { /* not implemented */ }

	enum vert_mapping_enum {
		vert_mapping_TOPOLOGY = 251658240,
		vert_mapping_NEAREST = 16777488,
		vert_mapping_EDGE_NEAREST = 16777504,
		vert_mapping_EDGEINTERP_NEAREST = 16778528,
		vert_mapping_POLY_NEAREST = 16777600,
		vert_mapping_POLYINTERP_NEAREST = 16778624,
		vert_mapping_POLYINTERP_VNORPROJ = 16778880,
	};

	/** Getter: Method used to map source vertices to destination ones */
	vert_mapping_enum vert_mapping() { /* not implemented */ throw NULL; }
	/** Setter: Method used to map source vertices to destination ones */
	void vert_mapping(vert_mapping_enum value) { /* not implemented */ }

	enum edge_mapping_enum {
		edge_mapping_TOPOLOGY = 251658240,
		edge_mapping_VERT_NEAREST = 33554704,
		edge_mapping_NEAREST = 33554720,
		edge_mapping_POLY_NEAREST = 33554816,
		edge_mapping_EDGEINTERP_VNORPROJ = 33555984,
	};

	/** Getter: Method used to map source edges to destination ones */
	edge_mapping_enum edge_mapping() { /* not implemented */ throw NULL; }
	/** Setter: Method used to map source edges to destination ones */
	void edge_mapping(edge_mapping_enum value) { /* not implemented */ }

	enum loop_mapping_enum {
		loop_mapping_TOPOLOGY = 251658240,
		loop_mapping_NEAREST_NORMAL = 67111248,
		loop_mapping_NEAREST_POLYNOR = 67111312,
		loop_mapping_NEAREST_POLY = 67109248,
		loop_mapping_POLYINTERP_NEAREST = 67110272,
		loop_mapping_POLYINTERP_LNORPROJ = 67110528,
	};

	/** Getter: Method used to map source faces' corners to destination ones */
	loop_mapping_enum loop_mapping() { /* not implemented */ throw NULL; }
	/** Setter: Method used to map source faces' corners to destination ones */
	void loop_mapping(loop_mapping_enum value) { /* not implemented */ }

	enum poly_mapping_enum {
		poly_mapping_TOPOLOGY = 251658240,
		poly_mapping_NEAREST = 134218112,
		poly_mapping_NORMAL = 134219904,
		poly_mapping_POLYINTERP_PNORPROJ = 134219392,
	};

	/** Getter: Method used to map source faces to destination ones */
	poly_mapping_enum poly_mapping() { /* not implemented */ throw NULL; }
	/** Setter: Method used to map source faces to destination ones */
	void poly_mapping(poly_mapping_enum value) { /* not implemented */ }

	/** Getter: Source elements must be closer than given distance from destination one */
	bool use_max_distance() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_max_distance")) == 1;
	}

	/** Setter: Source elements must be closer than given distance from destination one */
	void use_max_distance(bool value) {
		PyObject_SetAttrString(pyobjref, "use_max_distance", Py_BuildValue("i", value));
	}

	/** Getter: Maximum allowed distance between source and destination element, for non-topology mappings */
	float max_distance() { /* not implemented */ throw NULL; }
	/** Setter: Maximum allowed distance between source and destination element, for non-topology mappings */
	void max_distance(float value) {
		PyObject_SetAttrString(pyobjref, "max_distance", Py_BuildValue("f", value));
	}

	/** Getter: 'Width' of rays (especially useful when raycasting against vertices or edges) */
	float ray_radius() { /* not implemented */ throw NULL; }
	/** Setter: 'Width' of rays (especially useful when raycasting against vertices or edges) */
	void ray_radius(float value) {
		PyObject_SetAttrString(pyobjref, "ray_radius", Py_BuildValue("f", value));
	}

	/** Getter: Factor controlling precision of islands handling (typically, 0.1 should be enough, higher values can make things really slow) */
	float islands_precision() { /* not implemented */ throw NULL; }
	/** Setter: Factor controlling precision of islands handling (typically, 0.1 should be enough, higher values can make things really slow) */
	void islands_precision(float value) {
		PyObject_SetAttrString(pyobjref, "islands_precision", Py_BuildValue("f", value));
	}

	enum layers_vgroup_select_src_enum {
		layers_vgroup_select_src_ACTIVE = -1,
		layers_vgroup_select_src_ALL = -2,
		layers_vgroup_select_src_BONE_SELECT = -257,
		layers_vgroup_select_src_BONE_DEFORM = -258,
	};

	/** Getter: Which layers to transfer, in case of multi-layers types */
	layers_vgroup_select_src_enum layers_vgroup_select_src() { /* not implemented */ throw NULL; }
	/** Setter: Which layers to transfer, in case of multi-layers types */
	void layers_vgroup_select_src(layers_vgroup_select_src_enum value) { /* not implemented */ }

	enum layers_vcol_select_src_enum {
		layers_vcol_select_src_ACTIVE = -1,
		layers_vcol_select_src_ALL = -2,
		layers_vcol_select_src_BONE_SELECT = -257,
		layers_vcol_select_src_BONE_DEFORM = -258,
	};

	/** Getter: Which layers to transfer, in case of multi-layers types */
	layers_vcol_select_src_enum layers_vcol_select_src() { /* not implemented */ throw NULL; }
	/** Setter: Which layers to transfer, in case of multi-layers types */
	void layers_vcol_select_src(layers_vcol_select_src_enum value) { /* not implemented */ }

	enum layers_uv_select_src_enum {
		layers_uv_select_src_ACTIVE = -1,
		layers_uv_select_src_ALL = -2,
		layers_uv_select_src_BONE_SELECT = -257,
		layers_uv_select_src_BONE_DEFORM = -258,
	};

	/** Getter: Which layers to transfer, in case of multi-layers types */
	layers_uv_select_src_enum layers_uv_select_src() { /* not implemented */ throw NULL; }
	/** Setter: Which layers to transfer, in case of multi-layers types */
	void layers_uv_select_src(layers_uv_select_src_enum value) { /* not implemented */ }

	enum layers_vgroup_select_dst_enum {
		layers_vgroup_select_dst_ACTIVE = -1,
		layers_vgroup_select_dst_NAME = -2,
		layers_vgroup_select_dst_INDEX = -3,
	};

	/** Getter: How to match source and destination layers */
	layers_vgroup_select_dst_enum layers_vgroup_select_dst() { /* not implemented */ throw NULL; }
	/** Setter: How to match source and destination layers */
	void layers_vgroup_select_dst(layers_vgroup_select_dst_enum value) { /* not implemented */ }

	enum layers_vcol_select_dst_enum {
		layers_vcol_select_dst_ACTIVE = -1,
		layers_vcol_select_dst_NAME = -2,
		layers_vcol_select_dst_INDEX = -3,
	};

	/** Getter: How to match source and destination layers */
	layers_vcol_select_dst_enum layers_vcol_select_dst() { /* not implemented */ throw NULL; }
	/** Setter: How to match source and destination layers */
	void layers_vcol_select_dst(layers_vcol_select_dst_enum value) { /* not implemented */ }

	enum layers_uv_select_dst_enum {
		layers_uv_select_dst_ACTIVE = -1,
		layers_uv_select_dst_NAME = -2,
		layers_uv_select_dst_INDEX = -3,
	};

	/** Getter: How to match source and destination layers */
	layers_uv_select_dst_enum layers_uv_select_dst() { /* not implemented */ throw NULL; }
	/** Setter: How to match source and destination layers */
	void layers_uv_select_dst(layers_uv_select_dst_enum value) { /* not implemented */ }

	enum mix_mode_enum {
		mix_mode_REPLACE = 0,
		mix_mode_ABOVE_THRESHOLD = 1,
		mix_mode_BELOW_THRESHOLD = 2,
		mix_mode_MIX = 16,
		mix_mode_ADD = 17,
		mix_mode_SUB = 18,
		mix_mode_MUL = 19,
	};

	/** Getter: How to affect destination elements with source values */
	mix_mode_enum mix_mode() { /* not implemented */ throw NULL; }
	/** Setter: How to affect destination elements with source values */
	void mix_mode(mix_mode_enum value) { /* not implemented */ }

	/** Getter: Factor to use when applying data to destination (exact behavior depends on mix mode) */
	float mix_factor() { /* not implemented */ throw NULL; }
	/** Setter: Factor to use when applying data to destination (exact behavior depends on mix mode) */
	void mix_factor(float value) {
		PyObject_SetAttrString(pyobjref, "mix_factor", Py_BuildValue("f", value));
	}

	/** Getter: Vertex group name for selecting the affected areas */
	std::string vertex_group() { /* not implemented */ throw NULL; }
	/** Setter: Vertex group name for selecting the affected areas */
	void vertex_group(const std::string& value) { /* not implemented */ }

	/** Getter: Invert vertex group influence */
	bool invert_vertex_group() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "invert_vertex_group")) == 1;
	}

	/** Setter: Invert vertex group influence */
	void invert_vertex_group(bool value) {
		PyObject_SetAttrString(pyobjref, "invert_vertex_group", Py_BuildValue("i", value));
	}

};

/**************** Normal Edit Modifier ****************/

/**
 * Modifier affecting/generating custom normals
 */
class NormalEditModifier : public Modifier {
public:
	NormalEditModifier(PyObject* pyobj) : Modifier(pyobj) {}

	NormalEditModifier() : Modifier(0)
	{
		// not implemented
	}

	enum mode_enum {
		mode_RADIAL = 0,
		mode_DIRECTIONAL = 1,
	};

	/** Getter: How to affect (generate) normals */
	mode_enum mode() { /* not implemented */ throw NULL; }
	/** Setter: How to affect (generate) normals */
	void mode(mode_enum value) { /* not implemented */ }

	/** Getter: Offset from object's center */
	std::array<float, 3> offset() {
		// TODO: MISSING DEREF! USE #DEFINE!
		PyObject *seqval = PyObject_GetAttrString(pyobjref, "offset");
		std::array<float, 3> resarr;
		for (int i = 0; i < 3; i++)
			resarr[i] = (float)PyFloat_AsDouble(PySequence_GetItem(seqval, i));
		return resarr;
	}

	/** Setter: Offset from object's center */
	void offset(float values[3]) { /* not implemented */ }

	enum mix_mode_enum {
		mix_mode_COPY = 0,
		mix_mode_ADD = 1,
		mix_mode_SUB = 2,
		mix_mode_MUL = 3,
	};

	/** Getter: How to mix generated normals with existing ones */
	mix_mode_enum mix_mode() { /* not implemented */ throw NULL; }
	/** Setter: How to mix generated normals with existing ones */
	void mix_mode(mix_mode_enum value) { /* not implemented */ }

	/** Getter: How much of generated normals to mix with exiting ones */
	float mix_factor() { /* not implemented */ throw NULL; }
	/** Setter: How much of generated normals to mix with exiting ones */
	void mix_factor(float value) {
		PyObject_SetAttrString(pyobjref, "mix_factor", Py_BuildValue("f", value));
	}

	/** Getter: Vertex group name for selecting/weighting the affected areas */
	std::string vertex_group() { /* not implemented */ throw NULL; }
	/** Setter: Vertex group name for selecting/weighting the affected areas */
	void vertex_group(const std::string& value) { /* not implemented */ }

	/** Getter: Invert vertex group influence */
	bool invert_vertex_group() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "invert_vertex_group")) == 1;
	}

	/** Setter: Invert vertex group influence */
	void invert_vertex_group(bool value) {
		PyObject_SetAttrString(pyobjref, "invert_vertex_group", Py_BuildValue("i", value));
	}

	/** Getter: Target object used to affect normals */
	Object target();

	/** Getter: Use same direction for all normals, from origin to target's center (Directional mode only) */
	bool use_direction_parallel() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_direction_parallel")) == 1;
	}

	/** Setter: Use same direction for all normals, from origin to target's center (Directional mode only) */
	void use_direction_parallel(bool value) {
		PyObject_SetAttrString(pyobjref, "use_direction_parallel", Py_BuildValue("i", value));
	}

};

/**************** NLA Track ****************/

/**
 * A animation layer containing Actions referenced as NLA strips
 */
class NlaTrack : public pyUniplug {
public:
	NlaTrack(PyObject* pyobj) : pyUniplug(pyobj) {}

	NlaTrack() : pyUniplug(0)
	{
		// not implemented
	}

	/** Getter: NLA Strips on this NLA-track */
	std::map<std::string, NlaStrip> strips();
	/** Setter: NLA Strips on this NLA-track */
	void strips(std::map<std::string, NlaStrip> value);

	/** Getter:  */
	std::string name() { /* not implemented */ throw NULL; }
	/** Setter:  */
	void name(const std::string& value) { /* not implemented */ }

	/** Getter: NLA Track is active */
	bool active() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "active")) == 1;
	}

	/** Setter: NLA Track is active */
	void active(bool value) {
		PyObject_SetAttrString(pyobjref, "active", Py_BuildValue("i", value));
	}

	/** Getter: NLA Track is evaluated itself (i.e. active Action and all other NLA Tracks in the same AnimData block are disabled) */
	bool is_solo() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "is_solo")) == 1;
	}

	/** Setter: NLA Track is evaluated itself (i.e. active Action and all other NLA Tracks in the same AnimData block are disabled) */
	void is_solo(bool value) {
		PyObject_SetAttrString(pyobjref, "is_solo", Py_BuildValue("i", value));
	}

	/** Getter: NLA Track is selected */
	bool select() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "select")) == 1;
	}

	/** Setter: NLA Track is selected */
	void select(bool value) {
		PyObject_SetAttrString(pyobjref, "select", Py_BuildValue("i", value));
	}

	/** Getter: NLA Track is not evaluated */
	bool mute() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "mute")) == 1;
	}

	/** Setter: NLA Track is not evaluated */
	void mute(bool value) {
		PyObject_SetAttrString(pyobjref, "mute", Py_BuildValue("i", value));
	}

	/** Getter: NLA Track is locked */
	bool lock_value() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "lock")) == 1;
	}

	/** Setter: NLA Track is locked */
	void lock_value(bool value) {
		PyObject_SetAttrString(pyobjref, "lock", Py_BuildValue("i", value));
	}

};

/**************** NLA Strip ****************/

/**
 * A container referencing an existing Action
 */
class NlaStrip : public pyUniplug {
public:
	NlaStrip(PyObject* pyobj) : pyUniplug(pyobj) {}

	NlaStrip() : pyUniplug(0)
	{
		// not implemented
	}

	/** Getter:  */
	std::string name() { /* not implemented */ throw NULL; }
	/** Setter:  */
	void name(const std::string& value) { /* not implemented */ }

	enum type_enum {
		type_CLIP = 0,
		type_TRANSITION = 1,
		type_META = 2,
		type_SOUND = 3,
	};

	/** Getter: Type of NLA Strip */
	type_enum type() { /* not implemented */ throw NULL; }
	/** Setter: Type of NLA Strip */
	void type(type_enum value) { /* not implemented */ }

	enum extrapolation_enum {
		extrapolation_NOTHING = 2,
		extrapolation_HOLD = 0,
		extrapolation_HOLD_FORWARD = 1,
	};

	/** Getter: Action to take for gaps past the strip extents */
	extrapolation_enum extrapolation() { /* not implemented */ throw NULL; }
	/** Setter: Action to take for gaps past the strip extents */
	void extrapolation(extrapolation_enum value) { /* not implemented */ }

	enum blend_type_enum {
		blend_type_REPLACE = 0,
		blend_type_ADD = 1,
		blend_type_SUBTRACT = 2,
		blend_type_MULTIPLY = 3,
	};

	/** Getter: Method used for combining strip's result with accumulated result */
	blend_type_enum blend_type() { /* not implemented */ throw NULL; }
	/** Setter: Method used for combining strip's result with accumulated result */
	void blend_type(blend_type_enum value) { /* not implemented */ }

	/** Getter:  */
	float frame_start() { /* not implemented */ throw NULL; }
	/** Setter:  */
	void frame_start(float value) {
		PyObject_SetAttrString(pyobjref, "frame_start", Py_BuildValue("f", value));
	}

	/** Getter:  */
	float frame_end() { /* not implemented */ throw NULL; }
	/** Setter:  */
	void frame_end(float value) {
		PyObject_SetAttrString(pyobjref, "frame_end", Py_BuildValue("f", value));
	}

	/** Getter: Number of frames at start of strip to fade in influence */
	float blend_in() { /* not implemented */ throw NULL; }
	/** Setter: Number of frames at start of strip to fade in influence */
	void blend_in(float value) {
		PyObject_SetAttrString(pyobjref, "blend_in", Py_BuildValue("f", value));
	}

	/** Getter:  */
	float blend_out() { /* not implemented */ throw NULL; }
	/** Setter:  */
	void blend_out(float value) {
		PyObject_SetAttrString(pyobjref, "blend_out", Py_BuildValue("f", value));
	}

	/** Getter: Number of frames for Blending In/Out is automatically determined from overlapping strips */
	bool use_auto_blend() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_auto_blend")) == 1;
	}

	/** Setter: Number of frames for Blending In/Out is automatically determined from overlapping strips */
	void use_auto_blend(bool value) {
		PyObject_SetAttrString(pyobjref, "use_auto_blend", Py_BuildValue("i", value));
	}

	/** Getter: Action referenced by this strip */
	Action action() {
		/* not implemented */ throw NULL;
	}

	/** Getter: First frame from action to use */
	float action_frame_start() { /* not implemented */ throw NULL; }
	/** Setter: First frame from action to use */
	void action_frame_start(float value) {
		PyObject_SetAttrString(pyobjref, "action_frame_start", Py_BuildValue("f", value));
	}

	/** Getter: Last frame from action to use */
	float action_frame_end() { /* not implemented */ throw NULL; }
	/** Setter: Last frame from action to use */
	void action_frame_end(float value) {
		PyObject_SetAttrString(pyobjref, "action_frame_end", Py_BuildValue("f", value));
	}

	/** Getter: Number of times to repeat the action range */
	float repeat() { /* not implemented */ throw NULL; }
	/** Setter: Number of times to repeat the action range */
	void repeat(float value) {
		PyObject_SetAttrString(pyobjref, "repeat", Py_BuildValue("f", value));
	}

	/** Getter: Scaling factor for action */
	float scale() { /* not implemented */ throw NULL; }
	/** Setter: Scaling factor for action */
	void scale(float value) {
		PyObject_SetAttrString(pyobjref, "scale", Py_BuildValue("f", value));
	}

	/** Getter: F-Curves for controlling the strip's influence and timing */
	std::map<std::string, FCurve> fcurves() {
		// TODO: MISSING DEREF! USE #DEFINE!
		PyObject *seqval = PyObject_GetAttrString(pyobjref, "fcurves");
		PyObject *seqkeys = PyObject_CallMethod(seqval, "keys", NULL);
		std::map<std::string, FCurve> resmap;
		for (int i = 0; i < PySequence_Length(seqval); i++) {
			PyObject *keyobj = PySequence_GetItem(seqkeys, i);
			std::string key = PyBytes_AsString(PyUnicode_AsASCIIString(keyobj));
			FCurve value = FCurve(PySequence_GetItem(seqval, i));
			resmap.insert(std::pair<std::string,FCurve>(key, value));
		}
		return resmap;
	}

	/** Setter: F-Curves for controlling the strip's influence and timing */
	void fcurves(std::map<std::string, FCurve> value) { /* not implemented */ }

	/** Getter: Modifiers affecting all the F-Curves in the referenced Action */
	std::map<std::string, FModifier> modifiers() {
		// TODO: MISSING DEREF! USE #DEFINE!
		PyObject *seqval = PyObject_GetAttrString(pyobjref, "modifiers");
		PyObject *seqkeys = PyObject_CallMethod(seqval, "keys", NULL);
		std::map<std::string, FModifier> resmap;
		for (int i = 0; i < PySequence_Length(seqval); i++) {
			PyObject *keyobj = PySequence_GetItem(seqkeys, i);
			std::string key = PyBytes_AsString(PyUnicode_AsASCIIString(keyobj));
			FModifier value = FModifier(PySequence_GetItem(seqval, i));
			resmap.insert(std::pair<std::string,FModifier>(key, value));
		}
		return resmap;
	}

	/** Setter: Modifiers affecting all the F-Curves in the referenced Action */
	void modifiers(std::map<std::string, FModifier> value) { /* not implemented */ }

	/** Getter: NLA Strips that this strip acts as a container for (if it is of type Meta) */
	std::map<std::string, NlaStrip> strips() {
		// TODO: MISSING DEREF! USE #DEFINE!
		PyObject *seqval = PyObject_GetAttrString(pyobjref, "strips");
		PyObject *seqkeys = PyObject_CallMethod(seqval, "keys", NULL);
		std::map<std::string, NlaStrip> resmap;
		for (int i = 0; i < PySequence_Length(seqval); i++) {
			PyObject *keyobj = PySequence_GetItem(seqkeys, i);
			std::string key = PyBytes_AsString(PyUnicode_AsASCIIString(keyobj));
			NlaStrip value = NlaStrip(PySequence_GetItem(seqval, i));
			resmap.insert(std::pair<std::string,NlaStrip>(key, value));
		}
		return resmap;
	}

	/** Setter: NLA Strips that this strip acts as a container for (if it is of type Meta) */
	void strips(std::map<std::string, NlaStrip> value) { /* not implemented */ }

	/** Getter: Amount the strip contributes to the current result */
	float influence() { /* not implemented */ throw NULL; }
	/** Setter: Amount the strip contributes to the current result */
	void influence(float value) {
		PyObject_SetAttrString(pyobjref, "influence", Py_BuildValue("f", value));
	}

	/** Getter: Frame of referenced Action to evaluate */
	float strip_time() { /* not implemented */ throw NULL; }
	/** Setter: Frame of referenced Action to evaluate */
	void strip_time(float value) {
		PyObject_SetAttrString(pyobjref, "strip_time", Py_BuildValue("f", value));
	}

	/** Getter: Influence setting is controlled by an F-Curve rather than automatically determined */
	bool use_animated_influence() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_animated_influence")) == 1;
	}

	/** Setter: Influence setting is controlled by an F-Curve rather than automatically determined */
	void use_animated_influence(bool value) {
		PyObject_SetAttrString(pyobjref, "use_animated_influence", Py_BuildValue("i", value));
	}

	/** Getter: Strip time is controlled by an F-Curve rather than automatically determined */
	bool use_animated_time() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_animated_time")) == 1;
	}

	/** Setter: Strip time is controlled by an F-Curve rather than automatically determined */
	void use_animated_time(bool value) {
		PyObject_SetAttrString(pyobjref, "use_animated_time", Py_BuildValue("i", value));
	}

	/** Getter: Cycle the animated time within the action start & end */
	bool use_animated_time_cyclic() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_animated_time_cyclic")) == 1;
	}

	/** Setter: Cycle the animated time within the action start & end */
	void use_animated_time_cyclic(bool value) {
		PyObject_SetAttrString(pyobjref, "use_animated_time_cyclic", Py_BuildValue("i", value));
	}

	/** Getter: NLA Strip is active */
	bool active() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "active")) == 1;
	}

	/** Setter: NLA Strip is active */
	void active(bool value) {
		PyObject_SetAttrString(pyobjref, "active", Py_BuildValue("i", value));
	}

	/** Getter: NLA Strip is selected */
	bool select() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "select")) == 1;
	}

	/** Setter: NLA Strip is selected */
	void select(bool value) {
		PyObject_SetAttrString(pyobjref, "select", Py_BuildValue("i", value));
	}

	/** Getter: NLA Strip is not evaluated */
	bool mute() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "mute")) == 1;
	}

	/** Setter: NLA Strip is not evaluated */
	void mute(bool value) {
		PyObject_SetAttrString(pyobjref, "mute", Py_BuildValue("i", value));
	}

	/** Getter: NLA Strip is played back in reverse order (only when timing is automatically determined) */
	bool use_reverse() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_reverse")) == 1;
	}

	/** Setter: NLA Strip is played back in reverse order (only when timing is automatically determined) */
	void use_reverse(bool value) {
		PyObject_SetAttrString(pyobjref, "use_reverse", Py_BuildValue("i", value));
	}

	/** Getter: Update range of frames referenced from action after tweaking strip and its keyframes */
	bool use_sync_length() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_sync_length")) == 1;
	}

	/** Setter: Update range of frames referenced from action after tweaking strip and its keyframes */
	void use_sync_length(bool value) {
		PyObject_SetAttrString(pyobjref, "use_sync_length", Py_BuildValue("i", value));
	}

};

/**************** Node Socket ****************/

/**
 * Input or output socket of a node
 */
class NodeSocket : public pyUniplug {
public:
	NodeSocket(PyObject* pyobj) : pyUniplug(pyobj) {}

	NodeSocket() : pyUniplug(0)
	{
		// not implemented
	}

	/** Getter: Socket name */
	std::string name() { /* not implemented */ throw NULL; }
	/** Setter: Socket name */
	void name(const std::string& value) { /* not implemented */ }

	/** Getter: Unique identifier for mapping sockets */
	std::string identifier() { /* not implemented */ throw NULL; }
	/** Setter: Unique identifier for mapping sockets */
	void identifier(const std::string& value) { /* not implemented */ }

	/** Getter: True if the socket is an output, otherwise input */
	bool is_output() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "is_output")) == 1;
	}

	/** Setter: True if the socket is an output, otherwise input */
	void is_output(bool value) {
		PyObject_SetAttrString(pyobjref, "is_output", Py_BuildValue("i", value));
	}

	/** Getter: Hide the socket */
	bool hide() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "hide")) == 1;
	}

	/** Setter: Hide the socket */
	void hide(bool value) {
		PyObject_SetAttrString(pyobjref, "hide", Py_BuildValue("i", value));
	}

	/** Getter: Enable the socket */
	bool enabled() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "enabled")) == 1;
	}

	/** Setter: Enable the socket */
	void enabled(bool value) {
		PyObject_SetAttrString(pyobjref, "enabled", Py_BuildValue("i", value));
	}

	/** Getter: Max number of links allowed for this socket */
	int link_limit() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "link_limit"));
	}

	/** Setter: Max number of links allowed for this socket */
	void link_limit(int value) {
		PyObject_SetAttrString(pyobjref, "link_limit", Py_BuildValue("i", value));
	}

	/** Getter: True if the socket is connected */
	bool is_linked() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "is_linked")) == 1;
	}

	/** Setter: True if the socket is connected */
	void is_linked(bool value) {
		PyObject_SetAttrString(pyobjref, "is_linked", Py_BuildValue("i", value));
	}

	/** Getter: Socket links are expanded in the user interface */
	bool show_expanded() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "show_expanded")) == 1;
	}

	/** Setter: Socket links are expanded in the user interface */
	void show_expanded(bool value) {
		PyObject_SetAttrString(pyobjref, "show_expanded", Py_BuildValue("i", value));
	}

	/** Getter: Hide the socket input value */
	bool hide_value() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "hide_value")) == 1;
	}

	/** Setter: Hide the socket input value */
	void hide_value(bool value) {
		PyObject_SetAttrString(pyobjref, "hide_value", Py_BuildValue("i", value));
	}

	/** Getter: Node owning this socket */
	Node node();

	enum type_enum {
		type_CUSTOM = -1,
		type_VALUE = 0,
		type_INT = 6,
		type_BOOLEAN = 4,
		type_VECTOR = 1,
		type_STRING = 7,
		type_RGBA = 2,
		type_SHADER = 3,
	};

	/** Getter: Data type */
	type_enum type() { /* not implemented */ throw NULL; }
	/** Setter: Data type */
	void type(type_enum value) { /* not implemented */ }

	/** Getter:  */
	std::string bl_idname() { /* not implemented */ throw NULL; }
	/** Setter:  */
	void bl_idname(const std::string& value) { /* not implemented */ }

};

/**************** Node Socket Template ****************/

/**
 * Parameters to define node sockets
 */
class NodeSocketInterface : public pyUniplug {
public:
	NodeSocketInterface(PyObject* pyobj) : pyUniplug(pyobj) {}

	NodeSocketInterface() : pyUniplug(0)
	{
		// not implemented
	}

	/** Getter: Socket name */
	std::string name() { /* not implemented */ throw NULL; }
	/** Setter: Socket name */
	void name(const std::string& value) { /* not implemented */ }

	/** Getter: Unique identifier for mapping sockets */
	std::string identifier() { /* not implemented */ throw NULL; }
	/** Setter: Unique identifier for mapping sockets */
	void identifier(const std::string& value) { /* not implemented */ }

	/** Getter: True if the socket is an output, otherwise input */
	bool is_output() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "is_output")) == 1;
	}

	/** Setter: True if the socket is an output, otherwise input */
	void is_output(bool value) {
		PyObject_SetAttrString(pyobjref, "is_output", Py_BuildValue("i", value));
	}

	/** Getter:  */
	std::string bl_socket_idname() { /* not implemented */ throw NULL; }
	/** Setter:  */
	void bl_socket_idname(const std::string& value) { /* not implemented */ }

};

/**************** Node ****************/

/**
 * Node in a node tree
 */
class Node : public pyUniplug {
public:
	Node(PyObject* pyobj) : pyUniplug(pyobj) {}

	Node() : pyUniplug(0)
	{
		// not implemented
	}

	enum type_enum {
		type_CUSTOM = -1,
	};

	/** Getter: Node type (deprecated, use bl_static_type or bl_idname for the actual identifier string) */
	type_enum type() { /* not implemented */ throw NULL; }
	/** Setter: Node type (deprecated, use bl_static_type or bl_idname for the actual identifier string) */
	void type(type_enum value) { /* not implemented */ }

	/** Getter:  */
	std::array<float, 2> location() {
		// TODO: MISSING DEREF! USE #DEFINE!
		PyObject *seqval = PyObject_GetAttrString(pyobjref, "location");
		std::array<float, 2> resarr;
		for (int i = 0; i < 2; i++)
			resarr[i] = (float)PyFloat_AsDouble(PySequence_GetItem(seqval, i));
		return resarr;
	}

	/** Setter:  */
	void location(float values[2]) { /* not implemented */ }

	/** Getter: Width of the node */
	float width() { /* not implemented */ throw NULL; }
	/** Setter: Width of the node */
	void width(float value) {
		PyObject_SetAttrString(pyobjref, "width", Py_BuildValue("f", value));
	}

	/** Getter: Width of the node in hidden state */
	float width_hidden() { /* not implemented */ throw NULL; }
	/** Setter: Width of the node in hidden state */
	void width_hidden(float value) {
		PyObject_SetAttrString(pyobjref, "width_hidden", Py_BuildValue("f", value));
	}

	/** Getter: Height of the node */
	float height() { /* not implemented */ throw NULL; }
	/** Setter: Height of the node */
	void height(float value) {
		PyObject_SetAttrString(pyobjref, "height", Py_BuildValue("f", value));
	}

	/** Getter: Absolute bounding box dimensions of the node */
	std::array<float, 2> dimensions() {
		// TODO: MISSING DEREF! USE #DEFINE!
		PyObject *seqval = PyObject_GetAttrString(pyobjref, "dimensions");
		std::array<float, 2> resarr;
		for (int i = 0; i < 2; i++)
			resarr[i] = (float)PyFloat_AsDouble(PySequence_GetItem(seqval, i));
		return resarr;
	}

	/** Setter: Absolute bounding box dimensions of the node */
	void dimensions(float values[2]) { /* not implemented */ }

	/** Getter: Unique node identifier */
	std::string name() { /* not implemented */ throw NULL; }
	/** Setter: Unique node identifier */
	void name(const std::string& value) { /* not implemented */ }

	/** Getter: Optional custom node label */
	std::string label() { /* not implemented */ throw NULL; }
	/** Setter: Optional custom node label */
	void label(const std::string& value) { /* not implemented */ }

	/** Getter:  */
	std::map<std::string, NodeSocket> inputs() {
		// TODO: MISSING DEREF! USE #DEFINE!
		PyObject *seqval = PyObject_GetAttrString(pyobjref, "inputs");
		PyObject *seqkeys = PyObject_CallMethod(seqval, "keys", NULL);
		std::map<std::string, NodeSocket> resmap;
		for (int i = 0; i < PySequence_Length(seqval); i++) {
			PyObject *keyobj = PySequence_GetItem(seqkeys, i);
			std::string key = PyBytes_AsString(PyUnicode_AsASCIIString(keyobj));
			NodeSocket value = NodeSocket(PySequence_GetItem(seqval, i));
			resmap.insert(std::pair<std::string,NodeSocket>(key, value));
		}
		return resmap;
	}

	/** Setter:  */
	void inputs(std::map<std::string, NodeSocket> value) { /* not implemented */ }

	/** Getter:  */
	std::map<std::string, NodeSocket> outputs() {
		// TODO: MISSING DEREF! USE #DEFINE!
		PyObject *seqval = PyObject_GetAttrString(pyobjref, "outputs");
		PyObject *seqkeys = PyObject_CallMethod(seqval, "keys", NULL);
		std::map<std::string, NodeSocket> resmap;
		for (int i = 0; i < PySequence_Length(seqval); i++) {
			PyObject *keyobj = PySequence_GetItem(seqkeys, i);
			std::string key = PyBytes_AsString(PyUnicode_AsASCIIString(keyobj));
			NodeSocket value = NodeSocket(PySequence_GetItem(seqval, i));
			resmap.insert(std::pair<std::string,NodeSocket>(key, value));
		}
		return resmap;
	}

	/** Setter:  */
	void outputs(std::map<std::string, NodeSocket> value) { /* not implemented */ }

	/** Getter: Internal input-to-output connections for muting */
	std::map<std::string, NodeLink> internal_links();
	/** Setter: Internal input-to-output connections for muting */
	void internal_links(std::map<std::string, NodeLink> value);

	/** Getter: Parent this node is attached to */
	Node parent() {
		/* not implemented */ throw NULL;
	}

	/** Getter: Use custom color for the node */
	bool use_custom_color() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_custom_color")) == 1;
	}

	/** Setter: Use custom color for the node */
	void use_custom_color(bool value) {
		PyObject_SetAttrString(pyobjref, "use_custom_color", Py_BuildValue("i", value));
	}

	/** Getter: Custom color of the node body */
	std::array<float, 3> color() {
		// TODO: MISSING DEREF! USE #DEFINE!
		PyObject *seqval = PyObject_GetAttrString(pyobjref, "color");
		std::array<float, 3> resarr;
		for (int i = 0; i < 3; i++)
			resarr[i] = (float)PyFloat_AsDouble(PySequence_GetItem(seqval, i));
		return resarr;
	}

	/** Setter: Custom color of the node body */
	void color(float values[3]) { /* not implemented */ }

	/** Getter: Node selection state */
	bool select() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "select")) == 1;
	}

	/** Setter: Node selection state */
	void select(bool value) {
		PyObject_SetAttrString(pyobjref, "select", Py_BuildValue("i", value));
	}

	/** Getter:  */
	bool show_options() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "show_options")) == 1;
	}

	/** Setter:  */
	void show_options(bool value) {
		PyObject_SetAttrString(pyobjref, "show_options", Py_BuildValue("i", value));
	}

	/** Getter:  */
	bool show_preview() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "show_preview")) == 1;
	}

	/** Setter:  */
	void show_preview(bool value) {
		PyObject_SetAttrString(pyobjref, "show_preview", Py_BuildValue("i", value));
	}

	/** Getter:  */
	bool hide() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "hide")) == 1;
	}

	/** Setter:  */
	void hide(bool value) {
		PyObject_SetAttrString(pyobjref, "hide", Py_BuildValue("i", value));
	}

	/** Getter:  */
	bool mute() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "mute")) == 1;
	}

	/** Setter:  */
	void mute(bool value) {
		PyObject_SetAttrString(pyobjref, "mute", Py_BuildValue("i", value));
	}

	/** Getter: Draw node in viewport textured draw mode */
	bool show_texture() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "show_texture")) == 1;
	}

	/** Setter: Draw node in viewport textured draw mode */
	void show_texture(bool value) {
		PyObject_SetAttrString(pyobjref, "show_texture", Py_BuildValue("i", value));
	}

	enum shading_compatibility_enum {
		shading_compatibility_OLD_SHADING = 1,
		shading_compatibility_NEW_SHADING = 2,
	};

	/** Getter:  */
	shading_compatibility_enum shading_compatibility() { /* not implemented */ throw NULL; }
	/** Setter:  */
	void shading_compatibility(shading_compatibility_enum value) { /* not implemented */ }

	/** Getter:  */
	std::string bl_idname() { /* not implemented */ throw NULL; }
	/** Setter:  */
	void bl_idname(const std::string& value) { /* not implemented */ }

	/** Getter: The node label */
	std::string bl_label() { /* not implemented */ throw NULL; }
	/** Setter: The node label */
	void bl_label(const std::string& value) { /* not implemented */ }

	/** Getter:  */
	std::string bl_description() { /* not implemented */ throw NULL; }
	/** Setter:  */
	void bl_description(const std::string& value) { /* not implemented */ }

	enum bl_icon_enum {
		bl_icon_NONE = 0,
		bl_icon_QUESTION = 1,
		bl_icon_ERROR = 2,
		bl_icon_CANCEL = 3,
		bl_icon_TRIA_RIGHT = 4,
		bl_icon_TRIA_DOWN = 5,
		bl_icon_TRIA_LEFT = 6,
		bl_icon_TRIA_UP = 7,
		bl_icon_ARROW_LEFTRIGHT = 8,
		bl_icon_PLUS = 9,
		bl_icon_DISCLOSURE_TRI_DOWN = 10,
		bl_icon_DISCLOSURE_TRI_RIGHT = 11,
		bl_icon_RADIOBUT_OFF = 12,
		bl_icon_RADIOBUT_ON = 13,
		bl_icon_MENU_PANEL = 14,
		bl_icon_BLENDER = 15,
		bl_icon_GRIP = 16,
		bl_icon_DOT = 17,
		bl_icon_COLLAPSEMENU = 18,
		bl_icon_X = 19,
		bl_icon_GO_LEFT = 21,
		bl_icon_PLUG = 22,
		bl_icon_UI = 23,
		bl_icon_NODE = 24,
		bl_icon_NODE_SEL = 25,
		bl_icon_FULLSCREEN = 26,
		bl_icon_SPLITSCREEN = 27,
		bl_icon_RIGHTARROW_THIN = 28,
		bl_icon_BORDERMOVE = 29,
		bl_icon_VIEWZOOM = 30,
		bl_icon_ZOOMIN = 31,
		bl_icon_ZOOMOUT = 32,
		bl_icon_PANEL_CLOSE = 33,
		bl_icon_COPY_ID = 34,
		bl_icon_EYEDROPPER = 35,
		bl_icon_LINK_AREA = 36,
		bl_icon_AUTO = 37,
		bl_icon_CHECKBOX_DEHLT = 38,
		bl_icon_CHECKBOX_HLT = 39,
		bl_icon_UNLOCKED = 40,
		bl_icon_LOCKED = 41,
		bl_icon_UNPINNED = 42,
		bl_icon_PINNED = 43,
		bl_icon_SCREEN_BACK = 44,
		bl_icon_RIGHTARROW = 45,
		bl_icon_DOWNARROW_HLT = 46,
		bl_icon_DOTSUP = 47,
		bl_icon_DOTSDOWN = 48,
		bl_icon_LINK = 49,
		bl_icon_INLINK = 50,
		bl_icon_PLUGIN = 51,
		bl_icon_HELP = 52,
		bl_icon_GHOST_ENABLED = 53,
		bl_icon_COLOR = 54,
		bl_icon_LINKED = 55,
		bl_icon_UNLINKED = 56,
		bl_icon_HAND = 57,
		bl_icon_ZOOM_ALL = 58,
		bl_icon_ZOOM_SELECTED = 59,
		bl_icon_ZOOM_PREVIOUS = 60,
		bl_icon_ZOOM_IN = 61,
		bl_icon_ZOOM_OUT = 62,
		bl_icon_RENDER_REGION = 63,
		bl_icon_BORDER_RECT = 64,
		bl_icon_BORDER_LASSO = 65,
		bl_icon_FREEZE = 66,
		bl_icon_STYLUS_PRESSURE = 67,
		bl_icon_GHOST_DISABLED = 68,
		bl_icon_NEW = 69,
		bl_icon_FILE_TICK = 70,
		bl_icon_QUIT = 71,
		bl_icon_URL = 72,
		bl_icon_RECOVER_LAST = 73,
		bl_icon_FULLSCREEN_ENTER = 75,
		bl_icon_FULLSCREEN_EXIT = 76,
		bl_icon_BLANK1 = 77,
		bl_icon_LAMP = 78,
		bl_icon_MATERIAL = 79,
		bl_icon_TEXTURE = 80,
		bl_icon_ANIM = 81,
		bl_icon_WORLD = 82,
		bl_icon_SCENE = 83,
		bl_icon_EDIT = 84,
		bl_icon_GAME = 85,
		bl_icon_RADIO = 86,
		bl_icon_SCRIPT = 87,
		bl_icon_PARTICLES = 88,
		bl_icon_PHYSICS = 89,
		bl_icon_SPEAKER = 90,
		bl_icon_TEXTURE_SHADED = 91,
		bl_icon_VIEW3D = 104,
		bl_icon_IPO = 105,
		bl_icon_OOPS = 106,
		bl_icon_BUTS = 107,
		bl_icon_FILESEL = 108,
		bl_icon_IMAGE_COL = 109,
		bl_icon_INFO = 110,
		bl_icon_SEQUENCE = 111,
		bl_icon_TEXT = 112,
		bl_icon_IMASEL = 113,
		bl_icon_SOUND = 114,
		bl_icon_ACTION = 115,
		bl_icon_NLA = 116,
		bl_icon_SCRIPTWIN = 117,
		bl_icon_TIME = 118,
		bl_icon_NODETREE = 119,
		bl_icon_LOGIC = 120,
		bl_icon_CONSOLE = 121,
		bl_icon_PREFERENCES = 122,
		bl_icon_CLIP = 123,
		bl_icon_ASSET_MANAGER = 124,
		bl_icon_OBJECT_DATAMODE = 130,
		bl_icon_EDITMODE_HLT = 131,
		bl_icon_FACESEL_HLT = 132,
		bl_icon_VPAINT_HLT = 133,
		bl_icon_TPAINT_HLT = 134,
		bl_icon_WPAINT_HLT = 135,
		bl_icon_SCULPTMODE_HLT = 136,
		bl_icon_POSE_HLT = 137,
		bl_icon_PARTICLEMODE = 138,
		bl_icon_LIGHTPAINT = 139,
		bl_icon_SCENE_DATA = 156,
		bl_icon_RENDERLAYERS = 157,
		bl_icon_WORLD_DATA = 158,
		bl_icon_OBJECT_DATA = 159,
		bl_icon_MESH_DATA = 160,
		bl_icon_CURVE_DATA = 161,
		bl_icon_META_DATA = 162,
		bl_icon_LATTICE_DATA = 163,
		bl_icon_LAMP_DATA = 164,
		bl_icon_MATERIAL_DATA = 165,
		bl_icon_TEXTURE_DATA = 166,
		bl_icon_ANIM_DATA = 167,
		bl_icon_CAMERA_DATA = 168,
		bl_icon_PARTICLE_DATA = 169,
		bl_icon_LIBRARY_DATA_DIRECT = 170,
		bl_icon_GROUP = 171,
		bl_icon_ARMATURE_DATA = 172,
		bl_icon_POSE_DATA = 173,
		bl_icon_BONE_DATA = 174,
		bl_icon_CONSTRAINT = 175,
		bl_icon_SHAPEKEY_DATA = 176,
		bl_icon_CONSTRAINT_BONE = 177,
		bl_icon_CAMERA_STEREO = 178,
		bl_icon_PACKAGE = 179,
		bl_icon_UGLYPACKAGE = 180,
		bl_icon_BRUSH_DATA = 182,
		bl_icon_IMAGE_DATA = 183,
		bl_icon_FILE = 184,
		bl_icon_FCURVE = 185,
		bl_icon_FONT_DATA = 186,
		bl_icon_RENDER_RESULT = 187,
		bl_icon_SURFACE_DATA = 188,
		bl_icon_EMPTY_DATA = 189,
		bl_icon_SETTINGS = 190,
		bl_icon_RENDER_ANIMATION = 191,
		bl_icon_RENDER_STILL = 192,
		bl_icon_BOIDS = 194,
		bl_icon_STRANDS = 195,
		bl_icon_LIBRARY_DATA_INDIRECT = 196,
		bl_icon_GREASEPENCIL = 197,
		bl_icon_LINE_DATA = 198,
		bl_icon_GROUP_BONE = 200,
		bl_icon_GROUP_VERTEX = 201,
		bl_icon_GROUP_VCOL = 202,
		bl_icon_GROUP_UVS = 203,
		bl_icon_RNA = 206,
		bl_icon_RNA_ADD = 207,
		bl_icon_OUTLINER_OB_EMPTY = 234,
		bl_icon_OUTLINER_OB_MESH = 235,
		bl_icon_OUTLINER_OB_CURVE = 236,
		bl_icon_OUTLINER_OB_LATTICE = 237,
		bl_icon_OUTLINER_OB_META = 238,
		bl_icon_OUTLINER_OB_LAMP = 239,
		bl_icon_OUTLINER_OB_CAMERA = 240,
		bl_icon_OUTLINER_OB_ARMATURE = 241,
		bl_icon_OUTLINER_OB_FONT = 242,
		bl_icon_OUTLINER_OB_SURFACE = 243,
		bl_icon_OUTLINER_OB_SPEAKER = 244,
		bl_icon_RESTRICT_VIEW_OFF = 253,
		bl_icon_RESTRICT_VIEW_ON = 254,
		bl_icon_RESTRICT_SELECT_OFF = 255,
		bl_icon_RESTRICT_SELECT_ON = 256,
		bl_icon_RESTRICT_RENDER_OFF = 257,
		bl_icon_RESTRICT_RENDER_ON = 258,
		bl_icon_OUTLINER_DATA_EMPTY = 260,
		bl_icon_OUTLINER_DATA_MESH = 261,
		bl_icon_OUTLINER_DATA_CURVE = 262,
		bl_icon_OUTLINER_DATA_LATTICE = 263,
		bl_icon_OUTLINER_DATA_META = 264,
		bl_icon_OUTLINER_DATA_LAMP = 265,
		bl_icon_OUTLINER_DATA_CAMERA = 266,
		bl_icon_OUTLINER_DATA_ARMATURE = 267,
		bl_icon_OUTLINER_DATA_FONT = 268,
		bl_icon_OUTLINER_DATA_SURFACE = 269,
		bl_icon_OUTLINER_DATA_SPEAKER = 270,
		bl_icon_OUTLINER_DATA_POSE = 271,
		bl_icon_MESH_PLANE = 286,
		bl_icon_MESH_CUBE = 287,
		bl_icon_MESH_CIRCLE = 288,
		bl_icon_MESH_UVSPHERE = 289,
		bl_icon_MESH_ICOSPHERE = 290,
		bl_icon_MESH_GRID = 291,
		bl_icon_MESH_MONKEY = 292,
		bl_icon_MESH_CYLINDER = 293,
		bl_icon_MESH_TORUS = 294,
		bl_icon_MESH_CONE = 295,
		bl_icon_LAMP_POINT = 298,
		bl_icon_LAMP_SUN = 299,
		bl_icon_LAMP_SPOT = 300,
		bl_icon_LAMP_HEMI = 301,
		bl_icon_LAMP_AREA = 302,
		bl_icon_META_EMPTY = 305,
		bl_icon_META_PLANE = 306,
		bl_icon_META_CUBE = 307,
		bl_icon_META_BALL = 308,
		bl_icon_META_ELLIPSOID = 309,
		bl_icon_META_CAPSULE = 310,
		bl_icon_SURFACE_NCURVE = 312,
		bl_icon_SURFACE_NCIRCLE = 313,
		bl_icon_SURFACE_NSURFACE = 314,
		bl_icon_SURFACE_NCYLINDER = 315,
		bl_icon_SURFACE_NSPHERE = 316,
		bl_icon_SURFACE_NTORUS = 317,
		bl_icon_CURVE_BEZCURVE = 321,
		bl_icon_CURVE_BEZCIRCLE = 322,
		bl_icon_CURVE_NCURVE = 323,
		bl_icon_CURVE_NCIRCLE = 324,
		bl_icon_CURVE_PATH = 325,
		bl_icon_COLOR_RED = 331,
		bl_icon_COLOR_GREEN = 332,
		bl_icon_COLOR_BLUE = 333,
		bl_icon_TRIA_RIGHT_BAR = 334,
		bl_icon_TRIA_DOWN_BAR = 335,
		bl_icon_TRIA_LEFT_BAR = 336,
		bl_icon_TRIA_UP_BAR = 337,
		bl_icon_FORCE_FORCE = 338,
		bl_icon_FORCE_WIND = 339,
		bl_icon_FORCE_VORTEX = 340,
		bl_icon_FORCE_MAGNETIC = 341,
		bl_icon_FORCE_HARMONIC = 342,
		bl_icon_FORCE_CHARGE = 343,
		bl_icon_FORCE_LENNARDJONES = 344,
		bl_icon_FORCE_TEXTURE = 345,
		bl_icon_FORCE_CURVE = 346,
		bl_icon_FORCE_BOID = 347,
		bl_icon_FORCE_TURBULENCE = 348,
		bl_icon_FORCE_DRAG = 349,
		bl_icon_FORCE_SMOKEFLOW = 350,
		bl_icon_MODIFIER = 442,
		bl_icon_MOD_WAVE = 443,
		bl_icon_MOD_BUILD = 444,
		bl_icon_MOD_DECIM = 445,
		bl_icon_MOD_MIRROR = 446,
		bl_icon_MOD_SOFT = 447,
		bl_icon_MOD_SUBSURF = 448,
		bl_icon_HOOK = 449,
		bl_icon_MOD_PHYSICS = 450,
		bl_icon_MOD_PARTICLES = 451,
		bl_icon_MOD_BOOLEAN = 452,
		bl_icon_MOD_EDGESPLIT = 453,
		bl_icon_MOD_ARRAY = 454,
		bl_icon_MOD_UVPROJECT = 455,
		bl_icon_MOD_DISPLACE = 456,
		bl_icon_MOD_CURVE = 457,
		bl_icon_MOD_LATTICE = 458,
		bl_icon_CONSTRAINT_DATA = 459,
		bl_icon_MOD_ARMATURE = 460,
		bl_icon_MOD_SHRINKWRAP = 461,
		bl_icon_MOD_CAST = 462,
		bl_icon_MOD_MESHDEFORM = 463,
		bl_icon_MOD_BEVEL = 464,
		bl_icon_MOD_SMOOTH = 465,
		bl_icon_MOD_SIMPLEDEFORM = 466,
		bl_icon_MOD_MASK = 467,
		bl_icon_MOD_CLOTH = 468,
		bl_icon_MOD_EXPLODE = 469,
		bl_icon_MOD_FLUIDSIM = 470,
		bl_icon_MOD_MULTIRES = 471,
		bl_icon_MOD_SMOKE = 472,
		bl_icon_MOD_SOLIDIFY = 473,
		bl_icon_MOD_SCREW = 474,
		bl_icon_MOD_VERTEX_WEIGHT = 475,
		bl_icon_MOD_DYNAMICPAINT = 476,
		bl_icon_MOD_REMESH = 477,
		bl_icon_MOD_OCEAN = 478,
		bl_icon_MOD_WARP = 479,
		bl_icon_MOD_SKIN = 480,
		bl_icon_MOD_TRIANGULATE = 481,
		bl_icon_MOD_WIREFRAME = 482,
		bl_icon_MOD_DATA_TRANSFER = 483,
		bl_icon_MOD_NORMALEDIT = 484,
		bl_icon_REC = 494,
		bl_icon_PLAY = 495,
		bl_icon_FF = 496,
		bl_icon_REW = 497,
		bl_icon_PAUSE = 498,
		bl_icon_PREV_KEYFRAME = 499,
		bl_icon_NEXT_KEYFRAME = 500,
		bl_icon_PLAY_AUDIO = 501,
		bl_icon_PLAY_REVERSE = 502,
		bl_icon_PREVIEW_RANGE = 503,
		bl_icon_ACTION_TWEAK = 504,
		bl_icon_PMARKER_ACT = 505,
		bl_icon_PMARKER_SEL = 506,
		bl_icon_PMARKER = 507,
		bl_icon_MARKER_HLT = 508,
		bl_icon_MARKER = 509,
		bl_icon_SPACE2 = 510,
		bl_icon_SPACE3 = 511,
		bl_icon_KEYINGSET = 512,
		bl_icon_KEY_DEHLT = 513,
		bl_icon_KEY_HLT = 514,
		bl_icon_MUTE_IPO_OFF = 515,
		bl_icon_MUTE_IPO_ON = 516,
		bl_icon_VISIBLE_IPO_OFF = 517,
		bl_icon_VISIBLE_IPO_ON = 518,
		bl_icon_DRIVER = 519,
		bl_icon_SOLO_OFF = 520,
		bl_icon_SOLO_ON = 521,
		bl_icon_FRAME_PREV = 522,
		bl_icon_FRAME_NEXT = 523,
		bl_icon_NLA_PUSHDOWN = 524,
		bl_icon_IPO_CONSTANT = 525,
		bl_icon_IPO_LINEAR = 526,
		bl_icon_IPO_BEZIER = 527,
		bl_icon_IPO_SINE = 528,
		bl_icon_IPO_QUAD = 529,
		bl_icon_IPO_CUBIC = 530,
		bl_icon_IPO_QUART = 531,
		bl_icon_IPO_QUINT = 532,
		bl_icon_IPO_EXPO = 533,
		bl_icon_IPO_CIRC = 534,
		bl_icon_IPO_BOUNCE = 535,
		bl_icon_IPO_ELASTIC = 536,
		bl_icon_IPO_BACK = 537,
		bl_icon_IPO_EASE_IN = 538,
		bl_icon_IPO_EASE_OUT = 539,
		bl_icon_IPO_EASE_IN_OUT = 540,
		bl_icon_VERTEXSEL = 546,
		bl_icon_EDGESEL = 547,
		bl_icon_FACESEL = 548,
		bl_icon_LOOPSEL = 549,
		bl_icon_ROTATE = 551,
		bl_icon_CURSOR = 552,
		bl_icon_ROTATECOLLECTION = 553,
		bl_icon_ROTATECENTER = 554,
		bl_icon_ROTACTIVE = 555,
		bl_icon_ALIGN = 556,
		bl_icon_SMOOTHCURVE = 558,
		bl_icon_SPHERECURVE = 559,
		bl_icon_ROOTCURVE = 560,
		bl_icon_SHARPCURVE = 561,
		bl_icon_LINCURVE = 562,
		bl_icon_NOCURVE = 563,
		bl_icon_RNDCURVE = 564,
		bl_icon_PROP_OFF = 565,
		bl_icon_PROP_ON = 566,
		bl_icon_PROP_CON = 567,
		bl_icon_SCULPT_DYNTOPO = 568,
		bl_icon_PARTICLE_POINT = 569,
		bl_icon_PARTICLE_TIP = 570,
		bl_icon_PARTICLE_PATH = 571,
		bl_icon_MAN_TRANS = 572,
		bl_icon_MAN_ROT = 573,
		bl_icon_MAN_SCALE = 574,
		bl_icon_MANIPUL = 575,
		bl_icon_SNAP_OFF = 576,
		bl_icon_SNAP_ON = 577,
		bl_icon_SNAP_NORMAL = 578,
		bl_icon_SNAP_INCREMENT = 579,
		bl_icon_SNAP_VERTEX = 580,
		bl_icon_SNAP_EDGE = 581,
		bl_icon_SNAP_FACE = 582,
		bl_icon_SNAP_VOLUME = 583,
		bl_icon_STICKY_UVS_LOC = 585,
		bl_icon_STICKY_UVS_DISABLE = 586,
		bl_icon_STICKY_UVS_VERT = 587,
		bl_icon_CLIPUV_DEHLT = 588,
		bl_icon_CLIPUV_HLT = 589,
		bl_icon_SNAP_PEEL_OBJECT = 590,
		bl_icon_GRID = 591,
		bl_icon_PASTEDOWN = 598,
		bl_icon_COPYDOWN = 599,
		bl_icon_PASTEFLIPUP = 600,
		bl_icon_PASTEFLIPDOWN = 601,
		bl_icon_SNAP_SURFACE = 606,
		bl_icon_AUTOMERGE_ON = 607,
		bl_icon_AUTOMERGE_OFF = 608,
		bl_icon_RETOPO = 609,
		bl_icon_UV_VERTEXSEL = 610,
		bl_icon_UV_EDGESEL = 611,
		bl_icon_UV_FACESEL = 612,
		bl_icon_UV_ISLANDSEL = 613,
		bl_icon_UV_SYNC_SELECT = 614,
		bl_icon_BBOX = 624,
		bl_icon_WIRE = 625,
		bl_icon_SOLID = 626,
		bl_icon_SMOOTH = 627,
		bl_icon_POTATO = 628,
		bl_icon_ORTHO = 630,
		bl_icon_LOCKVIEW_OFF = 633,
		bl_icon_LOCKVIEW_ON = 634,
		bl_icon_AXIS_SIDE = 636,
		bl_icon_AXIS_FRONT = 637,
		bl_icon_AXIS_TOP = 638,
		bl_icon_NDOF_DOM = 639,
		bl_icon_NDOF_TURN = 640,
		bl_icon_NDOF_FLY = 641,
		bl_icon_NDOF_TRANS = 642,
		bl_icon_LAYER_USED = 643,
		bl_icon_LAYER_ACTIVE = 644,
		bl_icon_SORTALPHA = 676,
		bl_icon_SORTBYEXT = 677,
		bl_icon_SORTTIME = 678,
		bl_icon_SORTSIZE = 679,
		bl_icon_LONGDISPLAY = 680,
		bl_icon_SHORTDISPLAY = 681,
		bl_icon_GHOST = 682,
		bl_icon_IMGDISPLAY = 683,
		bl_icon_SAVE_AS = 684,
		bl_icon_SAVE_COPY = 685,
		bl_icon_BOOKMARKS = 686,
		bl_icon_FONTPREVIEW = 687,
		bl_icon_FILTER = 688,
		bl_icon_NEWFOLDER = 689,
		bl_icon_OPEN_RECENT = 690,
		bl_icon_FILE_PARENT = 691,
		bl_icon_FILE_REFRESH = 692,
		bl_icon_FILE_FOLDER = 693,
		bl_icon_FILE_BLANK = 694,
		bl_icon_FILE_BLEND = 695,
		bl_icon_FILE_IMAGE = 696,
		bl_icon_FILE_MOVIE = 697,
		bl_icon_FILE_SCRIPT = 698,
		bl_icon_FILE_SOUND = 699,
		bl_icon_FILE_FONT = 700,
		bl_icon_FILE_TEXT = 701,
		bl_icon_RECOVER_AUTO = 702,
		bl_icon_SAVE_PREFS = 703,
		bl_icon_LINK_BLEND = 704,
		bl_icon_APPEND_BLEND = 705,
		bl_icon_IMPORT = 706,
		bl_icon_EXPORT = 707,
		bl_icon_EXTERNAL_DATA = 708,
		bl_icon_LOAD_FACTORY = 709,
		bl_icon_LOOP_BACK = 715,
		bl_icon_LOOP_FORWARDS = 716,
		bl_icon_BACK = 717,
		bl_icon_FORWARD = 718,
		bl_icon_FILE_HIDDEN = 725,
		bl_icon_FILE_BACKUP = 726,
		bl_icon_DISK_DRIVE = 727,
		bl_icon_MATPLANE = 728,
		bl_icon_MATSPHERE = 729,
		bl_icon_MATCUBE = 730,
		bl_icon_MONKEY = 731,
		bl_icon_HAIR = 732,
		bl_icon_ALIASED = 733,
		bl_icon_ANTIALIASED = 734,
		bl_icon_MAT_SPHERE_SKY = 735,
		bl_icon_WORDWRAP_OFF = 740,
		bl_icon_WORDWRAP_ON = 741,
		bl_icon_SYNTAX_OFF = 742,
		bl_icon_SYNTAX_ON = 743,
		bl_icon_LINENUMBERS_OFF = 744,
		bl_icon_LINENUMBERS_ON = 745,
		bl_icon_SCRIPTPLUGINS = 746,
		bl_icon_SEQ_SEQUENCER = 754,
		bl_icon_SEQ_PREVIEW = 755,
		bl_icon_SEQ_LUMA_WAVEFORM = 756,
		bl_icon_SEQ_CHROMA_SCOPE = 757,
		bl_icon_SEQ_HISTOGRAM = 758,
		bl_icon_SEQ_SPLITVIEW = 759,
		bl_icon_IMAGE_RGB = 763,
		bl_icon_IMAGE_RGB_ALPHA = 764,
		bl_icon_IMAGE_ALPHA = 765,
		bl_icon_IMAGE_ZDEPTH = 766,
		bl_icon_IMAGEFILE = 767,
		bl_icon_BRUSH_ADD = 780,
		bl_icon_BRUSH_BLOB = 781,
		bl_icon_BRUSH_BLUR = 782,
		bl_icon_BRUSH_CLAY = 783,
		bl_icon_BRUSH_CLAY_STRIPS = 784,
		bl_icon_BRUSH_CLONE = 785,
		bl_icon_BRUSH_CREASE = 786,
		bl_icon_BRUSH_DARKEN = 787,
		bl_icon_BRUSH_FILL = 788,
		bl_icon_BRUSH_FLATTEN = 789,
		bl_icon_BRUSH_GRAB = 790,
		bl_icon_BRUSH_INFLATE = 791,
		bl_icon_BRUSH_LAYER = 792,
		bl_icon_BRUSH_LIGHTEN = 793,
		bl_icon_BRUSH_MASK = 794,
		bl_icon_BRUSH_MIX = 795,
		bl_icon_BRUSH_MULTIPLY = 796,
		bl_icon_BRUSH_NUDGE = 797,
		bl_icon_BRUSH_PINCH = 798,
		bl_icon_BRUSH_SCRAPE = 799,
		bl_icon_BRUSH_SCULPT_DRAW = 800,
		bl_icon_BRUSH_SMEAR = 801,
		bl_icon_BRUSH_SMOOTH = 802,
		bl_icon_BRUSH_SNAKE_HOOK = 803,
		bl_icon_BRUSH_SOFTEN = 804,
		bl_icon_BRUSH_SUBTRACT = 805,
		bl_icon_BRUSH_TEXDRAW = 806,
		bl_icon_BRUSH_TEXFILL = 807,
		bl_icon_BRUSH_TEXMASK = 808,
		bl_icon_BRUSH_THUMB = 809,
		bl_icon_BRUSH_ROTATE = 810,
		bl_icon_BRUSH_VERTEXDRAW = 811,
		bl_icon_MATCAP_01 = 812,
		bl_icon_MATCAP_02 = 813,
		bl_icon_MATCAP_03 = 814,
		bl_icon_MATCAP_04 = 815,
		bl_icon_MATCAP_05 = 816,
		bl_icon_MATCAP_06 = 817,
		bl_icon_MATCAP_07 = 818,
		bl_icon_MATCAP_08 = 819,
		bl_icon_MATCAP_09 = 820,
		bl_icon_MATCAP_10 = 821,
		bl_icon_MATCAP_11 = 822,
		bl_icon_MATCAP_12 = 823,
		bl_icon_MATCAP_13 = 824,
		bl_icon_MATCAP_14 = 825,
		bl_icon_MATCAP_15 = 826,
		bl_icon_MATCAP_16 = 827,
		bl_icon_MATCAP_17 = 828,
		bl_icon_MATCAP_18 = 829,
		bl_icon_MATCAP_19 = 830,
		bl_icon_MATCAP_20 = 831,
		bl_icon_MATCAP_21 = 832,
		bl_icon_MATCAP_22 = 833,
		bl_icon_MATCAP_23 = 834,
		bl_icon_MATCAP_24 = 835,
	};

	/** Getter: The node icon */
	bl_icon_enum bl_icon() { /* not implemented */ throw NULL; }
	/** Setter: The node icon */
	void bl_icon(bl_icon_enum value) { /* not implemented */ }

	enum bl_static_type_enum {
		bl_static_type_CUSTOM = -1,
	};

	/** Getter: Node type (deprecated, use with care) */
	bl_static_type_enum bl_static_type() { /* not implemented */ throw NULL; }
	/** Setter: Node type (deprecated, use with care) */
	void bl_static_type(bl_static_type_enum value) { /* not implemented */ }

	/** Getter:  */
	float bl_width_default() { /* not implemented */ throw NULL; }
	/** Setter:  */
	void bl_width_default(float value) {
		PyObject_SetAttrString(pyobjref, "bl_width_default", Py_BuildValue("f", value));
	}

	/** Getter:  */
	float bl_width_min() { /* not implemented */ throw NULL; }
	/** Setter:  */
	void bl_width_min(float value) {
		PyObject_SetAttrString(pyobjref, "bl_width_min", Py_BuildValue("f", value));
	}

	/** Getter:  */
	float bl_width_max() { /* not implemented */ throw NULL; }
	/** Setter:  */
	void bl_width_max(float value) {
		PyObject_SetAttrString(pyobjref, "bl_width_max", Py_BuildValue("f", value));
	}

	/** Getter:  */
	float bl_height_default() { /* not implemented */ throw NULL; }
	/** Setter:  */
	void bl_height_default(float value) {
		PyObject_SetAttrString(pyobjref, "bl_height_default", Py_BuildValue("f", value));
	}

	/** Getter:  */
	float bl_height_min() { /* not implemented */ throw NULL; }
	/** Setter:  */
	void bl_height_min(float value) {
		PyObject_SetAttrString(pyobjref, "bl_height_min", Py_BuildValue("f", value));
	}

	/** Getter:  */
	float bl_height_max() { /* not implemented */ throw NULL; }
	/** Setter:  */
	void bl_height_max(float value) {
		PyObject_SetAttrString(pyobjref, "bl_height_max", Py_BuildValue("f", value));
	}

	/**
	 * Update after property changes
	 * @param Param 'context'
	 */
	void socket_value_update(Context context)
	{
		// not implemented
	}

	/**
	 * True if a registered node type
	 * @return 
	 */
	bool is_registered_node_type()
	{
		// not implemented
		return true;
	}

};

/**************** Valid ****************/

/**
 * Link is valid
 */
class NodeLink : public pyUniplug {
public:
	NodeLink(PyObject* pyobj) : pyUniplug(pyobj) {}

	NodeLink() : pyUniplug(0)
	{
		// not implemented
	}

	/** Getter:  */
	bool is_valid() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "is_valid")) == 1;
	}

	/** Setter:  */
	void is_valid(bool value) {
		PyObject_SetAttrString(pyobjref, "is_valid", Py_BuildValue("i", value));
	}

	/** Getter:  */
	Node from_node() {
		/* not implemented */ throw NULL;
	}

	/** Getter:  */
	Node to_node() {
		/* not implemented */ throw NULL;
	}

	/** Getter:  */
	NodeSocket from_socket() {
		/* not implemented */ throw NULL;
	}

	/** Getter:  */
	NodeSocket to_socket() {
		/* not implemented */ throw NULL;
	}

	/** Getter: Link is hidden due to invisible sockets */
	bool is_hidden() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "is_hidden")) == 1;
	}

	/** Setter: Link is hidden due to invisible sockets */
	void is_hidden(bool value) {
		PyObject_SetAttrString(pyobjref, "is_hidden", Py_BuildValue("i", value));
	}

};

/**************** Socket Template ****************/

/**
 * Type and default value of a node socket
 */
class NodeInternalSocketTemplate : public pyUniplug {
public:
	NodeInternalSocketTemplate(PyObject* pyobj) : pyUniplug(pyobj) {}

	NodeInternalSocketTemplate() : pyUniplug(0)
	{
		// not implemented
	}

	/** Getter: Name of the socket */
	std::string name() { /* not implemented */ throw NULL; }
	/** Setter: Name of the socket */
	void name(const std::string& value) { /* not implemented */ }

	/** Getter: Identifier of the socket */
	std::string identifier() { /* not implemented */ throw NULL; }
	/** Setter: Identifier of the socket */
	void identifier(const std::string& value) { /* not implemented */ }

	enum type_enum {
		type_CUSTOM = -1,
		type_VALUE = 0,
		type_INT = 6,
		type_BOOLEAN = 4,
		type_VECTOR = 1,
		type_STRING = 7,
		type_RGBA = 2,
		type_SHADER = 3,
	};

	/** Getter: Data type of the socket */
	type_enum type() { /* not implemented */ throw NULL; }
	/** Setter: Data type of the socket */
	void type(type_enum value) { /* not implemented */ }

};

/**************** NodeInternal ****************/

/**
 * 
 */
class NodeInternal : public Node {
public:
	NodeInternal(PyObject* pyobj) : Node(pyobj) {}

	NodeInternal() : Node(0)
	{
		// not implemented
	}

	/**
	 * If non-null output is returned, the node type can be added to the tree
	 * @return 
	 * @param Param 'node_tree'
	 */
	bool poll(NodeTree node_tree);

	/**
	 * If non-null output is returned, the node can be added to the tree
	 * @return 
	 * @param Param 'node_tree'
	 */
	bool poll_instance(NodeTree node_tree);

	/**
	 * Update on editor changes
	 */
	void update()
	{
		// not implemented
	}

	/**
	 * Draw node buttons
	 * @param Param 'context'
	 * @param Layout in the UI
	 */
	void draw_buttons(Context context, UILayout layout);

	/**
	 * Draw node buttons in the sidebar
	 * @param Param 'context'
	 * @param Layout in the UI
	 */
	void draw_buttons_ext(Context context, UILayout layout);

};

/**************** Shader Node ****************/

/**
 * Material shader node
 */
class ShaderNode : public NodeInternal {
public:
	ShaderNode(PyObject* pyobj) : NodeInternal(pyobj) {}

	ShaderNode() : NodeInternal(0)
	{
		// not implemented
	}

};

/**************** Compositor Node ****************/

/**
 * 
 */
class CompositorNode : public NodeInternal {
public:
	CompositorNode(PyObject* pyobj) : NodeInternal(pyobj) {}

	CompositorNode() : NodeInternal(0)
	{
		// not implemented
	}

	/**
	 * Tag the node for compositor update
	 */
	void tag_need_exec()
	{
		// not implemented
	}

};

/**************** Texture Node ****************/

/**
 * 
 */
class TextureNode : public NodeInternal {
public:
	TextureNode(PyObject* pyobj) : NodeInternal(pyobj) {}

	TextureNode() : NodeInternal(0)
	{
		// not implemented
	}

};

/**************** Node Tree ****************/

/**
 * Node tree consisting of linked nodes used for shading, textures and compositing
 */
class NodeTree : public ID {
public:
	NodeTree(PyObject* pyobj) : ID(pyobj) {}

	NodeTree() : ID(0)
	{
		// not implemented
	}

	/** Getter:  */
	std::array<float, 2> view_center() {
		// TODO: MISSING DEREF! USE #DEFINE!
		PyObject *seqval = PyObject_GetAttrString(pyobjref, "view_center");
		std::array<float, 2> resarr;
		for (int i = 0; i < 2; i++)
			resarr[i] = (float)PyFloat_AsDouble(PySequence_GetItem(seqval, i));
		return resarr;
	}

	/** Setter:  */
	void view_center(float values[2]) { /* not implemented */ }

	/** Getter: Animation data for this datablock */
	AnimData animation_data() {
		/* not implemented */ throw NULL;
	}

	/** Getter:  */
	std::map<std::string, Node> nodes() {
		// TODO: MISSING DEREF! USE #DEFINE!
		PyObject *seqval = PyObject_GetAttrString(pyobjref, "nodes");
		PyObject *seqkeys = PyObject_CallMethod(seqval, "keys", NULL);
		std::map<std::string, Node> resmap;
		for (int i = 0; i < PySequence_Length(seqval); i++) {
			PyObject *keyobj = PySequence_GetItem(seqkeys, i);
			std::string key = PyBytes_AsString(PyUnicode_AsASCIIString(keyobj));
			Node value = Node(PySequence_GetItem(seqval, i));
			resmap.insert(std::pair<std::string,Node>(key, value));
		}
		return resmap;
	}

	/** Setter:  */
	void nodes(std::map<std::string, Node> value) { /* not implemented */ }

	/** Getter:  */
	std::map<std::string, NodeLink> links() {
		// TODO: MISSING DEREF! USE #DEFINE!
		PyObject *seqval = PyObject_GetAttrString(pyobjref, "links");
		PyObject *seqkeys = PyObject_CallMethod(seqval, "keys", NULL);
		std::map<std::string, NodeLink> resmap;
		for (int i = 0; i < PySequence_Length(seqval); i++) {
			PyObject *keyobj = PySequence_GetItem(seqkeys, i);
			std::string key = PyBytes_AsString(PyUnicode_AsASCIIString(keyobj));
			NodeLink value = NodeLink(PySequence_GetItem(seqval, i));
			resmap.insert(std::pair<std::string,NodeLink>(key, value));
		}
		return resmap;
	}

	/** Setter:  */
	void links(std::map<std::string, NodeLink> value) { /* not implemented */ }

	/** Getter: Grease Pencil datablock */
	GreasePencil grease_pencil() {
		/* not implemented */ throw NULL;
	}

	enum type_enum {
		type_SHADER = 0,
		type_TEXTURE = 2,
		type_COMPOSITING = 1,
	};

	/** Getter: Node Tree type (deprecated, bl_idname is the actual node tree type identifier) */
	type_enum type() { /* not implemented */ throw NULL; }
	/** Setter: Node Tree type (deprecated, bl_idname is the actual node tree type identifier) */
	void type(type_enum value) { /* not implemented */ }

	/** Getter: Node tree inputs */
	std::map<std::string, NodeSocketInterface> inputs() {
		// TODO: MISSING DEREF! USE #DEFINE!
		PyObject *seqval = PyObject_GetAttrString(pyobjref, "inputs");
		PyObject *seqkeys = PyObject_CallMethod(seqval, "keys", NULL);
		std::map<std::string, NodeSocketInterface> resmap;
		for (int i = 0; i < PySequence_Length(seqval); i++) {
			PyObject *keyobj = PySequence_GetItem(seqkeys, i);
			std::string key = PyBytes_AsString(PyUnicode_AsASCIIString(keyobj));
			NodeSocketInterface value = NodeSocketInterface(PySequence_GetItem(seqval, i));
			resmap.insert(std::pair<std::string,NodeSocketInterface>(key, value));
		}
		return resmap;
	}

	/** Setter: Node tree inputs */
	void inputs(std::map<std::string, NodeSocketInterface> value) { /* not implemented */ }

	/** Getter: Index of the active input */
	int active_input() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "active_input"));
	}

	/** Setter: Index of the active input */
	void active_input(int value) {
		PyObject_SetAttrString(pyobjref, "active_input", Py_BuildValue("i", value));
	}

	/** Getter: Node tree outputs */
	std::map<std::string, NodeSocketInterface> outputs() {
		// TODO: MISSING DEREF! USE #DEFINE!
		PyObject *seqval = PyObject_GetAttrString(pyobjref, "outputs");
		PyObject *seqkeys = PyObject_CallMethod(seqval, "keys", NULL);
		std::map<std::string, NodeSocketInterface> resmap;
		for (int i = 0; i < PySequence_Length(seqval); i++) {
			PyObject *keyobj = PySequence_GetItem(seqkeys, i);
			std::string key = PyBytes_AsString(PyUnicode_AsASCIIString(keyobj));
			NodeSocketInterface value = NodeSocketInterface(PySequence_GetItem(seqval, i));
			resmap.insert(std::pair<std::string,NodeSocketInterface>(key, value));
		}
		return resmap;
	}

	/** Setter: Node tree outputs */
	void outputs(std::map<std::string, NodeSocketInterface> value) { /* not implemented */ }

	/** Getter: Index of the active output */
	int active_output() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "active_output"));
	}

	/** Setter: Index of the active output */
	void active_output(int value) {
		PyObject_SetAttrString(pyobjref, "active_output", Py_BuildValue("i", value));
	}

	/** Getter:  */
	std::string bl_idname() { /* not implemented */ throw NULL; }
	/** Setter:  */
	void bl_idname(const std::string& value) { /* not implemented */ }

	/** Getter: The node tree label */
	std::string bl_label() { /* not implemented */ throw NULL; }
	/** Setter: The node tree label */
	void bl_label(const std::string& value) { /* not implemented */ }

	/** Getter:  */
	std::string bl_description() { /* not implemented */ throw NULL; }
	/** Setter:  */
	void bl_description(const std::string& value) { /* not implemented */ }

	enum bl_icon_enum {
		bl_icon_NONE = 0,
		bl_icon_QUESTION = 1,
		bl_icon_ERROR = 2,
		bl_icon_CANCEL = 3,
		bl_icon_TRIA_RIGHT = 4,
		bl_icon_TRIA_DOWN = 5,
		bl_icon_TRIA_LEFT = 6,
		bl_icon_TRIA_UP = 7,
		bl_icon_ARROW_LEFTRIGHT = 8,
		bl_icon_PLUS = 9,
		bl_icon_DISCLOSURE_TRI_DOWN = 10,
		bl_icon_DISCLOSURE_TRI_RIGHT = 11,
		bl_icon_RADIOBUT_OFF = 12,
		bl_icon_RADIOBUT_ON = 13,
		bl_icon_MENU_PANEL = 14,
		bl_icon_BLENDER = 15,
		bl_icon_GRIP = 16,
		bl_icon_DOT = 17,
		bl_icon_COLLAPSEMENU = 18,
		bl_icon_X = 19,
		bl_icon_GO_LEFT = 21,
		bl_icon_PLUG = 22,
		bl_icon_UI = 23,
		bl_icon_NODE = 24,
		bl_icon_NODE_SEL = 25,
		bl_icon_FULLSCREEN = 26,
		bl_icon_SPLITSCREEN = 27,
		bl_icon_RIGHTARROW_THIN = 28,
		bl_icon_BORDERMOVE = 29,
		bl_icon_VIEWZOOM = 30,
		bl_icon_ZOOMIN = 31,
		bl_icon_ZOOMOUT = 32,
		bl_icon_PANEL_CLOSE = 33,
		bl_icon_COPY_ID = 34,
		bl_icon_EYEDROPPER = 35,
		bl_icon_LINK_AREA = 36,
		bl_icon_AUTO = 37,
		bl_icon_CHECKBOX_DEHLT = 38,
		bl_icon_CHECKBOX_HLT = 39,
		bl_icon_UNLOCKED = 40,
		bl_icon_LOCKED = 41,
		bl_icon_UNPINNED = 42,
		bl_icon_PINNED = 43,
		bl_icon_SCREEN_BACK = 44,
		bl_icon_RIGHTARROW = 45,
		bl_icon_DOWNARROW_HLT = 46,
		bl_icon_DOTSUP = 47,
		bl_icon_DOTSDOWN = 48,
		bl_icon_LINK = 49,
		bl_icon_INLINK = 50,
		bl_icon_PLUGIN = 51,
		bl_icon_HELP = 52,
		bl_icon_GHOST_ENABLED = 53,
		bl_icon_COLOR = 54,
		bl_icon_LINKED = 55,
		bl_icon_UNLINKED = 56,
		bl_icon_HAND = 57,
		bl_icon_ZOOM_ALL = 58,
		bl_icon_ZOOM_SELECTED = 59,
		bl_icon_ZOOM_PREVIOUS = 60,
		bl_icon_ZOOM_IN = 61,
		bl_icon_ZOOM_OUT = 62,
		bl_icon_RENDER_REGION = 63,
		bl_icon_BORDER_RECT = 64,
		bl_icon_BORDER_LASSO = 65,
		bl_icon_FREEZE = 66,
		bl_icon_STYLUS_PRESSURE = 67,
		bl_icon_GHOST_DISABLED = 68,
		bl_icon_NEW = 69,
		bl_icon_FILE_TICK = 70,
		bl_icon_QUIT = 71,
		bl_icon_URL = 72,
		bl_icon_RECOVER_LAST = 73,
		bl_icon_FULLSCREEN_ENTER = 75,
		bl_icon_FULLSCREEN_EXIT = 76,
		bl_icon_BLANK1 = 77,
		bl_icon_LAMP = 78,
		bl_icon_MATERIAL = 79,
		bl_icon_TEXTURE = 80,
		bl_icon_ANIM = 81,
		bl_icon_WORLD = 82,
		bl_icon_SCENE = 83,
		bl_icon_EDIT = 84,
		bl_icon_GAME = 85,
		bl_icon_RADIO = 86,
		bl_icon_SCRIPT = 87,
		bl_icon_PARTICLES = 88,
		bl_icon_PHYSICS = 89,
		bl_icon_SPEAKER = 90,
		bl_icon_TEXTURE_SHADED = 91,
		bl_icon_VIEW3D = 104,
		bl_icon_IPO = 105,
		bl_icon_OOPS = 106,
		bl_icon_BUTS = 107,
		bl_icon_FILESEL = 108,
		bl_icon_IMAGE_COL = 109,
		bl_icon_INFO = 110,
		bl_icon_SEQUENCE = 111,
		bl_icon_TEXT = 112,
		bl_icon_IMASEL = 113,
		bl_icon_SOUND = 114,
		bl_icon_ACTION = 115,
		bl_icon_NLA = 116,
		bl_icon_SCRIPTWIN = 117,
		bl_icon_TIME = 118,
		bl_icon_NODETREE = 119,
		bl_icon_LOGIC = 120,
		bl_icon_CONSOLE = 121,
		bl_icon_PREFERENCES = 122,
		bl_icon_CLIP = 123,
		bl_icon_ASSET_MANAGER = 124,
		bl_icon_OBJECT_DATAMODE = 130,
		bl_icon_EDITMODE_HLT = 131,
		bl_icon_FACESEL_HLT = 132,
		bl_icon_VPAINT_HLT = 133,
		bl_icon_TPAINT_HLT = 134,
		bl_icon_WPAINT_HLT = 135,
		bl_icon_SCULPTMODE_HLT = 136,
		bl_icon_POSE_HLT = 137,
		bl_icon_PARTICLEMODE = 138,
		bl_icon_LIGHTPAINT = 139,
		bl_icon_SCENE_DATA = 156,
		bl_icon_RENDERLAYERS = 157,
		bl_icon_WORLD_DATA = 158,
		bl_icon_OBJECT_DATA = 159,
		bl_icon_MESH_DATA = 160,
		bl_icon_CURVE_DATA = 161,
		bl_icon_META_DATA = 162,
		bl_icon_LATTICE_DATA = 163,
		bl_icon_LAMP_DATA = 164,
		bl_icon_MATERIAL_DATA = 165,
		bl_icon_TEXTURE_DATA = 166,
		bl_icon_ANIM_DATA = 167,
		bl_icon_CAMERA_DATA = 168,
		bl_icon_PARTICLE_DATA = 169,
		bl_icon_LIBRARY_DATA_DIRECT = 170,
		bl_icon_GROUP = 171,
		bl_icon_ARMATURE_DATA = 172,
		bl_icon_POSE_DATA = 173,
		bl_icon_BONE_DATA = 174,
		bl_icon_CONSTRAINT = 175,
		bl_icon_SHAPEKEY_DATA = 176,
		bl_icon_CONSTRAINT_BONE = 177,
		bl_icon_CAMERA_STEREO = 178,
		bl_icon_PACKAGE = 179,
		bl_icon_UGLYPACKAGE = 180,
		bl_icon_BRUSH_DATA = 182,
		bl_icon_IMAGE_DATA = 183,
		bl_icon_FILE = 184,
		bl_icon_FCURVE = 185,
		bl_icon_FONT_DATA = 186,
		bl_icon_RENDER_RESULT = 187,
		bl_icon_SURFACE_DATA = 188,
		bl_icon_EMPTY_DATA = 189,
		bl_icon_SETTINGS = 190,
		bl_icon_RENDER_ANIMATION = 191,
		bl_icon_RENDER_STILL = 192,
		bl_icon_BOIDS = 194,
		bl_icon_STRANDS = 195,
		bl_icon_LIBRARY_DATA_INDIRECT = 196,
		bl_icon_GREASEPENCIL = 197,
		bl_icon_LINE_DATA = 198,
		bl_icon_GROUP_BONE = 200,
		bl_icon_GROUP_VERTEX = 201,
		bl_icon_GROUP_VCOL = 202,
		bl_icon_GROUP_UVS = 203,
		bl_icon_RNA = 206,
		bl_icon_RNA_ADD = 207,
		bl_icon_OUTLINER_OB_EMPTY = 234,
		bl_icon_OUTLINER_OB_MESH = 235,
		bl_icon_OUTLINER_OB_CURVE = 236,
		bl_icon_OUTLINER_OB_LATTICE = 237,
		bl_icon_OUTLINER_OB_META = 238,
		bl_icon_OUTLINER_OB_LAMP = 239,
		bl_icon_OUTLINER_OB_CAMERA = 240,
		bl_icon_OUTLINER_OB_ARMATURE = 241,
		bl_icon_OUTLINER_OB_FONT = 242,
		bl_icon_OUTLINER_OB_SURFACE = 243,
		bl_icon_OUTLINER_OB_SPEAKER = 244,
		bl_icon_RESTRICT_VIEW_OFF = 253,
		bl_icon_RESTRICT_VIEW_ON = 254,
		bl_icon_RESTRICT_SELECT_OFF = 255,
		bl_icon_RESTRICT_SELECT_ON = 256,
		bl_icon_RESTRICT_RENDER_OFF = 257,
		bl_icon_RESTRICT_RENDER_ON = 258,
		bl_icon_OUTLINER_DATA_EMPTY = 260,
		bl_icon_OUTLINER_DATA_MESH = 261,
		bl_icon_OUTLINER_DATA_CURVE = 262,
		bl_icon_OUTLINER_DATA_LATTICE = 263,
		bl_icon_OUTLINER_DATA_META = 264,
		bl_icon_OUTLINER_DATA_LAMP = 265,
		bl_icon_OUTLINER_DATA_CAMERA = 266,
		bl_icon_OUTLINER_DATA_ARMATURE = 267,
		bl_icon_OUTLINER_DATA_FONT = 268,
		bl_icon_OUTLINER_DATA_SURFACE = 269,
		bl_icon_OUTLINER_DATA_SPEAKER = 270,
		bl_icon_OUTLINER_DATA_POSE = 271,
		bl_icon_MESH_PLANE = 286,
		bl_icon_MESH_CUBE = 287,
		bl_icon_MESH_CIRCLE = 288,
		bl_icon_MESH_UVSPHERE = 289,
		bl_icon_MESH_ICOSPHERE = 290,
		bl_icon_MESH_GRID = 291,
		bl_icon_MESH_MONKEY = 292,
		bl_icon_MESH_CYLINDER = 293,
		bl_icon_MESH_TORUS = 294,
		bl_icon_MESH_CONE = 295,
		bl_icon_LAMP_POINT = 298,
		bl_icon_LAMP_SUN = 299,
		bl_icon_LAMP_SPOT = 300,
		bl_icon_LAMP_HEMI = 301,
		bl_icon_LAMP_AREA = 302,
		bl_icon_META_EMPTY = 305,
		bl_icon_META_PLANE = 306,
		bl_icon_META_CUBE = 307,
		bl_icon_META_BALL = 308,
		bl_icon_META_ELLIPSOID = 309,
		bl_icon_META_CAPSULE = 310,
		bl_icon_SURFACE_NCURVE = 312,
		bl_icon_SURFACE_NCIRCLE = 313,
		bl_icon_SURFACE_NSURFACE = 314,
		bl_icon_SURFACE_NCYLINDER = 315,
		bl_icon_SURFACE_NSPHERE = 316,
		bl_icon_SURFACE_NTORUS = 317,
		bl_icon_CURVE_BEZCURVE = 321,
		bl_icon_CURVE_BEZCIRCLE = 322,
		bl_icon_CURVE_NCURVE = 323,
		bl_icon_CURVE_NCIRCLE = 324,
		bl_icon_CURVE_PATH = 325,
		bl_icon_COLOR_RED = 331,
		bl_icon_COLOR_GREEN = 332,
		bl_icon_COLOR_BLUE = 333,
		bl_icon_TRIA_RIGHT_BAR = 334,
		bl_icon_TRIA_DOWN_BAR = 335,
		bl_icon_TRIA_LEFT_BAR = 336,
		bl_icon_TRIA_UP_BAR = 337,
		bl_icon_FORCE_FORCE = 338,
		bl_icon_FORCE_WIND = 339,
		bl_icon_FORCE_VORTEX = 340,
		bl_icon_FORCE_MAGNETIC = 341,
		bl_icon_FORCE_HARMONIC = 342,
		bl_icon_FORCE_CHARGE = 343,
		bl_icon_FORCE_LENNARDJONES = 344,
		bl_icon_FORCE_TEXTURE = 345,
		bl_icon_FORCE_CURVE = 346,
		bl_icon_FORCE_BOID = 347,
		bl_icon_FORCE_TURBULENCE = 348,
		bl_icon_FORCE_DRAG = 349,
		bl_icon_FORCE_SMOKEFLOW = 350,
		bl_icon_MODIFIER = 442,
		bl_icon_MOD_WAVE = 443,
		bl_icon_MOD_BUILD = 444,
		bl_icon_MOD_DECIM = 445,
		bl_icon_MOD_MIRROR = 446,
		bl_icon_MOD_SOFT = 447,
		bl_icon_MOD_SUBSURF = 448,
		bl_icon_HOOK = 449,
		bl_icon_MOD_PHYSICS = 450,
		bl_icon_MOD_PARTICLES = 451,
		bl_icon_MOD_BOOLEAN = 452,
		bl_icon_MOD_EDGESPLIT = 453,
		bl_icon_MOD_ARRAY = 454,
		bl_icon_MOD_UVPROJECT = 455,
		bl_icon_MOD_DISPLACE = 456,
		bl_icon_MOD_CURVE = 457,
		bl_icon_MOD_LATTICE = 458,
		bl_icon_CONSTRAINT_DATA = 459,
		bl_icon_MOD_ARMATURE = 460,
		bl_icon_MOD_SHRINKWRAP = 461,
		bl_icon_MOD_CAST = 462,
		bl_icon_MOD_MESHDEFORM = 463,
		bl_icon_MOD_BEVEL = 464,
		bl_icon_MOD_SMOOTH = 465,
		bl_icon_MOD_SIMPLEDEFORM = 466,
		bl_icon_MOD_MASK = 467,
		bl_icon_MOD_CLOTH = 468,
		bl_icon_MOD_EXPLODE = 469,
		bl_icon_MOD_FLUIDSIM = 470,
		bl_icon_MOD_MULTIRES = 471,
		bl_icon_MOD_SMOKE = 472,
		bl_icon_MOD_SOLIDIFY = 473,
		bl_icon_MOD_SCREW = 474,
		bl_icon_MOD_VERTEX_WEIGHT = 475,
		bl_icon_MOD_DYNAMICPAINT = 476,
		bl_icon_MOD_REMESH = 477,
		bl_icon_MOD_OCEAN = 478,
		bl_icon_MOD_WARP = 479,
		bl_icon_MOD_SKIN = 480,
		bl_icon_MOD_TRIANGULATE = 481,
		bl_icon_MOD_WIREFRAME = 482,
		bl_icon_MOD_DATA_TRANSFER = 483,
		bl_icon_MOD_NORMALEDIT = 484,
		bl_icon_REC = 494,
		bl_icon_PLAY = 495,
		bl_icon_FF = 496,
		bl_icon_REW = 497,
		bl_icon_PAUSE = 498,
		bl_icon_PREV_KEYFRAME = 499,
		bl_icon_NEXT_KEYFRAME = 500,
		bl_icon_PLAY_AUDIO = 501,
		bl_icon_PLAY_REVERSE = 502,
		bl_icon_PREVIEW_RANGE = 503,
		bl_icon_ACTION_TWEAK = 504,
		bl_icon_PMARKER_ACT = 505,
		bl_icon_PMARKER_SEL = 506,
		bl_icon_PMARKER = 507,
		bl_icon_MARKER_HLT = 508,
		bl_icon_MARKER = 509,
		bl_icon_SPACE2 = 510,
		bl_icon_SPACE3 = 511,
		bl_icon_KEYINGSET = 512,
		bl_icon_KEY_DEHLT = 513,
		bl_icon_KEY_HLT = 514,
		bl_icon_MUTE_IPO_OFF = 515,
		bl_icon_MUTE_IPO_ON = 516,
		bl_icon_VISIBLE_IPO_OFF = 517,
		bl_icon_VISIBLE_IPO_ON = 518,
		bl_icon_DRIVER = 519,
		bl_icon_SOLO_OFF = 520,
		bl_icon_SOLO_ON = 521,
		bl_icon_FRAME_PREV = 522,
		bl_icon_FRAME_NEXT = 523,
		bl_icon_NLA_PUSHDOWN = 524,
		bl_icon_IPO_CONSTANT = 525,
		bl_icon_IPO_LINEAR = 526,
		bl_icon_IPO_BEZIER = 527,
		bl_icon_IPO_SINE = 528,
		bl_icon_IPO_QUAD = 529,
		bl_icon_IPO_CUBIC = 530,
		bl_icon_IPO_QUART = 531,
		bl_icon_IPO_QUINT = 532,
		bl_icon_IPO_EXPO = 533,
		bl_icon_IPO_CIRC = 534,
		bl_icon_IPO_BOUNCE = 535,
		bl_icon_IPO_ELASTIC = 536,
		bl_icon_IPO_BACK = 537,
		bl_icon_IPO_EASE_IN = 538,
		bl_icon_IPO_EASE_OUT = 539,
		bl_icon_IPO_EASE_IN_OUT = 540,
		bl_icon_VERTEXSEL = 546,
		bl_icon_EDGESEL = 547,
		bl_icon_FACESEL = 548,
		bl_icon_LOOPSEL = 549,
		bl_icon_ROTATE = 551,
		bl_icon_CURSOR = 552,
		bl_icon_ROTATECOLLECTION = 553,
		bl_icon_ROTATECENTER = 554,
		bl_icon_ROTACTIVE = 555,
		bl_icon_ALIGN = 556,
		bl_icon_SMOOTHCURVE = 558,
		bl_icon_SPHERECURVE = 559,
		bl_icon_ROOTCURVE = 560,
		bl_icon_SHARPCURVE = 561,
		bl_icon_LINCURVE = 562,
		bl_icon_NOCURVE = 563,
		bl_icon_RNDCURVE = 564,
		bl_icon_PROP_OFF = 565,
		bl_icon_PROP_ON = 566,
		bl_icon_PROP_CON = 567,
		bl_icon_SCULPT_DYNTOPO = 568,
		bl_icon_PARTICLE_POINT = 569,
		bl_icon_PARTICLE_TIP = 570,
		bl_icon_PARTICLE_PATH = 571,
		bl_icon_MAN_TRANS = 572,
		bl_icon_MAN_ROT = 573,
		bl_icon_MAN_SCALE = 574,
		bl_icon_MANIPUL = 575,
		bl_icon_SNAP_OFF = 576,
		bl_icon_SNAP_ON = 577,
		bl_icon_SNAP_NORMAL = 578,
		bl_icon_SNAP_INCREMENT = 579,
		bl_icon_SNAP_VERTEX = 580,
		bl_icon_SNAP_EDGE = 581,
		bl_icon_SNAP_FACE = 582,
		bl_icon_SNAP_VOLUME = 583,
		bl_icon_STICKY_UVS_LOC = 585,
		bl_icon_STICKY_UVS_DISABLE = 586,
		bl_icon_STICKY_UVS_VERT = 587,
		bl_icon_CLIPUV_DEHLT = 588,
		bl_icon_CLIPUV_HLT = 589,
		bl_icon_SNAP_PEEL_OBJECT = 590,
		bl_icon_GRID = 591,
		bl_icon_PASTEDOWN = 598,
		bl_icon_COPYDOWN = 599,
		bl_icon_PASTEFLIPUP = 600,
		bl_icon_PASTEFLIPDOWN = 601,
		bl_icon_SNAP_SURFACE = 606,
		bl_icon_AUTOMERGE_ON = 607,
		bl_icon_AUTOMERGE_OFF = 608,
		bl_icon_RETOPO = 609,
		bl_icon_UV_VERTEXSEL = 610,
		bl_icon_UV_EDGESEL = 611,
		bl_icon_UV_FACESEL = 612,
		bl_icon_UV_ISLANDSEL = 613,
		bl_icon_UV_SYNC_SELECT = 614,
		bl_icon_BBOX = 624,
		bl_icon_WIRE = 625,
		bl_icon_SOLID = 626,
		bl_icon_SMOOTH = 627,
		bl_icon_POTATO = 628,
		bl_icon_ORTHO = 630,
		bl_icon_LOCKVIEW_OFF = 633,
		bl_icon_LOCKVIEW_ON = 634,
		bl_icon_AXIS_SIDE = 636,
		bl_icon_AXIS_FRONT = 637,
		bl_icon_AXIS_TOP = 638,
		bl_icon_NDOF_DOM = 639,
		bl_icon_NDOF_TURN = 640,
		bl_icon_NDOF_FLY = 641,
		bl_icon_NDOF_TRANS = 642,
		bl_icon_LAYER_USED = 643,
		bl_icon_LAYER_ACTIVE = 644,
		bl_icon_SORTALPHA = 676,
		bl_icon_SORTBYEXT = 677,
		bl_icon_SORTTIME = 678,
		bl_icon_SORTSIZE = 679,
		bl_icon_LONGDISPLAY = 680,
		bl_icon_SHORTDISPLAY = 681,
		bl_icon_GHOST = 682,
		bl_icon_IMGDISPLAY = 683,
		bl_icon_SAVE_AS = 684,
		bl_icon_SAVE_COPY = 685,
		bl_icon_BOOKMARKS = 686,
		bl_icon_FONTPREVIEW = 687,
		bl_icon_FILTER = 688,
		bl_icon_NEWFOLDER = 689,
		bl_icon_OPEN_RECENT = 690,
		bl_icon_FILE_PARENT = 691,
		bl_icon_FILE_REFRESH = 692,
		bl_icon_FILE_FOLDER = 693,
		bl_icon_FILE_BLANK = 694,
		bl_icon_FILE_BLEND = 695,
		bl_icon_FILE_IMAGE = 696,
		bl_icon_FILE_MOVIE = 697,
		bl_icon_FILE_SCRIPT = 698,
		bl_icon_FILE_SOUND = 699,
		bl_icon_FILE_FONT = 700,
		bl_icon_FILE_TEXT = 701,
		bl_icon_RECOVER_AUTO = 702,
		bl_icon_SAVE_PREFS = 703,
		bl_icon_LINK_BLEND = 704,
		bl_icon_APPEND_BLEND = 705,
		bl_icon_IMPORT = 706,
		bl_icon_EXPORT = 707,
		bl_icon_EXTERNAL_DATA = 708,
		bl_icon_LOAD_FACTORY = 709,
		bl_icon_LOOP_BACK = 715,
		bl_icon_LOOP_FORWARDS = 716,
		bl_icon_BACK = 717,
		bl_icon_FORWARD = 718,
		bl_icon_FILE_HIDDEN = 725,
		bl_icon_FILE_BACKUP = 726,
		bl_icon_DISK_DRIVE = 727,
		bl_icon_MATPLANE = 728,
		bl_icon_MATSPHERE = 729,
		bl_icon_MATCUBE = 730,
		bl_icon_MONKEY = 731,
		bl_icon_HAIR = 732,
		bl_icon_ALIASED = 733,
		bl_icon_ANTIALIASED = 734,
		bl_icon_MAT_SPHERE_SKY = 735,
		bl_icon_WORDWRAP_OFF = 740,
		bl_icon_WORDWRAP_ON = 741,
		bl_icon_SYNTAX_OFF = 742,
		bl_icon_SYNTAX_ON = 743,
		bl_icon_LINENUMBERS_OFF = 744,
		bl_icon_LINENUMBERS_ON = 745,
		bl_icon_SCRIPTPLUGINS = 746,
		bl_icon_SEQ_SEQUENCER = 754,
		bl_icon_SEQ_PREVIEW = 755,
		bl_icon_SEQ_LUMA_WAVEFORM = 756,
		bl_icon_SEQ_CHROMA_SCOPE = 757,
		bl_icon_SEQ_HISTOGRAM = 758,
		bl_icon_SEQ_SPLITVIEW = 759,
		bl_icon_IMAGE_RGB = 763,
		bl_icon_IMAGE_RGB_ALPHA = 764,
		bl_icon_IMAGE_ALPHA = 765,
		bl_icon_IMAGE_ZDEPTH = 766,
		bl_icon_IMAGEFILE = 767,
		bl_icon_BRUSH_ADD = 780,
		bl_icon_BRUSH_BLOB = 781,
		bl_icon_BRUSH_BLUR = 782,
		bl_icon_BRUSH_CLAY = 783,
		bl_icon_BRUSH_CLAY_STRIPS = 784,
		bl_icon_BRUSH_CLONE = 785,
		bl_icon_BRUSH_CREASE = 786,
		bl_icon_BRUSH_DARKEN = 787,
		bl_icon_BRUSH_FILL = 788,
		bl_icon_BRUSH_FLATTEN = 789,
		bl_icon_BRUSH_GRAB = 790,
		bl_icon_BRUSH_INFLATE = 791,
		bl_icon_BRUSH_LAYER = 792,
		bl_icon_BRUSH_LIGHTEN = 793,
		bl_icon_BRUSH_MASK = 794,
		bl_icon_BRUSH_MIX = 795,
		bl_icon_BRUSH_MULTIPLY = 796,
		bl_icon_BRUSH_NUDGE = 797,
		bl_icon_BRUSH_PINCH = 798,
		bl_icon_BRUSH_SCRAPE = 799,
		bl_icon_BRUSH_SCULPT_DRAW = 800,
		bl_icon_BRUSH_SMEAR = 801,
		bl_icon_BRUSH_SMOOTH = 802,
		bl_icon_BRUSH_SNAKE_HOOK = 803,
		bl_icon_BRUSH_SOFTEN = 804,
		bl_icon_BRUSH_SUBTRACT = 805,
		bl_icon_BRUSH_TEXDRAW = 806,
		bl_icon_BRUSH_TEXFILL = 807,
		bl_icon_BRUSH_TEXMASK = 808,
		bl_icon_BRUSH_THUMB = 809,
		bl_icon_BRUSH_ROTATE = 810,
		bl_icon_BRUSH_VERTEXDRAW = 811,
		bl_icon_MATCAP_01 = 812,
		bl_icon_MATCAP_02 = 813,
		bl_icon_MATCAP_03 = 814,
		bl_icon_MATCAP_04 = 815,
		bl_icon_MATCAP_05 = 816,
		bl_icon_MATCAP_06 = 817,
		bl_icon_MATCAP_07 = 818,
		bl_icon_MATCAP_08 = 819,
		bl_icon_MATCAP_09 = 820,
		bl_icon_MATCAP_10 = 821,
		bl_icon_MATCAP_11 = 822,
		bl_icon_MATCAP_12 = 823,
		bl_icon_MATCAP_13 = 824,
		bl_icon_MATCAP_14 = 825,
		bl_icon_MATCAP_15 = 826,
		bl_icon_MATCAP_16 = 827,
		bl_icon_MATCAP_17 = 828,
		bl_icon_MATCAP_18 = 829,
		bl_icon_MATCAP_19 = 830,
		bl_icon_MATCAP_20 = 831,
		bl_icon_MATCAP_21 = 832,
		bl_icon_MATCAP_22 = 833,
		bl_icon_MATCAP_23 = 834,
		bl_icon_MATCAP_24 = 835,
	};

	/** Getter: The node tree icon */
	bl_icon_enum bl_icon() { /* not implemented */ throw NULL; }
	/** Setter: The node tree icon */
	void bl_icon(bl_icon_enum value) { /* not implemented */ }

	/**
	 * Updated node group interface
	 * @param Param 'context'
	 */
	void interface_update(Context context)
	{
		// not implemented
	}

};

/**************** NodeSocketStandard ****************/

/**
 * 
 */
class NodeSocketStandard : public NodeSocket {
public:
	NodeSocketStandard(PyObject* pyobj) : NodeSocket(pyobj) {}

	NodeSocketStandard() : NodeSocket(0)
	{
		// not implemented
	}

	/**
	 * Draw socket
	 * @param Param 'context'
	 * @param Layout in the UI
	 * @param Node the socket belongs to
	 * @param Text label to draw alongside properties
	 */
	void draw(Context context, UILayout layout, Node node, const std::string text);

	/**
	 * Color of the socket icon
	 * @param Param 'context'
	 * @param Node the socket belongs to
	 * @return 
	 */
	std::array<float, 4> draw_color(Context context, Node node)
	{
		// not implemented
		throw NULL;
	}

};

/**************** NodeSocketInterfaceStandard ****************/

/**
 * 
 */
class NodeSocketInterfaceStandard : public NodeSocketInterface {
public:
	NodeSocketInterfaceStandard(PyObject* pyobj) : NodeSocketInterface(pyobj) {}

	NodeSocketInterfaceStandard() : NodeSocketInterface(0)
	{
		// not implemented
	}

	enum type_enum {
		type_CUSTOM = -1,
		type_VALUE = 0,
		type_INT = 6,
		type_BOOLEAN = 4,
		type_VECTOR = 1,
		type_STRING = 7,
		type_RGBA = 2,
		type_SHADER = 3,
	};

	/** Getter: Data type */
	type_enum type() { /* not implemented */ throw NULL; }
	/** Setter: Data type */
	void type(type_enum value) { /* not implemented */ }

	/**
	 * Draw template settings
	 * @param Param 'context'
	 * @param Layout in the UI
	 */
	void draw(Context context, UILayout layout);

	/**
	 * Color of the socket icon
	 * @param Param 'context'
	 * @return 
	 */
	std::array<float, 4> draw_color(Context context)
	{
		// not implemented
		throw NULL;
	}

};

/**************** Float Node Socket ****************/

/**
 * Floating point number socket of a node
 */
class NodeSocketFloat : public NodeSocketStandard {
public:
	NodeSocketFloat(PyObject* pyobj) : NodeSocketStandard(pyobj) {}

	NodeSocketFloat() : NodeSocketStandard(0)
	{
		// not implemented
	}

	/** Getter: Input value used for unconnected socket */
	float default_value() { /* not implemented */ throw NULL; }
	/** Setter: Input value used for unconnected socket */
	void default_value(float value) {
		PyObject_SetAttrString(pyobjref, "default_value", Py_BuildValue("f", value));
	}

};

/**************** Float Node Socket Interface ****************/

/**
 * Floating point number socket of a node
 */
class NodeSocketInterfaceFloat : public NodeSocketInterfaceStandard {
public:
	NodeSocketInterfaceFloat(PyObject* pyobj) : NodeSocketInterfaceStandard(pyobj) {}

	NodeSocketInterfaceFloat() : NodeSocketInterfaceStandard(0)
	{
		// not implemented
	}

	/** Getter: Input value used for unconnected socket */
	float default_value() { /* not implemented */ throw NULL; }
	/** Setter: Input value used for unconnected socket */
	void default_value(float value) {
		PyObject_SetAttrString(pyobjref, "default_value", Py_BuildValue("f", value));
	}

	/** Getter: Minimum value */
	float min_value() { /* not implemented */ throw NULL; }
	/** Setter: Minimum value */
	void min_value(float value) {
		PyObject_SetAttrString(pyobjref, "min_value", Py_BuildValue("f", value));
	}

	/** Getter: Maximum value */
	float max_value() { /* not implemented */ throw NULL; }
	/** Setter: Maximum value */
	void max_value(float value) {
		PyObject_SetAttrString(pyobjref, "max_value", Py_BuildValue("f", value));
	}

};

/**************** Float Node Socket ****************/

/**
 * Floating point number socket of a node
 */
class NodeSocketFloatUnsigned : public NodeSocketStandard {
public:
	NodeSocketFloatUnsigned(PyObject* pyobj) : NodeSocketStandard(pyobj) {}

	NodeSocketFloatUnsigned() : NodeSocketStandard(0)
	{
		// not implemented
	}

	/** Getter: Input value used for unconnected socket */
	float default_value() { /* not implemented */ throw NULL; }
	/** Setter: Input value used for unconnected socket */
	void default_value(float value) {
		PyObject_SetAttrString(pyobjref, "default_value", Py_BuildValue("f", value));
	}

};

/**************** Float Node Socket Interface ****************/

/**
 * Floating point number socket of a node
 */
class NodeSocketInterfaceFloatUnsigned : public NodeSocketInterfaceStandard {
public:
	NodeSocketInterfaceFloatUnsigned(PyObject* pyobj) : NodeSocketInterfaceStandard(pyobj) {}

	NodeSocketInterfaceFloatUnsigned() : NodeSocketInterfaceStandard(0)
	{
		// not implemented
	}

	/** Getter: Input value used for unconnected socket */
	float default_value() { /* not implemented */ throw NULL; }
	/** Setter: Input value used for unconnected socket */
	void default_value(float value) {
		PyObject_SetAttrString(pyobjref, "default_value", Py_BuildValue("f", value));
	}

	/** Getter: Minimum value */
	float min_value() { /* not implemented */ throw NULL; }
	/** Setter: Minimum value */
	void min_value(float value) {
		PyObject_SetAttrString(pyobjref, "min_value", Py_BuildValue("f", value));
	}

	/** Getter: Maximum value */
	float max_value() { /* not implemented */ throw NULL; }
	/** Setter: Maximum value */
	void max_value(float value) {
		PyObject_SetAttrString(pyobjref, "max_value", Py_BuildValue("f", value));
	}

};

/**************** Float Node Socket ****************/

/**
 * Floating point number socket of a node
 */
class NodeSocketFloatPercentage : public NodeSocketStandard {
public:
	NodeSocketFloatPercentage(PyObject* pyobj) : NodeSocketStandard(pyobj) {}

	NodeSocketFloatPercentage() : NodeSocketStandard(0)
	{
		// not implemented
	}

	/** Getter: Input value used for unconnected socket */
	float default_value() { /* not implemented */ throw NULL; }
	/** Setter: Input value used for unconnected socket */
	void default_value(float value) {
		PyObject_SetAttrString(pyobjref, "default_value", Py_BuildValue("f", value));
	}

};

/**************** Float Node Socket Interface ****************/

/**
 * Floating point number socket of a node
 */
class NodeSocketInterfaceFloatPercentage : public NodeSocketInterfaceStandard {
public:
	NodeSocketInterfaceFloatPercentage(PyObject* pyobj) : NodeSocketInterfaceStandard(pyobj) {}

	NodeSocketInterfaceFloatPercentage() : NodeSocketInterfaceStandard(0)
	{
		// not implemented
	}

	/** Getter: Input value used for unconnected socket */
	float default_value() { /* not implemented */ throw NULL; }
	/** Setter: Input value used for unconnected socket */
	void default_value(float value) {
		PyObject_SetAttrString(pyobjref, "default_value", Py_BuildValue("f", value));
	}

	/** Getter: Minimum value */
	float min_value() { /* not implemented */ throw NULL; }
	/** Setter: Minimum value */
	void min_value(float value) {
		PyObject_SetAttrString(pyobjref, "min_value", Py_BuildValue("f", value));
	}

	/** Getter: Maximum value */
	float max_value() { /* not implemented */ throw NULL; }
	/** Setter: Maximum value */
	void max_value(float value) {
		PyObject_SetAttrString(pyobjref, "max_value", Py_BuildValue("f", value));
	}

};

/**************** Float Node Socket ****************/

/**
 * Floating point number socket of a node
 */
class NodeSocketFloatFactor : public NodeSocketStandard {
public:
	NodeSocketFloatFactor(PyObject* pyobj) : NodeSocketStandard(pyobj) {}

	NodeSocketFloatFactor() : NodeSocketStandard(0)
	{
		// not implemented
	}

	/** Getter: Input value used for unconnected socket */
	float default_value() { /* not implemented */ throw NULL; }
	/** Setter: Input value used for unconnected socket */
	void default_value(float value) {
		PyObject_SetAttrString(pyobjref, "default_value", Py_BuildValue("f", value));
	}

};

/**************** Float Node Socket Interface ****************/

/**
 * Floating point number socket of a node
 */
class NodeSocketInterfaceFloatFactor : public NodeSocketInterfaceStandard {
public:
	NodeSocketInterfaceFloatFactor(PyObject* pyobj) : NodeSocketInterfaceStandard(pyobj) {}

	NodeSocketInterfaceFloatFactor() : NodeSocketInterfaceStandard(0)
	{
		// not implemented
	}

	/** Getter: Input value used for unconnected socket */
	float default_value() { /* not implemented */ throw NULL; }
	/** Setter: Input value used for unconnected socket */
	void default_value(float value) {
		PyObject_SetAttrString(pyobjref, "default_value", Py_BuildValue("f", value));
	}

	/** Getter: Minimum value */
	float min_value() { /* not implemented */ throw NULL; }
	/** Setter: Minimum value */
	void min_value(float value) {
		PyObject_SetAttrString(pyobjref, "min_value", Py_BuildValue("f", value));
	}

	/** Getter: Maximum value */
	float max_value() { /* not implemented */ throw NULL; }
	/** Setter: Maximum value */
	void max_value(float value) {
		PyObject_SetAttrString(pyobjref, "max_value", Py_BuildValue("f", value));
	}

};

/**************** Float Node Socket ****************/

/**
 * Floating point number socket of a node
 */
class NodeSocketFloatAngle : public NodeSocketStandard {
public:
	NodeSocketFloatAngle(PyObject* pyobj) : NodeSocketStandard(pyobj) {}

	NodeSocketFloatAngle() : NodeSocketStandard(0)
	{
		// not implemented
	}

	/** Getter: Input value used for unconnected socket */
	float default_value() { /* not implemented */ throw NULL; }
	/** Setter: Input value used for unconnected socket */
	void default_value(float value) {
		PyObject_SetAttrString(pyobjref, "default_value", Py_BuildValue("f", value));
	}

};

/**************** Float Node Socket Interface ****************/

/**
 * Floating point number socket of a node
 */
class NodeSocketInterfaceFloatAngle : public NodeSocketInterfaceStandard {
public:
	NodeSocketInterfaceFloatAngle(PyObject* pyobj) : NodeSocketInterfaceStandard(pyobj) {}

	NodeSocketInterfaceFloatAngle() : NodeSocketInterfaceStandard(0)
	{
		// not implemented
	}

	/** Getter: Input value used for unconnected socket */
	float default_value() { /* not implemented */ throw NULL; }
	/** Setter: Input value used for unconnected socket */
	void default_value(float value) {
		PyObject_SetAttrString(pyobjref, "default_value", Py_BuildValue("f", value));
	}

	/** Getter: Minimum value */
	float min_value() { /* not implemented */ throw NULL; }
	/** Setter: Minimum value */
	void min_value(float value) {
		PyObject_SetAttrString(pyobjref, "min_value", Py_BuildValue("f", value));
	}

	/** Getter: Maximum value */
	float max_value() { /* not implemented */ throw NULL; }
	/** Setter: Maximum value */
	void max_value(float value) {
		PyObject_SetAttrString(pyobjref, "max_value", Py_BuildValue("f", value));
	}

};

/**************** Float Node Socket ****************/

/**
 * Floating point number socket of a node
 */
class NodeSocketFloatTime : public NodeSocketStandard {
public:
	NodeSocketFloatTime(PyObject* pyobj) : NodeSocketStandard(pyobj) {}

	NodeSocketFloatTime() : NodeSocketStandard(0)
	{
		// not implemented
	}

	/** Getter: Input value used for unconnected socket */
	float default_value() { /* not implemented */ throw NULL; }
	/** Setter: Input value used for unconnected socket */
	void default_value(float value) {
		PyObject_SetAttrString(pyobjref, "default_value", Py_BuildValue("f", value));
	}

};

/**************** Float Node Socket Interface ****************/

/**
 * Floating point number socket of a node
 */
class NodeSocketInterfaceFloatTime : public NodeSocketInterfaceStandard {
public:
	NodeSocketInterfaceFloatTime(PyObject* pyobj) : NodeSocketInterfaceStandard(pyobj) {}

	NodeSocketInterfaceFloatTime() : NodeSocketInterfaceStandard(0)
	{
		// not implemented
	}

	/** Getter: Input value used for unconnected socket */
	float default_value() { /* not implemented */ throw NULL; }
	/** Setter: Input value used for unconnected socket */
	void default_value(float value) {
		PyObject_SetAttrString(pyobjref, "default_value", Py_BuildValue("f", value));
	}

	/** Getter: Minimum value */
	float min_value() { /* not implemented */ throw NULL; }
	/** Setter: Minimum value */
	void min_value(float value) {
		PyObject_SetAttrString(pyobjref, "min_value", Py_BuildValue("f", value));
	}

	/** Getter: Maximum value */
	float max_value() { /* not implemented */ throw NULL; }
	/** Setter: Maximum value */
	void max_value(float value) {
		PyObject_SetAttrString(pyobjref, "max_value", Py_BuildValue("f", value));
	}

};

/**************** Integer Node Socket ****************/

/**
 * Integer number socket of a node
 */
class NodeSocketInt : public NodeSocketStandard {
public:
	NodeSocketInt(PyObject* pyobj) : NodeSocketStandard(pyobj) {}

	NodeSocketInt() : NodeSocketStandard(0)
	{
		// not implemented
	}

	/** Getter: Input value used for unconnected socket */
	int default_value() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "default_value"));
	}

	/** Setter: Input value used for unconnected socket */
	void default_value(int value) {
		PyObject_SetAttrString(pyobjref, "default_value", Py_BuildValue("i", value));
	}

};

/**************** Integer Node Socket Interface ****************/

/**
 * Integer number socket of a node
 */
class NodeSocketInterfaceInt : public NodeSocketInterfaceStandard {
public:
	NodeSocketInterfaceInt(PyObject* pyobj) : NodeSocketInterfaceStandard(pyobj) {}

	NodeSocketInterfaceInt() : NodeSocketInterfaceStandard(0)
	{
		// not implemented
	}

	/** Getter: Input value used for unconnected socket */
	int default_value() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "default_value"));
	}

	/** Setter: Input value used for unconnected socket */
	void default_value(int value) {
		PyObject_SetAttrString(pyobjref, "default_value", Py_BuildValue("i", value));
	}

	/** Getter: Minimum value */
	int min_value() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "min_value"));
	}

	/** Setter: Minimum value */
	void min_value(int value) {
		PyObject_SetAttrString(pyobjref, "min_value", Py_BuildValue("i", value));
	}

	/** Getter: Maximum value */
	int max_value() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "max_value"));
	}

	/** Setter: Maximum value */
	void max_value(int value) {
		PyObject_SetAttrString(pyobjref, "max_value", Py_BuildValue("i", value));
	}

};

/**************** Integer Node Socket ****************/

/**
 * Integer number socket of a node
 */
class NodeSocketIntUnsigned : public NodeSocketStandard {
public:
	NodeSocketIntUnsigned(PyObject* pyobj) : NodeSocketStandard(pyobj) {}

	NodeSocketIntUnsigned() : NodeSocketStandard(0)
	{
		// not implemented
	}

	/** Getter: Input value used for unconnected socket */
	int default_value() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "default_value"));
	}

	/** Setter: Input value used for unconnected socket */
	void default_value(int value) {
		PyObject_SetAttrString(pyobjref, "default_value", Py_BuildValue("i", value));
	}

};

/**************** Integer Node Socket Interface ****************/

/**
 * Integer number socket of a node
 */
class NodeSocketInterfaceIntUnsigned : public NodeSocketInterfaceStandard {
public:
	NodeSocketInterfaceIntUnsigned(PyObject* pyobj) : NodeSocketInterfaceStandard(pyobj) {}

	NodeSocketInterfaceIntUnsigned() : NodeSocketInterfaceStandard(0)
	{
		// not implemented
	}

	/** Getter: Input value used for unconnected socket */
	int default_value() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "default_value"));
	}

	/** Setter: Input value used for unconnected socket */
	void default_value(int value) {
		PyObject_SetAttrString(pyobjref, "default_value", Py_BuildValue("i", value));
	}

	/** Getter: Minimum value */
	int min_value() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "min_value"));
	}

	/** Setter: Minimum value */
	void min_value(int value) {
		PyObject_SetAttrString(pyobjref, "min_value", Py_BuildValue("i", value));
	}

	/** Getter: Maximum value */
	int max_value() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "max_value"));
	}

	/** Setter: Maximum value */
	void max_value(int value) {
		PyObject_SetAttrString(pyobjref, "max_value", Py_BuildValue("i", value));
	}

};

/**************** Integer Node Socket ****************/

/**
 * Integer number socket of a node
 */
class NodeSocketIntPercentage : public NodeSocketStandard {
public:
	NodeSocketIntPercentage(PyObject* pyobj) : NodeSocketStandard(pyobj) {}

	NodeSocketIntPercentage() : NodeSocketStandard(0)
	{
		// not implemented
	}

	/** Getter: Input value used for unconnected socket */
	int default_value() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "default_value"));
	}

	/** Setter: Input value used for unconnected socket */
	void default_value(int value) {
		PyObject_SetAttrString(pyobjref, "default_value", Py_BuildValue("i", value));
	}

};

/**************** Integer Node Socket Interface ****************/

/**
 * Integer number socket of a node
 */
class NodeSocketInterfaceIntPercentage : public NodeSocketInterfaceStandard {
public:
	NodeSocketInterfaceIntPercentage(PyObject* pyobj) : NodeSocketInterfaceStandard(pyobj) {}

	NodeSocketInterfaceIntPercentage() : NodeSocketInterfaceStandard(0)
	{
		// not implemented
	}

	/** Getter: Input value used for unconnected socket */
	int default_value() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "default_value"));
	}

	/** Setter: Input value used for unconnected socket */
	void default_value(int value) {
		PyObject_SetAttrString(pyobjref, "default_value", Py_BuildValue("i", value));
	}

	/** Getter: Minimum value */
	int min_value() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "min_value"));
	}

	/** Setter: Minimum value */
	void min_value(int value) {
		PyObject_SetAttrString(pyobjref, "min_value", Py_BuildValue("i", value));
	}

	/** Getter: Maximum value */
	int max_value() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "max_value"));
	}

	/** Setter: Maximum value */
	void max_value(int value) {
		PyObject_SetAttrString(pyobjref, "max_value", Py_BuildValue("i", value));
	}

};

/**************** Integer Node Socket ****************/

/**
 * Integer number socket of a node
 */
class NodeSocketIntFactor : public NodeSocketStandard {
public:
	NodeSocketIntFactor(PyObject* pyobj) : NodeSocketStandard(pyobj) {}

	NodeSocketIntFactor() : NodeSocketStandard(0)
	{
		// not implemented
	}

	/** Getter: Input value used for unconnected socket */
	int default_value() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "default_value"));
	}

	/** Setter: Input value used for unconnected socket */
	void default_value(int value) {
		PyObject_SetAttrString(pyobjref, "default_value", Py_BuildValue("i", value));
	}

};

/**************** Integer Node Socket Interface ****************/

/**
 * Integer number socket of a node
 */
class NodeSocketInterfaceIntFactor : public NodeSocketInterfaceStandard {
public:
	NodeSocketInterfaceIntFactor(PyObject* pyobj) : NodeSocketInterfaceStandard(pyobj) {}

	NodeSocketInterfaceIntFactor() : NodeSocketInterfaceStandard(0)
	{
		// not implemented
	}

	/** Getter: Input value used for unconnected socket */
	int default_value() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "default_value"));
	}

	/** Setter: Input value used for unconnected socket */
	void default_value(int value) {
		PyObject_SetAttrString(pyobjref, "default_value", Py_BuildValue("i", value));
	}

	/** Getter: Minimum value */
	int min_value() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "min_value"));
	}

	/** Setter: Minimum value */
	void min_value(int value) {
		PyObject_SetAttrString(pyobjref, "min_value", Py_BuildValue("i", value));
	}

	/** Getter: Maximum value */
	int max_value() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "max_value"));
	}

	/** Setter: Maximum value */
	void max_value(int value) {
		PyObject_SetAttrString(pyobjref, "max_value", Py_BuildValue("i", value));
	}

};

/**************** Boolean Node Socket ****************/

/**
 * Boolean value socket of a node
 */
class NodeSocketBool : public NodeSocketStandard {
public:
	NodeSocketBool(PyObject* pyobj) : NodeSocketStandard(pyobj) {}

	NodeSocketBool() : NodeSocketStandard(0)
	{
		// not implemented
	}

	/** Getter: Input value used for unconnected socket */
	bool default_value() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "default_value")) == 1;
	}

	/** Setter: Input value used for unconnected socket */
	void default_value(bool value) {
		PyObject_SetAttrString(pyobjref, "default_value", Py_BuildValue("i", value));
	}

};

/**************** Boolean Node Socket Interface ****************/

/**
 * Boolean value socket of a node
 */
class NodeSocketInterfaceBool : public NodeSocketInterfaceStandard {
public:
	NodeSocketInterfaceBool(PyObject* pyobj) : NodeSocketInterfaceStandard(pyobj) {}

	NodeSocketInterfaceBool() : NodeSocketInterfaceStandard(0)
	{
		// not implemented
	}

	/** Getter: Input value used for unconnected socket */
	bool default_value() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "default_value")) == 1;
	}

	/** Setter: Input value used for unconnected socket */
	void default_value(bool value) {
		PyObject_SetAttrString(pyobjref, "default_value", Py_BuildValue("i", value));
	}

};

/**************** Vector Node Socket ****************/

/**
 * 3D vector socket of a node
 */
class NodeSocketVector : public NodeSocketStandard {
public:
	NodeSocketVector(PyObject* pyobj) : NodeSocketStandard(pyobj) {}

	NodeSocketVector() : NodeSocketStandard(0)
	{
		// not implemented
	}

	/** Getter: Input value used for unconnected socket */
	std::array<float, 3> default_value() {
		// TODO: MISSING DEREF! USE #DEFINE!
		PyObject *seqval = PyObject_GetAttrString(pyobjref, "default_value");
		std::array<float, 3> resarr;
		for (int i = 0; i < 3; i++)
			resarr[i] = (float)PyFloat_AsDouble(PySequence_GetItem(seqval, i));
		return resarr;
	}

	/** Setter: Input value used for unconnected socket */
	void default_value(float values[3]) { /* not implemented */ }

};

/**************** Vector Node Socket Interface ****************/

/**
 * 3D vector socket of a node
 */
class NodeSocketInterfaceVector : public NodeSocketInterfaceStandard {
public:
	NodeSocketInterfaceVector(PyObject* pyobj) : NodeSocketInterfaceStandard(pyobj) {}

	NodeSocketInterfaceVector() : NodeSocketInterfaceStandard(0)
	{
		// not implemented
	}

	/** Getter: Input value used for unconnected socket */
	std::array<float, 3> default_value() {
		// TODO: MISSING DEREF! USE #DEFINE!
		PyObject *seqval = PyObject_GetAttrString(pyobjref, "default_value");
		std::array<float, 3> resarr;
		for (int i = 0; i < 3; i++)
			resarr[i] = (float)PyFloat_AsDouble(PySequence_GetItem(seqval, i));
		return resarr;
	}

	/** Setter: Input value used for unconnected socket */
	void default_value(float values[3]) { /* not implemented */ }

	/** Getter: Minimum value */
	float min_value() { /* not implemented */ throw NULL; }
	/** Setter: Minimum value */
	void min_value(float value) {
		PyObject_SetAttrString(pyobjref, "min_value", Py_BuildValue("f", value));
	}

	/** Getter: Maximum value */
	float max_value() { /* not implemented */ throw NULL; }
	/** Setter: Maximum value */
	void max_value(float value) {
		PyObject_SetAttrString(pyobjref, "max_value", Py_BuildValue("f", value));
	}

};

/**************** Vector Node Socket ****************/

/**
 * 3D vector socket of a node
 */
class NodeSocketVectorTranslation : public NodeSocketStandard {
public:
	NodeSocketVectorTranslation(PyObject* pyobj) : NodeSocketStandard(pyobj) {}

	NodeSocketVectorTranslation() : NodeSocketStandard(0)
	{
		// not implemented
	}

	/** Getter: Input value used for unconnected socket */
	std::array<float, 3> default_value() {
		// TODO: MISSING DEREF! USE #DEFINE!
		PyObject *seqval = PyObject_GetAttrString(pyobjref, "default_value");
		std::array<float, 3> resarr;
		for (int i = 0; i < 3; i++)
			resarr[i] = (float)PyFloat_AsDouble(PySequence_GetItem(seqval, i));
		return resarr;
	}

	/** Setter: Input value used for unconnected socket */
	void default_value(float values[3]) { /* not implemented */ }

};

/**************** Vector Node Socket Interface ****************/

/**
 * 3D vector socket of a node
 */
class NodeSocketInterfaceVectorTranslation : public NodeSocketInterfaceStandard {
public:
	NodeSocketInterfaceVectorTranslation(PyObject* pyobj) : NodeSocketInterfaceStandard(pyobj) {}

	NodeSocketInterfaceVectorTranslation() : NodeSocketInterfaceStandard(0)
	{
		// not implemented
	}

	/** Getter: Input value used for unconnected socket */
	std::array<float, 3> default_value() {
		// TODO: MISSING DEREF! USE #DEFINE!
		PyObject *seqval = PyObject_GetAttrString(pyobjref, "default_value");
		std::array<float, 3> resarr;
		for (int i = 0; i < 3; i++)
			resarr[i] = (float)PyFloat_AsDouble(PySequence_GetItem(seqval, i));
		return resarr;
	}

	/** Setter: Input value used for unconnected socket */
	void default_value(float values[3]) { /* not implemented */ }

	/** Getter: Minimum value */
	float min_value() { /* not implemented */ throw NULL; }
	/** Setter: Minimum value */
	void min_value(float value) {
		PyObject_SetAttrString(pyobjref, "min_value", Py_BuildValue("f", value));
	}

	/** Getter: Maximum value */
	float max_value() { /* not implemented */ throw NULL; }
	/** Setter: Maximum value */
	void max_value(float value) {
		PyObject_SetAttrString(pyobjref, "max_value", Py_BuildValue("f", value));
	}

};

/**************** Vector Node Socket ****************/

/**
 * 3D vector socket of a node
 */
class NodeSocketVectorDirection : public NodeSocketStandard {
public:
	NodeSocketVectorDirection(PyObject* pyobj) : NodeSocketStandard(pyobj) {}

	NodeSocketVectorDirection() : NodeSocketStandard(0)
	{
		// not implemented
	}

	/** Getter: Input value used for unconnected socket */
	std::array<float, 3> default_value() {
		// TODO: MISSING DEREF! USE #DEFINE!
		PyObject *seqval = PyObject_GetAttrString(pyobjref, "default_value");
		std::array<float, 3> resarr;
		for (int i = 0; i < 3; i++)
			resarr[i] = (float)PyFloat_AsDouble(PySequence_GetItem(seqval, i));
		return resarr;
	}

	/** Setter: Input value used for unconnected socket */
	void default_value(float values[3]) { /* not implemented */ }

};

/**************** Vector Node Socket Interface ****************/

/**
 * 3D vector socket of a node
 */
class NodeSocketInterfaceVectorDirection : public NodeSocketInterfaceStandard {
public:
	NodeSocketInterfaceVectorDirection(PyObject* pyobj) : NodeSocketInterfaceStandard(pyobj) {}

	NodeSocketInterfaceVectorDirection() : NodeSocketInterfaceStandard(0)
	{
		// not implemented
	}

	/** Getter: Input value used for unconnected socket */
	std::array<float, 3> default_value() {
		// TODO: MISSING DEREF! USE #DEFINE!
		PyObject *seqval = PyObject_GetAttrString(pyobjref, "default_value");
		std::array<float, 3> resarr;
		for (int i = 0; i < 3; i++)
			resarr[i] = (float)PyFloat_AsDouble(PySequence_GetItem(seqval, i));
		return resarr;
	}

	/** Setter: Input value used for unconnected socket */
	void default_value(float values[3]) { /* not implemented */ }

	/** Getter: Minimum value */
	float min_value() { /* not implemented */ throw NULL; }
	/** Setter: Minimum value */
	void min_value(float value) {
		PyObject_SetAttrString(pyobjref, "min_value", Py_BuildValue("f", value));
	}

	/** Getter: Maximum value */
	float max_value() { /* not implemented */ throw NULL; }
	/** Setter: Maximum value */
	void max_value(float value) {
		PyObject_SetAttrString(pyobjref, "max_value", Py_BuildValue("f", value));
	}

};

/**************** Vector Node Socket ****************/

/**
 * 3D vector socket of a node
 */
class NodeSocketVectorVelocity : public NodeSocketStandard {
public:
	NodeSocketVectorVelocity(PyObject* pyobj) : NodeSocketStandard(pyobj) {}

	NodeSocketVectorVelocity() : NodeSocketStandard(0)
	{
		// not implemented
	}

	/** Getter: Input value used for unconnected socket */
	std::array<float, 3> default_value() {
		// TODO: MISSING DEREF! USE #DEFINE!
		PyObject *seqval = PyObject_GetAttrString(pyobjref, "default_value");
		std::array<float, 3> resarr;
		for (int i = 0; i < 3; i++)
			resarr[i] = (float)PyFloat_AsDouble(PySequence_GetItem(seqval, i));
		return resarr;
	}

	/** Setter: Input value used for unconnected socket */
	void default_value(float values[3]) { /* not implemented */ }

};

/**************** Vector Node Socket Interface ****************/

/**
 * 3D vector socket of a node
 */
class NodeSocketInterfaceVectorVelocity : public NodeSocketInterfaceStandard {
public:
	NodeSocketInterfaceVectorVelocity(PyObject* pyobj) : NodeSocketInterfaceStandard(pyobj) {}

	NodeSocketInterfaceVectorVelocity() : NodeSocketInterfaceStandard(0)
	{
		// not implemented
	}

	/** Getter: Input value used for unconnected socket */
	std::array<float, 3> default_value() {
		// TODO: MISSING DEREF! USE #DEFINE!
		PyObject *seqval = PyObject_GetAttrString(pyobjref, "default_value");
		std::array<float, 3> resarr;
		for (int i = 0; i < 3; i++)
			resarr[i] = (float)PyFloat_AsDouble(PySequence_GetItem(seqval, i));
		return resarr;
	}

	/** Setter: Input value used for unconnected socket */
	void default_value(float values[3]) { /* not implemented */ }

	/** Getter: Minimum value */
	float min_value() { /* not implemented */ throw NULL; }
	/** Setter: Minimum value */
	void min_value(float value) {
		PyObject_SetAttrString(pyobjref, "min_value", Py_BuildValue("f", value));
	}

	/** Getter: Maximum value */
	float max_value() { /* not implemented */ throw NULL; }
	/** Setter: Maximum value */
	void max_value(float value) {
		PyObject_SetAttrString(pyobjref, "max_value", Py_BuildValue("f", value));
	}

};

/**************** Vector Node Socket ****************/

/**
 * 3D vector socket of a node
 */
class NodeSocketVectorAcceleration : public NodeSocketStandard {
public:
	NodeSocketVectorAcceleration(PyObject* pyobj) : NodeSocketStandard(pyobj) {}

	NodeSocketVectorAcceleration() : NodeSocketStandard(0)
	{
		// not implemented
	}

	/** Getter: Input value used for unconnected socket */
	std::array<float, 3> default_value() {
		// TODO: MISSING DEREF! USE #DEFINE!
		PyObject *seqval = PyObject_GetAttrString(pyobjref, "default_value");
		std::array<float, 3> resarr;
		for (int i = 0; i < 3; i++)
			resarr[i] = (float)PyFloat_AsDouble(PySequence_GetItem(seqval, i));
		return resarr;
	}

	/** Setter: Input value used for unconnected socket */
	void default_value(float values[3]) { /* not implemented */ }

};

/**************** Vector Node Socket Interface ****************/

/**
 * 3D vector socket of a node
 */
class NodeSocketInterfaceVectorAcceleration : public NodeSocketInterfaceStandard {
public:
	NodeSocketInterfaceVectorAcceleration(PyObject* pyobj) : NodeSocketInterfaceStandard(pyobj) {}

	NodeSocketInterfaceVectorAcceleration() : NodeSocketInterfaceStandard(0)
	{
		// not implemented
	}

	/** Getter: Input value used for unconnected socket */
	std::array<float, 3> default_value() {
		// TODO: MISSING DEREF! USE #DEFINE!
		PyObject *seqval = PyObject_GetAttrString(pyobjref, "default_value");
		std::array<float, 3> resarr;
		for (int i = 0; i < 3; i++)
			resarr[i] = (float)PyFloat_AsDouble(PySequence_GetItem(seqval, i));
		return resarr;
	}

	/** Setter: Input value used for unconnected socket */
	void default_value(float values[3]) { /* not implemented */ }

	/** Getter: Minimum value */
	float min_value() { /* not implemented */ throw NULL; }
	/** Setter: Minimum value */
	void min_value(float value) {
		PyObject_SetAttrString(pyobjref, "min_value", Py_BuildValue("f", value));
	}

	/** Getter: Maximum value */
	float max_value() { /* not implemented */ throw NULL; }
	/** Setter: Maximum value */
	void max_value(float value) {
		PyObject_SetAttrString(pyobjref, "max_value", Py_BuildValue("f", value));
	}

};

/**************** Vector Node Socket ****************/

/**
 * 3D vector socket of a node
 */
class NodeSocketVectorEuler : public NodeSocketStandard {
public:
	NodeSocketVectorEuler(PyObject* pyobj) : NodeSocketStandard(pyobj) {}

	NodeSocketVectorEuler() : NodeSocketStandard(0)
	{
		// not implemented
	}

	/** Getter: Input value used for unconnected socket */
	std::array<float, 3> default_value() {
		// TODO: MISSING DEREF! USE #DEFINE!
		PyObject *seqval = PyObject_GetAttrString(pyobjref, "default_value");
		std::array<float, 3> resarr;
		for (int i = 0; i < 3; i++)
			resarr[i] = (float)PyFloat_AsDouble(PySequence_GetItem(seqval, i));
		return resarr;
	}

	/** Setter: Input value used for unconnected socket */
	void default_value(float values[3]) { /* not implemented */ }

};

/**************** Vector Node Socket Interface ****************/

/**
 * 3D vector socket of a node
 */
class NodeSocketInterfaceVectorEuler : public NodeSocketInterfaceStandard {
public:
	NodeSocketInterfaceVectorEuler(PyObject* pyobj) : NodeSocketInterfaceStandard(pyobj) {}

	NodeSocketInterfaceVectorEuler() : NodeSocketInterfaceStandard(0)
	{
		// not implemented
	}

	/** Getter: Input value used for unconnected socket */
	std::array<float, 3> default_value() {
		// TODO: MISSING DEREF! USE #DEFINE!
		PyObject *seqval = PyObject_GetAttrString(pyobjref, "default_value");
		std::array<float, 3> resarr;
		for (int i = 0; i < 3; i++)
			resarr[i] = (float)PyFloat_AsDouble(PySequence_GetItem(seqval, i));
		return resarr;
	}

	/** Setter: Input value used for unconnected socket */
	void default_value(float values[3]) { /* not implemented */ }

	/** Getter: Minimum value */
	float min_value() { /* not implemented */ throw NULL; }
	/** Setter: Minimum value */
	void min_value(float value) {
		PyObject_SetAttrString(pyobjref, "min_value", Py_BuildValue("f", value));
	}

	/** Getter: Maximum value */
	float max_value() { /* not implemented */ throw NULL; }
	/** Setter: Maximum value */
	void max_value(float value) {
		PyObject_SetAttrString(pyobjref, "max_value", Py_BuildValue("f", value));
	}

};

/**************** Vector Node Socket ****************/

/**
 * 3D vector socket of a node
 */
class NodeSocketVectorXYZ : public NodeSocketStandard {
public:
	NodeSocketVectorXYZ(PyObject* pyobj) : NodeSocketStandard(pyobj) {}

	NodeSocketVectorXYZ() : NodeSocketStandard(0)
	{
		// not implemented
	}

	/** Getter: Input value used for unconnected socket */
	std::array<float, 3> default_value() {
		// TODO: MISSING DEREF! USE #DEFINE!
		PyObject *seqval = PyObject_GetAttrString(pyobjref, "default_value");
		std::array<float, 3> resarr;
		for (int i = 0; i < 3; i++)
			resarr[i] = (float)PyFloat_AsDouble(PySequence_GetItem(seqval, i));
		return resarr;
	}

	/** Setter: Input value used for unconnected socket */
	void default_value(float values[3]) { /* not implemented */ }

};

/**************** Vector Node Socket Interface ****************/

/**
 * 3D vector socket of a node
 */
class NodeSocketInterfaceVectorXYZ : public NodeSocketInterfaceStandard {
public:
	NodeSocketInterfaceVectorXYZ(PyObject* pyobj) : NodeSocketInterfaceStandard(pyobj) {}

	NodeSocketInterfaceVectorXYZ() : NodeSocketInterfaceStandard(0)
	{
		// not implemented
	}

	/** Getter: Input value used for unconnected socket */
	std::array<float, 3> default_value() {
		// TODO: MISSING DEREF! USE #DEFINE!
		PyObject *seqval = PyObject_GetAttrString(pyobjref, "default_value");
		std::array<float, 3> resarr;
		for (int i = 0; i < 3; i++)
			resarr[i] = (float)PyFloat_AsDouble(PySequence_GetItem(seqval, i));
		return resarr;
	}

	/** Setter: Input value used for unconnected socket */
	void default_value(float values[3]) { /* not implemented */ }

	/** Getter: Minimum value */
	float min_value() { /* not implemented */ throw NULL; }
	/** Setter: Minimum value */
	void min_value(float value) {
		PyObject_SetAttrString(pyobjref, "min_value", Py_BuildValue("f", value));
	}

	/** Getter: Maximum value */
	float max_value() { /* not implemented */ throw NULL; }
	/** Setter: Maximum value */
	void max_value(float value) {
		PyObject_SetAttrString(pyobjref, "max_value", Py_BuildValue("f", value));
	}

};

/**************** Color Node Socket ****************/

/**
 * RGBA color socket of a node
 */
class NodeSocketColor : public NodeSocketStandard {
public:
	NodeSocketColor(PyObject* pyobj) : NodeSocketStandard(pyobj) {}

	NodeSocketColor() : NodeSocketStandard(0)
	{
		// not implemented
	}

	/** Getter: Input value used for unconnected socket */
	std::array<float, 4> default_value() {
		// TODO: MISSING DEREF! USE #DEFINE!
		PyObject *seqval = PyObject_GetAttrString(pyobjref, "default_value");
		std::array<float, 4> resarr;
		for (int i = 0; i < 4; i++)
			resarr[i] = (float)PyFloat_AsDouble(PySequence_GetItem(seqval, i));
		return resarr;
	}

	/** Setter: Input value used for unconnected socket */
	void default_value(float values[4]) { /* not implemented */ }

};

/**************** Color Node Socket Interface ****************/

/**
 * RGBA color socket of a node
 */
class NodeSocketInterfaceColor : public NodeSocketInterfaceStandard {
public:
	NodeSocketInterfaceColor(PyObject* pyobj) : NodeSocketInterfaceStandard(pyobj) {}

	NodeSocketInterfaceColor() : NodeSocketInterfaceStandard(0)
	{
		// not implemented
	}

	/** Getter: Input value used for unconnected socket */
	std::array<float, 4> default_value() {
		// TODO: MISSING DEREF! USE #DEFINE!
		PyObject *seqval = PyObject_GetAttrString(pyobjref, "default_value");
		std::array<float, 4> resarr;
		for (int i = 0; i < 4; i++)
			resarr[i] = (float)PyFloat_AsDouble(PySequence_GetItem(seqval, i));
		return resarr;
	}

	/** Setter: Input value used for unconnected socket */
	void default_value(float values[4]) { /* not implemented */ }

};

/**************** String Node Socket ****************/

/**
 * String socket of a node
 */
class NodeSocketString : public NodeSocketStandard {
public:
	NodeSocketString(PyObject* pyobj) : NodeSocketStandard(pyobj) {}

	NodeSocketString() : NodeSocketStandard(0)
	{
		// not implemented
	}

	/** Getter: Input value used for unconnected socket */
	std::string default_value() { /* not implemented */ throw NULL; }
	/** Setter: Input value used for unconnected socket */
	void default_value(const std::string& value) { /* not implemented */ }

};

/**************** String Node Socket Interface ****************/

/**
 * String socket of a node
 */
class NodeSocketInterfaceString : public NodeSocketInterfaceStandard {
public:
	NodeSocketInterfaceString(PyObject* pyobj) : NodeSocketInterfaceStandard(pyobj) {}

	NodeSocketInterfaceString() : NodeSocketInterfaceStandard(0)
	{
		// not implemented
	}

	/** Getter: Input value used for unconnected socket */
	std::string default_value() { /* not implemented */ throw NULL; }
	/** Setter: Input value used for unconnected socket */
	void default_value(const std::string& value) { /* not implemented */ }

};

/**************** Shader Node Socket ****************/

/**
 * Shader socket of a node
 */
class NodeSocketShader : public NodeSocketStandard {
public:
	NodeSocketShader(PyObject* pyobj) : NodeSocketStandard(pyobj) {}

	NodeSocketShader() : NodeSocketStandard(0)
	{
		// not implemented
	}

};

/**************** Shader Node Socket Interface ****************/

/**
 * Shader socket of a node
 */
class NodeSocketInterfaceShader : public NodeSocketInterfaceStandard {
public:
	NodeSocketInterfaceShader(PyObject* pyobj) : NodeSocketInterfaceStandard(pyobj) {}

	NodeSocketInterfaceShader() : NodeSocketInterfaceStandard(0)
	{
		// not implemented
	}

};

/**************** Virtual Node Socket ****************/

/**
 * Virtual socket of a node
 */
class NodeSocketVirtual : public NodeSocketStandard {
public:
	NodeSocketVirtual(PyObject* pyobj) : NodeSocketStandard(pyobj) {}

	NodeSocketVirtual() : NodeSocketStandard(0)
	{
		// not implemented
	}

};

/**************** Compositor Node Tree ****************/

/**
 * Node tree consisting of linked nodes used for compositing
 */
class CompositorNodeTree : public NodeTree {
public:
	CompositorNodeTree(PyObject* pyobj) : NodeTree(pyobj) {}

	CompositorNodeTree() : NodeTree(0)
	{
		// not implemented
	}

	enum render_quality_enum {
		render_quality_HIGH = 0,
		render_quality_MEDIUM = 1,
		render_quality_LOW = 2,
	};

	/** Getter: Quality when rendering */
	render_quality_enum render_quality() { /* not implemented */ throw NULL; }
	/** Setter: Quality when rendering */
	void render_quality(render_quality_enum value) { /* not implemented */ }

	enum edit_quality_enum {
		edit_quality_HIGH = 0,
		edit_quality_MEDIUM = 1,
		edit_quality_LOW = 2,
	};

	/** Getter: Quality when editing */
	edit_quality_enum edit_quality() { /* not implemented */ throw NULL; }
	/** Setter: Quality when editing */
	void edit_quality(edit_quality_enum value) { /* not implemented */ }

	enum chunk_size_enum {
		chunk_size_32 = 32,
		chunk_size_64 = 64,
		chunk_size_128 = 128,
		chunk_size_256 = 256,
		chunk_size_512 = 512,
		chunk_size_1024 = 1024,
	};

	/** Getter: Max size of a tile (smaller values gives better distribution of multiple threads, but more overhead) */
	chunk_size_enum chunk_size() { /* not implemented */ throw NULL; }
	/** Setter: Max size of a tile (smaller values gives better distribution of multiple threads, but more overhead) */
	void chunk_size(chunk_size_enum value) { /* not implemented */ }

	/** Getter: Enable GPU calculations */
	bool use_opencl() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_opencl")) == 1;
	}

	/** Setter: Enable GPU calculations */
	void use_opencl(bool value) {
		PyObject_SetAttrString(pyobjref, "use_opencl", Py_BuildValue("i", value));
	}

	/** Getter: Enable buffering of group nodes */
	bool use_groupnode_buffer() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_groupnode_buffer")) == 1;
	}

	/** Setter: Enable buffering of group nodes */
	void use_groupnode_buffer(bool value) {
		PyObject_SetAttrString(pyobjref, "use_groupnode_buffer", Py_BuildValue("i", value));
	}

	/** Getter: Use two pass execution during editing: first calculate fast nodes, second pass calculate all nodes */
	bool use_two_pass() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_two_pass")) == 1;
	}

	/** Setter: Use two pass execution during editing: first calculate fast nodes, second pass calculate all nodes */
	void use_two_pass(bool value) {
		PyObject_SetAttrString(pyobjref, "use_two_pass", Py_BuildValue("i", value));
	}

	/** Getter: Use boundaries for viewer nodes and composite backdrop */
	bool use_viewer_border() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_viewer_border")) == 1;
	}

	/** Setter: Use boundaries for viewer nodes and composite backdrop */
	void use_viewer_border(bool value) {
		PyObject_SetAttrString(pyobjref, "use_viewer_border", Py_BuildValue("i", value));
	}

};

/**************** Shader Node Tree ****************/

/**
 * Node tree consisting of linked nodes used for materials (and other shading datablocks)
 */
class ShaderNodeTree : public NodeTree {
public:
	ShaderNodeTree(PyObject* pyobj) : NodeTree(pyobj) {}

	ShaderNodeTree() : NodeTree(0)
	{
		// not implemented
	}

};

/**************** Texture Node Tree ****************/

/**
 * Node tree consisting of linked nodes used for textures
 */
class TextureNodeTree : public NodeTree {
public:
	TextureNodeTree(PyObject* pyobj) : NodeTree(pyobj) {}

	TextureNodeTree() : NodeTree(0)
	{
		// not implemented
	}

};

/**************** Frame ****************/

/**
 * 
 */
class NodeFrame : public NodeInternal {
public:
	NodeFrame(PyObject* pyobj) : NodeInternal(pyobj) {}

	NodeFrame() : NodeInternal(0)
	{
		// not implemented
	}

	/** Getter:  */
	Text text();

	/** Getter: Shrink the frame to minimal bounding box */
	bool shrink() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "shrink")) == 1;
	}

	/** Setter: Shrink the frame to minimal bounding box */
	void shrink(bool value) {
		PyObject_SetAttrString(pyobjref, "shrink", Py_BuildValue("i", value));
	}

	/** Getter: Font size to use for displaying the label */
	int label_size() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "label_size"));
	}

	/** Setter: Font size to use for displaying the label */
	void label_size(int value) {
		PyObject_SetAttrString(pyobjref, "label_size", Py_BuildValue("i", value));
	}

	/**
	 * True if a registered node type
	 * @return 
	 */
	bool is_registered_node_type()
	{
		// not implemented
		return true;
	}

	/**
	 * Input socket template
	 * @param Param 'index'
	 * @return 
	 */
	NodeInternalSocketTemplate input_template(int index)
	{
		// not implemented
		return NodeInternalSocketTemplate();
	}

	/**
	 * Output socket template
	 * @param Param 'index'
	 * @return 
	 */
	NodeInternalSocketTemplate output_template(int index)
	{
		// not implemented
		return NodeInternalSocketTemplate();
	}

};

/**************** Group ****************/

/**
 * 
 */
class NodeGroup : public NodeInternal {
public:
	NodeGroup(PyObject* pyobj) : NodeInternal(pyobj) {}

	NodeGroup() : NodeInternal(0)
	{
		// not implemented
	}

	/** Getter:  */
	NodeTree node_tree() {
		/* not implemented */ throw NULL;
	}

	/** Getter: Interface socket data */
	PropertyGroup interface_value() {
		/* not implemented */ throw NULL;
	}

	/**
	 * True if a registered node type
	 * @return 
	 */
	bool is_registered_node_type()
	{
		// not implemented
		return true;
	}

	/**
	 * Input socket template
	 * @param Param 'index'
	 * @return 
	 */
	NodeInternalSocketTemplate input_template(int index)
	{
		// not implemented
		return NodeInternalSocketTemplate();
	}

	/**
	 * Output socket template
	 * @param Param 'index'
	 * @return 
	 */
	NodeInternalSocketTemplate output_template(int index)
	{
		// not implemented
		return NodeInternalSocketTemplate();
	}

};

/**************** Group Input ****************/

/**
 * 
 */
class NodeGroupInput : public NodeInternal {
public:
	NodeGroupInput(PyObject* pyobj) : NodeInternal(pyobj) {}

	NodeGroupInput() : NodeInternal(0)
	{
		// not implemented
	}

	/** Getter: Interface socket data */
	PropertyGroup interface_value() {
		/* not implemented */ throw NULL;
	}

	/**
	 * True if a registered node type
	 * @return 
	 */
	bool is_registered_node_type()
	{
		// not implemented
		return true;
	}

	/**
	 * Input socket template
	 * @param Param 'index'
	 * @return 
	 */
	NodeInternalSocketTemplate input_template(int index)
	{
		// not implemented
		return NodeInternalSocketTemplate();
	}

	/**
	 * Output socket template
	 * @param Param 'index'
	 * @return 
	 */
	NodeInternalSocketTemplate output_template(int index)
	{
		// not implemented
		return NodeInternalSocketTemplate();
	}

};

/**************** Group Output ****************/

/**
 * 
 */
class NodeGroupOutput : public NodeInternal {
public:
	NodeGroupOutput(PyObject* pyobj) : NodeInternal(pyobj) {}

	NodeGroupOutput() : NodeInternal(0)
	{
		// not implemented
	}

	/** Getter: Interface socket data */
	PropertyGroup interface_value() {
		/* not implemented */ throw NULL;
	}

	/** Getter: True if this node is used as the active group output */
	bool is_active_output() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "is_active_output")) == 1;
	}

	/** Setter: True if this node is used as the active group output */
	void is_active_output(bool value) {
		PyObject_SetAttrString(pyobjref, "is_active_output", Py_BuildValue("i", value));
	}

	/**
	 * True if a registered node type
	 * @return 
	 */
	bool is_registered_node_type()
	{
		// not implemented
		return true;
	}

	/**
	 * Input socket template
	 * @param Param 'index'
	 * @return 
	 */
	NodeInternalSocketTemplate input_template(int index)
	{
		// not implemented
		return NodeInternalSocketTemplate();
	}

	/**
	 * Output socket template
	 * @param Param 'index'
	 * @return 
	 */
	NodeInternalSocketTemplate output_template(int index)
	{
		// not implemented
		return NodeInternalSocketTemplate();
	}

};

/**************** Reroute ****************/

/**
 * 
 */
class NodeReroute : public NodeInternal {
public:
	NodeReroute(PyObject* pyobj) : NodeInternal(pyobj) {}

	NodeReroute() : NodeInternal(0)
	{
		// not implemented
	}

	/**
	 * True if a registered node type
	 * @return 
	 */
	bool is_registered_node_type()
	{
		// not implemented
		return true;
	}

	/**
	 * Input socket template
	 * @param Param 'index'
	 * @return 
	 */
	NodeInternalSocketTemplate input_template(int index)
	{
		// not implemented
		return NodeInternalSocketTemplate();
	}

	/**
	 * Output socket template
	 * @param Param 'index'
	 * @return 
	 */
	NodeInternalSocketTemplate output_template(int index)
	{
		// not implemented
		return NodeInternalSocketTemplate();
	}

};

/**************** Output ****************/

/**
 * 
 */
class ShaderNodeOutput : public ShaderNode {
public:
	ShaderNodeOutput(PyObject* pyobj) : ShaderNode(pyobj) {}

	ShaderNodeOutput() : ShaderNode(0)
	{
		// not implemented
	}

	/** Getter: True if this node is used as the active output */
	bool is_active_output() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "is_active_output")) == 1;
	}

	/** Setter: True if this node is used as the active output */
	void is_active_output(bool value) {
		PyObject_SetAttrString(pyobjref, "is_active_output", Py_BuildValue("i", value));
	}

	/**
	 * True if a registered node type
	 * @return 
	 */
	bool is_registered_node_type()
	{
		// not implemented
		return true;
	}

	/**
	 * Input socket template
	 * @param Param 'index'
	 * @return 
	 */
	NodeInternalSocketTemplate input_template(int index)
	{
		// not implemented
		return NodeInternalSocketTemplate();
	}

	/**
	 * Output socket template
	 * @param Param 'index'
	 * @return 
	 */
	NodeInternalSocketTemplate output_template(int index)
	{
		// not implemented
		return NodeInternalSocketTemplate();
	}

};

/**************** Material ****************/

/**
 * 
 */
class ShaderNodeMaterial : public ShaderNode {
public:
	ShaderNodeMaterial(PyObject* pyobj) : ShaderNode(pyobj) {}

	ShaderNodeMaterial() : ShaderNode(0)
	{
		// not implemented
	}

	/** Getter:  */
	Material material() {
		/* not implemented */ throw NULL;
	}

	/** Getter: Material Node outputs Diffuse */
	bool use_diffuse() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_diffuse")) == 1;
	}

	/** Setter: Material Node outputs Diffuse */
	void use_diffuse(bool value) {
		PyObject_SetAttrString(pyobjref, "use_diffuse", Py_BuildValue("i", value));
	}

	/** Getter: Material Node outputs Specular */
	bool use_specular() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_specular")) == 1;
	}

	/** Setter: Material Node outputs Specular */
	void use_specular(bool value) {
		PyObject_SetAttrString(pyobjref, "use_specular", Py_BuildValue("i", value));
	}

	/** Getter: Material Node uses inverted normal */
	bool invert_normal() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "invert_normal")) == 1;
	}

	/** Setter: Material Node uses inverted normal */
	void invert_normal(bool value) {
		PyObject_SetAttrString(pyobjref, "invert_normal", Py_BuildValue("i", value));
	}

	/**
	 * True if a registered node type
	 * @return 
	 */
	bool is_registered_node_type()
	{
		// not implemented
		return true;
	}

	/**
	 * Input socket template
	 * @param Param 'index'
	 * @return 
	 */
	NodeInternalSocketTemplate input_template(int index)
	{
		// not implemented
		return NodeInternalSocketTemplate();
	}

	/**
	 * Output socket template
	 * @param Param 'index'
	 * @return 
	 */
	NodeInternalSocketTemplate output_template(int index)
	{
		// not implemented
		return NodeInternalSocketTemplate();
	}

};

/**************** RGB ****************/

/**
 * 
 */
class ShaderNodeRGB : public ShaderNode {
public:
	ShaderNodeRGB(PyObject* pyobj) : ShaderNode(pyobj) {}

	ShaderNodeRGB() : ShaderNode(0)
	{
		// not implemented
	}

	/**
	 * True if a registered node type
	 * @return 
	 */
	bool is_registered_node_type()
	{
		// not implemented
		return true;
	}

	/**
	 * Input socket template
	 * @param Param 'index'
	 * @return 
	 */
	NodeInternalSocketTemplate input_template(int index)
	{
		// not implemented
		return NodeInternalSocketTemplate();
	}

	/**
	 * Output socket template
	 * @param Param 'index'
	 * @return 
	 */
	NodeInternalSocketTemplate output_template(int index)
	{
		// not implemented
		return NodeInternalSocketTemplate();
	}

};

/**************** Value ****************/

/**
 * 
 */
class ShaderNodeValue : public ShaderNode {
public:
	ShaderNodeValue(PyObject* pyobj) : ShaderNode(pyobj) {}

	ShaderNodeValue() : ShaderNode(0)
	{
		// not implemented
	}

	/**
	 * True if a registered node type
	 * @return 
	 */
	bool is_registered_node_type()
	{
		// not implemented
		return true;
	}

	/**
	 * Input socket template
	 * @param Param 'index'
	 * @return 
	 */
	NodeInternalSocketTemplate input_template(int index)
	{
		// not implemented
		return NodeInternalSocketTemplate();
	}

	/**
	 * Output socket template
	 * @param Param 'index'
	 * @return 
	 */
	NodeInternalSocketTemplate output_template(int index)
	{
		// not implemented
		return NodeInternalSocketTemplate();
	}

};

/**************** MixRGB ****************/

/**
 * 
 */
class ShaderNodeMixRGB : public ShaderNode {
public:
	ShaderNodeMixRGB(PyObject* pyobj) : ShaderNode(pyobj) {}

	ShaderNodeMixRGB() : ShaderNode(0)
	{
		// not implemented
	}

	enum blend_type_enum {
		blend_type_MIX = 0,
		blend_type_ADD = 1,
		blend_type_MULTIPLY = 2,
		blend_type_SUBTRACT = 3,
		blend_type_SCREEN = 4,
		blend_type_DIVIDE = 5,
		blend_type_DIFFERENCE = 6,
		blend_type_DARKEN = 7,
		blend_type_LIGHTEN = 8,
		blend_type_OVERLAY = 9,
		blend_type_DODGE = 10,
		blend_type_BURN = 11,
		blend_type_HUE = 12,
		blend_type_SATURATION = 13,
		blend_type_VALUE = 14,
		blend_type_COLOR = 15,
		blend_type_SOFT_LIGHT = 16,
		blend_type_LINEAR_LIGHT = 17,
	};

	/** Getter:  */
	blend_type_enum blend_type() { /* not implemented */ throw NULL; }
	/** Setter:  */
	void blend_type(blend_type_enum value) { /* not implemented */ }

	/** Getter: Include alpha of second input in this operation */
	bool use_alpha() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_alpha")) == 1;
	}

	/** Setter: Include alpha of second input in this operation */
	void use_alpha(bool value) {
		PyObject_SetAttrString(pyobjref, "use_alpha", Py_BuildValue("i", value));
	}

	/** Getter: Clamp result of the node to 0..1 range */
	bool use_clamp() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_clamp")) == 1;
	}

	/** Setter: Clamp result of the node to 0..1 range */
	void use_clamp(bool value) {
		PyObject_SetAttrString(pyobjref, "use_clamp", Py_BuildValue("i", value));
	}

	/**
	 * True if a registered node type
	 * @return 
	 */
	bool is_registered_node_type()
	{
		// not implemented
		return true;
	}

	/**
	 * Input socket template
	 * @param Param 'index'
	 * @return 
	 */
	NodeInternalSocketTemplate input_template(int index)
	{
		// not implemented
		return NodeInternalSocketTemplate();
	}

	/**
	 * Output socket template
	 * @param Param 'index'
	 * @return 
	 */
	NodeInternalSocketTemplate output_template(int index)
	{
		// not implemented
		return NodeInternalSocketTemplate();
	}

};

/**************** ColorRamp ****************/

/**
 * 
 */
class ShaderNodeValToRGB : public ShaderNode {
public:
	ShaderNodeValToRGB(PyObject* pyobj) : ShaderNode(pyobj) {}

	ShaderNodeValToRGB() : ShaderNode(0)
	{
		// not implemented
	}

	/** Getter:  */
	ColorRamp color_ramp() {
		/* not implemented */ throw NULL;
	}

	/**
	 * True if a registered node type
	 * @return 
	 */
	bool is_registered_node_type()
	{
		// not implemented
		return true;
	}

	/**
	 * Input socket template
	 * @param Param 'index'
	 * @return 
	 */
	NodeInternalSocketTemplate input_template(int index)
	{
		// not implemented
		return NodeInternalSocketTemplate();
	}

	/**
	 * Output socket template
	 * @param Param 'index'
	 * @return 
	 */
	NodeInternalSocketTemplate output_template(int index)
	{
		// not implemented
		return NodeInternalSocketTemplate();
	}

};

/**************** RGB to BW ****************/

/**
 * 
 */
class ShaderNodeRGBToBW : public ShaderNode {
public:
	ShaderNodeRGBToBW(PyObject* pyobj) : ShaderNode(pyobj) {}

	ShaderNodeRGBToBW() : ShaderNode(0)
	{
		// not implemented
	}

	/**
	 * True if a registered node type
	 * @return 
	 */
	bool is_registered_node_type()
	{
		// not implemented
		return true;
	}

	/**
	 * Input socket template
	 * @param Param 'index'
	 * @return 
	 */
	NodeInternalSocketTemplate input_template(int index)
	{
		// not implemented
		return NodeInternalSocketTemplate();
	}

	/**
	 * Output socket template
	 * @param Param 'index'
	 * @return 
	 */
	NodeInternalSocketTemplate output_template(int index)
	{
		// not implemented
		return NodeInternalSocketTemplate();
	}

};

/**************** Texture ****************/

/**
 * 
 */
class ShaderNodeTexture : public ShaderNode {
public:
	ShaderNodeTexture(PyObject* pyobj) : ShaderNode(pyobj) {}

	ShaderNodeTexture() : ShaderNode(0)
	{
		// not implemented
	}

	/** Getter:  */
	Texture texture() {
		/* not implemented */ throw NULL;
	}

	/** Getter: For node-based textures, which output node to use */
	int node_output() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "node_output"));
	}

	/** Setter: For node-based textures, which output node to use */
	void node_output(int value) {
		PyObject_SetAttrString(pyobjref, "node_output", Py_BuildValue("i", value));
	}

	/**
	 * True if a registered node type
	 * @return 
	 */
	bool is_registered_node_type()
	{
		// not implemented
		return true;
	}

	/**
	 * Input socket template
	 * @param Param 'index'
	 * @return 
	 */
	NodeInternalSocketTemplate input_template(int index)
	{
		// not implemented
		return NodeInternalSocketTemplate();
	}

	/**
	 * Output socket template
	 * @param Param 'index'
	 * @return 
	 */
	NodeInternalSocketTemplate output_template(int index)
	{
		// not implemented
		return NodeInternalSocketTemplate();
	}

};

/**************** Normal ****************/

/**
 * 
 */
class ShaderNodeNormal : public ShaderNode {
public:
	ShaderNodeNormal(PyObject* pyobj) : ShaderNode(pyobj) {}

	ShaderNodeNormal() : ShaderNode(0)
	{
		// not implemented
	}

	/**
	 * True if a registered node type
	 * @return 
	 */
	bool is_registered_node_type()
	{
		// not implemented
		return true;
	}

	/**
	 * Input socket template
	 * @param Param 'index'
	 * @return 
	 */
	NodeInternalSocketTemplate input_template(int index)
	{
		// not implemented
		return NodeInternalSocketTemplate();
	}

	/**
	 * Output socket template
	 * @param Param 'index'
	 * @return 
	 */
	NodeInternalSocketTemplate output_template(int index)
	{
		// not implemented
		return NodeInternalSocketTemplate();
	}

};

/**************** Gamma ****************/

/**
 * 
 */
class ShaderNodeGamma : public ShaderNode {
public:
	ShaderNodeGamma(PyObject* pyobj) : ShaderNode(pyobj) {}

	ShaderNodeGamma() : ShaderNode(0)
	{
		// not implemented
	}

	/**
	 * True if a registered node type
	 * @return 
	 */
	bool is_registered_node_type()
	{
		// not implemented
		return true;
	}

	/**
	 * Input socket template
	 * @param Param 'index'
	 * @return 
	 */
	NodeInternalSocketTemplate input_template(int index)
	{
		// not implemented
		return NodeInternalSocketTemplate();
	}

	/**
	 * Output socket template
	 * @param Param 'index'
	 * @return 
	 */
	NodeInternalSocketTemplate output_template(int index)
	{
		// not implemented
		return NodeInternalSocketTemplate();
	}

};

/**************** Bright Contrast ****************/

/**
 * 
 */
class ShaderNodeBrightContrast : public ShaderNode {
public:
	ShaderNodeBrightContrast(PyObject* pyobj) : ShaderNode(pyobj) {}

	ShaderNodeBrightContrast() : ShaderNode(0)
	{
		// not implemented
	}

	/**
	 * True if a registered node type
	 * @return 
	 */
	bool is_registered_node_type()
	{
		// not implemented
		return true;
	}

	/**
	 * Input socket template
	 * @param Param 'index'
	 * @return 
	 */
	NodeInternalSocketTemplate input_template(int index)
	{
		// not implemented
		return NodeInternalSocketTemplate();
	}

	/**
	 * Output socket template
	 * @param Param 'index'
	 * @return 
	 */
	NodeInternalSocketTemplate output_template(int index)
	{
		// not implemented
		return NodeInternalSocketTemplate();
	}

};

/**************** Geometry ****************/

/**
 * 
 */
class ShaderNodeGeometry : public ShaderNode {
public:
	ShaderNodeGeometry(PyObject* pyobj) : ShaderNode(pyobj) {}

	ShaderNodeGeometry() : ShaderNode(0)
	{
		// not implemented
	}

	/** Getter:  */
	std::string uv_layer() { /* not implemented */ throw NULL; }
	/** Setter:  */
	void uv_layer(const std::string& value) { /* not implemented */ }

	/** Getter:  */
	std::string color_layer() { /* not implemented */ throw NULL; }
	/** Setter:  */
	void color_layer(const std::string& value) { /* not implemented */ }

	/**
	 * True if a registered node type
	 * @return 
	 */
	bool is_registered_node_type()
	{
		// not implemented
		return true;
	}

	/**
	 * Input socket template
	 * @param Param 'index'
	 * @return 
	 */
	NodeInternalSocketTemplate input_template(int index)
	{
		// not implemented
		return NodeInternalSocketTemplate();
	}

	/**
	 * Output socket template
	 * @param Param 'index'
	 * @return 
	 */
	NodeInternalSocketTemplate output_template(int index)
	{
		// not implemented
		return NodeInternalSocketTemplate();
	}

};

/**************** Mapping ****************/

/**
 * 
 */
class ShaderNodeMapping : public ShaderNode {
public:
	ShaderNodeMapping(PyObject* pyobj) : ShaderNode(pyobj) {}

	ShaderNodeMapping() : ShaderNode(0)
	{
		// not implemented
	}

	enum vector_type_enum {
		vector_type_TEXTURE = 1,
		vector_type_POINT = 0,
		vector_type_VECTOR = 2,
		vector_type_NORMAL = 3,
	};

	/** Getter: Type of vector that the mapping transforms */
	vector_type_enum vector_type() { /* not implemented */ throw NULL; }
	/** Setter: Type of vector that the mapping transforms */
	void vector_type(vector_type_enum value) { /* not implemented */ }

	/** Getter:  */
	std::array<float, 3> translation() {
		// TODO: MISSING DEREF! USE #DEFINE!
		PyObject *seqval = PyObject_GetAttrString(pyobjref, "translation");
		std::array<float, 3> resarr;
		for (int i = 0; i < 3; i++)
			resarr[i] = (float)PyFloat_AsDouble(PySequence_GetItem(seqval, i));
		return resarr;
	}

	/** Setter:  */
	void translation(float values[3]) { /* not implemented */ }

	/** Getter:  */
	std::array<float, 3> rotation() {
		// TODO: MISSING DEREF! USE #DEFINE!
		PyObject *seqval = PyObject_GetAttrString(pyobjref, "rotation");
		std::array<float, 3> resarr;
		for (int i = 0; i < 3; i++)
			resarr[i] = (float)PyFloat_AsDouble(PySequence_GetItem(seqval, i));
		return resarr;
	}

	/** Setter:  */
	void rotation(float values[3]) { /* not implemented */ }

	/** Getter:  */
	std::array<float, 3> scale() {
		// TODO: MISSING DEREF! USE #DEFINE!
		PyObject *seqval = PyObject_GetAttrString(pyobjref, "scale");
		std::array<float, 3> resarr;
		for (int i = 0; i < 3; i++)
			resarr[i] = (float)PyFloat_AsDouble(PySequence_GetItem(seqval, i));
		return resarr;
	}

	/** Setter:  */
	void scale(float values[3]) { /* not implemented */ }

	/** Getter: Minimum value for clipping */
	std::array<float, 3> min() {
		// TODO: MISSING DEREF! USE #DEFINE!
		PyObject *seqval = PyObject_GetAttrString(pyobjref, "min");
		std::array<float, 3> resarr;
		for (int i = 0; i < 3; i++)
			resarr[i] = (float)PyFloat_AsDouble(PySequence_GetItem(seqval, i));
		return resarr;
	}

	/** Setter: Minimum value for clipping */
	void min(float values[3]) { /* not implemented */ }

	/** Getter: Maximum value for clipping */
	std::array<float, 3> max() {
		// TODO: MISSING DEREF! USE #DEFINE!
		PyObject *seqval = PyObject_GetAttrString(pyobjref, "max");
		std::array<float, 3> resarr;
		for (int i = 0; i < 3; i++)
			resarr[i] = (float)PyFloat_AsDouble(PySequence_GetItem(seqval, i));
		return resarr;
	}

	/** Setter: Maximum value for clipping */
	void max(float values[3]) { /* not implemented */ }

	/** Getter: Whether to use minimum clipping value */
	bool use_min() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_min")) == 1;
	}

	/** Setter: Whether to use minimum clipping value */
	void use_min(bool value) {
		PyObject_SetAttrString(pyobjref, "use_min", Py_BuildValue("i", value));
	}

	/** Getter: Whether to use maximum clipping value */
	bool use_max() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_max")) == 1;
	}

	/** Setter: Whether to use maximum clipping value */
	void use_max(bool value) {
		PyObject_SetAttrString(pyobjref, "use_max", Py_BuildValue("i", value));
	}

	/**
	 * True if a registered node type
	 * @return 
	 */
	bool is_registered_node_type()
	{
		// not implemented
		return true;
	}

	/**
	 * Input socket template
	 * @param Param 'index'
	 * @return 
	 */
	NodeInternalSocketTemplate input_template(int index)
	{
		// not implemented
		return NodeInternalSocketTemplate();
	}

	/**
	 * Output socket template
	 * @param Param 'index'
	 * @return 
	 */
	NodeInternalSocketTemplate output_template(int index)
	{
		// not implemented
		return NodeInternalSocketTemplate();
	}

};

/**************** Vector Curves ****************/

/**
 * 
 */
class ShaderNodeVectorCurve : public ShaderNode {
public:
	ShaderNodeVectorCurve(PyObject* pyobj) : ShaderNode(pyobj) {}

	ShaderNodeVectorCurve() : ShaderNode(0)
	{
		// not implemented
	}

	/** Getter:  */
	CurveMapping mapping() {
		/* not implemented */ throw NULL;
	}

	/**
	 * True if a registered node type
	 * @return 
	 */
	bool is_registered_node_type()
	{
		// not implemented
		return true;
	}

	/**
	 * Input socket template
	 * @param Param 'index'
	 * @return 
	 */
	NodeInternalSocketTemplate input_template(int index)
	{
		// not implemented
		return NodeInternalSocketTemplate();
	}

	/**
	 * Output socket template
	 * @param Param 'index'
	 * @return 
	 */
	NodeInternalSocketTemplate output_template(int index)
	{
		// not implemented
		return NodeInternalSocketTemplate();
	}

};

/**************** RGB Curves ****************/

/**
 * 
 */
class ShaderNodeRGBCurve : public ShaderNode {
public:
	ShaderNodeRGBCurve(PyObject* pyobj) : ShaderNode(pyobj) {}

	ShaderNodeRGBCurve() : ShaderNode(0)
	{
		// not implemented
	}

	/** Getter:  */
	CurveMapping mapping() {
		/* not implemented */ throw NULL;
	}

	/**
	 * True if a registered node type
	 * @return 
	 */
	bool is_registered_node_type()
	{
		// not implemented
		return true;
	}

	/**
	 * Input socket template
	 * @param Param 'index'
	 * @return 
	 */
	NodeInternalSocketTemplate input_template(int index)
	{
		// not implemented
		return NodeInternalSocketTemplate();
	}

	/**
	 * Output socket template
	 * @param Param 'index'
	 * @return 
	 */
	NodeInternalSocketTemplate output_template(int index)
	{
		// not implemented
		return NodeInternalSocketTemplate();
	}

};

/**************** Camera Data ****************/

/**
 * 
 */
class ShaderNodeCameraData : public ShaderNode {
public:
	ShaderNodeCameraData(PyObject* pyobj) : ShaderNode(pyobj) {}

	ShaderNodeCameraData() : ShaderNode(0)
	{
		// not implemented
	}

	/**
	 * True if a registered node type
	 * @return 
	 */
	bool is_registered_node_type()
	{
		// not implemented
		return true;
	}

	/**
	 * Input socket template
	 * @param Param 'index'
	 * @return 
	 */
	NodeInternalSocketTemplate input_template(int index)
	{
		// not implemented
		return NodeInternalSocketTemplate();
	}

	/**
	 * Output socket template
	 * @param Param 'index'
	 * @return 
	 */
	NodeInternalSocketTemplate output_template(int index)
	{
		// not implemented
		return NodeInternalSocketTemplate();
	}

};

/**************** Lamp Data ****************/

/**
 * 
 */
class ShaderNodeLampData : public ShaderNode {
public:
	ShaderNodeLampData(PyObject* pyobj) : ShaderNode(pyobj) {}

	ShaderNodeLampData() : ShaderNode(0)
	{
		// not implemented
	}

	/** Getter:  */
	Object lamp_object();

	/**
	 * True if a registered node type
	 * @return 
	 */
	bool is_registered_node_type()
	{
		// not implemented
		return true;
	}

	/**
	 * Input socket template
	 * @param Param 'index'
	 * @return 
	 */
	NodeInternalSocketTemplate input_template(int index)
	{
		// not implemented
		return NodeInternalSocketTemplate();
	}

	/**
	 * Output socket template
	 * @param Param 'index'
	 * @return 
	 */
	NodeInternalSocketTemplate output_template(int index)
	{
		// not implemented
		return NodeInternalSocketTemplate();
	}

};

/**************** Math ****************/

/**
 * 
 */
class ShaderNodeMath : public ShaderNode {
public:
	ShaderNodeMath(PyObject* pyobj) : ShaderNode(pyobj) {}

	ShaderNodeMath() : ShaderNode(0)
	{
		// not implemented
	}

	enum operation_enum {
		operation_ADD = 0,
		operation_SUBTRACT = 1,
		operation_MULTIPLY = 2,
		operation_DIVIDE = 3,
		operation_SINE = 4,
		operation_COSINE = 5,
		operation_TANGENT = 6,
		operation_ARCSINE = 7,
		operation_ARCCOSINE = 8,
		operation_ARCTANGENT = 9,
		operation_POWER = 10,
		operation_LOGARITHM = 11,
		operation_MINIMUM = 12,
		operation_MAXIMUM = 13,
		operation_ROUND = 14,
		operation_LESS_THAN = 15,
		operation_GREATER_THAN = 16,
		operation_MODULO = 17,
		operation_ABSOLUTE = 18,
	};

	/** Getter:  */
	operation_enum operation() { /* not implemented */ throw NULL; }
	/** Setter:  */
	void operation(operation_enum value) { /* not implemented */ }

	/** Getter: Clamp result of the node to 0..1 range */
	bool use_clamp() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_clamp")) == 1;
	}

	/** Setter: Clamp result of the node to 0..1 range */
	void use_clamp(bool value) {
		PyObject_SetAttrString(pyobjref, "use_clamp", Py_BuildValue("i", value));
	}

	/**
	 * True if a registered node type
	 * @return 
	 */
	bool is_registered_node_type()
	{
		// not implemented
		return true;
	}

	/**
	 * Input socket template
	 * @param Param 'index'
	 * @return 
	 */
	NodeInternalSocketTemplate input_template(int index)
	{
		// not implemented
		return NodeInternalSocketTemplate();
	}

	/**
	 * Output socket template
	 * @param Param 'index'
	 * @return 
	 */
	NodeInternalSocketTemplate output_template(int index)
	{
		// not implemented
		return NodeInternalSocketTemplate();
	}

};

/**************** Vector Math ****************/

/**
 * 
 */
class ShaderNodeVectorMath : public ShaderNode {
public:
	ShaderNodeVectorMath(PyObject* pyobj) : ShaderNode(pyobj) {}

	ShaderNodeVectorMath() : ShaderNode(0)
	{
		// not implemented
	}

	enum operation_enum {
		operation_ADD = 0,
		operation_SUBTRACT = 1,
		operation_AVERAGE = 2,
		operation_DOT_PRODUCT = 3,
		operation_CROSS_PRODUCT = 4,
		operation_NORMALIZE = 5,
	};

	/** Getter:  */
	operation_enum operation() { /* not implemented */ throw NULL; }
	/** Setter:  */
	void operation(operation_enum value) { /* not implemented */ }

	/**
	 * True if a registered node type
	 * @return 
	 */
	bool is_registered_node_type()
	{
		// not implemented
		return true;
	}

	/**
	 * Input socket template
	 * @param Param 'index'
	 * @return 
	 */
	NodeInternalSocketTemplate input_template(int index)
	{
		// not implemented
		return NodeInternalSocketTemplate();
	}

	/**
	 * Output socket template
	 * @param Param 'index'
	 * @return 
	 */
	NodeInternalSocketTemplate output_template(int index)
	{
		// not implemented
		return NodeInternalSocketTemplate();
	}

};

/**************** Squeeze Value ****************/

/**
 * 
 */
class ShaderNodeSqueeze : public ShaderNode {
public:
	ShaderNodeSqueeze(PyObject* pyobj) : ShaderNode(pyobj) {}

	ShaderNodeSqueeze() : ShaderNode(0)
	{
		// not implemented
	}

	/**
	 * True if a registered node type
	 * @return 
	 */
	bool is_registered_node_type()
	{
		// not implemented
		return true;
	}

	/**
	 * Input socket template
	 * @param Param 'index'
	 * @return 
	 */
	NodeInternalSocketTemplate input_template(int index)
	{
		// not implemented
		return NodeInternalSocketTemplate();
	}

	/**
	 * Output socket template
	 * @param Param 'index'
	 * @return 
	 */
	NodeInternalSocketTemplate output_template(int index)
	{
		// not implemented
		return NodeInternalSocketTemplate();
	}

};

/**************** Extended Material ****************/

/**
 * 
 */
class ShaderNodeExtendedMaterial : public ShaderNode {
public:
	ShaderNodeExtendedMaterial(PyObject* pyobj) : ShaderNode(pyobj) {}

	ShaderNodeExtendedMaterial() : ShaderNode(0)
	{
		// not implemented
	}

	/** Getter:  */
	Material material() {
		/* not implemented */ throw NULL;
	}

	/** Getter: Material Node outputs Diffuse */
	bool use_diffuse() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_diffuse")) == 1;
	}

	/** Setter: Material Node outputs Diffuse */
	void use_diffuse(bool value) {
		PyObject_SetAttrString(pyobjref, "use_diffuse", Py_BuildValue("i", value));
	}

	/** Getter: Material Node outputs Specular */
	bool use_specular() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_specular")) == 1;
	}

	/** Setter: Material Node outputs Specular */
	void use_specular(bool value) {
		PyObject_SetAttrString(pyobjref, "use_specular", Py_BuildValue("i", value));
	}

	/** Getter: Material Node uses inverted normal */
	bool invert_normal() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "invert_normal")) == 1;
	}

	/** Setter: Material Node uses inverted normal */
	void invert_normal(bool value) {
		PyObject_SetAttrString(pyobjref, "invert_normal", Py_BuildValue("i", value));
	}

	/**
	 * True if a registered node type
	 * @return 
	 */
	bool is_registered_node_type()
	{
		// not implemented
		return true;
	}

	/**
	 * Input socket template
	 * @param Param 'index'
	 * @return 
	 */
	NodeInternalSocketTemplate input_template(int index)
	{
		// not implemented
		return NodeInternalSocketTemplate();
	}

	/**
	 * Output socket template
	 * @param Param 'index'
	 * @return 
	 */
	NodeInternalSocketTemplate output_template(int index)
	{
		// not implemented
		return NodeInternalSocketTemplate();
	}

};

/**************** Invert ****************/

/**
 * 
 */
class ShaderNodeInvert : public ShaderNode {
public:
	ShaderNodeInvert(PyObject* pyobj) : ShaderNode(pyobj) {}

	ShaderNodeInvert() : ShaderNode(0)
	{
		// not implemented
	}

	/**
	 * True if a registered node type
	 * @return 
	 */
	bool is_registered_node_type()
	{
		// not implemented
		return true;
	}

	/**
	 * Input socket template
	 * @param Param 'index'
	 * @return 
	 */
	NodeInternalSocketTemplate input_template(int index)
	{
		// not implemented
		return NodeInternalSocketTemplate();
	}

	/**
	 * Output socket template
	 * @param Param 'index'
	 * @return 
	 */
	NodeInternalSocketTemplate output_template(int index)
	{
		// not implemented
		return NodeInternalSocketTemplate();
	}

};

/**************** Separate RGB ****************/

/**
 * 
 */
class ShaderNodeSeparateRGB : public ShaderNode {
public:
	ShaderNodeSeparateRGB(PyObject* pyobj) : ShaderNode(pyobj) {}

	ShaderNodeSeparateRGB() : ShaderNode(0)
	{
		// not implemented
	}

	/**
	 * True if a registered node type
	 * @return 
	 */
	bool is_registered_node_type()
	{
		// not implemented
		return true;
	}

	/**
	 * Input socket template
	 * @param Param 'index'
	 * @return 
	 */
	NodeInternalSocketTemplate input_template(int index)
	{
		// not implemented
		return NodeInternalSocketTemplate();
	}

	/**
	 * Output socket template
	 * @param Param 'index'
	 * @return 
	 */
	NodeInternalSocketTemplate output_template(int index)
	{
		// not implemented
		return NodeInternalSocketTemplate();
	}

};

/**************** Combine RGB ****************/

/**
 * 
 */
class ShaderNodeCombineRGB : public ShaderNode {
public:
	ShaderNodeCombineRGB(PyObject* pyobj) : ShaderNode(pyobj) {}

	ShaderNodeCombineRGB() : ShaderNode(0)
	{
		// not implemented
	}

	/**
	 * True if a registered node type
	 * @return 
	 */
	bool is_registered_node_type()
	{
		// not implemented
		return true;
	}

	/**
	 * Input socket template
	 * @param Param 'index'
	 * @return 
	 */
	NodeInternalSocketTemplate input_template(int index)
	{
		// not implemented
		return NodeInternalSocketTemplate();
	}

	/**
	 * Output socket template
	 * @param Param 'index'
	 * @return 
	 */
	NodeInternalSocketTemplate output_template(int index)
	{
		// not implemented
		return NodeInternalSocketTemplate();
	}

};

/**************** Hue/Saturation ****************/

/**
 * 
 */
class ShaderNodeHueSaturation : public ShaderNode {
public:
	ShaderNodeHueSaturation(PyObject* pyobj) : ShaderNode(pyobj) {}

	ShaderNodeHueSaturation() : ShaderNode(0)
	{
		// not implemented
	}

	/**
	 * True if a registered node type
	 * @return 
	 */
	bool is_registered_node_type()
	{
		// not implemented
		return true;
	}

	/**
	 * Input socket template
	 * @param Param 'index'
	 * @return 
	 */
	NodeInternalSocketTemplate input_template(int index)
	{
		// not implemented
		return NodeInternalSocketTemplate();
	}

	/**
	 * Output socket template
	 * @param Param 'index'
	 * @return 
	 */
	NodeInternalSocketTemplate output_template(int index)
	{
		// not implemented
		return NodeInternalSocketTemplate();
	}

};

/**************** Material Output ****************/

/**
 * 
 */
class ShaderNodeOutputMaterial : public ShaderNode {
public:
	ShaderNodeOutputMaterial(PyObject* pyobj) : ShaderNode(pyobj) {}

	ShaderNodeOutputMaterial() : ShaderNode(0)
	{
		// not implemented
	}

	/** Getter: True if this node is used as the active output */
	bool is_active_output() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "is_active_output")) == 1;
	}

	/** Setter: True if this node is used as the active output */
	void is_active_output(bool value) {
		PyObject_SetAttrString(pyobjref, "is_active_output", Py_BuildValue("i", value));
	}

	/**
	 * True if a registered node type
	 * @return 
	 */
	bool is_registered_node_type()
	{
		// not implemented
		return true;
	}

	/**
	 * Input socket template
	 * @param Param 'index'
	 * @return 
	 */
	NodeInternalSocketTemplate input_template(int index)
	{
		// not implemented
		return NodeInternalSocketTemplate();
	}

	/**
	 * Output socket template
	 * @param Param 'index'
	 * @return 
	 */
	NodeInternalSocketTemplate output_template(int index)
	{
		// not implemented
		return NodeInternalSocketTemplate();
	}

};

/**************** Lamp Output ****************/

/**
 * 
 */
class ShaderNodeOutputLamp : public ShaderNode {
public:
	ShaderNodeOutputLamp(PyObject* pyobj) : ShaderNode(pyobj) {}

	ShaderNodeOutputLamp() : ShaderNode(0)
	{
		// not implemented
	}

	/** Getter: True if this node is used as the active output */
	bool is_active_output() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "is_active_output")) == 1;
	}

	/** Setter: True if this node is used as the active output */
	void is_active_output(bool value) {
		PyObject_SetAttrString(pyobjref, "is_active_output", Py_BuildValue("i", value));
	}

	/**
	 * True if a registered node type
	 * @return 
	 */
	bool is_registered_node_type()
	{
		// not implemented
		return true;
	}

	/**
	 * Input socket template
	 * @param Param 'index'
	 * @return 
	 */
	NodeInternalSocketTemplate input_template(int index)
	{
		// not implemented
		return NodeInternalSocketTemplate();
	}

	/**
	 * Output socket template
	 * @param Param 'index'
	 * @return 
	 */
	NodeInternalSocketTemplate output_template(int index)
	{
		// not implemented
		return NodeInternalSocketTemplate();
	}

};

/**************** World Output ****************/

/**
 * 
 */
class ShaderNodeOutputWorld : public ShaderNode {
public:
	ShaderNodeOutputWorld(PyObject* pyobj) : ShaderNode(pyobj) {}

	ShaderNodeOutputWorld() : ShaderNode(0)
	{
		// not implemented
	}

	/** Getter: True if this node is used as the active output */
	bool is_active_output() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "is_active_output")) == 1;
	}

	/** Setter: True if this node is used as the active output */
	void is_active_output(bool value) {
		PyObject_SetAttrString(pyobjref, "is_active_output", Py_BuildValue("i", value));
	}

	/**
	 * True if a registered node type
	 * @return 
	 */
	bool is_registered_node_type()
	{
		// not implemented
		return true;
	}

	/**
	 * Input socket template
	 * @param Param 'index'
	 * @return 
	 */
	NodeInternalSocketTemplate input_template(int index)
	{
		// not implemented
		return NodeInternalSocketTemplate();
	}

	/**
	 * Output socket template
	 * @param Param 'index'
	 * @return 
	 */
	NodeInternalSocketTemplate output_template(int index)
	{
		// not implemented
		return NodeInternalSocketTemplate();
	}

};

/**************** Line Style Output ****************/

/**
 * 
 */
class ShaderNodeOutputLineStyle : public ShaderNode {
public:
	ShaderNodeOutputLineStyle(PyObject* pyobj) : ShaderNode(pyobj) {}

	ShaderNodeOutputLineStyle() : ShaderNode(0)
	{
		// not implemented
	}

	/** Getter: True if this node is used as the active output */
	bool is_active_output() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "is_active_output")) == 1;
	}

	/** Setter: True if this node is used as the active output */
	void is_active_output(bool value) {
		PyObject_SetAttrString(pyobjref, "is_active_output", Py_BuildValue("i", value));
	}

	enum blend_type_enum {
		blend_type_MIX = 0,
		blend_type_ADD = 1,
		blend_type_MULTIPLY = 2,
		blend_type_SUBTRACT = 3,
		blend_type_SCREEN = 4,
		blend_type_DIVIDE = 5,
		blend_type_DIFFERENCE = 6,
		blend_type_DARKEN = 7,
		blend_type_LIGHTEN = 8,
		blend_type_OVERLAY = 9,
		blend_type_DODGE = 10,
		blend_type_BURN = 11,
		blend_type_HUE = 12,
		blend_type_SATURATION = 13,
		blend_type_VALUE = 14,
		blend_type_COLOR = 15,
		blend_type_SOFT_LIGHT = 16,
		blend_type_LINEAR_LIGHT = 17,
	};

	/** Getter:  */
	blend_type_enum blend_type() { /* not implemented */ throw NULL; }
	/** Setter:  */
	void blend_type(blend_type_enum value) { /* not implemented */ }

	/** Getter: Include alpha of second input in this operation */
	bool use_alpha() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_alpha")) == 1;
	}

	/** Setter: Include alpha of second input in this operation */
	void use_alpha(bool value) {
		PyObject_SetAttrString(pyobjref, "use_alpha", Py_BuildValue("i", value));
	}

	/** Getter: Clamp result of the node to 0..1 range */
	bool use_clamp() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_clamp")) == 1;
	}

	/** Setter: Clamp result of the node to 0..1 range */
	void use_clamp(bool value) {
		PyObject_SetAttrString(pyobjref, "use_clamp", Py_BuildValue("i", value));
	}

	/**
	 * True if a registered node type
	 * @return 
	 */
	bool is_registered_node_type()
	{
		// not implemented
		return true;
	}

	/**
	 * Input socket template
	 * @param Param 'index'
	 * @return 
	 */
	NodeInternalSocketTemplate input_template(int index)
	{
		// not implemented
		return NodeInternalSocketTemplate();
	}

	/**
	 * Output socket template
	 * @param Param 'index'
	 * @return 
	 */
	NodeInternalSocketTemplate output_template(int index)
	{
		// not implemented
		return NodeInternalSocketTemplate();
	}

};

/**************** Fresnel ****************/

/**
 * 
 */
class ShaderNodeFresnel : public ShaderNode {
public:
	ShaderNodeFresnel(PyObject* pyobj) : ShaderNode(pyobj) {}

	ShaderNodeFresnel() : ShaderNode(0)
	{
		// not implemented
	}

	/**
	 * True if a registered node type
	 * @return 
	 */
	bool is_registered_node_type()
	{
		// not implemented
		return true;
	}

	/**
	 * Input socket template
	 * @param Param 'index'
	 * @return 
	 */
	NodeInternalSocketTemplate input_template(int index)
	{
		// not implemented
		return NodeInternalSocketTemplate();
	}

	/**
	 * Output socket template
	 * @param Param 'index'
	 * @return 
	 */
	NodeInternalSocketTemplate output_template(int index)
	{
		// not implemented
		return NodeInternalSocketTemplate();
	}

};

/**************** Layer Weight ****************/

/**
 * 
 */
class ShaderNodeLayerWeight : public ShaderNode {
public:
	ShaderNodeLayerWeight(PyObject* pyobj) : ShaderNode(pyobj) {}

	ShaderNodeLayerWeight() : ShaderNode(0)
	{
		// not implemented
	}

	/**
	 * True if a registered node type
	 * @return 
	 */
	bool is_registered_node_type()
	{
		// not implemented
		return true;
	}

	/**
	 * Input socket template
	 * @param Param 'index'
	 * @return 
	 */
	NodeInternalSocketTemplate input_template(int index)
	{
		// not implemented
		return NodeInternalSocketTemplate();
	}

	/**
	 * Output socket template
	 * @param Param 'index'
	 * @return 
	 */
	NodeInternalSocketTemplate output_template(int index)
	{
		// not implemented
		return NodeInternalSocketTemplate();
	}

};

/**************** Mix Shader ****************/

/**
 * 
 */
class ShaderNodeMixShader : public ShaderNode {
public:
	ShaderNodeMixShader(PyObject* pyobj) : ShaderNode(pyobj) {}

	ShaderNodeMixShader() : ShaderNode(0)
	{
		// not implemented
	}

	/**
	 * True if a registered node type
	 * @return 
	 */
	bool is_registered_node_type()
	{
		// not implemented
		return true;
	}

	/**
	 * Input socket template
	 * @param Param 'index'
	 * @return 
	 */
	NodeInternalSocketTemplate input_template(int index)
	{
		// not implemented
		return NodeInternalSocketTemplate();
	}

	/**
	 * Output socket template
	 * @param Param 'index'
	 * @return 
	 */
	NodeInternalSocketTemplate output_template(int index)
	{
		// not implemented
		return NodeInternalSocketTemplate();
	}

};

/**************** Add Shader ****************/

/**
 * 
 */
class ShaderNodeAddShader : public ShaderNode {
public:
	ShaderNodeAddShader(PyObject* pyobj) : ShaderNode(pyobj) {}

	ShaderNodeAddShader() : ShaderNode(0)
	{
		// not implemented
	}

	/**
	 * True if a registered node type
	 * @return 
	 */
	bool is_registered_node_type()
	{
		// not implemented
		return true;
	}

	/**
	 * Input socket template
	 * @param Param 'index'
	 * @return 
	 */
	NodeInternalSocketTemplate input_template(int index)
	{
		// not implemented
		return NodeInternalSocketTemplate();
	}

	/**
	 * Output socket template
	 * @param Param 'index'
	 * @return 
	 */
	NodeInternalSocketTemplate output_template(int index)
	{
		// not implemented
		return NodeInternalSocketTemplate();
	}

};

/**************** Attribute ****************/

/**
 * 
 */
class ShaderNodeAttribute : public ShaderNode {
public:
	ShaderNodeAttribute(PyObject* pyobj) : ShaderNode(pyobj) {}

	ShaderNodeAttribute() : ShaderNode(0)
	{
		// not implemented
	}

	/** Getter:  */
	std::string attribute_name() { /* not implemented */ throw NULL; }
	/** Setter:  */
	void attribute_name(const std::string& value) { /* not implemented */ }

	/**
	 * True if a registered node type
	 * @return 
	 */
	bool is_registered_node_type()
	{
		// not implemented
		return true;
	}

	/**
	 * Input socket template
	 * @param Param 'index'
	 * @return 
	 */
	NodeInternalSocketTemplate input_template(int index)
	{
		// not implemented
		return NodeInternalSocketTemplate();
	}

	/**
	 * Output socket template
	 * @param Param 'index'
	 * @return 
	 */
	NodeInternalSocketTemplate output_template(int index)
	{
		// not implemented
		return NodeInternalSocketTemplate();
	}

};

/**************** Ambient Occlusion ****************/

/**
 * 
 */
class ShaderNodeAmbientOcclusion : public ShaderNode {
public:
	ShaderNodeAmbientOcclusion(PyObject* pyobj) : ShaderNode(pyobj) {}

	ShaderNodeAmbientOcclusion() : ShaderNode(0)
	{
		// not implemented
	}

	/**
	 * True if a registered node type
	 * @return 
	 */
	bool is_registered_node_type()
	{
		// not implemented
		return true;
	}

	/**
	 * Input socket template
	 * @param Param 'index'
	 * @return 
	 */
	NodeInternalSocketTemplate input_template(int index)
	{
		// not implemented
		return NodeInternalSocketTemplate();
	}

	/**
	 * Output socket template
	 * @param Param 'index'
	 * @return 
	 */
	NodeInternalSocketTemplate output_template(int index)
	{
		// not implemented
		return NodeInternalSocketTemplate();
	}

};

/**************** Background ****************/

/**
 * 
 */
class ShaderNodeBackground : public ShaderNode {
public:
	ShaderNodeBackground(PyObject* pyobj) : ShaderNode(pyobj) {}

	ShaderNodeBackground() : ShaderNode(0)
	{
		// not implemented
	}

	/**
	 * True if a registered node type
	 * @return 
	 */
	bool is_registered_node_type()
	{
		// not implemented
		return true;
	}

	/**
	 * Input socket template
	 * @param Param 'index'
	 * @return 
	 */
	NodeInternalSocketTemplate input_template(int index)
	{
		// not implemented
		return NodeInternalSocketTemplate();
	}

	/**
	 * Output socket template
	 * @param Param 'index'
	 * @return 
	 */
	NodeInternalSocketTemplate output_template(int index)
	{
		// not implemented
		return NodeInternalSocketTemplate();
	}

};

/**************** Holdout ****************/

/**
 * 
 */
class ShaderNodeHoldout : public ShaderNode {
public:
	ShaderNodeHoldout(PyObject* pyobj) : ShaderNode(pyobj) {}

	ShaderNodeHoldout() : ShaderNode(0)
	{
		// not implemented
	}

	/**
	 * True if a registered node type
	 * @return 
	 */
	bool is_registered_node_type()
	{
		// not implemented
		return true;
	}

	/**
	 * Input socket template
	 * @param Param 'index'
	 * @return 
	 */
	NodeInternalSocketTemplate input_template(int index)
	{
		// not implemented
		return NodeInternalSocketTemplate();
	}

	/**
	 * Output socket template
	 * @param Param 'index'
	 * @return 
	 */
	NodeInternalSocketTemplate output_template(int index)
	{
		// not implemented
		return NodeInternalSocketTemplate();
	}

};

/**************** Anisotropic BSDF ****************/

/**
 * 
 */
class ShaderNodeBsdfAnisotropic : public ShaderNode {
public:
	ShaderNodeBsdfAnisotropic(PyObject* pyobj) : ShaderNode(pyobj) {}

	ShaderNodeBsdfAnisotropic() : ShaderNode(0)
	{
		// not implemented
	}

	enum distribution_enum {
		distribution_BECKMANN = 0,
		distribution_GGX = 2,
		distribution_ASHIKHMIN_SHIRLEY = 3,
	};

	/** Getter:  */
	distribution_enum distribution() { /* not implemented */ throw NULL; }
	/** Setter:  */
	void distribution(distribution_enum value) { /* not implemented */ }

	/**
	 * True if a registered node type
	 * @return 
	 */
	bool is_registered_node_type()
	{
		// not implemented
		return true;
	}

	/**
	 * Input socket template
	 * @param Param 'index'
	 * @return 
	 */
	NodeInternalSocketTemplate input_template(int index)
	{
		// not implemented
		return NodeInternalSocketTemplate();
	}

	/**
	 * Output socket template
	 * @param Param 'index'
	 * @return 
	 */
	NodeInternalSocketTemplate output_template(int index)
	{
		// not implemented
		return NodeInternalSocketTemplate();
	}

};

/**************** Diffuse BSDF ****************/

/**
 * 
 */
class ShaderNodeBsdfDiffuse : public ShaderNode {
public:
	ShaderNodeBsdfDiffuse(PyObject* pyobj) : ShaderNode(pyobj) {}

	ShaderNodeBsdfDiffuse() : ShaderNode(0)
	{
		// not implemented
	}

	/**
	 * True if a registered node type
	 * @return 
	 */
	bool is_registered_node_type()
	{
		// not implemented
		return true;
	}

	/**
	 * Input socket template
	 * @param Param 'index'
	 * @return 
	 */
	NodeInternalSocketTemplate input_template(int index)
	{
		// not implemented
		return NodeInternalSocketTemplate();
	}

	/**
	 * Output socket template
	 * @param Param 'index'
	 * @return 
	 */
	NodeInternalSocketTemplate output_template(int index)
	{
		// not implemented
		return NodeInternalSocketTemplate();
	}

};

/**************** Glossy BSDF ****************/

/**
 * 
 */
class ShaderNodeBsdfGlossy : public ShaderNode {
public:
	ShaderNodeBsdfGlossy(PyObject* pyobj) : ShaderNode(pyobj) {}

	ShaderNodeBsdfGlossy() : ShaderNode(0)
	{
		// not implemented
	}

	enum distribution_enum {
		distribution_SHARP = 1,
		distribution_BECKMANN = 0,
		distribution_GGX = 2,
		distribution_ASHIKHMIN_SHIRLEY = 3,
	};

	/** Getter:  */
	distribution_enum distribution() { /* not implemented */ throw NULL; }
	/** Setter:  */
	void distribution(distribution_enum value) { /* not implemented */ }

	/**
	 * True if a registered node type
	 * @return 
	 */
	bool is_registered_node_type()
	{
		// not implemented
		return true;
	}

	/**
	 * Input socket template
	 * @param Param 'index'
	 * @return 
	 */
	NodeInternalSocketTemplate input_template(int index)
	{
		// not implemented
		return NodeInternalSocketTemplate();
	}

	/**
	 * Output socket template
	 * @param Param 'index'
	 * @return 
	 */
	NodeInternalSocketTemplate output_template(int index)
	{
		// not implemented
		return NodeInternalSocketTemplate();
	}

};

/**************** Glass BSDF ****************/

/**
 * 
 */
class ShaderNodeBsdfGlass : public ShaderNode {
public:
	ShaderNodeBsdfGlass(PyObject* pyobj) : ShaderNode(pyobj) {}

	ShaderNodeBsdfGlass() : ShaderNode(0)
	{
		// not implemented
	}

	enum distribution_enum {
		distribution_SHARP = 1,
		distribution_BECKMANN = 0,
		distribution_GGX = 2,
	};

	/** Getter:  */
	distribution_enum distribution() { /* not implemented */ throw NULL; }
	/** Setter:  */
	void distribution(distribution_enum value) { /* not implemented */ }

	/**
	 * True if a registered node type
	 * @return 
	 */
	bool is_registered_node_type()
	{
		// not implemented
		return true;
	}

	/**
	 * Input socket template
	 * @param Param 'index'
	 * @return 
	 */
	NodeInternalSocketTemplate input_template(int index)
	{
		// not implemented
		return NodeInternalSocketTemplate();
	}

	/**
	 * Output socket template
	 * @param Param 'index'
	 * @return 
	 */
	NodeInternalSocketTemplate output_template(int index)
	{
		// not implemented
		return NodeInternalSocketTemplate();
	}

};

/**************** Refraction BSDF ****************/

/**
 * 
 */
class ShaderNodeBsdfRefraction : public ShaderNode {
public:
	ShaderNodeBsdfRefraction(PyObject* pyobj) : ShaderNode(pyobj) {}

	ShaderNodeBsdfRefraction() : ShaderNode(0)
	{
		// not implemented
	}

	enum distribution_enum {
		distribution_SHARP = 1,
		distribution_BECKMANN = 0,
		distribution_GGX = 2,
	};

	/** Getter:  */
	distribution_enum distribution() { /* not implemented */ throw NULL; }
	/** Setter:  */
	void distribution(distribution_enum value) { /* not implemented */ }

	/**
	 * True if a registered node type
	 * @return 
	 */
	bool is_registered_node_type()
	{
		// not implemented
		return true;
	}

	/**
	 * Input socket template
	 * @param Param 'index'
	 * @return 
	 */
	NodeInternalSocketTemplate input_template(int index)
	{
		// not implemented
		return NodeInternalSocketTemplate();
	}

	/**
	 * Output socket template
	 * @param Param 'index'
	 * @return 
	 */
	NodeInternalSocketTemplate output_template(int index)
	{
		// not implemented
		return NodeInternalSocketTemplate();
	}

};

/**************** Translucent BSDF ****************/

/**
 * 
 */
class ShaderNodeBsdfTranslucent : public ShaderNode {
public:
	ShaderNodeBsdfTranslucent(PyObject* pyobj) : ShaderNode(pyobj) {}

	ShaderNodeBsdfTranslucent() : ShaderNode(0)
	{
		// not implemented
	}

	/**
	 * True if a registered node type
	 * @return 
	 */
	bool is_registered_node_type()
	{
		// not implemented
		return true;
	}

	/**
	 * Input socket template
	 * @param Param 'index'
	 * @return 
	 */
	NodeInternalSocketTemplate input_template(int index)
	{
		// not implemented
		return NodeInternalSocketTemplate();
	}

	/**
	 * Output socket template
	 * @param Param 'index'
	 * @return 
	 */
	NodeInternalSocketTemplate output_template(int index)
	{
		// not implemented
		return NodeInternalSocketTemplate();
	}

};

/**************** Transparent BSDF ****************/

/**
 * 
 */
class ShaderNodeBsdfTransparent : public ShaderNode {
public:
	ShaderNodeBsdfTransparent(PyObject* pyobj) : ShaderNode(pyobj) {}

	ShaderNodeBsdfTransparent() : ShaderNode(0)
	{
		// not implemented
	}

	/**
	 * True if a registered node type
	 * @return 
	 */
	bool is_registered_node_type()
	{
		// not implemented
		return true;
	}

	/**
	 * Input socket template
	 * @param Param 'index'
	 * @return 
	 */
	NodeInternalSocketTemplate input_template(int index)
	{
		// not implemented
		return NodeInternalSocketTemplate();
	}

	/**
	 * Output socket template
	 * @param Param 'index'
	 * @return 
	 */
	NodeInternalSocketTemplate output_template(int index)
	{
		// not implemented
		return NodeInternalSocketTemplate();
	}

};

/**************** Velvet BSDF ****************/

/**
 * 
 */
class ShaderNodeBsdfVelvet : public ShaderNode {
public:
	ShaderNodeBsdfVelvet(PyObject* pyobj) : ShaderNode(pyobj) {}

	ShaderNodeBsdfVelvet() : ShaderNode(0)
	{
		// not implemented
	}

	/**
	 * True if a registered node type
	 * @return 
	 */
	bool is_registered_node_type()
	{
		// not implemented
		return true;
	}

	/**
	 * Input socket template
	 * @param Param 'index'
	 * @return 
	 */
	NodeInternalSocketTemplate input_template(int index)
	{
		// not implemented
		return NodeInternalSocketTemplate();
	}

	/**
	 * Output socket template
	 * @param Param 'index'
	 * @return 
	 */
	NodeInternalSocketTemplate output_template(int index)
	{
		// not implemented
		return NodeInternalSocketTemplate();
	}

};

/**************** Toon BSDF ****************/

/**
 * 
 */
class ShaderNodeBsdfToon : public ShaderNode {
public:
	ShaderNodeBsdfToon(PyObject* pyobj) : ShaderNode(pyobj) {}

	ShaderNodeBsdfToon() : ShaderNode(0)
	{
		// not implemented
	}

	enum component_enum {
		component_DIFFUSE = 0,
		component_GLOSSY = 1,
	};

	/** Getter:  */
	component_enum component() { /* not implemented */ throw NULL; }
	/** Setter:  */
	void component(component_enum value) { /* not implemented */ }

	/**
	 * True if a registered node type
	 * @return 
	 */
	bool is_registered_node_type()
	{
		// not implemented
		return true;
	}

	/**
	 * Input socket template
	 * @param Param 'index'
	 * @return 
	 */
	NodeInternalSocketTemplate input_template(int index)
	{
		// not implemented
		return NodeInternalSocketTemplate();
	}

	/**
	 * Output socket template
	 * @param Param 'index'
	 * @return 
	 */
	NodeInternalSocketTemplate output_template(int index)
	{
		// not implemented
		return NodeInternalSocketTemplate();
	}

};

/**************** Hair BSDF ****************/

/**
 * 
 */
class ShaderNodeBsdfHair : public ShaderNode {
public:
	ShaderNodeBsdfHair(PyObject* pyobj) : ShaderNode(pyobj) {}

	ShaderNodeBsdfHair() : ShaderNode(0)
	{
		// not implemented
	}

	enum component_enum {
		component_Reflection = 0,
		component_Transmission = 1,
	};

	/** Getter:  */
	component_enum component() { /* not implemented */ throw NULL; }
	/** Setter:  */
	void component(component_enum value) { /* not implemented */ }

	/**
	 * True if a registered node type
	 * @return 
	 */
	bool is_registered_node_type()
	{
		// not implemented
		return true;
	}

	/**
	 * Input socket template
	 * @param Param 'index'
	 * @return 
	 */
	NodeInternalSocketTemplate input_template(int index)
	{
		// not implemented
		return NodeInternalSocketTemplate();
	}

	/**
	 * Output socket template
	 * @param Param 'index'
	 * @return 
	 */
	NodeInternalSocketTemplate output_template(int index)
	{
		// not implemented
		return NodeInternalSocketTemplate();
	}

};

/**************** Subsurface Scattering ****************/

/**
 * 
 */
class ShaderNodeSubsurfaceScattering : public ShaderNode {
public:
	ShaderNodeSubsurfaceScattering(PyObject* pyobj) : ShaderNode(pyobj) {}

	ShaderNodeSubsurfaceScattering() : ShaderNode(0)
	{
		// not implemented
	}

	enum falloff_enum {
		falloff_CUBIC = 1,
		falloff_GAUSSIAN = 2,
	};

	/** Getter: Function to determine how much light nearby points contribute based on their distance to the shading point */
	falloff_enum falloff() { /* not implemented */ throw NULL; }
	/** Setter: Function to determine how much light nearby points contribute based on their distance to the shading point */
	void falloff(falloff_enum value) { /* not implemented */ }

	/**
	 * True if a registered node type
	 * @return 
	 */
	bool is_registered_node_type()
	{
		// not implemented
		return true;
	}

	/**
	 * Input socket template
	 * @param Param 'index'
	 * @return 
	 */
	NodeInternalSocketTemplate input_template(int index)
	{
		// not implemented
		return NodeInternalSocketTemplate();
	}

	/**
	 * Output socket template
	 * @param Param 'index'
	 * @return 
	 */
	NodeInternalSocketTemplate output_template(int index)
	{
		// not implemented
		return NodeInternalSocketTemplate();
	}

};

/**************** Volume Absorption ****************/

/**
 * 
 */
class ShaderNodeVolumeAbsorption : public ShaderNode {
public:
	ShaderNodeVolumeAbsorption(PyObject* pyobj) : ShaderNode(pyobj) {}

	ShaderNodeVolumeAbsorption() : ShaderNode(0)
	{
		// not implemented
	}

	/**
	 * True if a registered node type
	 * @return 
	 */
	bool is_registered_node_type()
	{
		// not implemented
		return true;
	}

	/**
	 * Input socket template
	 * @param Param 'index'
	 * @return 
	 */
	NodeInternalSocketTemplate input_template(int index)
	{
		// not implemented
		return NodeInternalSocketTemplate();
	}

	/**
	 * Output socket template
	 * @param Param 'index'
	 * @return 
	 */
	NodeInternalSocketTemplate output_template(int index)
	{
		// not implemented
		return NodeInternalSocketTemplate();
	}

};

/**************** Volume Scatter ****************/

/**
 * 
 */
class ShaderNodeVolumeScatter : public ShaderNode {
public:
	ShaderNodeVolumeScatter(PyObject* pyobj) : ShaderNode(pyobj) {}

	ShaderNodeVolumeScatter() : ShaderNode(0)
	{
		// not implemented
	}

	/**
	 * True if a registered node type
	 * @return 
	 */
	bool is_registered_node_type()
	{
		// not implemented
		return true;
	}

	/**
	 * Input socket template
	 * @param Param 'index'
	 * @return 
	 */
	NodeInternalSocketTemplate input_template(int index)
	{
		// not implemented
		return NodeInternalSocketTemplate();
	}

	/**
	 * Output socket template
	 * @param Param 'index'
	 * @return 
	 */
	NodeInternalSocketTemplate output_template(int index)
	{
		// not implemented
		return NodeInternalSocketTemplate();
	}

};

/**************** Emission ****************/

/**
 * 
 */
class ShaderNodeEmission : public ShaderNode {
public:
	ShaderNodeEmission(PyObject* pyobj) : ShaderNode(pyobj) {}

	ShaderNodeEmission() : ShaderNode(0)
	{
		// not implemented
	}

	/**
	 * True if a registered node type
	 * @return 
	 */
	bool is_registered_node_type()
	{
		// not implemented
		return true;
	}

	/**
	 * Input socket template
	 * @param Param 'index'
	 * @return 
	 */
	NodeInternalSocketTemplate input_template(int index)
	{
		// not implemented
		return NodeInternalSocketTemplate();
	}

	/**
	 * Output socket template
	 * @param Param 'index'
	 * @return 
	 */
	NodeInternalSocketTemplate output_template(int index)
	{
		// not implemented
		return NodeInternalSocketTemplate();
	}

};

/**************** Geometry ****************/

/**
 * 
 */
class ShaderNodeNewGeometry : public ShaderNode {
public:
	ShaderNodeNewGeometry(PyObject* pyobj) : ShaderNode(pyobj) {}

	ShaderNodeNewGeometry() : ShaderNode(0)
	{
		// not implemented
	}

	/**
	 * True if a registered node type
	 * @return 
	 */
	bool is_registered_node_type()
	{
		// not implemented
		return true;
	}

	/**
	 * Input socket template
	 * @param Param 'index'
	 * @return 
	 */
	NodeInternalSocketTemplate input_template(int index)
	{
		// not implemented
		return NodeInternalSocketTemplate();
	}

	/**
	 * Output socket template
	 * @param Param 'index'
	 * @return 
	 */
	NodeInternalSocketTemplate output_template(int index)
	{
		// not implemented
		return NodeInternalSocketTemplate();
	}

};

/**************** Light Path ****************/

/**
 * 
 */
class ShaderNodeLightPath : public ShaderNode {
public:
	ShaderNodeLightPath(PyObject* pyobj) : ShaderNode(pyobj) {}

	ShaderNodeLightPath() : ShaderNode(0)
	{
		// not implemented
	}

	/**
	 * True if a registered node type
	 * @return 
	 */
	bool is_registered_node_type()
	{
		// not implemented
		return true;
	}

	/**
	 * Input socket template
	 * @param Param 'index'
	 * @return 
	 */
	NodeInternalSocketTemplate input_template(int index)
	{
		// not implemented
		return NodeInternalSocketTemplate();
	}

	/**
	 * Output socket template
	 * @param Param 'index'
	 * @return 
	 */
	NodeInternalSocketTemplate output_template(int index)
	{
		// not implemented
		return NodeInternalSocketTemplate();
	}

};

/**************** Light Falloff ****************/

/**
 * 
 */
class ShaderNodeLightFalloff : public ShaderNode {
public:
	ShaderNodeLightFalloff(PyObject* pyobj) : ShaderNode(pyobj) {}

	ShaderNodeLightFalloff() : ShaderNode(0)
	{
		// not implemented
	}

	/**
	 * True if a registered node type
	 * @return 
	 */
	bool is_registered_node_type()
	{
		// not implemented
		return true;
	}

	/**
	 * Input socket template
	 * @param Param 'index'
	 * @return 
	 */
	NodeInternalSocketTemplate input_template(int index)
	{
		// not implemented
		return NodeInternalSocketTemplate();
	}

	/**
	 * Output socket template
	 * @param Param 'index'
	 * @return 
	 */
	NodeInternalSocketTemplate output_template(int index)
	{
		// not implemented
		return NodeInternalSocketTemplate();
	}

};

/**************** Object Info ****************/

/**
 * 
 */
class ShaderNodeObjectInfo : public ShaderNode {
public:
	ShaderNodeObjectInfo(PyObject* pyobj) : ShaderNode(pyobj) {}

	ShaderNodeObjectInfo() : ShaderNode(0)
	{
		// not implemented
	}

	/**
	 * True if a registered node type
	 * @return 
	 */
	bool is_registered_node_type()
	{
		// not implemented
		return true;
	}

	/**
	 * Input socket template
	 * @param Param 'index'
	 * @return 
	 */
	NodeInternalSocketTemplate input_template(int index)
	{
		// not implemented
		return NodeInternalSocketTemplate();
	}

	/**
	 * Output socket template
	 * @param Param 'index'
	 * @return 
	 */
	NodeInternalSocketTemplate output_template(int index)
	{
		// not implemented
		return NodeInternalSocketTemplate();
	}

};

/**************** Particle Info ****************/

/**
 * 
 */
class ShaderNodeParticleInfo : public ShaderNode {
public:
	ShaderNodeParticleInfo(PyObject* pyobj) : ShaderNode(pyobj) {}

	ShaderNodeParticleInfo() : ShaderNode(0)
	{
		// not implemented
	}

	/**
	 * True if a registered node type
	 * @return 
	 */
	bool is_registered_node_type()
	{
		// not implemented
		return true;
	}

	/**
	 * Input socket template
	 * @param Param 'index'
	 * @return 
	 */
	NodeInternalSocketTemplate input_template(int index)
	{
		// not implemented
		return NodeInternalSocketTemplate();
	}

	/**
	 * Output socket template
	 * @param Param 'index'
	 * @return 
	 */
	NodeInternalSocketTemplate output_template(int index)
	{
		// not implemented
		return NodeInternalSocketTemplate();
	}

};

/**************** Hair Info ****************/

/**
 * 
 */
class ShaderNodeHairInfo : public ShaderNode {
public:
	ShaderNodeHairInfo(PyObject* pyobj) : ShaderNode(pyobj) {}

	ShaderNodeHairInfo() : ShaderNode(0)
	{
		// not implemented
	}

	/**
	 * True if a registered node type
	 * @return 
	 */
	bool is_registered_node_type()
	{
		// not implemented
		return true;
	}

	/**
	 * Input socket template
	 * @param Param 'index'
	 * @return 
	 */
	NodeInternalSocketTemplate input_template(int index)
	{
		// not implemented
		return NodeInternalSocketTemplate();
	}

	/**
	 * Output socket template
	 * @param Param 'index'
	 * @return 
	 */
	NodeInternalSocketTemplate output_template(int index)
	{
		// not implemented
		return NodeInternalSocketTemplate();
	}

};

/**************** Wireframe ****************/

/**
 * 
 */
class ShaderNodeWireframe : public ShaderNode {
public:
	ShaderNodeWireframe(PyObject* pyobj) : ShaderNode(pyobj) {}

	ShaderNodeWireframe() : ShaderNode(0)
	{
		// not implemented
	}

	/** Getter: Use screen pixel size instead of world units */
	bool use_pixel_size() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_pixel_size")) == 1;
	}

	/** Setter: Use screen pixel size instead of world units */
	void use_pixel_size(bool value) {
		PyObject_SetAttrString(pyobjref, "use_pixel_size", Py_BuildValue("i", value));
	}

	/**
	 * True if a registered node type
	 * @return 
	 */
	bool is_registered_node_type()
	{
		// not implemented
		return true;
	}

	/**
	 * Input socket template
	 * @param Param 'index'
	 * @return 
	 */
	NodeInternalSocketTemplate input_template(int index)
	{
		// not implemented
		return NodeInternalSocketTemplate();
	}

	/**
	 * Output socket template
	 * @param Param 'index'
	 * @return 
	 */
	NodeInternalSocketTemplate output_template(int index)
	{
		// not implemented
		return NodeInternalSocketTemplate();
	}

};

/**************** Wavelength ****************/

/**
 * 
 */
class ShaderNodeWavelength : public ShaderNode {
public:
	ShaderNodeWavelength(PyObject* pyobj) : ShaderNode(pyobj) {}

	ShaderNodeWavelength() : ShaderNode(0)
	{
		// not implemented
	}

	/**
	 * True if a registered node type
	 * @return 
	 */
	bool is_registered_node_type()
	{
		// not implemented
		return true;
	}

	/**
	 * Input socket template
	 * @param Param 'index'
	 * @return 
	 */
	NodeInternalSocketTemplate input_template(int index)
	{
		// not implemented
		return NodeInternalSocketTemplate();
	}

	/**
	 * Output socket template
	 * @param Param 'index'
	 * @return 
	 */
	NodeInternalSocketTemplate output_template(int index)
	{
		// not implemented
		return NodeInternalSocketTemplate();
	}

};

/**************** Blackbody ****************/

/**
 * 
 */
class ShaderNodeBlackbody : public ShaderNode {
public:
	ShaderNodeBlackbody(PyObject* pyobj) : ShaderNode(pyobj) {}

	ShaderNodeBlackbody() : ShaderNode(0)
	{
		// not implemented
	}

	/**
	 * True if a registered node type
	 * @return 
	 */
	bool is_registered_node_type()
	{
		// not implemented
		return true;
	}

	/**
	 * Input socket template
	 * @param Param 'index'
	 * @return 
	 */
	NodeInternalSocketTemplate input_template(int index)
	{
		// not implemented
		return NodeInternalSocketTemplate();
	}

	/**
	 * Output socket template
	 * @param Param 'index'
	 * @return 
	 */
	NodeInternalSocketTemplate output_template(int index)
	{
		// not implemented
		return NodeInternalSocketTemplate();
	}

};

/**************** Bump ****************/

/**
 * 
 */
class ShaderNodeBump : public ShaderNode {
public:
	ShaderNodeBump(PyObject* pyobj) : ShaderNode(pyobj) {}

	ShaderNodeBump() : ShaderNode(0)
	{
		// not implemented
	}

	/** Getter: Invert the bump mapping direction to push into the surface instead of out */
	bool invert() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "invert")) == 1;
	}

	/** Setter: Invert the bump mapping direction to push into the surface instead of out */
	void invert(bool value) {
		PyObject_SetAttrString(pyobjref, "invert", Py_BuildValue("i", value));
	}

	/**
	 * True if a registered node type
	 * @return 
	 */
	bool is_registered_node_type()
	{
		// not implemented
		return true;
	}

	/**
	 * Input socket template
	 * @param Param 'index'
	 * @return 
	 */
	NodeInternalSocketTemplate input_template(int index)
	{
		// not implemented
		return NodeInternalSocketTemplate();
	}

	/**
	 * Output socket template
	 * @param Param 'index'
	 * @return 
	 */
	NodeInternalSocketTemplate output_template(int index)
	{
		// not implemented
		return NodeInternalSocketTemplate();
	}

};

/**************** Normal Map ****************/

/**
 * 
 */
class ShaderNodeNormalMap : public ShaderNode {
public:
	ShaderNodeNormalMap(PyObject* pyobj) : ShaderNode(pyobj) {}

	ShaderNodeNormalMap() : ShaderNode(0)
	{
		// not implemented
	}

	enum space_enum {
		space_TANGENT = 0,
		space_OBJECT = 1,
		space_WORLD = 2,
		space_BLENDER_OBJECT = 3,
		space_BLENDER_WORLD = 4,
	};

	/** Getter: Space of the input normal */
	space_enum space() { /* not implemented */ throw NULL; }
	/** Setter: Space of the input normal */
	void space(space_enum value) { /* not implemented */ }

	/** Getter: UV Map for tangent space maps */
	std::string uv_map() { /* not implemented */ throw NULL; }
	/** Setter: UV Map for tangent space maps */
	void uv_map(const std::string& value) { /* not implemented */ }

	/**
	 * True if a registered node type
	 * @return 
	 */
	bool is_registered_node_type()
	{
		// not implemented
		return true;
	}

	/**
	 * Input socket template
	 * @param Param 'index'
	 * @return 
	 */
	NodeInternalSocketTemplate input_template(int index)
	{
		// not implemented
		return NodeInternalSocketTemplate();
	}

	/**
	 * Output socket template
	 * @param Param 'index'
	 * @return 
	 */
	NodeInternalSocketTemplate output_template(int index)
	{
		// not implemented
		return NodeInternalSocketTemplate();
	}

};

/**************** Tangent ****************/

/**
 * 
 */
class ShaderNodeTangent : public ShaderNode {
public:
	ShaderNodeTangent(PyObject* pyobj) : ShaderNode(pyobj) {}

	ShaderNodeTangent() : ShaderNode(0)
	{
		// not implemented
	}

	enum direction_type_enum {
		direction_type_RADIAL = 0,
		direction_type_UV_MAP = 1,
	};

	/** Getter: Method to use for the tangent */
	direction_type_enum direction_type() { /* not implemented */ throw NULL; }
	/** Setter: Method to use for the tangent */
	void direction_type(direction_type_enum value) { /* not implemented */ }

	enum axis_enum {
		axis_X = 0,
		axis_Y = 1,
		axis_Z = 2,
	};

	/** Getter: Axis for radial tangents */
	axis_enum axis() { /* not implemented */ throw NULL; }
	/** Setter: Axis for radial tangents */
	void axis(axis_enum value) { /* not implemented */ }

	/** Getter: UV Map for tangent generated from UV */
	std::string uv_map() { /* not implemented */ throw NULL; }
	/** Setter: UV Map for tangent generated from UV */
	void uv_map(const std::string& value) { /* not implemented */ }

	/**
	 * True if a registered node type
	 * @return 
	 */
	bool is_registered_node_type()
	{
		// not implemented
		return true;
	}

	/**
	 * Input socket template
	 * @param Param 'index'
	 * @return 
	 */
	NodeInternalSocketTemplate input_template(int index)
	{
		// not implemented
		return NodeInternalSocketTemplate();
	}

	/**
	 * Output socket template
	 * @param Param 'index'
	 * @return 
	 */
	NodeInternalSocketTemplate output_template(int index)
	{
		// not implemented
		return NodeInternalSocketTemplate();
	}

};

/**************** Script ****************/

/**
 * 
 */
class ShaderNodeScript : public ShaderNode {
public:
	ShaderNodeScript(PyObject* pyobj) : ShaderNode(pyobj) {}

	ShaderNodeScript() : ShaderNode(0)
	{
		// not implemented
	}

	/** Getter: Internal shader script to define the shader */
	Text script();

	/** Getter: Shader script path */
	std::string filepath() { /* not implemented */ throw NULL; }
	/** Setter: Shader script path */
	void filepath(const std::string& value) { /* not implemented */ }

	enum mode_enum {
		mode_INTERNAL = 0,
		mode_EXTERNAL = 1,
	};

	/** Getter:  */
	mode_enum mode() { /* not implemented */ throw NULL; }
	/** Setter:  */
	void mode(mode_enum value) { /* not implemented */ }

	/** Getter: Automatically update the shader when the .osl file changes (external scripts only) */
	bool use_auto_update() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_auto_update")) == 1;
	}

	/** Setter: Automatically update the shader when the .osl file changes (external scripts only) */
	void use_auto_update(bool value) {
		PyObject_SetAttrString(pyobjref, "use_auto_update", Py_BuildValue("i", value));
	}

	/** Getter: Compile bytecode for shader script node */
	std::string bytecode() { /* not implemented */ throw NULL; }
	/** Setter: Compile bytecode for shader script node */
	void bytecode(const std::string& value) { /* not implemented */ }

	/** Getter: Hash of compile bytecode, for quick equality checking */
	std::string bytecode_hash() { /* not implemented */ throw NULL; }
	/** Setter: Hash of compile bytecode, for quick equality checking */
	void bytecode_hash(const std::string& value) { /* not implemented */ }

	/**
	 * True if a registered node type
	 * @return 
	 */
	bool is_registered_node_type()
	{
		// not implemented
		return true;
	}

	/**
	 * Input socket template
	 * @param Param 'index'
	 * @return 
	 */
	NodeInternalSocketTemplate input_template(int index)
	{
		// not implemented
		return NodeInternalSocketTemplate();
	}

	/**
	 * Output socket template
	 * @param Param 'index'
	 * @return 
	 */
	NodeInternalSocketTemplate output_template(int index)
	{
		// not implemented
		return NodeInternalSocketTemplate();
	}

};

/**************** Image Texture ****************/

/**
 * 
 */
class ShaderNodeTexImage : public ShaderNode {
public:
	ShaderNodeTexImage(PyObject* pyobj) : ShaderNode(pyobj) {}

	ShaderNodeTexImage() : ShaderNode(0)
	{
		// not implemented
	}

	/** Getter:  */
	Image image() {
		/* not implemented */ throw NULL;
	}

	/** Getter: Texture coordinate mapping settings */
	TexMapping texture_mapping() {
		/* not implemented */ throw NULL;
	}

	/** Getter: Color mapping settings */
	ColorMapping color_mapping() {
		/* not implemented */ throw NULL;
	}

	enum color_space_enum {
		color_space_COLOR = 1,
		color_space_NONE = 0,
	};

	/** Getter: Image file color space */
	color_space_enum color_space() { /* not implemented */ throw NULL; }
	/** Setter: Image file color space */
	void color_space(color_space_enum value) { /* not implemented */ }

	enum projection_enum {
		projection_FLAT = 0,
		projection_BOX = 1,
		projection_SPHERE = 2,
		projection_TUBE = 3,
	};

	/** Getter: Method to project 2D image on object with a 3D texture vector */
	projection_enum projection() { /* not implemented */ throw NULL; }
	/** Setter: Method to project 2D image on object with a 3D texture vector */
	void projection(projection_enum value) { /* not implemented */ }

	enum interpolation_enum {
		interpolation_Linear = 0,
		interpolation_Closest = 1,
		interpolation_Cubic = 2,
		interpolation_Smart = 3,
	};

	/** Getter: Texture interpolation */
	interpolation_enum interpolation() { /* not implemented */ throw NULL; }
	/** Setter: Texture interpolation */
	void interpolation(interpolation_enum value) { /* not implemented */ }

	/** Getter: For box projection, amount of blend to use between sides */
	float projection_blend() { /* not implemented */ throw NULL; }
	/** Setter: For box projection, amount of blend to use between sides */
	void projection_blend(float value) {
		PyObject_SetAttrString(pyobjref, "projection_blend", Py_BuildValue("f", value));
	}

	/** Getter: Parameters defining which layer, pass and frame of the image is displayed */
	ImageUser image_user() {
		/* not implemented */ throw NULL;
	}

	/**
	 * True if a registered node type
	 * @return 
	 */
	bool is_registered_node_type()
	{
		// not implemented
		return true;
	}

	/**
	 * Input socket template
	 * @param Param 'index'
	 * @return 
	 */
	NodeInternalSocketTemplate input_template(int index)
	{
		// not implemented
		return NodeInternalSocketTemplate();
	}

	/**
	 * Output socket template
	 * @param Param 'index'
	 * @return 
	 */
	NodeInternalSocketTemplate output_template(int index)
	{
		// not implemented
		return NodeInternalSocketTemplate();
	}

};

/**************** Environment Texture ****************/

/**
 * 
 */
class ShaderNodeTexEnvironment : public ShaderNode {
public:
	ShaderNodeTexEnvironment(PyObject* pyobj) : ShaderNode(pyobj) {}

	ShaderNodeTexEnvironment() : ShaderNode(0)
	{
		// not implemented
	}

	/** Getter:  */
	Image image() {
		/* not implemented */ throw NULL;
	}

	/** Getter: Texture coordinate mapping settings */
	TexMapping texture_mapping() {
		/* not implemented */ throw NULL;
	}

	/** Getter: Color mapping settings */
	ColorMapping color_mapping() {
		/* not implemented */ throw NULL;
	}

	enum color_space_enum {
		color_space_COLOR = 1,
		color_space_NONE = 0,
	};

	/** Getter: Image file color space */
	color_space_enum color_space() { /* not implemented */ throw NULL; }
	/** Setter: Image file color space */
	void color_space(color_space_enum value) { /* not implemented */ }

	enum projection_enum {
		projection_EQUIRECTANGULAR = 0,
		projection_MIRROR_BALL = 1,
	};

	/** Getter: Projection of the input image */
	projection_enum projection() { /* not implemented */ throw NULL; }
	/** Setter: Projection of the input image */
	void projection(projection_enum value) { /* not implemented */ }

	/** Getter: Parameters defining which layer, pass and frame of the image is displayed */
	ImageUser image_user() {
		/* not implemented */ throw NULL;
	}

	/**
	 * True if a registered node type
	 * @return 
	 */
	bool is_registered_node_type()
	{
		// not implemented
		return true;
	}

	/**
	 * Input socket template
	 * @param Param 'index'
	 * @return 
	 */
	NodeInternalSocketTemplate input_template(int index)
	{
		// not implemented
		return NodeInternalSocketTemplate();
	}

	/**
	 * Output socket template
	 * @param Param 'index'
	 * @return 
	 */
	NodeInternalSocketTemplate output_template(int index)
	{
		// not implemented
		return NodeInternalSocketTemplate();
	}

};

/**************** Sky Texture ****************/

/**
 * 
 */
class ShaderNodeTexSky : public ShaderNode {
public:
	ShaderNodeTexSky(PyObject* pyobj) : ShaderNode(pyobj) {}

	ShaderNodeTexSky() : ShaderNode(0)
	{
		// not implemented
	}

	/** Getter: Texture coordinate mapping settings */
	TexMapping texture_mapping() {
		/* not implemented */ throw NULL;
	}

	/** Getter: Color mapping settings */
	ColorMapping color_mapping() {
		/* not implemented */ throw NULL;
	}

	enum sky_type_enum {
		sky_type_PREETHAM = 0,
		sky_type_HOSEK_WILKIE = 1,
	};

	/** Getter:  */
	sky_type_enum sky_type() { /* not implemented */ throw NULL; }
	/** Setter:  */
	void sky_type(sky_type_enum value) { /* not implemented */ }

	/** Getter: Direction from where the sun is shining */
	std::array<float, 3> sun_direction() {
		// TODO: MISSING DEREF! USE #DEFINE!
		PyObject *seqval = PyObject_GetAttrString(pyobjref, "sun_direction");
		std::array<float, 3> resarr;
		for (int i = 0; i < 3; i++)
			resarr[i] = (float)PyFloat_AsDouble(PySequence_GetItem(seqval, i));
		return resarr;
	}

	/** Setter: Direction from where the sun is shining */
	void sun_direction(float values[3]) { /* not implemented */ }

	/** Getter: Atmospheric turbidity */
	float turbidity() { /* not implemented */ throw NULL; }
	/** Setter: Atmospheric turbidity */
	void turbidity(float value) {
		PyObject_SetAttrString(pyobjref, "turbidity", Py_BuildValue("f", value));
	}

	/** Getter: Ground color that is subtly reflected in the sky */
	float ground_albedo() { /* not implemented */ throw NULL; }
	/** Setter: Ground color that is subtly reflected in the sky */
	void ground_albedo(float value) {
		PyObject_SetAttrString(pyobjref, "ground_albedo", Py_BuildValue("f", value));
	}

	/**
	 * True if a registered node type
	 * @return 
	 */
	bool is_registered_node_type()
	{
		// not implemented
		return true;
	}

	/**
	 * Input socket template
	 * @param Param 'index'
	 * @return 
	 */
	NodeInternalSocketTemplate input_template(int index)
	{
		// not implemented
		return NodeInternalSocketTemplate();
	}

	/**
	 * Output socket template
	 * @param Param 'index'
	 * @return 
	 */
	NodeInternalSocketTemplate output_template(int index)
	{
		// not implemented
		return NodeInternalSocketTemplate();
	}

};

/**************** Gradient Texture ****************/

/**
 * 
 */
class ShaderNodeTexGradient : public ShaderNode {
public:
	ShaderNodeTexGradient(PyObject* pyobj) : ShaderNode(pyobj) {}

	ShaderNodeTexGradient() : ShaderNode(0)
	{
		// not implemented
	}

	/** Getter: Texture coordinate mapping settings */
	TexMapping texture_mapping() {
		/* not implemented */ throw NULL;
	}

	/** Getter: Color mapping settings */
	ColorMapping color_mapping() {
		/* not implemented */ throw NULL;
	}

	enum gradient_type_enum {
		gradient_type_LINEAR = 0,
		gradient_type_QUADRATIC = 1,
		gradient_type_EASING = 2,
		gradient_type_DIAGONAL = 3,
		gradient_type_SPHERICAL = 6,
		gradient_type_QUADRATIC_SPHERE = 5,
		gradient_type_RADIAL = 4,
	};

	/** Getter: Style of the color blending */
	gradient_type_enum gradient_type() { /* not implemented */ throw NULL; }
	/** Setter: Style of the color blending */
	void gradient_type(gradient_type_enum value) { /* not implemented */ }

	/**
	 * True if a registered node type
	 * @return 
	 */
	bool is_registered_node_type()
	{
		// not implemented
		return true;
	}

	/**
	 * Input socket template
	 * @param Param 'index'
	 * @return 
	 */
	NodeInternalSocketTemplate input_template(int index)
	{
		// not implemented
		return NodeInternalSocketTemplate();
	}

	/**
	 * Output socket template
	 * @param Param 'index'
	 * @return 
	 */
	NodeInternalSocketTemplate output_template(int index)
	{
		// not implemented
		return NodeInternalSocketTemplate();
	}

};

/**************** Noise Texture ****************/

/**
 * 
 */
class ShaderNodeTexNoise : public ShaderNode {
public:
	ShaderNodeTexNoise(PyObject* pyobj) : ShaderNode(pyobj) {}

	ShaderNodeTexNoise() : ShaderNode(0)
	{
		// not implemented
	}

	/** Getter: Texture coordinate mapping settings */
	TexMapping texture_mapping() {
		/* not implemented */ throw NULL;
	}

	/** Getter: Color mapping settings */
	ColorMapping color_mapping() {
		/* not implemented */ throw NULL;
	}

	/**
	 * True if a registered node type
	 * @return 
	 */
	bool is_registered_node_type()
	{
		// not implemented
		return true;
	}

	/**
	 * Input socket template
	 * @param Param 'index'
	 * @return 
	 */
	NodeInternalSocketTemplate input_template(int index)
	{
		// not implemented
		return NodeInternalSocketTemplate();
	}

	/**
	 * Output socket template
	 * @param Param 'index'
	 * @return 
	 */
	NodeInternalSocketTemplate output_template(int index)
	{
		// not implemented
		return NodeInternalSocketTemplate();
	}

};

/**************** Magic Texture ****************/

/**
 * 
 */
class ShaderNodeTexMagic : public ShaderNode {
public:
	ShaderNodeTexMagic(PyObject* pyobj) : ShaderNode(pyobj) {}

	ShaderNodeTexMagic() : ShaderNode(0)
	{
		// not implemented
	}

	/** Getter: Texture coordinate mapping settings */
	TexMapping texture_mapping() {
		/* not implemented */ throw NULL;
	}

	/** Getter: Color mapping settings */
	ColorMapping color_mapping() {
		/* not implemented */ throw NULL;
	}

	/** Getter: Level of detail in the added turbulent noise */
	int turbulence_depth() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "turbulence_depth"));
	}

	/** Setter: Level of detail in the added turbulent noise */
	void turbulence_depth(int value) {
		PyObject_SetAttrString(pyobjref, "turbulence_depth", Py_BuildValue("i", value));
	}

	/**
	 * True if a registered node type
	 * @return 
	 */
	bool is_registered_node_type()
	{
		// not implemented
		return true;
	}

	/**
	 * Input socket template
	 * @param Param 'index'
	 * @return 
	 */
	NodeInternalSocketTemplate input_template(int index)
	{
		// not implemented
		return NodeInternalSocketTemplate();
	}

	/**
	 * Output socket template
	 * @param Param 'index'
	 * @return 
	 */
	NodeInternalSocketTemplate output_template(int index)
	{
		// not implemented
		return NodeInternalSocketTemplate();
	}

};

/**************** Wave Texture ****************/

/**
 * 
 */
class ShaderNodeTexWave : public ShaderNode {
public:
	ShaderNodeTexWave(PyObject* pyobj) : ShaderNode(pyobj) {}

	ShaderNodeTexWave() : ShaderNode(0)
	{
		// not implemented
	}

	/** Getter: Texture coordinate mapping settings */
	TexMapping texture_mapping() {
		/* not implemented */ throw NULL;
	}

	/** Getter: Color mapping settings */
	ColorMapping color_mapping() {
		/* not implemented */ throw NULL;
	}

	enum wave_type_enum {
		wave_type_BANDS = 0,
		wave_type_RINGS = 1,
	};

	/** Getter:  */
	wave_type_enum wave_type() { /* not implemented */ throw NULL; }
	/** Setter:  */
	void wave_type(wave_type_enum value) { /* not implemented */ }

	/**
	 * True if a registered node type
	 * @return 
	 */
	bool is_registered_node_type()
	{
		// not implemented
		return true;
	}

	/**
	 * Input socket template
	 * @param Param 'index'
	 * @return 
	 */
	NodeInternalSocketTemplate input_template(int index)
	{
		// not implemented
		return NodeInternalSocketTemplate();
	}

	/**
	 * Output socket template
	 * @param Param 'index'
	 * @return 
	 */
	NodeInternalSocketTemplate output_template(int index)
	{
		// not implemented
		return NodeInternalSocketTemplate();
	}

};

/**************** Musgrave Texture ****************/

/**
 * 
 */
class ShaderNodeTexMusgrave : public ShaderNode {
public:
	ShaderNodeTexMusgrave(PyObject* pyobj) : ShaderNode(pyobj) {}

	ShaderNodeTexMusgrave() : ShaderNode(0)
	{
		// not implemented
	}

	/** Getter: Texture coordinate mapping settings */
	TexMapping texture_mapping() {
		/* not implemented */ throw NULL;
	}

	/** Getter: Color mapping settings */
	ColorMapping color_mapping() {
		/* not implemented */ throw NULL;
	}

	enum musgrave_type_enum {
		musgrave_type_MULTIFRACTAL = 0,
		musgrave_type_RIDGED_MULTIFRACTAL = 3,
		musgrave_type_HYBRID_MULTIFRACTAL = 2,
		musgrave_type_FBM = 1,
		musgrave_type_HETERO_TERRAIN = 4,
	};

	/** Getter:  */
	musgrave_type_enum musgrave_type() { /* not implemented */ throw NULL; }
	/** Setter:  */
	void musgrave_type(musgrave_type_enum value) { /* not implemented */ }

	/**
	 * True if a registered node type
	 * @return 
	 */
	bool is_registered_node_type()
	{
		// not implemented
		return true;
	}

	/**
	 * Input socket template
	 * @param Param 'index'
	 * @return 
	 */
	NodeInternalSocketTemplate input_template(int index)
	{
		// not implemented
		return NodeInternalSocketTemplate();
	}

	/**
	 * Output socket template
	 * @param Param 'index'
	 * @return 
	 */
	NodeInternalSocketTemplate output_template(int index)
	{
		// not implemented
		return NodeInternalSocketTemplate();
	}

};

/**************** Voronoi Texture ****************/

/**
 * 
 */
class ShaderNodeTexVoronoi : public ShaderNode {
public:
	ShaderNodeTexVoronoi(PyObject* pyobj) : ShaderNode(pyobj) {}

	ShaderNodeTexVoronoi() : ShaderNode(0)
	{
		// not implemented
	}

	/** Getter: Texture coordinate mapping settings */
	TexMapping texture_mapping() {
		/* not implemented */ throw NULL;
	}

	/** Getter: Color mapping settings */
	ColorMapping color_mapping() {
		/* not implemented */ throw NULL;
	}

	enum coloring_enum {
		coloring_INTENSITY = 0,
		coloring_CELLS = 1,
	};

	/** Getter:  */
	coloring_enum coloring() { /* not implemented */ throw NULL; }
	/** Setter:  */
	void coloring(coloring_enum value) { /* not implemented */ }

	/**
	 * True if a registered node type
	 * @return 
	 */
	bool is_registered_node_type()
	{
		// not implemented
		return true;
	}

	/**
	 * Input socket template
	 * @param Param 'index'
	 * @return 
	 */
	NodeInternalSocketTemplate input_template(int index)
	{
		// not implemented
		return NodeInternalSocketTemplate();
	}

	/**
	 * Output socket template
	 * @param Param 'index'
	 * @return 
	 */
	NodeInternalSocketTemplate output_template(int index)
	{
		// not implemented
		return NodeInternalSocketTemplate();
	}

};

/**************** Checker Texture ****************/

/**
 * 
 */
class ShaderNodeTexChecker : public ShaderNode {
public:
	ShaderNodeTexChecker(PyObject* pyobj) : ShaderNode(pyobj) {}

	ShaderNodeTexChecker() : ShaderNode(0)
	{
		// not implemented
	}

	/** Getter: Texture coordinate mapping settings */
	TexMapping texture_mapping() {
		/* not implemented */ throw NULL;
	}

	/** Getter: Color mapping settings */
	ColorMapping color_mapping() {
		/* not implemented */ throw NULL;
	}

	/**
	 * True if a registered node type
	 * @return 
	 */
	bool is_registered_node_type()
	{
		// not implemented
		return true;
	}

	/**
	 * Input socket template
	 * @param Param 'index'
	 * @return 
	 */
	NodeInternalSocketTemplate input_template(int index)
	{
		// not implemented
		return NodeInternalSocketTemplate();
	}

	/**
	 * Output socket template
	 * @param Param 'index'
	 * @return 
	 */
	NodeInternalSocketTemplate output_template(int index)
	{
		// not implemented
		return NodeInternalSocketTemplate();
	}

};

/**************** Brick Texture ****************/

/**
 * 
 */
class ShaderNodeTexBrick : public ShaderNode {
public:
	ShaderNodeTexBrick(PyObject* pyobj) : ShaderNode(pyobj) {}

	ShaderNodeTexBrick() : ShaderNode(0)
	{
		// not implemented
	}

	/** Getter: Texture coordinate mapping settings */
	TexMapping texture_mapping() {
		/* not implemented */ throw NULL;
	}

	/** Getter: Color mapping settings */
	ColorMapping color_mapping() {
		/* not implemented */ throw NULL;
	}

	/** Getter:  */
	int offset_frequency() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "offset_frequency"));
	}

	/** Setter:  */
	void offset_frequency(int value) {
		PyObject_SetAttrString(pyobjref, "offset_frequency", Py_BuildValue("i", value));
	}

	/** Getter:  */
	int squash_frequency() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "squash_frequency"));
	}

	/** Setter:  */
	void squash_frequency(int value) {
		PyObject_SetAttrString(pyobjref, "squash_frequency", Py_BuildValue("i", value));
	}

	/** Getter:  */
	float offset() { /* not implemented */ throw NULL; }
	/** Setter:  */
	void offset(float value) {
		PyObject_SetAttrString(pyobjref, "offset", Py_BuildValue("f", value));
	}

	/** Getter:  */
	float squash() { /* not implemented */ throw NULL; }
	/** Setter:  */
	void squash(float value) {
		PyObject_SetAttrString(pyobjref, "squash", Py_BuildValue("f", value));
	}

	/**
	 * True if a registered node type
	 * @return 
	 */
	bool is_registered_node_type()
	{
		// not implemented
		return true;
	}

	/**
	 * Input socket template
	 * @param Param 'index'
	 * @return 
	 */
	NodeInternalSocketTemplate input_template(int index)
	{
		// not implemented
		return NodeInternalSocketTemplate();
	}

	/**
	 * Output socket template
	 * @param Param 'index'
	 * @return 
	 */
	NodeInternalSocketTemplate output_template(int index)
	{
		// not implemented
		return NodeInternalSocketTemplate();
	}

};

/**************** Texture Coordinate ****************/

/**
 * 
 */
class ShaderNodeTexCoord : public ShaderNode {
public:
	ShaderNodeTexCoord(PyObject* pyobj) : ShaderNode(pyobj) {}

	ShaderNodeTexCoord() : ShaderNode(0)
	{
		// not implemented
	}

	/** Getter: Use coordinates from this object (for object texture coordinates output) */
	Object object_value();

	/** Getter: Use the parent of the dupli object if possible */
	bool from_dupli() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "from_dupli")) == 1;
	}

	/** Setter: Use the parent of the dupli object if possible */
	void from_dupli(bool value) {
		PyObject_SetAttrString(pyobjref, "from_dupli", Py_BuildValue("i", value));
	}

	/**
	 * True if a registered node type
	 * @return 
	 */
	bool is_registered_node_type()
	{
		// not implemented
		return true;
	}

	/**
	 * Input socket template
	 * @param Param 'index'
	 * @return 
	 */
	NodeInternalSocketTemplate input_template(int index)
	{
		// not implemented
		return NodeInternalSocketTemplate();
	}

	/**
	 * Output socket template
	 * @param Param 'index'
	 * @return 
	 */
	NodeInternalSocketTemplate output_template(int index)
	{
		// not implemented
		return NodeInternalSocketTemplate();
	}

};

/**************** Vector Transform ****************/

/**
 * 
 */
class ShaderNodeVectorTransform : public ShaderNode {
public:
	ShaderNodeVectorTransform(PyObject* pyobj) : ShaderNode(pyobj) {}

	ShaderNodeVectorTransform() : ShaderNode(0)
	{
		// not implemented
	}

	enum vector_type_enum {
		vector_type_POINT = 1,
		vector_type_VECTOR = 0,
		vector_type_NORMAL = 2,
	};

	/** Getter:  */
	vector_type_enum vector_type() { /* not implemented */ throw NULL; }
	/** Setter:  */
	void vector_type(vector_type_enum value) { /* not implemented */ }

	enum convert_from_enum {
		convert_from_WORLD = 0,
		convert_from_OBJECT = 1,
		convert_from_CAMERA = 2,
	};

	/** Getter: Space to convert from */
	convert_from_enum convert_from() { /* not implemented */ throw NULL; }
	/** Setter: Space to convert from */
	void convert_from(convert_from_enum value) { /* not implemented */ }

	enum convert_to_enum {
		convert_to_WORLD = 0,
		convert_to_OBJECT = 1,
		convert_to_CAMERA = 2,
	};

	/** Getter: Space to convert to */
	convert_to_enum convert_to() { /* not implemented */ throw NULL; }
	/** Setter: Space to convert to */
	void convert_to(convert_to_enum value) { /* not implemented */ }

	/**
	 * True if a registered node type
	 * @return 
	 */
	bool is_registered_node_type()
	{
		// not implemented
		return true;
	}

	/**
	 * Input socket template
	 * @param Param 'index'
	 * @return 
	 */
	NodeInternalSocketTemplate input_template(int index)
	{
		// not implemented
		return NodeInternalSocketTemplate();
	}

	/**
	 * Output socket template
	 * @param Param 'index'
	 * @return 
	 */
	NodeInternalSocketTemplate output_template(int index)
	{
		// not implemented
		return NodeInternalSocketTemplate();
	}

};

/**************** Separate HSV ****************/

/**
 * 
 */
class ShaderNodeSeparateHSV : public ShaderNode {
public:
	ShaderNodeSeparateHSV(PyObject* pyobj) : ShaderNode(pyobj) {}

	ShaderNodeSeparateHSV() : ShaderNode(0)
	{
		// not implemented
	}

	/**
	 * True if a registered node type
	 * @return 
	 */
	bool is_registered_node_type()
	{
		// not implemented
		return true;
	}

	/**
	 * Input socket template
	 * @param Param 'index'
	 * @return 
	 */
	NodeInternalSocketTemplate input_template(int index)
	{
		// not implemented
		return NodeInternalSocketTemplate();
	}

	/**
	 * Output socket template
	 * @param Param 'index'
	 * @return 
	 */
	NodeInternalSocketTemplate output_template(int index)
	{
		// not implemented
		return NodeInternalSocketTemplate();
	}

};

/**************** Combine HSV ****************/

/**
 * 
 */
class ShaderNodeCombineHSV : public ShaderNode {
public:
	ShaderNodeCombineHSV(PyObject* pyobj) : ShaderNode(pyobj) {}

	ShaderNodeCombineHSV() : ShaderNode(0)
	{
		// not implemented
	}

	/**
	 * True if a registered node type
	 * @return 
	 */
	bool is_registered_node_type()
	{
		// not implemented
		return true;
	}

	/**
	 * Input socket template
	 * @param Param 'index'
	 * @return 
	 */
	NodeInternalSocketTemplate input_template(int index)
	{
		// not implemented
		return NodeInternalSocketTemplate();
	}

	/**
	 * Output socket template
	 * @param Param 'index'
	 * @return 
	 */
	NodeInternalSocketTemplate output_template(int index)
	{
		// not implemented
		return NodeInternalSocketTemplate();
	}

};

/**************** UV Map ****************/

/**
 * 
 */
class ShaderNodeUVMap : public ShaderNode {
public:
	ShaderNodeUVMap(PyObject* pyobj) : ShaderNode(pyobj) {}

	ShaderNodeUVMap() : ShaderNode(0)
	{
		// not implemented
	}

	/** Getter: Use the parent of the dupli object if possible */
	bool from_dupli() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "from_dupli")) == 1;
	}

	/** Setter: Use the parent of the dupli object if possible */
	void from_dupli(bool value) {
		PyObject_SetAttrString(pyobjref, "from_dupli", Py_BuildValue("i", value));
	}

	/** Getter: UV coordinates to be used for mapping */
	std::string uv_map() { /* not implemented */ throw NULL; }
	/** Setter: UV coordinates to be used for mapping */
	void uv_map(const std::string& value) { /* not implemented */ }

	/**
	 * True if a registered node type
	 * @return 
	 */
	bool is_registered_node_type()
	{
		// not implemented
		return true;
	}

	/**
	 * Input socket template
	 * @param Param 'index'
	 * @return 
	 */
	NodeInternalSocketTemplate input_template(int index)
	{
		// not implemented
		return NodeInternalSocketTemplate();
	}

	/**
	 * Output socket template
	 * @param Param 'index'
	 * @return 
	 */
	NodeInternalSocketTemplate output_template(int index)
	{
		// not implemented
		return NodeInternalSocketTemplate();
	}

};

/**************** UV Along Stroke ****************/

/**
 * 
 */
class ShaderNodeUVAlongStroke : public ShaderNode {
public:
	ShaderNodeUVAlongStroke(PyObject* pyobj) : ShaderNode(pyobj) {}

	ShaderNodeUVAlongStroke() : ShaderNode(0)
	{
		// not implemented
	}

	/** Getter: Lower half of the texture is for tips of the stroke */
	bool use_tips() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_tips")) == 1;
	}

	/** Setter: Lower half of the texture is for tips of the stroke */
	void use_tips(bool value) {
		PyObject_SetAttrString(pyobjref, "use_tips", Py_BuildValue("i", value));
	}

	/**
	 * True if a registered node type
	 * @return 
	 */
	bool is_registered_node_type()
	{
		// not implemented
		return true;
	}

	/**
	 * Input socket template
	 * @param Param 'index'
	 * @return 
	 */
	NodeInternalSocketTemplate input_template(int index)
	{
		// not implemented
		return NodeInternalSocketTemplate();
	}

	/**
	 * Output socket template
	 * @param Param 'index'
	 * @return 
	 */
	NodeInternalSocketTemplate output_template(int index)
	{
		// not implemented
		return NodeInternalSocketTemplate();
	}

};

/**************** Separate XYZ ****************/

/**
 * 
 */
class ShaderNodeSeparateXYZ : public ShaderNode {
public:
	ShaderNodeSeparateXYZ(PyObject* pyobj) : ShaderNode(pyobj) {}

	ShaderNodeSeparateXYZ() : ShaderNode(0)
	{
		// not implemented
	}

	/**
	 * True if a registered node type
	 * @return 
	 */
	bool is_registered_node_type()
	{
		// not implemented
		return true;
	}

	/**
	 * Input socket template
	 * @param Param 'index'
	 * @return 
	 */
	NodeInternalSocketTemplate input_template(int index)
	{
		// not implemented
		return NodeInternalSocketTemplate();
	}

	/**
	 * Output socket template
	 * @param Param 'index'
	 * @return 
	 */
	NodeInternalSocketTemplate output_template(int index)
	{
		// not implemented
		return NodeInternalSocketTemplate();
	}

};

/**************** Combine XYZ ****************/

/**
 * 
 */
class ShaderNodeCombineXYZ : public ShaderNode {
public:
	ShaderNodeCombineXYZ(PyObject* pyobj) : ShaderNode(pyobj) {}

	ShaderNodeCombineXYZ() : ShaderNode(0)
	{
		// not implemented
	}

	/**
	 * True if a registered node type
	 * @return 
	 */
	bool is_registered_node_type()
	{
		// not implemented
		return true;
	}

	/**
	 * Input socket template
	 * @param Param 'index'
	 * @return 
	 */
	NodeInternalSocketTemplate input_template(int index)
	{
		// not implemented
		return NodeInternalSocketTemplate();
	}

	/**
	 * Output socket template
	 * @param Param 'index'
	 * @return 
	 */
	NodeInternalSocketTemplate output_template(int index)
	{
		// not implemented
		return NodeInternalSocketTemplate();
	}

};

/**************** Viewer ****************/

/**
 * 
 */
class CompositorNodeViewer : public CompositorNode {
public:
	CompositorNodeViewer(PyObject* pyobj) : CompositorNode(pyobj) {}

	CompositorNodeViewer() : CompositorNode(0)
	{
		// not implemented
	}

	enum tile_order_enum {
		tile_order_CENTEROUT = 0,
		tile_order_RANDOM = 1,
		tile_order_BOTTOMUP = 2,
		tile_order_RULE_OF_THIRDS = 3,
	};

	/** Getter: Tile order */
	tile_order_enum tile_order() { /* not implemented */ throw NULL; }
	/** Setter: Tile order */
	void tile_order(tile_order_enum value) { /* not implemented */ }

	/** Getter:  */
	float center_x() { /* not implemented */ throw NULL; }
	/** Setter:  */
	void center_x(float value) {
		PyObject_SetAttrString(pyobjref, "center_x", Py_BuildValue("f", value));
	}

	/** Getter:  */
	float center_y() { /* not implemented */ throw NULL; }
	/** Setter:  */
	void center_y(float value) {
		PyObject_SetAttrString(pyobjref, "center_y", Py_BuildValue("f", value));
	}

	/** Getter: Colors are treated alpha premultiplied, or colors output straight (alpha gets set to 1) */
	bool use_alpha() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_alpha")) == 1;
	}

	/** Setter: Colors are treated alpha premultiplied, or colors output straight (alpha gets set to 1) */
	void use_alpha(bool value) {
		PyObject_SetAttrString(pyobjref, "use_alpha", Py_BuildValue("i", value));
	}

	/**
	 * True if a registered node type
	 * @return 
	 */
	bool is_registered_node_type()
	{
		// not implemented
		return true;
	}

	/**
	 * Input socket template
	 * @param Param 'index'
	 * @return 
	 */
	NodeInternalSocketTemplate input_template(int index)
	{
		// not implemented
		return NodeInternalSocketTemplate();
	}

	/**
	 * Output socket template
	 * @param Param 'index'
	 * @return 
	 */
	NodeInternalSocketTemplate output_template(int index)
	{
		// not implemented
		return NodeInternalSocketTemplate();
	}

};

/**************** RGB ****************/

/**
 * 
 */
class CompositorNodeRGB : public CompositorNode {
public:
	CompositorNodeRGB(PyObject* pyobj) : CompositorNode(pyobj) {}

	CompositorNodeRGB() : CompositorNode(0)
	{
		// not implemented
	}

	/**
	 * True if a registered node type
	 * @return 
	 */
	bool is_registered_node_type()
	{
		// not implemented
		return true;
	}

	/**
	 * Input socket template
	 * @param Param 'index'
	 * @return 
	 */
	NodeInternalSocketTemplate input_template(int index)
	{
		// not implemented
		return NodeInternalSocketTemplate();
	}

	/**
	 * Output socket template
	 * @param Param 'index'
	 * @return 
	 */
	NodeInternalSocketTemplate output_template(int index)
	{
		// not implemented
		return NodeInternalSocketTemplate();
	}

};

/**************** Value ****************/

/**
 * 
 */
class CompositorNodeValue : public CompositorNode {
public:
	CompositorNodeValue(PyObject* pyobj) : CompositorNode(pyobj) {}

	CompositorNodeValue() : CompositorNode(0)
	{
		// not implemented
	}

	/**
	 * True if a registered node type
	 * @return 
	 */
	bool is_registered_node_type()
	{
		// not implemented
		return true;
	}

	/**
	 * Input socket template
	 * @param Param 'index'
	 * @return 
	 */
	NodeInternalSocketTemplate input_template(int index)
	{
		// not implemented
		return NodeInternalSocketTemplate();
	}

	/**
	 * Output socket template
	 * @param Param 'index'
	 * @return 
	 */
	NodeInternalSocketTemplate output_template(int index)
	{
		// not implemented
		return NodeInternalSocketTemplate();
	}

};

/**************** Mix ****************/

/**
 * 
 */
class CompositorNodeMixRGB : public CompositorNode {
public:
	CompositorNodeMixRGB(PyObject* pyobj) : CompositorNode(pyobj) {}

	CompositorNodeMixRGB() : CompositorNode(0)
	{
		// not implemented
	}

	enum blend_type_enum {
		blend_type_MIX = 0,
		blend_type_ADD = 1,
		blend_type_MULTIPLY = 2,
		blend_type_SUBTRACT = 3,
		blend_type_SCREEN = 4,
		blend_type_DIVIDE = 5,
		blend_type_DIFFERENCE = 6,
		blend_type_DARKEN = 7,
		blend_type_LIGHTEN = 8,
		blend_type_OVERLAY = 9,
		blend_type_DODGE = 10,
		blend_type_BURN = 11,
		blend_type_HUE = 12,
		blend_type_SATURATION = 13,
		blend_type_VALUE = 14,
		blend_type_COLOR = 15,
		blend_type_SOFT_LIGHT = 16,
		blend_type_LINEAR_LIGHT = 17,
	};

	/** Getter:  */
	blend_type_enum blend_type() { /* not implemented */ throw NULL; }
	/** Setter:  */
	void blend_type(blend_type_enum value) { /* not implemented */ }

	/** Getter: Include alpha of second input in this operation */
	bool use_alpha() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_alpha")) == 1;
	}

	/** Setter: Include alpha of second input in this operation */
	void use_alpha(bool value) {
		PyObject_SetAttrString(pyobjref, "use_alpha", Py_BuildValue("i", value));
	}

	/** Getter: Clamp result of the node to 0..1 range */
	bool use_clamp() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_clamp")) == 1;
	}

	/** Setter: Clamp result of the node to 0..1 range */
	void use_clamp(bool value) {
		PyObject_SetAttrString(pyobjref, "use_clamp", Py_BuildValue("i", value));
	}

	/**
	 * True if a registered node type
	 * @return 
	 */
	bool is_registered_node_type()
	{
		// not implemented
		return true;
	}

	/**
	 * Input socket template
	 * @param Param 'index'
	 * @return 
	 */
	NodeInternalSocketTemplate input_template(int index)
	{
		// not implemented
		return NodeInternalSocketTemplate();
	}

	/**
	 * Output socket template
	 * @param Param 'index'
	 * @return 
	 */
	NodeInternalSocketTemplate output_template(int index)
	{
		// not implemented
		return NodeInternalSocketTemplate();
	}

};

/**************** ColorRamp ****************/

/**
 * 
 */
class CompositorNodeValToRGB : public CompositorNode {
public:
	CompositorNodeValToRGB(PyObject* pyobj) : CompositorNode(pyobj) {}

	CompositorNodeValToRGB() : CompositorNode(0)
	{
		// not implemented
	}

	/** Getter:  */
	ColorRamp color_ramp() {
		/* not implemented */ throw NULL;
	}

	/**
	 * True if a registered node type
	 * @return 
	 */
	bool is_registered_node_type()
	{
		// not implemented
		return true;
	}

	/**
	 * Input socket template
	 * @param Param 'index'
	 * @return 
	 */
	NodeInternalSocketTemplate input_template(int index)
	{
		// not implemented
		return NodeInternalSocketTemplate();
	}

	/**
	 * Output socket template
	 * @param Param 'index'
	 * @return 
	 */
	NodeInternalSocketTemplate output_template(int index)
	{
		// not implemented
		return NodeInternalSocketTemplate();
	}

};

/**************** RGB to BW ****************/

/**
 * 
 */
class CompositorNodeRGBToBW : public CompositorNode {
public:
	CompositorNodeRGBToBW(PyObject* pyobj) : CompositorNode(pyobj) {}

	CompositorNodeRGBToBW() : CompositorNode(0)
	{
		// not implemented
	}

	/**
	 * True if a registered node type
	 * @return 
	 */
	bool is_registered_node_type()
	{
		// not implemented
		return true;
	}

	/**
	 * Input socket template
	 * @param Param 'index'
	 * @return 
	 */
	NodeInternalSocketTemplate input_template(int index)
	{
		// not implemented
		return NodeInternalSocketTemplate();
	}

	/**
	 * Output socket template
	 * @param Param 'index'
	 * @return 
	 */
	NodeInternalSocketTemplate output_template(int index)
	{
		// not implemented
		return NodeInternalSocketTemplate();
	}

};

/**************** Normal ****************/

/**
 * 
 */
class CompositorNodeNormal : public CompositorNode {
public:
	CompositorNodeNormal(PyObject* pyobj) : CompositorNode(pyobj) {}

	CompositorNodeNormal() : CompositorNode(0)
	{
		// not implemented
	}

	/**
	 * True if a registered node type
	 * @return 
	 */
	bool is_registered_node_type()
	{
		// not implemented
		return true;
	}

	/**
	 * Input socket template
	 * @param Param 'index'
	 * @return 
	 */
	NodeInternalSocketTemplate input_template(int index)
	{
		// not implemented
		return NodeInternalSocketTemplate();
	}

	/**
	 * Output socket template
	 * @param Param 'index'
	 * @return 
	 */
	NodeInternalSocketTemplate output_template(int index)
	{
		// not implemented
		return NodeInternalSocketTemplate();
	}

};

/**************** Vector Curves ****************/

/**
 * 
 */
class CompositorNodeCurveVec : public CompositorNode {
public:
	CompositorNodeCurveVec(PyObject* pyobj) : CompositorNode(pyobj) {}

	CompositorNodeCurveVec() : CompositorNode(0)
	{
		// not implemented
	}

	/** Getter:  */
	CurveMapping mapping() {
		/* not implemented */ throw NULL;
	}

	/**
	 * True if a registered node type
	 * @return 
	 */
	bool is_registered_node_type()
	{
		// not implemented
		return true;
	}

	/**
	 * Input socket template
	 * @param Param 'index'
	 * @return 
	 */
	NodeInternalSocketTemplate input_template(int index)
	{
		// not implemented
		return NodeInternalSocketTemplate();
	}

	/**
	 * Output socket template
	 * @param Param 'index'
	 * @return 
	 */
	NodeInternalSocketTemplate output_template(int index)
	{
		// not implemented
		return NodeInternalSocketTemplate();
	}

};

/**************** RGB Curves ****************/

/**
 * 
 */
class CompositorNodeCurveRGB : public CompositorNode {
public:
	CompositorNodeCurveRGB(PyObject* pyobj) : CompositorNode(pyobj) {}

	CompositorNodeCurveRGB() : CompositorNode(0)
	{
		// not implemented
	}

	/** Getter:  */
	CurveMapping mapping() {
		/* not implemented */ throw NULL;
	}

	/**
	 * True if a registered node type
	 * @return 
	 */
	bool is_registered_node_type()
	{
		// not implemented
		return true;
	}

	/**
	 * Input socket template
	 * @param Param 'index'
	 * @return 
	 */
	NodeInternalSocketTemplate input_template(int index)
	{
		// not implemented
		return NodeInternalSocketTemplate();
	}

	/**
	 * Output socket template
	 * @param Param 'index'
	 * @return 
	 */
	NodeInternalSocketTemplate output_template(int index)
	{
		// not implemented
		return NodeInternalSocketTemplate();
	}

};

/**************** Alpha Over ****************/

/**
 * 
 */
class CompositorNodeAlphaOver : public CompositorNode {
public:
	CompositorNodeAlphaOver(PyObject* pyobj) : CompositorNode(pyobj) {}

	CompositorNodeAlphaOver() : CompositorNode(0)
	{
		// not implemented
	}

	/** Getter:  */
	bool use_premultiply() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_premultiply")) == 1;
	}

	/** Setter:  */
	void use_premultiply(bool value) {
		PyObject_SetAttrString(pyobjref, "use_premultiply", Py_BuildValue("i", value));
	}

	/** Getter: Mix Factor */
	float premul() { /* not implemented */ throw NULL; }
	/** Setter: Mix Factor */
	void premul(float value) {
		PyObject_SetAttrString(pyobjref, "premul", Py_BuildValue("f", value));
	}

	/**
	 * True if a registered node type
	 * @return 
	 */
	bool is_registered_node_type()
	{
		// not implemented
		return true;
	}

	/**
	 * Input socket template
	 * @param Param 'index'
	 * @return 
	 */
	NodeInternalSocketTemplate input_template(int index)
	{
		// not implemented
		return NodeInternalSocketTemplate();
	}

	/**
	 * Output socket template
	 * @param Param 'index'
	 * @return 
	 */
	NodeInternalSocketTemplate output_template(int index)
	{
		// not implemented
		return NodeInternalSocketTemplate();
	}

};

/**************** Blur ****************/

/**
 * 
 */
class CompositorNodeBlur : public CompositorNode {
public:
	CompositorNodeBlur(PyObject* pyobj) : CompositorNode(pyobj) {}

	CompositorNodeBlur() : CompositorNode(0)
	{
		// not implemented
	}

	/** Getter: Support variable blur per-pixel when using an image for size input */
	bool use_variable_size() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_variable_size")) == 1;
	}

	/** Setter: Support variable blur per-pixel when using an image for size input */
	void use_variable_size(bool value) {
		PyObject_SetAttrString(pyobjref, "use_variable_size", Py_BuildValue("i", value));
	}

	/** Getter:  */
	int size_x() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "size_x"));
	}

	/** Setter:  */
	void size_x(int value) {
		PyObject_SetAttrString(pyobjref, "size_x", Py_BuildValue("i", value));
	}

	/** Getter:  */
	int size_y() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "size_y"));
	}

	/** Setter:  */
	void size_y(int value) {
		PyObject_SetAttrString(pyobjref, "size_y", Py_BuildValue("i", value));
	}

	/** Getter: Use relative (percent) values to define blur radius */
	bool use_relative() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_relative")) == 1;
	}

	/** Setter: Use relative (percent) values to define blur radius */
	void use_relative(bool value) {
		PyObject_SetAttrString(pyobjref, "use_relative", Py_BuildValue("i", value));
	}

	enum aspect_correction_enum {
		aspect_correction_NONE = 0,
		aspect_correction_Y = 1,
		aspect_correction_X = 2,
	};

	/** Getter: Type of aspect correction to use */
	aspect_correction_enum aspect_correction() { /* not implemented */ throw NULL; }
	/** Setter: Type of aspect correction to use */
	void aspect_correction(aspect_correction_enum value) { /* not implemented */ }

	/** Getter:  */
	float factor() { /* not implemented */ throw NULL; }
	/** Setter:  */
	void factor(float value) {
		PyObject_SetAttrString(pyobjref, "factor", Py_BuildValue("f", value));
	}

	/** Getter:  */
	float factor_x() { /* not implemented */ throw NULL; }
	/** Setter:  */
	void factor_x(float value) {
		PyObject_SetAttrString(pyobjref, "factor_x", Py_BuildValue("f", value));
	}

	/** Getter:  */
	float factor_y() { /* not implemented */ throw NULL; }
	/** Setter:  */
	void factor_y(float value) {
		PyObject_SetAttrString(pyobjref, "factor_y", Py_BuildValue("f", value));
	}

	enum filter_type_enum {
		filter_type_FLAT = 0,
		filter_type_TENT = 1,
		filter_type_QUAD = 2,
		filter_type_CUBIC = 3,
		filter_type_GAUSS = 5,
		filter_type_FAST_GAUSS = 7,
		filter_type_CATROM = 4,
		filter_type_MITCH = 6,
	};

	/** Getter:  */
	filter_type_enum filter_type() { /* not implemented */ throw NULL; }
	/** Setter:  */
	void filter_type(filter_type_enum value) { /* not implemented */ }

	/** Getter: Use circular filter (slower) */
	bool use_bokeh() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_bokeh")) == 1;
	}

	/** Setter: Use circular filter (slower) */
	void use_bokeh(bool value) {
		PyObject_SetAttrString(pyobjref, "use_bokeh", Py_BuildValue("i", value));
	}

	/** Getter: Apply filter on gamma corrected values */
	bool use_gamma_correction() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_gamma_correction")) == 1;
	}

	/** Setter: Apply filter on gamma corrected values */
	void use_gamma_correction(bool value) {
		PyObject_SetAttrString(pyobjref, "use_gamma_correction", Py_BuildValue("i", value));
	}

	/**
	 * True if a registered node type
	 * @return 
	 */
	bool is_registered_node_type()
	{
		// not implemented
		return true;
	}

	/**
	 * Input socket template
	 * @param Param 'index'
	 * @return 
	 */
	NodeInternalSocketTemplate input_template(int index)
	{
		// not implemented
		return NodeInternalSocketTemplate();
	}

	/**
	 * Output socket template
	 * @param Param 'index'
	 * @return 
	 */
	NodeInternalSocketTemplate output_template(int index)
	{
		// not implemented
		return NodeInternalSocketTemplate();
	}

};

/**************** Filter ****************/

/**
 * 
 */
class CompositorNodeFilter : public CompositorNode {
public:
	CompositorNodeFilter(PyObject* pyobj) : CompositorNode(pyobj) {}

	CompositorNodeFilter() : CompositorNode(0)
	{
		// not implemented
	}

	enum filter_type_enum {
		filter_type_SOFTEN = 0,
		filter_type_SHARPEN = 1,
		filter_type_LAPLACE = 2,
		filter_type_SOBEL = 3,
		filter_type_PREWITT = 4,
		filter_type_KIRSCH = 5,
		filter_type_SHADOW = 6,
	};

	/** Getter:  */
	filter_type_enum filter_type() { /* not implemented */ throw NULL; }
	/** Setter:  */
	void filter_type(filter_type_enum value) { /* not implemented */ }

	/**
	 * True if a registered node type
	 * @return 
	 */
	bool is_registered_node_type()
	{
		// not implemented
		return true;
	}

	/**
	 * Input socket template
	 * @param Param 'index'
	 * @return 
	 */
	NodeInternalSocketTemplate input_template(int index)
	{
		// not implemented
		return NodeInternalSocketTemplate();
	}

	/**
	 * Output socket template
	 * @param Param 'index'
	 * @return 
	 */
	NodeInternalSocketTemplate output_template(int index)
	{
		// not implemented
		return NodeInternalSocketTemplate();
	}

};

/**************** Map Value ****************/

/**
 * 
 */
class CompositorNodeMapValue : public CompositorNode {
public:
	CompositorNodeMapValue(PyObject* pyobj) : CompositorNode(pyobj) {}

	CompositorNodeMapValue() : CompositorNode(0)
	{
		// not implemented
	}

	/** Getter:  */
	std::array<float, 1> offset() {
		// TODO: MISSING DEREF! USE #DEFINE!
		PyObject *seqval = PyObject_GetAttrString(pyobjref, "offset");
		std::array<float, 1> resarr;
		for (int i = 0; i < 1; i++)
			resarr[i] = (float)PyFloat_AsDouble(PySequence_GetItem(seqval, i));
		return resarr;
	}

	/** Setter:  */
	void offset(float values[1]) { /* not implemented */ }

	/** Getter:  */
	std::array<float, 1> size() {
		// TODO: MISSING DEREF! USE #DEFINE!
		PyObject *seqval = PyObject_GetAttrString(pyobjref, "size");
		std::array<float, 1> resarr;
		for (int i = 0; i < 1; i++)
			resarr[i] = (float)PyFloat_AsDouble(PySequence_GetItem(seqval, i));
		return resarr;
	}

	/** Setter:  */
	void size(float values[1]) { /* not implemented */ }

	/** Getter:  */
	bool use_min() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_min")) == 1;
	}

	/** Setter:  */
	void use_min(bool value) {
		PyObject_SetAttrString(pyobjref, "use_min", Py_BuildValue("i", value));
	}

	/** Getter:  */
	bool use_max() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_max")) == 1;
	}

	/** Setter:  */
	void use_max(bool value) {
		PyObject_SetAttrString(pyobjref, "use_max", Py_BuildValue("i", value));
	}

	/** Getter:  */
	std::array<float, 1> min() {
		// TODO: MISSING DEREF! USE #DEFINE!
		PyObject *seqval = PyObject_GetAttrString(pyobjref, "min");
		std::array<float, 1> resarr;
		for (int i = 0; i < 1; i++)
			resarr[i] = (float)PyFloat_AsDouble(PySequence_GetItem(seqval, i));
		return resarr;
	}

	/** Setter:  */
	void min(float values[1]) { /* not implemented */ }

	/** Getter:  */
	std::array<float, 1> max() {
		// TODO: MISSING DEREF! USE #DEFINE!
		PyObject *seqval = PyObject_GetAttrString(pyobjref, "max");
		std::array<float, 1> resarr;
		for (int i = 0; i < 1; i++)
			resarr[i] = (float)PyFloat_AsDouble(PySequence_GetItem(seqval, i));
		return resarr;
	}

	/** Setter:  */
	void max(float values[1]) { /* not implemented */ }

	/**
	 * True if a registered node type
	 * @return 
	 */
	bool is_registered_node_type()
	{
		// not implemented
		return true;
	}

	/**
	 * Input socket template
	 * @param Param 'index'
	 * @return 
	 */
	NodeInternalSocketTemplate input_template(int index)
	{
		// not implemented
		return NodeInternalSocketTemplate();
	}

	/**
	 * Output socket template
	 * @param Param 'index'
	 * @return 
	 */
	NodeInternalSocketTemplate output_template(int index)
	{
		// not implemented
		return NodeInternalSocketTemplate();
	}

};

/**************** Map Range ****************/

/**
 * 
 */
class CompositorNodeMapRange : public CompositorNode {
public:
	CompositorNodeMapRange(PyObject* pyobj) : CompositorNode(pyobj) {}

	CompositorNodeMapRange() : CompositorNode(0)
	{
		// not implemented
	}

	/** Getter: Clamp result of the node to 0..1 range */
	bool use_clamp() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_clamp")) == 1;
	}

	/** Setter: Clamp result of the node to 0..1 range */
	void use_clamp(bool value) {
		PyObject_SetAttrString(pyobjref, "use_clamp", Py_BuildValue("i", value));
	}

	/**
	 * True if a registered node type
	 * @return 
	 */
	bool is_registered_node_type()
	{
		// not implemented
		return true;
	}

	/**
	 * Input socket template
	 * @param Param 'index'
	 * @return 
	 */
	NodeInternalSocketTemplate input_template(int index)
	{
		// not implemented
		return NodeInternalSocketTemplate();
	}

	/**
	 * Output socket template
	 * @param Param 'index'
	 * @return 
	 */
	NodeInternalSocketTemplate output_template(int index)
	{
		// not implemented
		return NodeInternalSocketTemplate();
	}

};

/**************** Time ****************/

/**
 * 
 */
class CompositorNodeTime : public CompositorNode {
public:
	CompositorNodeTime(PyObject* pyobj) : CompositorNode(pyobj) {}

	CompositorNodeTime() : CompositorNode(0)
	{
		// not implemented
	}

	/** Getter:  */
	CurveMapping curve() {
		/* not implemented */ throw NULL;
	}

	/** Getter:  */
	int frame_start() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "frame_start"));
	}

	/** Setter:  */
	void frame_start(int value) {
		PyObject_SetAttrString(pyobjref, "frame_start", Py_BuildValue("i", value));
	}

	/** Getter:  */
	int frame_end() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "frame_end"));
	}

	/** Setter:  */
	void frame_end(int value) {
		PyObject_SetAttrString(pyobjref, "frame_end", Py_BuildValue("i", value));
	}

	/**
	 * True if a registered node type
	 * @return 
	 */
	bool is_registered_node_type()
	{
		// not implemented
		return true;
	}

	/**
	 * Input socket template
	 * @param Param 'index'
	 * @return 
	 */
	NodeInternalSocketTemplate input_template(int index)
	{
		// not implemented
		return NodeInternalSocketTemplate();
	}

	/**
	 * Output socket template
	 * @param Param 'index'
	 * @return 
	 */
	NodeInternalSocketTemplate output_template(int index)
	{
		// not implemented
		return NodeInternalSocketTemplate();
	}

};

/**************** Vector Blur ****************/

/**
 * 
 */
class CompositorNodeVecBlur : public CompositorNode {
public:
	CompositorNodeVecBlur(PyObject* pyobj) : CompositorNode(pyobj) {}

	CompositorNodeVecBlur() : CompositorNode(0)
	{
		// not implemented
	}

	/** Getter:  */
	int samples() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "samples"));
	}

	/** Setter:  */
	void samples(int value) {
		PyObject_SetAttrString(pyobjref, "samples", Py_BuildValue("i", value));
	}

	/** Getter: Minimum speed for a pixel to be blurred (used to separate background from foreground) */
	int speed_min() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "speed_min"));
	}

	/** Setter: Minimum speed for a pixel to be blurred (used to separate background from foreground) */
	void speed_min(int value) {
		PyObject_SetAttrString(pyobjref, "speed_min", Py_BuildValue("i", value));
	}

	/** Getter: Maximum speed, or zero for none */
	int speed_max() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "speed_max"));
	}

	/** Setter: Maximum speed, or zero for none */
	void speed_max(int value) {
		PyObject_SetAttrString(pyobjref, "speed_max", Py_BuildValue("i", value));
	}

	/** Getter: Scaling factor for motion vectors (actually, 'shutter speed', in frames) */
	float factor() { /* not implemented */ throw NULL; }
	/** Setter: Scaling factor for motion vectors (actually, 'shutter speed', in frames) */
	void factor(float value) {
		PyObject_SetAttrString(pyobjref, "factor", Py_BuildValue("f", value));
	}

	/** Getter: Interpolate between frames in a Bezier curve, rather than linearly */
	bool use_curved() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_curved")) == 1;
	}

	/** Setter: Interpolate between frames in a Bezier curve, rather than linearly */
	void use_curved(bool value) {
		PyObject_SetAttrString(pyobjref, "use_curved", Py_BuildValue("i", value));
	}

	/**
	 * True if a registered node type
	 * @return 
	 */
	bool is_registered_node_type()
	{
		// not implemented
		return true;
	}

	/**
	 * Input socket template
	 * @param Param 'index'
	 * @return 
	 */
	NodeInternalSocketTemplate input_template(int index)
	{
		// not implemented
		return NodeInternalSocketTemplate();
	}

	/**
	 * Output socket template
	 * @param Param 'index'
	 * @return 
	 */
	NodeInternalSocketTemplate output_template(int index)
	{
		// not implemented
		return NodeInternalSocketTemplate();
	}

};

/**************** Separate RGBA ****************/

/**
 * 
 */
class CompositorNodeSepRGBA : public CompositorNode {
public:
	CompositorNodeSepRGBA(PyObject* pyobj) : CompositorNode(pyobj) {}

	CompositorNodeSepRGBA() : CompositorNode(0)
	{
		// not implemented
	}

	/**
	 * True if a registered node type
	 * @return 
	 */
	bool is_registered_node_type()
	{
		// not implemented
		return true;
	}

	/**
	 * Input socket template
	 * @param Param 'index'
	 * @return 
	 */
	NodeInternalSocketTemplate input_template(int index)
	{
		// not implemented
		return NodeInternalSocketTemplate();
	}

	/**
	 * Output socket template
	 * @param Param 'index'
	 * @return 
	 */
	NodeInternalSocketTemplate output_template(int index)
	{
		// not implemented
		return NodeInternalSocketTemplate();
	}

};

/**************** Separate HSVA ****************/

/**
 * 
 */
class CompositorNodeSepHSVA : public CompositorNode {
public:
	CompositorNodeSepHSVA(PyObject* pyobj) : CompositorNode(pyobj) {}

	CompositorNodeSepHSVA() : CompositorNode(0)
	{
		// not implemented
	}

	/**
	 * True if a registered node type
	 * @return 
	 */
	bool is_registered_node_type()
	{
		// not implemented
		return true;
	}

	/**
	 * Input socket template
	 * @param Param 'index'
	 * @return 
	 */
	NodeInternalSocketTemplate input_template(int index)
	{
		// not implemented
		return NodeInternalSocketTemplate();
	}

	/**
	 * Output socket template
	 * @param Param 'index'
	 * @return 
	 */
	NodeInternalSocketTemplate output_template(int index)
	{
		// not implemented
		return NodeInternalSocketTemplate();
	}

};

/**************** Set Alpha ****************/

/**
 * 
 */
class CompositorNodeSetAlpha : public CompositorNode {
public:
	CompositorNodeSetAlpha(PyObject* pyobj) : CompositorNode(pyobj) {}

	CompositorNodeSetAlpha() : CompositorNode(0)
	{
		// not implemented
	}

	/**
	 * True if a registered node type
	 * @return 
	 */
	bool is_registered_node_type()
	{
		// not implemented
		return true;
	}

	/**
	 * Input socket template
	 * @param Param 'index'
	 * @return 
	 */
	NodeInternalSocketTemplate input_template(int index)
	{
		// not implemented
		return NodeInternalSocketTemplate();
	}

	/**
	 * Output socket template
	 * @param Param 'index'
	 * @return 
	 */
	NodeInternalSocketTemplate output_template(int index)
	{
		// not implemented
		return NodeInternalSocketTemplate();
	}

};

/**************** Hue Saturation Value ****************/

/**
 * 
 */
class CompositorNodeHueSat : public CompositorNode {
public:
	CompositorNodeHueSat(PyObject* pyobj) : CompositorNode(pyobj) {}

	CompositorNodeHueSat() : CompositorNode(0)
	{
		// not implemented
	}

	/** Getter:  */
	float color_hue() { /* not implemented */ throw NULL; }
	/** Setter:  */
	void color_hue(float value) {
		PyObject_SetAttrString(pyobjref, "color_hue", Py_BuildValue("f", value));
	}

	/** Getter:  */
	float color_saturation() { /* not implemented */ throw NULL; }
	/** Setter:  */
	void color_saturation(float value) {
		PyObject_SetAttrString(pyobjref, "color_saturation", Py_BuildValue("f", value));
	}

	/** Getter:  */
	float color_value() { /* not implemented */ throw NULL; }
	/** Setter:  */
	void color_value(float value) {
		PyObject_SetAttrString(pyobjref, "color_value", Py_BuildValue("f", value));
	}

	/**
	 * True if a registered node type
	 * @return 
	 */
	bool is_registered_node_type()
	{
		// not implemented
		return true;
	}

	/**
	 * Input socket template
	 * @param Param 'index'
	 * @return 
	 */
	NodeInternalSocketTemplate input_template(int index)
	{
		// not implemented
		return NodeInternalSocketTemplate();
	}

	/**
	 * Output socket template
	 * @param Param 'index'
	 * @return 
	 */
	NodeInternalSocketTemplate output_template(int index)
	{
		// not implemented
		return NodeInternalSocketTemplate();
	}

};

/**************** Image ****************/

/**
 * 
 */
class CompositorNodeImage : public CompositorNode {
public:
	CompositorNodeImage(PyObject* pyobj) : CompositorNode(pyobj) {}

	CompositorNodeImage() : CompositorNode(0)
	{
		// not implemented
	}

	/** Getter:  */
	Image image() {
		/* not implemented */ throw NULL;
	}

	/** Getter: Put Node output buffer to straight alpha instead of premultiplied */
	bool use_straight_alpha_output() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_straight_alpha_output")) == 1;
	}

	/** Setter: Put Node output buffer to straight alpha instead of premultiplied */
	void use_straight_alpha_output(bool value) {
		PyObject_SetAttrString(pyobjref, "use_straight_alpha_output", Py_BuildValue("i", value));
	}

	/** Getter: Number of images of a movie to use */
	int frame_duration() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "frame_duration"));
	}

	/** Setter: Number of images of a movie to use */
	void frame_duration(int value) {
		PyObject_SetAttrString(pyobjref, "frame_duration", Py_BuildValue("i", value));
	}

	/** Getter: Global starting frame of the movie/sequence, assuming first picture has a #1 */
	int frame_start() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "frame_start"));
	}

	/** Setter: Global starting frame of the movie/sequence, assuming first picture has a #1 */
	void frame_start(int value) {
		PyObject_SetAttrString(pyobjref, "frame_start", Py_BuildValue("i", value));
	}

	/** Getter: Offset the number of the frame to use in the animation */
	int frame_offset() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "frame_offset"));
	}

	/** Setter: Offset the number of the frame to use in the animation */
	void frame_offset(int value) {
		PyObject_SetAttrString(pyobjref, "frame_offset", Py_BuildValue("i", value));
	}

	/** Getter: Cycle the images in the movie */
	bool use_cyclic() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_cyclic")) == 1;
	}

	/** Setter: Cycle the images in the movie */
	void use_cyclic(bool value) {
		PyObject_SetAttrString(pyobjref, "use_cyclic", Py_BuildValue("i", value));
	}

	/** Getter: Always refresh image on frame changes */
	bool use_auto_refresh() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_auto_refresh")) == 1;
	}

	/** Setter: Always refresh image on frame changes */
	void use_auto_refresh(bool value) {
		PyObject_SetAttrString(pyobjref, "use_auto_refresh", Py_BuildValue("i", value));
	}

	enum layer_enum {
		layer_PLACEHOLDER = 0,
	};

	/** Getter:  */
	layer_enum layer() { /* not implemented */ throw NULL; }
	/** Setter:  */
	void layer(layer_enum value) { /* not implemented */ }

	/** Getter: True if this image has any named layer */
	bool has_layers() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "has_layers")) == 1;
	}

	/** Setter: True if this image has any named layer */
	void has_layers(bool value) {
		PyObject_SetAttrString(pyobjref, "has_layers", Py_BuildValue("i", value));
	}

	enum view_enum {
		view_ALL = 0,
	};

	/** Getter:  */
	view_enum view() { /* not implemented */ throw NULL; }
	/** Setter:  */
	void view(view_enum value) { /* not implemented */ }

	/** Getter: True if this image has multiple views */
	bool has_views() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "has_views")) == 1;
	}

	/** Setter: True if this image has multiple views */
	void has_views(bool value) {
		PyObject_SetAttrString(pyobjref, "has_views", Py_BuildValue("i", value));
	}

	/**
	 * True if a registered node type
	 * @return 
	 */
	bool is_registered_node_type()
	{
		// not implemented
		return true;
	}

	/**
	 * Input socket template
	 * @param Param 'index'
	 * @return 
	 */
	NodeInternalSocketTemplate input_template(int index)
	{
		// not implemented
		return NodeInternalSocketTemplate();
	}

	/**
	 * Output socket template
	 * @param Param 'index'
	 * @return 
	 */
	NodeInternalSocketTemplate output_template(int index)
	{
		// not implemented
		return NodeInternalSocketTemplate();
	}

};

/**************** Render Layers ****************/

/**
 * 
 */
class CompositorNodeRLayers : public CompositorNode {
public:
	CompositorNodeRLayers(PyObject* pyobj) : CompositorNode(pyobj) {}

	CompositorNodeRLayers() : CompositorNode(0)
	{
		// not implemented
	}

	/** Getter:  */
	Scene scene();

	enum layer_enum {
		layer_PLACEHOLDER = 0,
	};

	/** Getter:  */
	layer_enum layer() { /* not implemented */ throw NULL; }
	/** Setter:  */
	void layer(layer_enum value) { /* not implemented */ }

	/**
	 * True if a registered node type
	 * @return 
	 */
	bool is_registered_node_type()
	{
		// not implemented
		return true;
	}

	/**
	 * Input socket template
	 * @param Param 'index'
	 * @return 
	 */
	NodeInternalSocketTemplate input_template(int index)
	{
		// not implemented
		return NodeInternalSocketTemplate();
	}

	/**
	 * Output socket template
	 * @param Param 'index'
	 * @return 
	 */
	NodeInternalSocketTemplate output_template(int index)
	{
		// not implemented
		return NodeInternalSocketTemplate();
	}

};

/**************** Composite ****************/

/**
 * 
 */
class CompositorNodeComposite : public CompositorNode {
public:
	CompositorNodeComposite(PyObject* pyobj) : CompositorNode(pyobj) {}

	CompositorNodeComposite() : CompositorNode(0)
	{
		// not implemented
	}

	/** Getter: Colors are treated alpha premultiplied, or colors output straight (alpha gets set to 1) */
	bool use_alpha() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_alpha")) == 1;
	}

	/** Setter: Colors are treated alpha premultiplied, or colors output straight (alpha gets set to 1) */
	void use_alpha(bool value) {
		PyObject_SetAttrString(pyobjref, "use_alpha", Py_BuildValue("i", value));
	}

	/**
	 * True if a registered node type
	 * @return 
	 */
	bool is_registered_node_type()
	{
		// not implemented
		return true;
	}

	/**
	 * Input socket template
	 * @param Param 'index'
	 * @return 
	 */
	NodeInternalSocketTemplate input_template(int index)
	{
		// not implemented
		return NodeInternalSocketTemplate();
	}

	/**
	 * Output socket template
	 * @param Param 'index'
	 * @return 
	 */
	NodeInternalSocketTemplate output_template(int index)
	{
		// not implemented
		return NodeInternalSocketTemplate();
	}

};

/**************** File Output ****************/

/**
 * 
 */
class CompositorNodeOutputFile : public CompositorNode {
public:
	CompositorNodeOutputFile(PyObject* pyobj) : CompositorNode(pyobj) {}

	CompositorNodeOutputFile() : CompositorNode(0)
	{
		// not implemented
	}

	/** Getter: Base output path for the image */
	std::string base_path() { /* not implemented */ throw NULL; }
	/** Setter: Base output path for the image */
	void base_path(const std::string& value) { /* not implemented */ }

	/** Getter: Active input index in details view list */
	int active_input_index() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "active_input_index"));
	}

	/** Setter: Active input index in details view list */
	void active_input_index(int value) {
		PyObject_SetAttrString(pyobjref, "active_input_index", Py_BuildValue("i", value));
	}

	/** Getter:  */
	ImageFormatSettings format();

	/** Getter:  */
	std::map<std::string, NodeOutputFileSlotFile> file_slots();
	/** Setter:  */
	void file_slots(std::map<std::string, NodeOutputFileSlotFile> value);

	/** Getter:  */
	std::map<std::string, NodeOutputFileSlotLayer> layer_slots();
	/** Setter:  */
	void layer_slots(std::map<std::string, NodeOutputFileSlotLayer> value);

	/**
	 * True if a registered node type
	 * @return 
	 */
	bool is_registered_node_type()
	{
		// not implemented
		return true;
	}

	/**
	 * Input socket template
	 * @param Param 'index'
	 * @return 
	 */
	NodeInternalSocketTemplate input_template(int index)
	{
		// not implemented
		return NodeInternalSocketTemplate();
	}

	/**
	 * Output socket template
	 * @param Param 'index'
	 * @return 
	 */
	NodeInternalSocketTemplate output_template(int index)
	{
		// not implemented
		return NodeInternalSocketTemplate();
	}

};

/**************** Texture ****************/

/**
 * 
 */
class CompositorNodeTexture : public CompositorNode {
public:
	CompositorNodeTexture(PyObject* pyobj) : CompositorNode(pyobj) {}

	CompositorNodeTexture() : CompositorNode(0)
	{
		// not implemented
	}

	/** Getter:  */
	Texture texture() {
		/* not implemented */ throw NULL;
	}

	/** Getter: For node-based textures, which output node to use */
	int node_output() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "node_output"));
	}

	/** Setter: For node-based textures, which output node to use */
	void node_output(int value) {
		PyObject_SetAttrString(pyobjref, "node_output", Py_BuildValue("i", value));
	}

	/**
	 * True if a registered node type
	 * @return 
	 */
	bool is_registered_node_type()
	{
		// not implemented
		return true;
	}

	/**
	 * Input socket template
	 * @param Param 'index'
	 * @return 
	 */
	NodeInternalSocketTemplate input_template(int index)
	{
		// not implemented
		return NodeInternalSocketTemplate();
	}

	/**
	 * Output socket template
	 * @param Param 'index'
	 * @return 
	 */
	NodeInternalSocketTemplate output_template(int index)
	{
		// not implemented
		return NodeInternalSocketTemplate();
	}

};

/**************** Translate ****************/

/**
 * 
 */
class CompositorNodeTranslate : public CompositorNode {
public:
	CompositorNodeTranslate(PyObject* pyobj) : CompositorNode(pyobj) {}

	CompositorNodeTranslate() : CompositorNode(0)
	{
		// not implemented
	}

	/** Getter: Use relative (percent) values to define blur radius */
	bool use_relative() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_relative")) == 1;
	}

	/** Setter: Use relative (percent) values to define blur radius */
	void use_relative(bool value) {
		PyObject_SetAttrString(pyobjref, "use_relative", Py_BuildValue("i", value));
	}

	enum wrap_axis_enum {
		wrap_axis_NONE = 0,
		wrap_axis_XAXIS = 1,
		wrap_axis_YAXIS = 2,
		wrap_axis_BOTH = 3,
	};

	/** Getter: Wrap image on a specific axis */
	wrap_axis_enum wrap_axis() { /* not implemented */ throw NULL; }
	/** Setter: Wrap image on a specific axis */
	void wrap_axis(wrap_axis_enum value) { /* not implemented */ }

	/**
	 * True if a registered node type
	 * @return 
	 */
	bool is_registered_node_type()
	{
		// not implemented
		return true;
	}

	/**
	 * Input socket template
	 * @param Param 'index'
	 * @return 
	 */
	NodeInternalSocketTemplate input_template(int index)
	{
		// not implemented
		return NodeInternalSocketTemplate();
	}

	/**
	 * Output socket template
	 * @param Param 'index'
	 * @return 
	 */
	NodeInternalSocketTemplate output_template(int index)
	{
		// not implemented
		return NodeInternalSocketTemplate();
	}

};

/**************** Z Combine ****************/

/**
 * 
 */
class CompositorNodeZcombine : public CompositorNode {
public:
	CompositorNodeZcombine(PyObject* pyobj) : CompositorNode(pyobj) {}

	CompositorNodeZcombine() : CompositorNode(0)
	{
		// not implemented
	}

	/** Getter: Take Alpha channel into account when doing the Z operation */
	bool use_alpha() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_alpha")) == 1;
	}

	/** Setter: Take Alpha channel into account when doing the Z operation */
	void use_alpha(bool value) {
		PyObject_SetAttrString(pyobjref, "use_alpha", Py_BuildValue("i", value));
	}

	/** Getter: Anti-alias the z-buffer to try to avoid artifacts, mostly useful for Blender renders */
	bool use_antialias_z() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_antialias_z")) == 1;
	}

	/** Setter: Anti-alias the z-buffer to try to avoid artifacts, mostly useful for Blender renders */
	void use_antialias_z(bool value) {
		PyObject_SetAttrString(pyobjref, "use_antialias_z", Py_BuildValue("i", value));
	}

	/**
	 * True if a registered node type
	 * @return 
	 */
	bool is_registered_node_type()
	{
		// not implemented
		return true;
	}

	/**
	 * Input socket template
	 * @param Param 'index'
	 * @return 
	 */
	NodeInternalSocketTemplate input_template(int index)
	{
		// not implemented
		return NodeInternalSocketTemplate();
	}

	/**
	 * Output socket template
	 * @param Param 'index'
	 * @return 
	 */
	NodeInternalSocketTemplate output_template(int index)
	{
		// not implemented
		return NodeInternalSocketTemplate();
	}

};

/**************** Combine RGBA ****************/

/**
 * 
 */
class CompositorNodeCombRGBA : public CompositorNode {
public:
	CompositorNodeCombRGBA(PyObject* pyobj) : CompositorNode(pyobj) {}

	CompositorNodeCombRGBA() : CompositorNode(0)
	{
		// not implemented
	}

	/**
	 * True if a registered node type
	 * @return 
	 */
	bool is_registered_node_type()
	{
		// not implemented
		return true;
	}

	/**
	 * Input socket template
	 * @param Param 'index'
	 * @return 
	 */
	NodeInternalSocketTemplate input_template(int index)
	{
		// not implemented
		return NodeInternalSocketTemplate();
	}

	/**
	 * Output socket template
	 * @param Param 'index'
	 * @return 
	 */
	NodeInternalSocketTemplate output_template(int index)
	{
		// not implemented
		return NodeInternalSocketTemplate();
	}

};

/**************** Dilate/Erode ****************/

/**
 * 
 */
class CompositorNodeDilateErode : public CompositorNode {
public:
	CompositorNodeDilateErode(PyObject* pyobj) : CompositorNode(pyobj) {}

	CompositorNodeDilateErode() : CompositorNode(0)
	{
		// not implemented
	}

	enum mode_enum {
		mode_STEP = 0,
		mode_THRESHOLD = 1,
		mode_DISTANCE = 2,
		mode_FEATHER = 3,
	};

	/** Getter: Growing/shrinking mode */
	mode_enum mode() { /* not implemented */ throw NULL; }
	/** Setter: Growing/shrinking mode */
	void mode(mode_enum value) { /* not implemented */ }

	/** Getter: Distance to grow/shrink (number of iterations) */
	int distance() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "distance"));
	}

	/** Setter: Distance to grow/shrink (number of iterations) */
	void distance(int value) {
		PyObject_SetAttrString(pyobjref, "distance", Py_BuildValue("i", value));
	}

	/** Getter: Edge to inset */
	float edge() { /* not implemented */ throw NULL; }
	/** Setter: Edge to inset */
	void edge(float value) {
		PyObject_SetAttrString(pyobjref, "edge", Py_BuildValue("f", value));
	}

	enum falloff_enum {
		falloff_SMOOTH = 0,
		falloff_SPHERE = 1,
		falloff_ROOT = 2,
		falloff_INVERSE_SQUARE = 7,
		falloff_SHARP = 3,
		falloff_LINEAR = 4,
	};

	/** Getter: Falloff type the feather */
	falloff_enum falloff() { /* not implemented */ throw NULL; }
	/** Setter: Falloff type the feather */
	void falloff(falloff_enum value) { /* not implemented */ }

	/**
	 * True if a registered node type
	 * @return 
	 */
	bool is_registered_node_type()
	{
		// not implemented
		return true;
	}

	/**
	 * Input socket template
	 * @param Param 'index'
	 * @return 
	 */
	NodeInternalSocketTemplate input_template(int index)
	{
		// not implemented
		return NodeInternalSocketTemplate();
	}

	/**
	 * Output socket template
	 * @param Param 'index'
	 * @return 
	 */
	NodeInternalSocketTemplate output_template(int index)
	{
		// not implemented
		return NodeInternalSocketTemplate();
	}

};

/**************** Inpaint ****************/

/**
 * 
 */
class CompositorNodeInpaint : public CompositorNode {
public:
	CompositorNodeInpaint(PyObject* pyobj) : CompositorNode(pyobj) {}

	CompositorNodeInpaint() : CompositorNode(0)
	{
		// not implemented
	}

	/** Getter: Distance to inpaint (number of iterations) */
	int distance() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "distance"));
	}

	/** Setter: Distance to inpaint (number of iterations) */
	void distance(int value) {
		PyObject_SetAttrString(pyobjref, "distance", Py_BuildValue("i", value));
	}

	/**
	 * True if a registered node type
	 * @return 
	 */
	bool is_registered_node_type()
	{
		// not implemented
		return true;
	}

	/**
	 * Input socket template
	 * @param Param 'index'
	 * @return 
	 */
	NodeInternalSocketTemplate input_template(int index)
	{
		// not implemented
		return NodeInternalSocketTemplate();
	}

	/**
	 * Output socket template
	 * @param Param 'index'
	 * @return 
	 */
	NodeInternalSocketTemplate output_template(int index)
	{
		// not implemented
		return NodeInternalSocketTemplate();
	}

};

/**************** Despeckle ****************/

/**
 * 
 */
class CompositorNodeDespeckle : public CompositorNode {
public:
	CompositorNodeDespeckle(PyObject* pyobj) : CompositorNode(pyobj) {}

	CompositorNodeDespeckle() : CompositorNode(0)
	{
		// not implemented
	}

	/** Getter: Threshold for detecting pixels to despeckle */
	float threshold() { /* not implemented */ throw NULL; }
	/** Setter: Threshold for detecting pixels to despeckle */
	void threshold(float value) {
		PyObject_SetAttrString(pyobjref, "threshold", Py_BuildValue("f", value));
	}

	/** Getter: Threshold for the number of neighbor pixels that must match */
	float threshold_neighbor() { /* not implemented */ throw NULL; }
	/** Setter: Threshold for the number of neighbor pixels that must match */
	void threshold_neighbor(float value) {
		PyObject_SetAttrString(pyobjref, "threshold_neighbor", Py_BuildValue("f", value));
	}

	/**
	 * True if a registered node type
	 * @return 
	 */
	bool is_registered_node_type()
	{
		// not implemented
		return true;
	}

	/**
	 * Input socket template
	 * @param Param 'index'
	 * @return 
	 */
	NodeInternalSocketTemplate input_template(int index)
	{
		// not implemented
		return NodeInternalSocketTemplate();
	}

	/**
	 * Output socket template
	 * @param Param 'index'
	 * @return 
	 */
	NodeInternalSocketTemplate output_template(int index)
	{
		// not implemented
		return NodeInternalSocketTemplate();
	}

};

/**************** Rotate ****************/

/**
 * 
 */
class CompositorNodeRotate : public CompositorNode {
public:
	CompositorNodeRotate(PyObject* pyobj) : CompositorNode(pyobj) {}

	CompositorNodeRotate() : CompositorNode(0)
	{
		// not implemented
	}

	enum filter_type_enum {
		filter_type_NEAREST = 0,
		filter_type_BILINEAR = 1,
		filter_type_BICUBIC = 2,
	};

	/** Getter: Method to use to filter rotation */
	filter_type_enum filter_type() { /* not implemented */ throw NULL; }
	/** Setter: Method to use to filter rotation */
	void filter_type(filter_type_enum value) { /* not implemented */ }

	/**
	 * True if a registered node type
	 * @return 
	 */
	bool is_registered_node_type()
	{
		// not implemented
		return true;
	}

	/**
	 * Input socket template
	 * @param Param 'index'
	 * @return 
	 */
	NodeInternalSocketTemplate input_template(int index)
	{
		// not implemented
		return NodeInternalSocketTemplate();
	}

	/**
	 * Output socket template
	 * @param Param 'index'
	 * @return 
	 */
	NodeInternalSocketTemplate output_template(int index)
	{
		// not implemented
		return NodeInternalSocketTemplate();
	}

};

/**************** Scale ****************/

/**
 * 
 */
class CompositorNodeScale : public CompositorNode {
public:
	CompositorNodeScale(PyObject* pyobj) : CompositorNode(pyobj) {}

	CompositorNodeScale() : CompositorNode(0)
	{
		// not implemented
	}

	enum space_enum {
		space_RELATIVE = 0,
		space_ABSOLUTE = 1,
		space_SCENE_SIZE = 2,
		space_RENDER_SIZE = 3,
	};

	/** Getter: Coordinate space to scale relative to */
	space_enum space() { /* not implemented */ throw NULL; }
	/** Setter: Coordinate space to scale relative to */
	void space(space_enum value) { /* not implemented */ }

	enum frame_method_enum {
		frame_method_STRETCH = 0,
		frame_method_FIT = 1,
		frame_method_CROP = 3,
	};

	/** Getter: How the image fits in the camera frame */
	frame_method_enum frame_method() { /* not implemented */ throw NULL; }
	/** Setter: How the image fits in the camera frame */
	void frame_method(frame_method_enum value) { /* not implemented */ }

	/** Getter: Offset image horizontally (factor of image size) */
	float offset_x() { /* not implemented */ throw NULL; }
	/** Setter: Offset image horizontally (factor of image size) */
	void offset_x(float value) {
		PyObject_SetAttrString(pyobjref, "offset_x", Py_BuildValue("f", value));
	}

	/** Getter: Offset image vertically (factor of image size) */
	float offset_y() { /* not implemented */ throw NULL; }
	/** Setter: Offset image vertically (factor of image size) */
	void offset_y(float value) {
		PyObject_SetAttrString(pyobjref, "offset_y", Py_BuildValue("f", value));
	}

	/**
	 * True if a registered node type
	 * @return 
	 */
	bool is_registered_node_type()
	{
		// not implemented
		return true;
	}

	/**
	 * Input socket template
	 * @param Param 'index'
	 * @return 
	 */
	NodeInternalSocketTemplate input_template(int index)
	{
		// not implemented
		return NodeInternalSocketTemplate();
	}

	/**
	 * Output socket template
	 * @param Param 'index'
	 * @return 
	 */
	NodeInternalSocketTemplate output_template(int index)
	{
		// not implemented
		return NodeInternalSocketTemplate();
	}

};

/**************** Separate YCbCrA ****************/

/**
 * 
 */
class CompositorNodeSepYCCA : public CompositorNode {
public:
	CompositorNodeSepYCCA(PyObject* pyobj) : CompositorNode(pyobj) {}

	CompositorNodeSepYCCA() : CompositorNode(0)
	{
		// not implemented
	}

	enum mode_enum {
		mode_ITUBT601 = 0,
		mode_ITUBT709 = 1,
		mode_JFIF = 2,
	};

	/** Getter:  */
	mode_enum mode() { /* not implemented */ throw NULL; }
	/** Setter:  */
	void mode(mode_enum value) { /* not implemented */ }

	/**
	 * True if a registered node type
	 * @return 
	 */
	bool is_registered_node_type()
	{
		// not implemented
		return true;
	}

	/**
	 * Input socket template
	 * @param Param 'index'
	 * @return 
	 */
	NodeInternalSocketTemplate input_template(int index)
	{
		// not implemented
		return NodeInternalSocketTemplate();
	}

	/**
	 * Output socket template
	 * @param Param 'index'
	 * @return 
	 */
	NodeInternalSocketTemplate output_template(int index)
	{
		// not implemented
		return NodeInternalSocketTemplate();
	}

};

/**************** Combine YCbCrA ****************/

/**
 * 
 */
class CompositorNodeCombYCCA : public CompositorNode {
public:
	CompositorNodeCombYCCA(PyObject* pyobj) : CompositorNode(pyobj) {}

	CompositorNodeCombYCCA() : CompositorNode(0)
	{
		// not implemented
	}

	enum mode_enum {
		mode_ITUBT601 = 0,
		mode_ITUBT709 = 1,
		mode_JFIF = 2,
	};

	/** Getter:  */
	mode_enum mode() { /* not implemented */ throw NULL; }
	/** Setter:  */
	void mode(mode_enum value) { /* not implemented */ }

	/**
	 * True if a registered node type
	 * @return 
	 */
	bool is_registered_node_type()
	{
		// not implemented
		return true;
	}

	/**
	 * Input socket template
	 * @param Param 'index'
	 * @return 
	 */
	NodeInternalSocketTemplate input_template(int index)
	{
		// not implemented
		return NodeInternalSocketTemplate();
	}

	/**
	 * Output socket template
	 * @param Param 'index'
	 * @return 
	 */
	NodeInternalSocketTemplate output_template(int index)
	{
		// not implemented
		return NodeInternalSocketTemplate();
	}

};

/**************** Separate YUVA ****************/

/**
 * 
 */
class CompositorNodeSepYUVA : public CompositorNode {
public:
	CompositorNodeSepYUVA(PyObject* pyobj) : CompositorNode(pyobj) {}

	CompositorNodeSepYUVA() : CompositorNode(0)
	{
		// not implemented
	}

	/**
	 * True if a registered node type
	 * @return 
	 */
	bool is_registered_node_type()
	{
		// not implemented
		return true;
	}

	/**
	 * Input socket template
	 * @param Param 'index'
	 * @return 
	 */
	NodeInternalSocketTemplate input_template(int index)
	{
		// not implemented
		return NodeInternalSocketTemplate();
	}

	/**
	 * Output socket template
	 * @param Param 'index'
	 * @return 
	 */
	NodeInternalSocketTemplate output_template(int index)
	{
		// not implemented
		return NodeInternalSocketTemplate();
	}

};

/**************** Combine YUVA ****************/

/**
 * 
 */
class CompositorNodeCombYUVA : public CompositorNode {
public:
	CompositorNodeCombYUVA(PyObject* pyobj) : CompositorNode(pyobj) {}

	CompositorNodeCombYUVA() : CompositorNode(0)
	{
		// not implemented
	}

	/**
	 * True if a registered node type
	 * @return 
	 */
	bool is_registered_node_type()
	{
		// not implemented
		return true;
	}

	/**
	 * Input socket template
	 * @param Param 'index'
	 * @return 
	 */
	NodeInternalSocketTemplate input_template(int index)
	{
		// not implemented
		return NodeInternalSocketTemplate();
	}

	/**
	 * Output socket template
	 * @param Param 'index'
	 * @return 
	 */
	NodeInternalSocketTemplate output_template(int index)
	{
		// not implemented
		return NodeInternalSocketTemplate();
	}

};

/**************** Difference Key ****************/

/**
 * 
 */
class CompositorNodeDiffMatte : public CompositorNode {
public:
	CompositorNodeDiffMatte(PyObject* pyobj) : CompositorNode(pyobj) {}

	CompositorNodeDiffMatte() : CompositorNode(0)
	{
		// not implemented
	}

	/** Getter: Color distances below this threshold are keyed */
	float tolerance() { /* not implemented */ throw NULL; }
	/** Setter: Color distances below this threshold are keyed */
	void tolerance(float value) {
		PyObject_SetAttrString(pyobjref, "tolerance", Py_BuildValue("f", value));
	}

	/** Getter: Color distances below this additional threshold are partially keyed */
	float falloff() { /* not implemented */ throw NULL; }
	/** Setter: Color distances below this additional threshold are partially keyed */
	void falloff(float value) {
		PyObject_SetAttrString(pyobjref, "falloff", Py_BuildValue("f", value));
	}

	/**
	 * True if a registered node type
	 * @return 
	 */
	bool is_registered_node_type()
	{
		// not implemented
		return true;
	}

	/**
	 * Input socket template
	 * @param Param 'index'
	 * @return 
	 */
	NodeInternalSocketTemplate input_template(int index)
	{
		// not implemented
		return NodeInternalSocketTemplate();
	}

	/**
	 * Output socket template
	 * @param Param 'index'
	 * @return 
	 */
	NodeInternalSocketTemplate output_template(int index)
	{
		// not implemented
		return NodeInternalSocketTemplate();
	}

};

/**************** Color Spill ****************/

/**
 * 
 */
class CompositorNodeColorSpill : public CompositorNode {
public:
	CompositorNodeColorSpill(PyObject* pyobj) : CompositorNode(pyobj) {}

	CompositorNodeColorSpill() : CompositorNode(0)
	{
		// not implemented
	}

	enum channel_enum {
		channel_R = 1,
		channel_G = 2,
		channel_B = 3,
	};

	/** Getter:  */
	channel_enum channel() { /* not implemented */ throw NULL; }
	/** Setter:  */
	void channel(channel_enum value) { /* not implemented */ }

	enum limit_method_enum {
		limit_method_SIMPLE = 0,
		limit_method_AVERAGE = 1,
	};

	/** Getter:  */
	limit_method_enum limit_method() { /* not implemented */ throw NULL; }
	/** Setter:  */
	void limit_method(limit_method_enum value) { /* not implemented */ }

	enum limit_channel_enum {
		limit_channel_R = 1,
		limit_channel_G = 2,
		limit_channel_B = 3,
	};

	/** Getter:  */
	limit_channel_enum limit_channel() { /* not implemented */ throw NULL; }
	/** Setter:  */
	void limit_channel(limit_channel_enum value) { /* not implemented */ }

	/** Getter: Scale limit by value */
	float ratio() { /* not implemented */ throw NULL; }
	/** Setter: Scale limit by value */
	void ratio(float value) {
		PyObject_SetAttrString(pyobjref, "ratio", Py_BuildValue("f", value));
	}

	/** Getter: Compensate all channels (differently) by hand */
	bool use_unspill() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_unspill")) == 1;
	}

	/** Setter: Compensate all channels (differently) by hand */
	void use_unspill(bool value) {
		PyObject_SetAttrString(pyobjref, "use_unspill", Py_BuildValue("i", value));
	}

	/** Getter: Red spillmap scale */
	float unspill_red() { /* not implemented */ throw NULL; }
	/** Setter: Red spillmap scale */
	void unspill_red(float value) {
		PyObject_SetAttrString(pyobjref, "unspill_red", Py_BuildValue("f", value));
	}

	/** Getter: Green spillmap scale */
	float unspill_green() { /* not implemented */ throw NULL; }
	/** Setter: Green spillmap scale */
	void unspill_green(float value) {
		PyObject_SetAttrString(pyobjref, "unspill_green", Py_BuildValue("f", value));
	}

	/** Getter: Blue spillmap scale */
	float unspill_blue() { /* not implemented */ throw NULL; }
	/** Setter: Blue spillmap scale */
	void unspill_blue(float value) {
		PyObject_SetAttrString(pyobjref, "unspill_blue", Py_BuildValue("f", value));
	}

	/**
	 * True if a registered node type
	 * @return 
	 */
	bool is_registered_node_type()
	{
		// not implemented
		return true;
	}

	/**
	 * Input socket template
	 * @param Param 'index'
	 * @return 
	 */
	NodeInternalSocketTemplate input_template(int index)
	{
		// not implemented
		return NodeInternalSocketTemplate();
	}

	/**
	 * Output socket template
	 * @param Param 'index'
	 * @return 
	 */
	NodeInternalSocketTemplate output_template(int index)
	{
		// not implemented
		return NodeInternalSocketTemplate();
	}

};

/**************** Chroma Key ****************/

/**
 * 
 */
class CompositorNodeChromaMatte : public CompositorNode {
public:
	CompositorNodeChromaMatte(PyObject* pyobj) : CompositorNode(pyobj) {}

	CompositorNodeChromaMatte() : CompositorNode(0)
	{
		// not implemented
	}

	/** Getter: Tolerance for a color to be considered a keying color */
	float tolerance() { /* not implemented */ throw NULL; }
	/** Setter: Tolerance for a color to be considered a keying color */
	void tolerance(float value) {
		PyObject_SetAttrString(pyobjref, "tolerance", Py_BuildValue("f", value));
	}

	/** Getter: Tolerance below which colors will be considered as exact matches */
	float threshold() { /* not implemented */ throw NULL; }
	/** Setter: Tolerance below which colors will be considered as exact matches */
	void threshold(float value) {
		PyObject_SetAttrString(pyobjref, "threshold", Py_BuildValue("f", value));
	}

	/** Getter: Alpha lift */
	float lift() { /* not implemented */ throw NULL; }
	/** Setter: Alpha lift */
	void lift(float value) {
		PyObject_SetAttrString(pyobjref, "lift", Py_BuildValue("f", value));
	}

	/** Getter: Alpha falloff */
	float gain() { /* not implemented */ throw NULL; }
	/** Setter: Alpha falloff */
	void gain(float value) {
		PyObject_SetAttrString(pyobjref, "gain", Py_BuildValue("f", value));
	}

	/** Getter: Adjusts the brightness of any shadows captured */
	float shadow_adjust() { /* not implemented */ throw NULL; }
	/** Setter: Adjusts the brightness of any shadows captured */
	void shadow_adjust(float value) {
		PyObject_SetAttrString(pyobjref, "shadow_adjust", Py_BuildValue("f", value));
	}

	/**
	 * True if a registered node type
	 * @return 
	 */
	bool is_registered_node_type()
	{
		// not implemented
		return true;
	}

	/**
	 * Input socket template
	 * @param Param 'index'
	 * @return 
	 */
	NodeInternalSocketTemplate input_template(int index)
	{
		// not implemented
		return NodeInternalSocketTemplate();
	}

	/**
	 * Output socket template
	 * @param Param 'index'
	 * @return 
	 */
	NodeInternalSocketTemplate output_template(int index)
	{
		// not implemented
		return NodeInternalSocketTemplate();
	}

};

/**************** Channel Key ****************/

/**
 * 
 */
class CompositorNodeChannelMatte : public CompositorNode {
public:
	CompositorNodeChannelMatte(PyObject* pyobj) : CompositorNode(pyobj) {}

	CompositorNodeChannelMatte() : CompositorNode(0)
	{
		// not implemented
	}

	enum color_space_enum {
		color_space_RGB = 1,
		color_space_HSV = 2,
		color_space_YUV = 3,
		color_space_YCC = 4,
	};

	/** Getter:  */
	color_space_enum color_space() { /* not implemented */ throw NULL; }
	/** Setter:  */
	void color_space(color_space_enum value) { /* not implemented */ }

	enum matte_channel_enum {
		matte_channel_R = 1,
		matte_channel_G = 2,
		matte_channel_B = 3,
	};

	/** Getter: Channel used to determine matte */
	matte_channel_enum matte_channel() { /* not implemented */ throw NULL; }
	/** Setter: Channel used to determine matte */
	void matte_channel(matte_channel_enum value) { /* not implemented */ }

	enum limit_method_enum {
		limit_method_SINGLE = 0,
		limit_method_MAX = 1,
	};

	/** Getter: Algorithm to use to limit channel */
	limit_method_enum limit_method() { /* not implemented */ throw NULL; }
	/** Setter: Algorithm to use to limit channel */
	void limit_method(limit_method_enum value) { /* not implemented */ }

	enum limit_channel_enum {
		limit_channel_R = 1,
		limit_channel_G = 2,
		limit_channel_B = 3,
	};

	/** Getter: Limit by this channel's value */
	limit_channel_enum limit_channel() { /* not implemented */ throw NULL; }
	/** Setter: Limit by this channel's value */
	void limit_channel(limit_channel_enum value) { /* not implemented */ }

	/** Getter: Values higher than this setting are 100% opaque */
	float limit_max() { /* not implemented */ throw NULL; }
	/** Setter: Values higher than this setting are 100% opaque */
	void limit_max(float value) {
		PyObject_SetAttrString(pyobjref, "limit_max", Py_BuildValue("f", value));
	}

	/** Getter: Values lower than this setting are 100% keyed */
	float limit_min() { /* not implemented */ throw NULL; }
	/** Setter: Values lower than this setting are 100% keyed */
	void limit_min(float value) {
		PyObject_SetAttrString(pyobjref, "limit_min", Py_BuildValue("f", value));
	}

	/**
	 * True if a registered node type
	 * @return 
	 */
	bool is_registered_node_type()
	{
		// not implemented
		return true;
	}

	/**
	 * Input socket template
	 * @param Param 'index'
	 * @return 
	 */
	NodeInternalSocketTemplate input_template(int index)
	{
		// not implemented
		return NodeInternalSocketTemplate();
	}

	/**
	 * Output socket template
	 * @param Param 'index'
	 * @return 
	 */
	NodeInternalSocketTemplate output_template(int index)
	{
		// not implemented
		return NodeInternalSocketTemplate();
	}

};

/**************** Flip ****************/

/**
 * 
 */
class CompositorNodeFlip : public CompositorNode {
public:
	CompositorNodeFlip(PyObject* pyobj) : CompositorNode(pyobj) {}

	CompositorNodeFlip() : CompositorNode(0)
	{
		// not implemented
	}

	enum axis_enum {
		axis_X = 0,
		axis_Y = 1,
		axis_XY = 2,
	};

	/** Getter:  */
	axis_enum axis() { /* not implemented */ throw NULL; }
	/** Setter:  */
	void axis(axis_enum value) { /* not implemented */ }

	/**
	 * True if a registered node type
	 * @return 
	 */
	bool is_registered_node_type()
	{
		// not implemented
		return true;
	}

	/**
	 * Input socket template
	 * @param Param 'index'
	 * @return 
	 */
	NodeInternalSocketTemplate input_template(int index)
	{
		// not implemented
		return NodeInternalSocketTemplate();
	}

	/**
	 * Output socket template
	 * @param Param 'index'
	 * @return 
	 */
	NodeInternalSocketTemplate output_template(int index)
	{
		// not implemented
		return NodeInternalSocketTemplate();
	}

};

/**************** Split Viewer ****************/

/**
 * 
 */
class CompositorNodeSplitViewer : public CompositorNode {
public:
	CompositorNodeSplitViewer(PyObject* pyobj) : CompositorNode(pyobj) {}

	CompositorNodeSplitViewer() : CompositorNode(0)
	{
		// not implemented
	}

	enum axis_enum {
		axis_X = 0,
		axis_Y = 1,
	};

	/** Getter:  */
	axis_enum axis() { /* not implemented */ throw NULL; }
	/** Setter:  */
	void axis(axis_enum value) { /* not implemented */ }

	/** Getter:  */
	int factor() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "factor"));
	}

	/** Setter:  */
	void factor(int value) {
		PyObject_SetAttrString(pyobjref, "factor", Py_BuildValue("i", value));
	}

	/**
	 * True if a registered node type
	 * @return 
	 */
	bool is_registered_node_type()
	{
		// not implemented
		return true;
	}

	/**
	 * Input socket template
	 * @param Param 'index'
	 * @return 
	 */
	NodeInternalSocketTemplate input_template(int index)
	{
		// not implemented
		return NodeInternalSocketTemplate();
	}

	/**
	 * Output socket template
	 * @param Param 'index'
	 * @return 
	 */
	NodeInternalSocketTemplate output_template(int index)
	{
		// not implemented
		return NodeInternalSocketTemplate();
	}

};

/**************** Map UV ****************/

/**
 * 
 */
class CompositorNodeMapUV : public CompositorNode {
public:
	CompositorNodeMapUV(PyObject* pyobj) : CompositorNode(pyobj) {}

	CompositorNodeMapUV() : CompositorNode(0)
	{
		// not implemented
	}

	/** Getter:  */
	int alpha() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "alpha"));
	}

	/** Setter:  */
	void alpha(int value) {
		PyObject_SetAttrString(pyobjref, "alpha", Py_BuildValue("i", value));
	}

	/**
	 * True if a registered node type
	 * @return 
	 */
	bool is_registered_node_type()
	{
		// not implemented
		return true;
	}

	/**
	 * Input socket template
	 * @param Param 'index'
	 * @return 
	 */
	NodeInternalSocketTemplate input_template(int index)
	{
		// not implemented
		return NodeInternalSocketTemplate();
	}

	/**
	 * Output socket template
	 * @param Param 'index'
	 * @return 
	 */
	NodeInternalSocketTemplate output_template(int index)
	{
		// not implemented
		return NodeInternalSocketTemplate();
	}

};

/**************** ID Mask ****************/

/**
 * 
 */
class CompositorNodeIDMask : public CompositorNode {
public:
	CompositorNodeIDMask(PyObject* pyobj) : CompositorNode(pyobj) {}

	CompositorNodeIDMask() : CompositorNode(0)
	{
		// not implemented
	}

	/** Getter: Pass index number to convert to alpha */
	int index() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "index"));
	}

	/** Setter: Pass index number to convert to alpha */
	void index(int value) {
		PyObject_SetAttrString(pyobjref, "index", Py_BuildValue("i", value));
	}

	/** Getter: Apply an anti-aliasing filter to the mask */
	bool use_antialiasing() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_antialiasing")) == 1;
	}

	/** Setter: Apply an anti-aliasing filter to the mask */
	void use_antialiasing(bool value) {
		PyObject_SetAttrString(pyobjref, "use_antialiasing", Py_BuildValue("i", value));
	}

	/**
	 * True if a registered node type
	 * @return 
	 */
	bool is_registered_node_type()
	{
		// not implemented
		return true;
	}

	/**
	 * Input socket template
	 * @param Param 'index'
	 * @return 
	 */
	NodeInternalSocketTemplate input_template(int index)
	{
		// not implemented
		return NodeInternalSocketTemplate();
	}

	/**
	 * Output socket template
	 * @param Param 'index'
	 * @return 
	 */
	NodeInternalSocketTemplate output_template(int index)
	{
		// not implemented
		return NodeInternalSocketTemplate();
	}

};

/**************** Double Edge Mask ****************/

/**
 * 
 */
class CompositorNodeDoubleEdgeMask : public CompositorNode {
public:
	CompositorNodeDoubleEdgeMask(PyObject* pyobj) : CompositorNode(pyobj) {}

	CompositorNodeDoubleEdgeMask() : CompositorNode(0)
	{
		// not implemented
	}

	enum inner_mode_enum {
		inner_mode_ALL = 0,
		inner_mode_ADJACENT_ONLY = 1,
	};

	/** Getter:  */
	inner_mode_enum inner_mode() { /* not implemented */ throw NULL; }
	/** Setter:  */
	void inner_mode(inner_mode_enum value) { /* not implemented */ }

	enum edge_mode_enum {
		edge_mode_BLEED_OUT = 0,
		edge_mode_KEEP_IN = 1,
	};

	/** Getter:  */
	edge_mode_enum edge_mode() { /* not implemented */ throw NULL; }
	/** Setter:  */
	void edge_mode(edge_mode_enum value) { /* not implemented */ }

	/**
	 * True if a registered node type
	 * @return 
	 */
	bool is_registered_node_type()
	{
		// not implemented
		return true;
	}

	/**
	 * Input socket template
	 * @param Param 'index'
	 * @return 
	 */
	NodeInternalSocketTemplate input_template(int index)
	{
		// not implemented
		return NodeInternalSocketTemplate();
	}

	/**
	 * Output socket template
	 * @param Param 'index'
	 * @return 
	 */
	NodeInternalSocketTemplate output_template(int index)
	{
		// not implemented
		return NodeInternalSocketTemplate();
	}

};

/**************** Defocus ****************/

/**
 * 
 */
class CompositorNodeDefocus : public CompositorNode {
public:
	CompositorNodeDefocus(PyObject* pyobj) : CompositorNode(pyobj) {}

	CompositorNodeDefocus() : CompositorNode(0)
	{
		// not implemented
	}

	/** Getter: Scene from which to select the active camera (render scene if undefined) */
	Scene scene();

	enum bokeh_enum {
		bokeh_OCTAGON = 8,
		bokeh_HEPTAGON = 7,
		bokeh_HEXAGON = 6,
		bokeh_PENTAGON = 5,
		bokeh_SQUARE = 4,
		bokeh_TRIANGLE = 3,
		bokeh_CIRCLE = 0,
	};

	/** Getter:  */
	bokeh_enum bokeh() { /* not implemented */ throw NULL; }
	/** Setter:  */
	void bokeh(bokeh_enum value) { /* not implemented */ }

	/** Getter: Bokeh shape rotation offset */
	float angle() { /* not implemented */ throw NULL; }
	/** Setter: Bokeh shape rotation offset */
	void angle(float value) {
		PyObject_SetAttrString(pyobjref, "angle", Py_BuildValue("f", value));
	}

	/** Getter: Enable gamma correction before and after main process */
	bool use_gamma_correction() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_gamma_correction")) == 1;
	}

	/** Setter: Enable gamma correction before and after main process */
	void use_gamma_correction(bool value) {
		PyObject_SetAttrString(pyobjref, "use_gamma_correction", Py_BuildValue("i", value));
	}

	/** Getter: Amount of focal blur, 128=infinity=perfect focus, half the value doubles the blur radius */
	float f_stop() { /* not implemented */ throw NULL; }
	/** Setter: Amount of focal blur, 128=infinity=perfect focus, half the value doubles the blur radius */
	void f_stop(float value) {
		PyObject_SetAttrString(pyobjref, "f_stop", Py_BuildValue("f", value));
	}

	/** Getter: Blur limit, maximum CoC radius */
	float blur_max() { /* not implemented */ throw NULL; }
	/** Setter: Blur limit, maximum CoC radius */
	void blur_max(float value) {
		PyObject_SetAttrString(pyobjref, "blur_max", Py_BuildValue("f", value));
	}

	/** Getter: CoC radius threshold, prevents background bleed on in-focus midground, 0=off */
	float threshold() { /* not implemented */ throw NULL; }
	/** Setter: CoC radius threshold, prevents background bleed on in-focus midground, 0=off */
	void threshold(float value) {
		PyObject_SetAttrString(pyobjref, "threshold", Py_BuildValue("f", value));
	}

	/** Getter: Enable low quality mode, useful for preview */
	bool use_preview() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_preview")) == 1;
	}

	/** Setter: Enable low quality mode, useful for preview */
	void use_preview(bool value) {
		PyObject_SetAttrString(pyobjref, "use_preview", Py_BuildValue("i", value));
	}

	/** Getter: Disable when using an image as input instead of actual z-buffer (auto enabled if node not image based, eg. time node) */
	bool use_zbuffer() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_zbuffer")) == 1;
	}

	/** Setter: Disable when using an image as input instead of actual z-buffer (auto enabled if node not image based, eg. time node) */
	void use_zbuffer(bool value) {
		PyObject_SetAttrString(pyobjref, "use_zbuffer", Py_BuildValue("i", value));
	}

	/** Getter: Scale the Z input when not using a z-buffer, controls maximum blur designated by the color white or input value 1 */
	float z_scale() { /* not implemented */ throw NULL; }
	/** Setter: Scale the Z input when not using a z-buffer, controls maximum blur designated by the color white or input value 1 */
	void z_scale(float value) {
		PyObject_SetAttrString(pyobjref, "z_scale", Py_BuildValue("f", value));
	}

	/**
	 * True if a registered node type
	 * @return 
	 */
	bool is_registered_node_type()
	{
		// not implemented
		return true;
	}

	/**
	 * Input socket template
	 * @param Param 'index'
	 * @return 
	 */
	NodeInternalSocketTemplate input_template(int index)
	{
		// not implemented
		return NodeInternalSocketTemplate();
	}

	/**
	 * Output socket template
	 * @param Param 'index'
	 * @return 
	 */
	NodeInternalSocketTemplate output_template(int index)
	{
		// not implemented
		return NodeInternalSocketTemplate();
	}

};

/**************** Displace ****************/

/**
 * 
 */
class CompositorNodeDisplace : public CompositorNode {
public:
	CompositorNodeDisplace(PyObject* pyobj) : CompositorNode(pyobj) {}

	CompositorNodeDisplace() : CompositorNode(0)
	{
		// not implemented
	}

	/**
	 * True if a registered node type
	 * @return 
	 */
	bool is_registered_node_type()
	{
		// not implemented
		return true;
	}

	/**
	 * Input socket template
	 * @param Param 'index'
	 * @return 
	 */
	NodeInternalSocketTemplate input_template(int index)
	{
		// not implemented
		return NodeInternalSocketTemplate();
	}

	/**
	 * Output socket template
	 * @param Param 'index'
	 * @return 
	 */
	NodeInternalSocketTemplate output_template(int index)
	{
		// not implemented
		return NodeInternalSocketTemplate();
	}

};

/**************** Combine HSVA ****************/

/**
 * 
 */
class CompositorNodeCombHSVA : public CompositorNode {
public:
	CompositorNodeCombHSVA(PyObject* pyobj) : CompositorNode(pyobj) {}

	CompositorNodeCombHSVA() : CompositorNode(0)
	{
		// not implemented
	}

	/**
	 * True if a registered node type
	 * @return 
	 */
	bool is_registered_node_type()
	{
		// not implemented
		return true;
	}

	/**
	 * Input socket template
	 * @param Param 'index'
	 * @return 
	 */
	NodeInternalSocketTemplate input_template(int index)
	{
		// not implemented
		return NodeInternalSocketTemplate();
	}

	/**
	 * Output socket template
	 * @param Param 'index'
	 * @return 
	 */
	NodeInternalSocketTemplate output_template(int index)
	{
		// not implemented
		return NodeInternalSocketTemplate();
	}

};

/**************** Math ****************/

/**
 * 
 */
class CompositorNodeMath : public CompositorNode {
public:
	CompositorNodeMath(PyObject* pyobj) : CompositorNode(pyobj) {}

	CompositorNodeMath() : CompositorNode(0)
	{
		// not implemented
	}

	enum operation_enum {
		operation_ADD = 0,
		operation_SUBTRACT = 1,
		operation_MULTIPLY = 2,
		operation_DIVIDE = 3,
		operation_SINE = 4,
		operation_COSINE = 5,
		operation_TANGENT = 6,
		operation_ARCSINE = 7,
		operation_ARCCOSINE = 8,
		operation_ARCTANGENT = 9,
		operation_POWER = 10,
		operation_LOGARITHM = 11,
		operation_MINIMUM = 12,
		operation_MAXIMUM = 13,
		operation_ROUND = 14,
		operation_LESS_THAN = 15,
		operation_GREATER_THAN = 16,
		operation_MODULO = 17,
		operation_ABSOLUTE = 18,
	};

	/** Getter:  */
	operation_enum operation() { /* not implemented */ throw NULL; }
	/** Setter:  */
	void operation(operation_enum value) { /* not implemented */ }

	/** Getter: Clamp result of the node to 0..1 range */
	bool use_clamp() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_clamp")) == 1;
	}

	/** Setter: Clamp result of the node to 0..1 range */
	void use_clamp(bool value) {
		PyObject_SetAttrString(pyobjref, "use_clamp", Py_BuildValue("i", value));
	}

	/**
	 * True if a registered node type
	 * @return 
	 */
	bool is_registered_node_type()
	{
		// not implemented
		return true;
	}

	/**
	 * Input socket template
	 * @param Param 'index'
	 * @return 
	 */
	NodeInternalSocketTemplate input_template(int index)
	{
		// not implemented
		return NodeInternalSocketTemplate();
	}

	/**
	 * Output socket template
	 * @param Param 'index'
	 * @return 
	 */
	NodeInternalSocketTemplate output_template(int index)
	{
		// not implemented
		return NodeInternalSocketTemplate();
	}

};

/**************** Luminance Key ****************/

/**
 * 
 */
class CompositorNodeLumaMatte : public CompositorNode {
public:
	CompositorNodeLumaMatte(PyObject* pyobj) : CompositorNode(pyobj) {}

	CompositorNodeLumaMatte() : CompositorNode(0)
	{
		// not implemented
	}

	/** Getter: Values higher than this setting are 100% opaque */
	float limit_max() { /* not implemented */ throw NULL; }
	/** Setter: Values higher than this setting are 100% opaque */
	void limit_max(float value) {
		PyObject_SetAttrString(pyobjref, "limit_max", Py_BuildValue("f", value));
	}

	/** Getter: Values lower than this setting are 100% keyed */
	float limit_min() { /* not implemented */ throw NULL; }
	/** Setter: Values lower than this setting are 100% keyed */
	void limit_min(float value) {
		PyObject_SetAttrString(pyobjref, "limit_min", Py_BuildValue("f", value));
	}

	/**
	 * True if a registered node type
	 * @return 
	 */
	bool is_registered_node_type()
	{
		// not implemented
		return true;
	}

	/**
	 * Input socket template
	 * @param Param 'index'
	 * @return 
	 */
	NodeInternalSocketTemplate input_template(int index)
	{
		// not implemented
		return NodeInternalSocketTemplate();
	}

	/**
	 * Output socket template
	 * @param Param 'index'
	 * @return 
	 */
	NodeInternalSocketTemplate output_template(int index)
	{
		// not implemented
		return NodeInternalSocketTemplate();
	}

};

/**************** Bright/Contrast ****************/

/**
 * 
 */
class CompositorNodeBrightContrast : public CompositorNode {
public:
	CompositorNodeBrightContrast(PyObject* pyobj) : CompositorNode(pyobj) {}

	CompositorNodeBrightContrast() : CompositorNode(0)
	{
		// not implemented
	}

	/**
	 * True if a registered node type
	 * @return 
	 */
	bool is_registered_node_type()
	{
		// not implemented
		return true;
	}

	/**
	 * Input socket template
	 * @param Param 'index'
	 * @return 
	 */
	NodeInternalSocketTemplate input_template(int index)
	{
		// not implemented
		return NodeInternalSocketTemplate();
	}

	/**
	 * Output socket template
	 * @param Param 'index'
	 * @return 
	 */
	NodeInternalSocketTemplate output_template(int index)
	{
		// not implemented
		return NodeInternalSocketTemplate();
	}

};

/**************** Gamma ****************/

/**
 * 
 */
class CompositorNodeGamma : public CompositorNode {
public:
	CompositorNodeGamma(PyObject* pyobj) : CompositorNode(pyobj) {}

	CompositorNodeGamma() : CompositorNode(0)
	{
		// not implemented
	}

	/**
	 * True if a registered node type
	 * @return 
	 */
	bool is_registered_node_type()
	{
		// not implemented
		return true;
	}

	/**
	 * Input socket template
	 * @param Param 'index'
	 * @return 
	 */
	NodeInternalSocketTemplate input_template(int index)
	{
		// not implemented
		return NodeInternalSocketTemplate();
	}

	/**
	 * Output socket template
	 * @param Param 'index'
	 * @return 
	 */
	NodeInternalSocketTemplate output_template(int index)
	{
		// not implemented
		return NodeInternalSocketTemplate();
	}

};

/**************** Invert ****************/

/**
 * 
 */
class CompositorNodeInvert : public CompositorNode {
public:
	CompositorNodeInvert(PyObject* pyobj) : CompositorNode(pyobj) {}

	CompositorNodeInvert() : CompositorNode(0)
	{
		// not implemented
	}

	/** Getter:  */
	bool invert_rgb() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "invert_rgb")) == 1;
	}

	/** Setter:  */
	void invert_rgb(bool value) {
		PyObject_SetAttrString(pyobjref, "invert_rgb", Py_BuildValue("i", value));
	}

	/** Getter:  */
	bool invert_alpha() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "invert_alpha")) == 1;
	}

	/** Setter:  */
	void invert_alpha(bool value) {
		PyObject_SetAttrString(pyobjref, "invert_alpha", Py_BuildValue("i", value));
	}

	/**
	 * True if a registered node type
	 * @return 
	 */
	bool is_registered_node_type()
	{
		// not implemented
		return true;
	}

	/**
	 * Input socket template
	 * @param Param 'index'
	 * @return 
	 */
	NodeInternalSocketTemplate input_template(int index)
	{
		// not implemented
		return NodeInternalSocketTemplate();
	}

	/**
	 * Output socket template
	 * @param Param 'index'
	 * @return 
	 */
	NodeInternalSocketTemplate output_template(int index)
	{
		// not implemented
		return NodeInternalSocketTemplate();
	}

};

/**************** Normalize ****************/

/**
 * 
 */
class CompositorNodeNormalize : public CompositorNode {
public:
	CompositorNodeNormalize(PyObject* pyobj) : CompositorNode(pyobj) {}

	CompositorNodeNormalize() : CompositorNode(0)
	{
		// not implemented
	}

	/**
	 * True if a registered node type
	 * @return 
	 */
	bool is_registered_node_type()
	{
		// not implemented
		return true;
	}

	/**
	 * Input socket template
	 * @param Param 'index'
	 * @return 
	 */
	NodeInternalSocketTemplate input_template(int index)
	{
		// not implemented
		return NodeInternalSocketTemplate();
	}

	/**
	 * Output socket template
	 * @param Param 'index'
	 * @return 
	 */
	NodeInternalSocketTemplate output_template(int index)
	{
		// not implemented
		return NodeInternalSocketTemplate();
	}

};

/**************** Crop ****************/

/**
 * 
 */
class CompositorNodeCrop : public CompositorNode {
public:
	CompositorNodeCrop(PyObject* pyobj) : CompositorNode(pyobj) {}

	CompositorNodeCrop() : CompositorNode(0)
	{
		// not implemented
	}

	/** Getter: Whether to crop the size of the input image */
	bool use_crop_size() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_crop_size")) == 1;
	}

	/** Setter: Whether to crop the size of the input image */
	void use_crop_size(bool value) {
		PyObject_SetAttrString(pyobjref, "use_crop_size", Py_BuildValue("i", value));
	}

	/** Getter: Use relative values to crop image */
	bool relative() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "relative")) == 1;
	}

	/** Setter: Use relative values to crop image */
	void relative(bool value) {
		PyObject_SetAttrString(pyobjref, "relative", Py_BuildValue("i", value));
	}

	/** Getter:  */
	int min_x() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "min_x"));
	}

	/** Setter:  */
	void min_x(int value) {
		PyObject_SetAttrString(pyobjref, "min_x", Py_BuildValue("i", value));
	}

	/** Getter:  */
	int max_x() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "max_x"));
	}

	/** Setter:  */
	void max_x(int value) {
		PyObject_SetAttrString(pyobjref, "max_x", Py_BuildValue("i", value));
	}

	/** Getter:  */
	int min_y() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "min_y"));
	}

	/** Setter:  */
	void min_y(int value) {
		PyObject_SetAttrString(pyobjref, "min_y", Py_BuildValue("i", value));
	}

	/** Getter:  */
	int max_y() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "max_y"));
	}

	/** Setter:  */
	void max_y(int value) {
		PyObject_SetAttrString(pyobjref, "max_y", Py_BuildValue("i", value));
	}

	/** Getter:  */
	float rel_min_x() { /* not implemented */ throw NULL; }
	/** Setter:  */
	void rel_min_x(float value) {
		PyObject_SetAttrString(pyobjref, "rel_min_x", Py_BuildValue("f", value));
	}

	/** Getter:  */
	float rel_max_x() { /* not implemented */ throw NULL; }
	/** Setter:  */
	void rel_max_x(float value) {
		PyObject_SetAttrString(pyobjref, "rel_max_x", Py_BuildValue("f", value));
	}

	/** Getter:  */
	float rel_min_y() { /* not implemented */ throw NULL; }
	/** Setter:  */
	void rel_min_y(float value) {
		PyObject_SetAttrString(pyobjref, "rel_min_y", Py_BuildValue("f", value));
	}

	/** Getter:  */
	float rel_max_y() { /* not implemented */ throw NULL; }
	/** Setter:  */
	void rel_max_y(float value) {
		PyObject_SetAttrString(pyobjref, "rel_max_y", Py_BuildValue("f", value));
	}

	/**
	 * True if a registered node type
	 * @return 
	 */
	bool is_registered_node_type()
	{
		// not implemented
		return true;
	}

	/**
	 * Input socket template
	 * @param Param 'index'
	 * @return 
	 */
	NodeInternalSocketTemplate input_template(int index)
	{
		// not implemented
		return NodeInternalSocketTemplate();
	}

	/**
	 * Output socket template
	 * @param Param 'index'
	 * @return 
	 */
	NodeInternalSocketTemplate output_template(int index)
	{
		// not implemented
		return NodeInternalSocketTemplate();
	}

};

/**************** Directional Blur ****************/

/**
 * 
 */
class CompositorNodeDBlur : public CompositorNode {
public:
	CompositorNodeDBlur(PyObject* pyobj) : CompositorNode(pyobj) {}

	CompositorNodeDBlur() : CompositorNode(0)
	{
		// not implemented
	}

	/** Getter:  */
	int iterations() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "iterations"));
	}

	/** Setter:  */
	void iterations(int value) {
		PyObject_SetAttrString(pyobjref, "iterations", Py_BuildValue("i", value));
	}

	/** Getter:  */
	bool use_wrap() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_wrap")) == 1;
	}

	/** Setter:  */
	void use_wrap(bool value) {
		PyObject_SetAttrString(pyobjref, "use_wrap", Py_BuildValue("i", value));
	}

	/** Getter:  */
	float center_x() { /* not implemented */ throw NULL; }
	/** Setter:  */
	void center_x(float value) {
		PyObject_SetAttrString(pyobjref, "center_x", Py_BuildValue("f", value));
	}

	/** Getter:  */
	float center_y() { /* not implemented */ throw NULL; }
	/** Setter:  */
	void center_y(float value) {
		PyObject_SetAttrString(pyobjref, "center_y", Py_BuildValue("f", value));
	}

	/** Getter:  */
	float distance() { /* not implemented */ throw NULL; }
	/** Setter:  */
	void distance(float value) {
		PyObject_SetAttrString(pyobjref, "distance", Py_BuildValue("f", value));
	}

	/** Getter:  */
	float angle() { /* not implemented */ throw NULL; }
	/** Setter:  */
	void angle(float value) {
		PyObject_SetAttrString(pyobjref, "angle", Py_BuildValue("f", value));
	}

	/** Getter:  */
	float spin() { /* not implemented */ throw NULL; }
	/** Setter:  */
	void spin(float value) {
		PyObject_SetAttrString(pyobjref, "spin", Py_BuildValue("f", value));
	}

	/** Getter:  */
	float zoom() { /* not implemented */ throw NULL; }
	/** Setter:  */
	void zoom(float value) {
		PyObject_SetAttrString(pyobjref, "zoom", Py_BuildValue("f", value));
	}

	/**
	 * True if a registered node type
	 * @return 
	 */
	bool is_registered_node_type()
	{
		// not implemented
		return true;
	}

	/**
	 * Input socket template
	 * @param Param 'index'
	 * @return 
	 */
	NodeInternalSocketTemplate input_template(int index)
	{
		// not implemented
		return NodeInternalSocketTemplate();
	}

	/**
	 * Output socket template
	 * @param Param 'index'
	 * @return 
	 */
	NodeInternalSocketTemplate output_template(int index)
	{
		// not implemented
		return NodeInternalSocketTemplate();
	}

};

/**************** Bilateral Blur ****************/

/**
 * 
 */
class CompositorNodeBilateralblur : public CompositorNode {
public:
	CompositorNodeBilateralblur(PyObject* pyobj) : CompositorNode(pyobj) {}

	CompositorNodeBilateralblur() : CompositorNode(0)
	{
		// not implemented
	}

	/** Getter:  */
	int iterations() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "iterations"));
	}

	/** Setter:  */
	void iterations(int value) {
		PyObject_SetAttrString(pyobjref, "iterations", Py_BuildValue("i", value));
	}

	/** Getter:  */
	float sigma_color() { /* not implemented */ throw NULL; }
	/** Setter:  */
	void sigma_color(float value) {
		PyObject_SetAttrString(pyobjref, "sigma_color", Py_BuildValue("f", value));
	}

	/** Getter:  */
	float sigma_space() { /* not implemented */ throw NULL; }
	/** Setter:  */
	void sigma_space(float value) {
		PyObject_SetAttrString(pyobjref, "sigma_space", Py_BuildValue("f", value));
	}

	/**
	 * True if a registered node type
	 * @return 
	 */
	bool is_registered_node_type()
	{
		// not implemented
		return true;
	}

	/**
	 * Input socket template
	 * @param Param 'index'
	 * @return 
	 */
	NodeInternalSocketTemplate input_template(int index)
	{
		// not implemented
		return NodeInternalSocketTemplate();
	}

	/**
	 * Output socket template
	 * @param Param 'index'
	 * @return 
	 */
	NodeInternalSocketTemplate output_template(int index)
	{
		// not implemented
		return NodeInternalSocketTemplate();
	}

};

/**************** Alpha Convert ****************/

/**
 * 
 */
class CompositorNodePremulKey : public CompositorNode {
public:
	CompositorNodePremulKey(PyObject* pyobj) : CompositorNode(pyobj) {}

	CompositorNodePremulKey() : CompositorNode(0)
	{
		// not implemented
	}

	enum mapping_enum {
		mapping_STRAIGHT_TO_PREMUL = 0,
		mapping_PREMUL_TO_STRAIGHT = 1,
	};

	/** Getter: Conversion between premultiplied alpha and key alpha */
	mapping_enum mapping() { /* not implemented */ throw NULL; }
	/** Setter: Conversion between premultiplied alpha and key alpha */
	void mapping(mapping_enum value) { /* not implemented */ }

	/**
	 * True if a registered node type
	 * @return 
	 */
	bool is_registered_node_type()
	{
		// not implemented
		return true;
	}

	/**
	 * Input socket template
	 * @param Param 'index'
	 * @return 
	 */
	NodeInternalSocketTemplate input_template(int index)
	{
		// not implemented
		return NodeInternalSocketTemplate();
	}

	/**
	 * Output socket template
	 * @param Param 'index'
	 * @return 
	 */
	NodeInternalSocketTemplate output_template(int index)
	{
		// not implemented
		return NodeInternalSocketTemplate();
	}

};

/**************** Glare ****************/

/**
 * 
 */
class CompositorNodeGlare : public CompositorNode {
public:
	CompositorNodeGlare(PyObject* pyobj) : CompositorNode(pyobj) {}

	CompositorNodeGlare() : CompositorNode(0)
	{
		// not implemented
	}

	enum glare_type_enum {
		glare_type_GHOSTS = 3,
		glare_type_STREAKS = 2,
		glare_type_FOG_GLOW = 1,
		glare_type_SIMPLE_STAR = 0,
	};

	/** Getter:  */
	glare_type_enum glare_type() { /* not implemented */ throw NULL; }
	/** Setter:  */
	void glare_type(glare_type_enum value) { /* not implemented */ }

	enum quality_enum {
		quality_HIGH = 0,
		quality_MEDIUM = 1,
		quality_LOW = 2,
	};

	/** Getter: If not set to high quality, the effect will be applied to a low-res copy of the source image */
	quality_enum quality() { /* not implemented */ throw NULL; }
	/** Setter: If not set to high quality, the effect will be applied to a low-res copy of the source image */
	void quality(quality_enum value) { /* not implemented */ }

	/** Getter:  */
	int iterations() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "iterations"));
	}

	/** Setter:  */
	void iterations(int value) {
		PyObject_SetAttrString(pyobjref, "iterations", Py_BuildValue("i", value));
	}

	/** Getter: Amount of Color Modulation, modulates colors of streaks and ghosts for a spectral dispersion effect */
	float color_modulation() { /* not implemented */ throw NULL; }
	/** Setter: Amount of Color Modulation, modulates colors of streaks and ghosts for a spectral dispersion effect */
	void color_modulation(float value) {
		PyObject_SetAttrString(pyobjref, "color_modulation", Py_BuildValue("f", value));
	}

	/** Getter: -1 is original image only, 0 is exact 50/50 mix, 1 is processed image only */
	float mix() { /* not implemented */ throw NULL; }
	/** Setter: -1 is original image only, 0 is exact 50/50 mix, 1 is processed image only */
	void mix(float value) {
		PyObject_SetAttrString(pyobjref, "mix", Py_BuildValue("f", value));
	}

	/** Getter: The glare filter will only be applied to pixels brighter than this value */
	float threshold() { /* not implemented */ throw NULL; }
	/** Setter: The glare filter will only be applied to pixels brighter than this value */
	void threshold(float value) {
		PyObject_SetAttrString(pyobjref, "threshold", Py_BuildValue("f", value));
	}

	/** Getter: Total number of streaks */
	int streaks() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "streaks"));
	}

	/** Setter: Total number of streaks */
	void streaks(int value) {
		PyObject_SetAttrString(pyobjref, "streaks", Py_BuildValue("i", value));
	}

	/** Getter: Streak angle offset */
	float angle_offset() { /* not implemented */ throw NULL; }
	/** Setter: Streak angle offset */
	void angle_offset(float value) {
		PyObject_SetAttrString(pyobjref, "angle_offset", Py_BuildValue("f", value));
	}

	/** Getter: Streak fade-out factor */
	float fade() { /* not implemented */ throw NULL; }
	/** Setter: Streak fade-out factor */
	void fade(float value) {
		PyObject_SetAttrString(pyobjref, "fade", Py_BuildValue("f", value));
	}

	/** Getter: Simple star filter: add 45 degree rotation offset */
	bool use_rotate_45() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_rotate_45")) == 1;
	}

	/** Setter: Simple star filter: add 45 degree rotation offset */
	void use_rotate_45(bool value) {
		PyObject_SetAttrString(pyobjref, "use_rotate_45", Py_BuildValue("i", value));
	}

	/** Getter: Glow/glare size (not actual size; relative to initial size of bright area of pixels) */
	int size() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "size"));
	}

	/** Setter: Glow/glare size (not actual size; relative to initial size of bright area of pixels) */
	void size(int value) {
		PyObject_SetAttrString(pyobjref, "size", Py_BuildValue("i", value));
	}

	/**
	 * True if a registered node type
	 * @return 
	 */
	bool is_registered_node_type()
	{
		// not implemented
		return true;
	}

	/**
	 * Input socket template
	 * @param Param 'index'
	 * @return 
	 */
	NodeInternalSocketTemplate input_template(int index)
	{
		// not implemented
		return NodeInternalSocketTemplate();
	}

	/**
	 * Output socket template
	 * @param Param 'index'
	 * @return 
	 */
	NodeInternalSocketTemplate output_template(int index)
	{
		// not implemented
		return NodeInternalSocketTemplate();
	}

};

/**************** Tonemap ****************/

/**
 * 
 */
class CompositorNodeTonemap : public CompositorNode {
public:
	CompositorNodeTonemap(PyObject* pyobj) : CompositorNode(pyobj) {}

	CompositorNodeTonemap() : CompositorNode(0)
	{
		// not implemented
	}

	enum tonemap_type_enum {
		tonemap_type_RD_PHOTORECEPTOR = 1,
		tonemap_type_RH_SIMPLE = 0,
	};

	/** Getter:  */
	tonemap_type_enum tonemap_type() { /* not implemented */ throw NULL; }
	/** Setter:  */
	void tonemap_type(tonemap_type_enum value) { /* not implemented */ }

	/** Getter: The value the average luminance is mapped to */
	float key() { /* not implemented */ throw NULL; }
	/** Setter: The value the average luminance is mapped to */
	void key(float value) {
		PyObject_SetAttrString(pyobjref, "key", Py_BuildValue("f", value));
	}

	/** Getter: Normally always 1, but can be used as an extra control to alter the brightness curve */
	float offset() { /* not implemented */ throw NULL; }
	/** Setter: Normally always 1, but can be used as an extra control to alter the brightness curve */
	void offset(float value) {
		PyObject_SetAttrString(pyobjref, "offset", Py_BuildValue("f", value));
	}

	/** Getter: If not used, set to 1 */
	float gamma() { /* not implemented */ throw NULL; }
	/** Setter: If not used, set to 1 */
	void gamma(float value) {
		PyObject_SetAttrString(pyobjref, "gamma", Py_BuildValue("f", value));
	}

	/** Getter: If less than zero, darkens image; otherwise, makes it brighter */
	float intensity() { /* not implemented */ throw NULL; }
	/** Setter: If less than zero, darkens image; otherwise, makes it brighter */
	void intensity(float value) {
		PyObject_SetAttrString(pyobjref, "intensity", Py_BuildValue("f", value));
	}

	/** Getter: Set to 0 to use estimate from input image */
	float contrast() { /* not implemented */ throw NULL; }
	/** Setter: Set to 0 to use estimate from input image */
	void contrast(float value) {
		PyObject_SetAttrString(pyobjref, "contrast", Py_BuildValue("f", value));
	}

	/** Getter: If 0, global; if 1, based on pixel intensity */
	float adaptation() { /* not implemented */ throw NULL; }
	/** Setter: If 0, global; if 1, based on pixel intensity */
	void adaptation(float value) {
		PyObject_SetAttrString(pyobjref, "adaptation", Py_BuildValue("f", value));
	}

	/** Getter: If 0, same for all channels; if 1, each independent */
	float correction() { /* not implemented */ throw NULL; }
	/** Setter: If 0, same for all channels; if 1, each independent */
	void correction(float value) {
		PyObject_SetAttrString(pyobjref, "correction", Py_BuildValue("f", value));
	}

	/**
	 * True if a registered node type
	 * @return 
	 */
	bool is_registered_node_type()
	{
		// not implemented
		return true;
	}

	/**
	 * Input socket template
	 * @param Param 'index'
	 * @return 
	 */
	NodeInternalSocketTemplate input_template(int index)
	{
		// not implemented
		return NodeInternalSocketTemplate();
	}

	/**
	 * Output socket template
	 * @param Param 'index'
	 * @return 
	 */
	NodeInternalSocketTemplate output_template(int index)
	{
		// not implemented
		return NodeInternalSocketTemplate();
	}

};

/**************** Lens Distortion ****************/

/**
 * 
 */
class CompositorNodeLensdist : public CompositorNode {
public:
	CompositorNodeLensdist(PyObject* pyobj) : CompositorNode(pyobj) {}

	CompositorNodeLensdist() : CompositorNode(0)
	{
		// not implemented
	}

	/** Getter: Enable/disable projector mode (the effect is applied in horizontal direction only) */
	bool use_projector() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_projector")) == 1;
	}

	/** Setter: Enable/disable projector mode (the effect is applied in horizontal direction only) */
	void use_projector(bool value) {
		PyObject_SetAttrString(pyobjref, "use_projector", Py_BuildValue("i", value));
	}

	/** Getter: Enable/disable jittering (faster, but also noisier) */
	bool use_jitter() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_jitter")) == 1;
	}

	/** Setter: Enable/disable jittering (faster, but also noisier) */
	void use_jitter(bool value) {
		PyObject_SetAttrString(pyobjref, "use_jitter", Py_BuildValue("i", value));
	}

	/** Getter: For positive distortion factor only: scale image such that black areas are not visible */
	bool use_fit() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_fit")) == 1;
	}

	/** Setter: For positive distortion factor only: scale image such that black areas are not visible */
	void use_fit(bool value) {
		PyObject_SetAttrString(pyobjref, "use_fit", Py_BuildValue("i", value));
	}

	/**
	 * True if a registered node type
	 * @return 
	 */
	bool is_registered_node_type()
	{
		// not implemented
		return true;
	}

	/**
	 * Input socket template
	 * @param Param 'index'
	 * @return 
	 */
	NodeInternalSocketTemplate input_template(int index)
	{
		// not implemented
		return NodeInternalSocketTemplate();
	}

	/**
	 * Output socket template
	 * @param Param 'index'
	 * @return 
	 */
	NodeInternalSocketTemplate output_template(int index)
	{
		// not implemented
		return NodeInternalSocketTemplate();
	}

};

/**************** Levels ****************/

/**
 * 
 */
class CompositorNodeLevels : public CompositorNode {
public:
	CompositorNodeLevels(PyObject* pyobj) : CompositorNode(pyobj) {}

	CompositorNodeLevels() : CompositorNode(0)
	{
		// not implemented
	}

	enum channel_enum {
		channel_COMBINED_RGB = 1,
		channel_RED = 2,
		channel_GREEN = 3,
		channel_BLUE = 4,
		channel_LUMINANCE = 5,
	};

	/** Getter:  */
	channel_enum channel() { /* not implemented */ throw NULL; }
	/** Setter:  */
	void channel(channel_enum value) { /* not implemented */ }

	/**
	 * True if a registered node type
	 * @return 
	 */
	bool is_registered_node_type()
	{
		// not implemented
		return true;
	}

	/**
	 * Input socket template
	 * @param Param 'index'
	 * @return 
	 */
	NodeInternalSocketTemplate input_template(int index)
	{
		// not implemented
		return NodeInternalSocketTemplate();
	}

	/**
	 * Output socket template
	 * @param Param 'index'
	 * @return 
	 */
	NodeInternalSocketTemplate output_template(int index)
	{
		// not implemented
		return NodeInternalSocketTemplate();
	}

};

/**************** Color Key ****************/

/**
 * 
 */
class CompositorNodeColorMatte : public CompositorNode {
public:
	CompositorNodeColorMatte(PyObject* pyobj) : CompositorNode(pyobj) {}

	CompositorNodeColorMatte() : CompositorNode(0)
	{
		// not implemented
	}

	/** Getter: Hue tolerance for colors to be considered a keying color */
	float color_hue() { /* not implemented */ throw NULL; }
	/** Setter: Hue tolerance for colors to be considered a keying color */
	void color_hue(float value) {
		PyObject_SetAttrString(pyobjref, "color_hue", Py_BuildValue("f", value));
	}

	/** Getter: Saturation Tolerance for the color */
	float color_saturation() { /* not implemented */ throw NULL; }
	/** Setter: Saturation Tolerance for the color */
	void color_saturation(float value) {
		PyObject_SetAttrString(pyobjref, "color_saturation", Py_BuildValue("f", value));
	}

	/** Getter: Value Tolerance for the color */
	float color_value() { /* not implemented */ throw NULL; }
	/** Setter: Value Tolerance for the color */
	void color_value(float value) {
		PyObject_SetAttrString(pyobjref, "color_value", Py_BuildValue("f", value));
	}

	/**
	 * True if a registered node type
	 * @return 
	 */
	bool is_registered_node_type()
	{
		// not implemented
		return true;
	}

	/**
	 * Input socket template
	 * @param Param 'index'
	 * @return 
	 */
	NodeInternalSocketTemplate input_template(int index)
	{
		// not implemented
		return NodeInternalSocketTemplate();
	}

	/**
	 * Output socket template
	 * @param Param 'index'
	 * @return 
	 */
	NodeInternalSocketTemplate output_template(int index)
	{
		// not implemented
		return NodeInternalSocketTemplate();
	}

};

/**************** Distance Key ****************/

/**
 * 
 */
class CompositorNodeDistanceMatte : public CompositorNode {
public:
	CompositorNodeDistanceMatte(PyObject* pyobj) : CompositorNode(pyobj) {}

	CompositorNodeDistanceMatte() : CompositorNode(0)
	{
		// not implemented
	}

	enum channel_enum {
		channel_RGB = 1,
		channel_YCC = 2,
	};

	/** Getter:  */
	channel_enum channel() { /* not implemented */ throw NULL; }
	/** Setter:  */
	void channel(channel_enum value) { /* not implemented */ }

	/** Getter: Color distances below this threshold are keyed */
	float tolerance() { /* not implemented */ throw NULL; }
	/** Setter: Color distances below this threshold are keyed */
	void tolerance(float value) {
		PyObject_SetAttrString(pyobjref, "tolerance", Py_BuildValue("f", value));
	}

	/** Getter: Color distances below this additional threshold are partially keyed */
	float falloff() { /* not implemented */ throw NULL; }
	/** Setter: Color distances below this additional threshold are partially keyed */
	void falloff(float value) {
		PyObject_SetAttrString(pyobjref, "falloff", Py_BuildValue("f", value));
	}

	/**
	 * True if a registered node type
	 * @return 
	 */
	bool is_registered_node_type()
	{
		// not implemented
		return true;
	}

	/**
	 * Input socket template
	 * @param Param 'index'
	 * @return 
	 */
	NodeInternalSocketTemplate input_template(int index)
	{
		// not implemented
		return NodeInternalSocketTemplate();
	}

	/**
	 * Output socket template
	 * @param Param 'index'
	 * @return 
	 */
	NodeInternalSocketTemplate output_template(int index)
	{
		// not implemented
		return NodeInternalSocketTemplate();
	}

};

/**************** Color Balance ****************/

/**
 * 
 */
class CompositorNodeColorBalance : public CompositorNode {
public:
	CompositorNodeColorBalance(PyObject* pyobj) : CompositorNode(pyobj) {}

	CompositorNodeColorBalance() : CompositorNode(0)
	{
		// not implemented
	}

	enum correction_method_enum {
		correction_method_LIFT_GAMMA_GAIN = 0,
		correction_method_OFFSET_POWER_SLOPE = 1,
	};

	/** Getter:  */
	correction_method_enum correction_method() { /* not implemented */ throw NULL; }
	/** Setter:  */
	void correction_method(correction_method_enum value) { /* not implemented */ }

	/** Getter: Correction for Shadows */
	std::array<float, 3> lift() {
		// TODO: MISSING DEREF! USE #DEFINE!
		PyObject *seqval = PyObject_GetAttrString(pyobjref, "lift");
		std::array<float, 3> resarr;
		for (int i = 0; i < 3; i++)
			resarr[i] = (float)PyFloat_AsDouble(PySequence_GetItem(seqval, i));
		return resarr;
	}

	/** Setter: Correction for Shadows */
	void lift(float values[3]) { /* not implemented */ }

	/** Getter: Correction for Midtones */
	std::array<float, 3> gamma() {
		// TODO: MISSING DEREF! USE #DEFINE!
		PyObject *seqval = PyObject_GetAttrString(pyobjref, "gamma");
		std::array<float, 3> resarr;
		for (int i = 0; i < 3; i++)
			resarr[i] = (float)PyFloat_AsDouble(PySequence_GetItem(seqval, i));
		return resarr;
	}

	/** Setter: Correction for Midtones */
	void gamma(float values[3]) { /* not implemented */ }

	/** Getter: Correction for Highlights */
	std::array<float, 3> gain() {
		// TODO: MISSING DEREF! USE #DEFINE!
		PyObject *seqval = PyObject_GetAttrString(pyobjref, "gain");
		std::array<float, 3> resarr;
		for (int i = 0; i < 3; i++)
			resarr[i] = (float)PyFloat_AsDouble(PySequence_GetItem(seqval, i));
		return resarr;
	}

	/** Setter: Correction for Highlights */
	void gain(float values[3]) { /* not implemented */ }

	/** Getter: Correction for Shadows */
	std::array<float, 3> offset() {
		// TODO: MISSING DEREF! USE #DEFINE!
		PyObject *seqval = PyObject_GetAttrString(pyobjref, "offset");
		std::array<float, 3> resarr;
		for (int i = 0; i < 3; i++)
			resarr[i] = (float)PyFloat_AsDouble(PySequence_GetItem(seqval, i));
		return resarr;
	}

	/** Setter: Correction for Shadows */
	void offset(float values[3]) { /* not implemented */ }

	/** Getter: Correction for Midtones */
	std::array<float, 3> power() {
		// TODO: MISSING DEREF! USE #DEFINE!
		PyObject *seqval = PyObject_GetAttrString(pyobjref, "power");
		std::array<float, 3> resarr;
		for (int i = 0; i < 3; i++)
			resarr[i] = (float)PyFloat_AsDouble(PySequence_GetItem(seqval, i));
		return resarr;
	}

	/** Setter: Correction for Midtones */
	void power(float values[3]) { /* not implemented */ }

	/** Getter: Correction for Highlights */
	std::array<float, 3> slope() {
		// TODO: MISSING DEREF! USE #DEFINE!
		PyObject *seqval = PyObject_GetAttrString(pyobjref, "slope");
		std::array<float, 3> resarr;
		for (int i = 0; i < 3; i++)
			resarr[i] = (float)PyFloat_AsDouble(PySequence_GetItem(seqval, i));
		return resarr;
	}

	/** Setter: Correction for Highlights */
	void slope(float values[3]) { /* not implemented */ }

	/**
	 * True if a registered node type
	 * @return 
	 */
	bool is_registered_node_type()
	{
		// not implemented
		return true;
	}

	/**
	 * Input socket template
	 * @param Param 'index'
	 * @return 
	 */
	NodeInternalSocketTemplate input_template(int index)
	{
		// not implemented
		return NodeInternalSocketTemplate();
	}

	/**
	 * Output socket template
	 * @param Param 'index'
	 * @return 
	 */
	NodeInternalSocketTemplate output_template(int index)
	{
		// not implemented
		return NodeInternalSocketTemplate();
	}

};

/**************** Hue Correct ****************/

/**
 * 
 */
class CompositorNodeHueCorrect : public CompositorNode {
public:
	CompositorNodeHueCorrect(PyObject* pyobj) : CompositorNode(pyobj) {}

	CompositorNodeHueCorrect() : CompositorNode(0)
	{
		// not implemented
	}

	/** Getter:  */
	CurveMapping mapping() {
		/* not implemented */ throw NULL;
	}

	/**
	 * True if a registered node type
	 * @return 
	 */
	bool is_registered_node_type()
	{
		// not implemented
		return true;
	}

	/**
	 * Input socket template
	 * @param Param 'index'
	 * @return 
	 */
	NodeInternalSocketTemplate input_template(int index)
	{
		// not implemented
		return NodeInternalSocketTemplate();
	}

	/**
	 * Output socket template
	 * @param Param 'index'
	 * @return 
	 */
	NodeInternalSocketTemplate output_template(int index)
	{
		// not implemented
		return NodeInternalSocketTemplate();
	}

};

/**************** Movie Clip ****************/

/**
 * 
 */
class CompositorNodeMovieClip : public CompositorNode {
public:
	CompositorNodeMovieClip(PyObject* pyobj) : CompositorNode(pyobj) {}

	CompositorNodeMovieClip() : CompositorNode(0)
	{
		// not implemented
	}

	/** Getter:  */
	MovieClip clip();

	/**
	 * True if a registered node type
	 * @return 
	 */
	bool is_registered_node_type()
	{
		// not implemented
		return true;
	}

	/**
	 * Input socket template
	 * @param Param 'index'
	 * @return 
	 */
	NodeInternalSocketTemplate input_template(int index)
	{
		// not implemented
		return NodeInternalSocketTemplate();
	}

	/**
	 * Output socket template
	 * @param Param 'index'
	 * @return 
	 */
	NodeInternalSocketTemplate output_template(int index)
	{
		// not implemented
		return NodeInternalSocketTemplate();
	}

};

/**************** Transform ****************/

/**
 * 
 */
class CompositorNodeTransform : public CompositorNode {
public:
	CompositorNodeTransform(PyObject* pyobj) : CompositorNode(pyobj) {}

	CompositorNodeTransform() : CompositorNode(0)
	{
		// not implemented
	}

	enum filter_type_enum {
		filter_type_NEAREST = 0,
		filter_type_BILINEAR = 1,
		filter_type_BICUBIC = 2,
	};

	/** Getter: Method to use to filter transform */
	filter_type_enum filter_type() { /* not implemented */ throw NULL; }
	/** Setter: Method to use to filter transform */
	void filter_type(filter_type_enum value) { /* not implemented */ }

	/**
	 * True if a registered node type
	 * @return 
	 */
	bool is_registered_node_type()
	{
		// not implemented
		return true;
	}

	/**
	 * Input socket template
	 * @param Param 'index'
	 * @return 
	 */
	NodeInternalSocketTemplate input_template(int index)
	{
		// not implemented
		return NodeInternalSocketTemplate();
	}

	/**
	 * Output socket template
	 * @param Param 'index'
	 * @return 
	 */
	NodeInternalSocketTemplate output_template(int index)
	{
		// not implemented
		return NodeInternalSocketTemplate();
	}

};

/**************** Stabilize 2D ****************/

/**
 * 
 */
class CompositorNodeStabilize : public CompositorNode {
public:
	CompositorNodeStabilize(PyObject* pyobj) : CompositorNode(pyobj) {}

	CompositorNodeStabilize() : CompositorNode(0)
	{
		// not implemented
	}

	/** Getter:  */
	MovieClip clip();

	enum filter_type_enum {
		filter_type_NEAREST = 0,
		filter_type_BILINEAR = 1,
		filter_type_BICUBIC = 2,
	};

	/** Getter: Method to use to filter stabilization */
	filter_type_enum filter_type() { /* not implemented */ throw NULL; }
	/** Setter: Method to use to filter stabilization */
	void filter_type(filter_type_enum value) { /* not implemented */ }

	/**
	 * True if a registered node type
	 * @return 
	 */
	bool is_registered_node_type()
	{
		// not implemented
		return true;
	}

	/**
	 * Input socket template
	 * @param Param 'index'
	 * @return 
	 */
	NodeInternalSocketTemplate input_template(int index)
	{
		// not implemented
		return NodeInternalSocketTemplate();
	}

	/**
	 * Output socket template
	 * @param Param 'index'
	 * @return 
	 */
	NodeInternalSocketTemplate output_template(int index)
	{
		// not implemented
		return NodeInternalSocketTemplate();
	}

};

/**************** Movie Distortion ****************/

/**
 * 
 */
class CompositorNodeMovieDistortion : public CompositorNode {
public:
	CompositorNodeMovieDistortion(PyObject* pyobj) : CompositorNode(pyobj) {}

	CompositorNodeMovieDistortion() : CompositorNode(0)
	{
		// not implemented
	}

	/** Getter:  */
	MovieClip clip();

	enum distortion_type_enum {
		distortion_type_UNDISTORT = 0,
		distortion_type_DISTORT = 1,
	};

	/** Getter: Distortion to use to filter image */
	distortion_type_enum distortion_type() { /* not implemented */ throw NULL; }
	/** Setter: Distortion to use to filter image */
	void distortion_type(distortion_type_enum value) { /* not implemented */ }

	/**
	 * True if a registered node type
	 * @return 
	 */
	bool is_registered_node_type()
	{
		// not implemented
		return true;
	}

	/**
	 * Input socket template
	 * @param Param 'index'
	 * @return 
	 */
	NodeInternalSocketTemplate input_template(int index)
	{
		// not implemented
		return NodeInternalSocketTemplate();
	}

	/**
	 * Output socket template
	 * @param Param 'index'
	 * @return 
	 */
	NodeInternalSocketTemplate output_template(int index)
	{
		// not implemented
		return NodeInternalSocketTemplate();
	}

};

/**************** Box Mask ****************/

/**
 * 
 */
class CompositorNodeBoxMask : public CompositorNode {
public:
	CompositorNodeBoxMask(PyObject* pyobj) : CompositorNode(pyobj) {}

	CompositorNodeBoxMask() : CompositorNode(0)
	{
		// not implemented
	}

	enum mask_type_enum {
		mask_type_ADD = 0,
		mask_type_SUBTRACT = 1,
		mask_type_MULTIPLY = 2,
		mask_type_NOT = 3,
	};

	/** Getter:  */
	mask_type_enum mask_type() { /* not implemented */ throw NULL; }
	/** Setter:  */
	void mask_type(mask_type_enum value) { /* not implemented */ }

	/** Getter: X position of the middle of the box */
	float x() { /* not implemented */ throw NULL; }
	/** Setter: X position of the middle of the box */
	void x(float value) {
		PyObject_SetAttrString(pyobjref, "x", Py_BuildValue("f", value));
	}

	/** Getter: Y position of the middle of the box */
	float y() { /* not implemented */ throw NULL; }
	/** Setter: Y position of the middle of the box */
	void y(float value) {
		PyObject_SetAttrString(pyobjref, "y", Py_BuildValue("f", value));
	}

	/** Getter: Width of the box */
	float width() { /* not implemented */ throw NULL; }
	/** Setter: Width of the box */
	void width(float value) {
		PyObject_SetAttrString(pyobjref, "width", Py_BuildValue("f", value));
	}

	/** Getter: Height of the box */
	float height() { /* not implemented */ throw NULL; }
	/** Setter: Height of the box */
	void height(float value) {
		PyObject_SetAttrString(pyobjref, "height", Py_BuildValue("f", value));
	}

	/** Getter: Rotation angle of the box */
	float rotation() { /* not implemented */ throw NULL; }
	/** Setter: Rotation angle of the box */
	void rotation(float value) {
		PyObject_SetAttrString(pyobjref, "rotation", Py_BuildValue("f", value));
	}

	/**
	 * True if a registered node type
	 * @return 
	 */
	bool is_registered_node_type()
	{
		// not implemented
		return true;
	}

	/**
	 * Input socket template
	 * @param Param 'index'
	 * @return 
	 */
	NodeInternalSocketTemplate input_template(int index)
	{
		// not implemented
		return NodeInternalSocketTemplate();
	}

	/**
	 * Output socket template
	 * @param Param 'index'
	 * @return 
	 */
	NodeInternalSocketTemplate output_template(int index)
	{
		// not implemented
		return NodeInternalSocketTemplate();
	}

};

/**************** Ellipse Mask ****************/

/**
 * 
 */
class CompositorNodeEllipseMask : public CompositorNode {
public:
	CompositorNodeEllipseMask(PyObject* pyobj) : CompositorNode(pyobj) {}

	CompositorNodeEllipseMask() : CompositorNode(0)
	{
		// not implemented
	}

	enum mask_type_enum {
		mask_type_ADD = 0,
		mask_type_SUBTRACT = 1,
		mask_type_MULTIPLY = 2,
		mask_type_NOT = 3,
	};

	/** Getter:  */
	mask_type_enum mask_type() { /* not implemented */ throw NULL; }
	/** Setter:  */
	void mask_type(mask_type_enum value) { /* not implemented */ }

	/** Getter: X position of the middle of the ellipse */
	float x() { /* not implemented */ throw NULL; }
	/** Setter: X position of the middle of the ellipse */
	void x(float value) {
		PyObject_SetAttrString(pyobjref, "x", Py_BuildValue("f", value));
	}

	/** Getter: Y position of the middle of the ellipse */
	float y() { /* not implemented */ throw NULL; }
	/** Setter: Y position of the middle of the ellipse */
	void y(float value) {
		PyObject_SetAttrString(pyobjref, "y", Py_BuildValue("f", value));
	}

	/** Getter: Width of the ellipse */
	float width() { /* not implemented */ throw NULL; }
	/** Setter: Width of the ellipse */
	void width(float value) {
		PyObject_SetAttrString(pyobjref, "width", Py_BuildValue("f", value));
	}

	/** Getter: Height of the ellipse */
	float height() { /* not implemented */ throw NULL; }
	/** Setter: Height of the ellipse */
	void height(float value) {
		PyObject_SetAttrString(pyobjref, "height", Py_BuildValue("f", value));
	}

	/** Getter: Rotation angle of the ellipse */
	float rotation() { /* not implemented */ throw NULL; }
	/** Setter: Rotation angle of the ellipse */
	void rotation(float value) {
		PyObject_SetAttrString(pyobjref, "rotation", Py_BuildValue("f", value));
	}

	/**
	 * True if a registered node type
	 * @return 
	 */
	bool is_registered_node_type()
	{
		// not implemented
		return true;
	}

	/**
	 * Input socket template
	 * @param Param 'index'
	 * @return 
	 */
	NodeInternalSocketTemplate input_template(int index)
	{
		// not implemented
		return NodeInternalSocketTemplate();
	}

	/**
	 * Output socket template
	 * @param Param 'index'
	 * @return 
	 */
	NodeInternalSocketTemplate output_template(int index)
	{
		// not implemented
		return NodeInternalSocketTemplate();
	}

};

/**************** Bokeh Image ****************/

/**
 * 
 */
class CompositorNodeBokehImage : public CompositorNode {
public:
	CompositorNodeBokehImage(PyObject* pyobj) : CompositorNode(pyobj) {}

	CompositorNodeBokehImage() : CompositorNode(0)
	{
		// not implemented
	}

	/** Getter: Angle of the bokeh */
	float angle() { /* not implemented */ throw NULL; }
	/** Setter: Angle of the bokeh */
	void angle(float value) {
		PyObject_SetAttrString(pyobjref, "angle", Py_BuildValue("f", value));
	}

	/** Getter: Number of flaps */
	int flaps() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "flaps"));
	}

	/** Setter: Number of flaps */
	void flaps(int value) {
		PyObject_SetAttrString(pyobjref, "flaps", Py_BuildValue("i", value));
	}

	/** Getter: Level of rounding of the bokeh */
	float rounding() { /* not implemented */ throw NULL; }
	/** Setter: Level of rounding of the bokeh */
	void rounding(float value) {
		PyObject_SetAttrString(pyobjref, "rounding", Py_BuildValue("f", value));
	}

	/** Getter: Level of catadioptric of the bokeh */
	float catadioptric() { /* not implemented */ throw NULL; }
	/** Setter: Level of catadioptric of the bokeh */
	void catadioptric(float value) {
		PyObject_SetAttrString(pyobjref, "catadioptric", Py_BuildValue("f", value));
	}

	/** Getter: Shift of the lens components */
	float shift() { /* not implemented */ throw NULL; }
	/** Setter: Shift of the lens components */
	void shift(float value) {
		PyObject_SetAttrString(pyobjref, "shift", Py_BuildValue("f", value));
	}

	/**
	 * True if a registered node type
	 * @return 
	 */
	bool is_registered_node_type()
	{
		// not implemented
		return true;
	}

	/**
	 * Input socket template
	 * @param Param 'index'
	 * @return 
	 */
	NodeInternalSocketTemplate input_template(int index)
	{
		// not implemented
		return NodeInternalSocketTemplate();
	}

	/**
	 * Output socket template
	 * @param Param 'index'
	 * @return 
	 */
	NodeInternalSocketTemplate output_template(int index)
	{
		// not implemented
		return NodeInternalSocketTemplate();
	}

};

/**************** Bokeh Blur ****************/

/**
 * 
 */
class CompositorNodeBokehBlur : public CompositorNode {
public:
	CompositorNodeBokehBlur(PyObject* pyobj) : CompositorNode(pyobj) {}

	CompositorNodeBokehBlur() : CompositorNode(0)
	{
		// not implemented
	}

	/** Getter: Support variable blur per-pixel when using an image for size input */
	bool use_variable_size() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_variable_size")) == 1;
	}

	/** Setter: Support variable blur per-pixel when using an image for size input */
	void use_variable_size(bool value) {
		PyObject_SetAttrString(pyobjref, "use_variable_size", Py_BuildValue("i", value));
	}

	/** Getter: Blur limit, maximum CoC radius */
	float blur_max() { /* not implemented */ throw NULL; }
	/** Setter: Blur limit, maximum CoC radius */
	void blur_max(float value) {
		PyObject_SetAttrString(pyobjref, "blur_max", Py_BuildValue("f", value));
	}

	/**
	 * True if a registered node type
	 * @return 
	 */
	bool is_registered_node_type()
	{
		// not implemented
		return true;
	}

	/**
	 * Input socket template
	 * @param Param 'index'
	 * @return 
	 */
	NodeInternalSocketTemplate input_template(int index)
	{
		// not implemented
		return NodeInternalSocketTemplate();
	}

	/**
	 * Output socket template
	 * @param Param 'index'
	 * @return 
	 */
	NodeInternalSocketTemplate output_template(int index)
	{
		// not implemented
		return NodeInternalSocketTemplate();
	}

};

/**************** Switch ****************/

/**
 * 
 */
class CompositorNodeSwitch : public CompositorNode {
public:
	CompositorNodeSwitch(PyObject* pyobj) : CompositorNode(pyobj) {}

	CompositorNodeSwitch() : CompositorNode(0)
	{
		// not implemented
	}

	/** Getter: Off: first socket, On: second socket */
	bool check() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "check")) == 1;
	}

	/** Setter: Off: first socket, On: second socket */
	void check(bool value) {
		PyObject_SetAttrString(pyobjref, "check", Py_BuildValue("i", value));
	}

	/**
	 * True if a registered node type
	 * @return 
	 */
	bool is_registered_node_type()
	{
		// not implemented
		return true;
	}

	/**
	 * Input socket template
	 * @param Param 'index'
	 * @return 
	 */
	NodeInternalSocketTemplate input_template(int index)
	{
		// not implemented
		return NodeInternalSocketTemplate();
	}

	/**
	 * Output socket template
	 * @param Param 'index'
	 * @return 
	 */
	NodeInternalSocketTemplate output_template(int index)
	{
		// not implemented
		return NodeInternalSocketTemplate();
	}

};

/**************** View Switch ****************/

/**
 * 
 */
class CompositorNodeSwitchView : public CompositorNode {
public:
	CompositorNodeSwitchView(PyObject* pyobj) : CompositorNode(pyobj) {}

	CompositorNodeSwitchView() : CompositorNode(0)
	{
		// not implemented
	}

	/** Getter: Off: first socket, On: second socket */
	bool check() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "check")) == 1;
	}

	/** Setter: Off: first socket, On: second socket */
	void check(bool value) {
		PyObject_SetAttrString(pyobjref, "check", Py_BuildValue("i", value));
	}

	/**
	 * True if a registered node type
	 * @return 
	 */
	bool is_registered_node_type()
	{
		// not implemented
		return true;
	}

	/**
	 * Input socket template
	 * @param Param 'index'
	 * @return 
	 */
	NodeInternalSocketTemplate input_template(int index)
	{
		// not implemented
		return NodeInternalSocketTemplate();
	}

	/**
	 * Output socket template
	 * @param Param 'index'
	 * @return 
	 */
	NodeInternalSocketTemplate output_template(int index)
	{
		// not implemented
		return NodeInternalSocketTemplate();
	}

};

/**************** Color Correction ****************/

/**
 * 
 */
class CompositorNodeColorCorrection : public CompositorNode {
public:
	CompositorNodeColorCorrection(PyObject* pyobj) : CompositorNode(pyobj) {}

	CompositorNodeColorCorrection() : CompositorNode(0)
	{
		// not implemented
	}

	/** Getter: Red channel active */
	bool red() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "red")) == 1;
	}

	/** Setter: Red channel active */
	void red(bool value) {
		PyObject_SetAttrString(pyobjref, "red", Py_BuildValue("i", value));
	}

	/** Getter: Green channel active */
	bool green() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "green")) == 1;
	}

	/** Setter: Green channel active */
	void green(bool value) {
		PyObject_SetAttrString(pyobjref, "green", Py_BuildValue("i", value));
	}

	/** Getter: Blue channel active */
	bool blue() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "blue")) == 1;
	}

	/** Setter: Blue channel active */
	void blue(bool value) {
		PyObject_SetAttrString(pyobjref, "blue", Py_BuildValue("i", value));
	}

	/** Getter: Start of midtones */
	float midtones_start() { /* not implemented */ throw NULL; }
	/** Setter: Start of midtones */
	void midtones_start(float value) {
		PyObject_SetAttrString(pyobjref, "midtones_start", Py_BuildValue("f", value));
	}

	/** Getter: End of midtones */
	float midtones_end() { /* not implemented */ throw NULL; }
	/** Setter: End of midtones */
	void midtones_end(float value) {
		PyObject_SetAttrString(pyobjref, "midtones_end", Py_BuildValue("f", value));
	}

	/** Getter: Master saturation */
	float master_saturation() { /* not implemented */ throw NULL; }
	/** Setter: Master saturation */
	void master_saturation(float value) {
		PyObject_SetAttrString(pyobjref, "master_saturation", Py_BuildValue("f", value));
	}

	/** Getter: Master contrast */
	float master_contrast() { /* not implemented */ throw NULL; }
	/** Setter: Master contrast */
	void master_contrast(float value) {
		PyObject_SetAttrString(pyobjref, "master_contrast", Py_BuildValue("f", value));
	}

	/** Getter: Master gamma */
	float master_gamma() { /* not implemented */ throw NULL; }
	/** Setter: Master gamma */
	void master_gamma(float value) {
		PyObject_SetAttrString(pyobjref, "master_gamma", Py_BuildValue("f", value));
	}

	/** Getter: Master gain */
	float master_gain() { /* not implemented */ throw NULL; }
	/** Setter: Master gain */
	void master_gain(float value) {
		PyObject_SetAttrString(pyobjref, "master_gain", Py_BuildValue("f", value));
	}

	/** Getter: Master lift */
	float master_lift() { /* not implemented */ throw NULL; }
	/** Setter: Master lift */
	void master_lift(float value) {
		PyObject_SetAttrString(pyobjref, "master_lift", Py_BuildValue("f", value));
	}

	/** Getter: Shadows saturation */
	float shadows_saturation() { /* not implemented */ throw NULL; }
	/** Setter: Shadows saturation */
	void shadows_saturation(float value) {
		PyObject_SetAttrString(pyobjref, "shadows_saturation", Py_BuildValue("f", value));
	}

	/** Getter: Shadows contrast */
	float shadows_contrast() { /* not implemented */ throw NULL; }
	/** Setter: Shadows contrast */
	void shadows_contrast(float value) {
		PyObject_SetAttrString(pyobjref, "shadows_contrast", Py_BuildValue("f", value));
	}

	/** Getter: Shadows gamma */
	float shadows_gamma() { /* not implemented */ throw NULL; }
	/** Setter: Shadows gamma */
	void shadows_gamma(float value) {
		PyObject_SetAttrString(pyobjref, "shadows_gamma", Py_BuildValue("f", value));
	}

	/** Getter: Shadows gain */
	float shadows_gain() { /* not implemented */ throw NULL; }
	/** Setter: Shadows gain */
	void shadows_gain(float value) {
		PyObject_SetAttrString(pyobjref, "shadows_gain", Py_BuildValue("f", value));
	}

	/** Getter: Shadows lift */
	float shadows_lift() { /* not implemented */ throw NULL; }
	/** Setter: Shadows lift */
	void shadows_lift(float value) {
		PyObject_SetAttrString(pyobjref, "shadows_lift", Py_BuildValue("f", value));
	}

	/** Getter: Midtones saturation */
	float midtones_saturation() { /* not implemented */ throw NULL; }
	/** Setter: Midtones saturation */
	void midtones_saturation(float value) {
		PyObject_SetAttrString(pyobjref, "midtones_saturation", Py_BuildValue("f", value));
	}

	/** Getter: Midtones contrast */
	float midtones_contrast() { /* not implemented */ throw NULL; }
	/** Setter: Midtones contrast */
	void midtones_contrast(float value) {
		PyObject_SetAttrString(pyobjref, "midtones_contrast", Py_BuildValue("f", value));
	}

	/** Getter: Midtones gamma */
	float midtones_gamma() { /* not implemented */ throw NULL; }
	/** Setter: Midtones gamma */
	void midtones_gamma(float value) {
		PyObject_SetAttrString(pyobjref, "midtones_gamma", Py_BuildValue("f", value));
	}

	/** Getter: Midtones gain */
	float midtones_gain() { /* not implemented */ throw NULL; }
	/** Setter: Midtones gain */
	void midtones_gain(float value) {
		PyObject_SetAttrString(pyobjref, "midtones_gain", Py_BuildValue("f", value));
	}

	/** Getter: Midtones lift */
	float midtones_lift() { /* not implemented */ throw NULL; }
	/** Setter: Midtones lift */
	void midtones_lift(float value) {
		PyObject_SetAttrString(pyobjref, "midtones_lift", Py_BuildValue("f", value));
	}

	/** Getter: Highlights saturation */
	float highlights_saturation() { /* not implemented */ throw NULL; }
	/** Setter: Highlights saturation */
	void highlights_saturation(float value) {
		PyObject_SetAttrString(pyobjref, "highlights_saturation", Py_BuildValue("f", value));
	}

	/** Getter: Highlights contrast */
	float highlights_contrast() { /* not implemented */ throw NULL; }
	/** Setter: Highlights contrast */
	void highlights_contrast(float value) {
		PyObject_SetAttrString(pyobjref, "highlights_contrast", Py_BuildValue("f", value));
	}

	/** Getter: Highlights gamma */
	float highlights_gamma() { /* not implemented */ throw NULL; }
	/** Setter: Highlights gamma */
	void highlights_gamma(float value) {
		PyObject_SetAttrString(pyobjref, "highlights_gamma", Py_BuildValue("f", value));
	}

	/** Getter: Highlights gain */
	float highlights_gain() { /* not implemented */ throw NULL; }
	/** Setter: Highlights gain */
	void highlights_gain(float value) {
		PyObject_SetAttrString(pyobjref, "highlights_gain", Py_BuildValue("f", value));
	}

	/** Getter: Highlights lift */
	float highlights_lift() { /* not implemented */ throw NULL; }
	/** Setter: Highlights lift */
	void highlights_lift(float value) {
		PyObject_SetAttrString(pyobjref, "highlights_lift", Py_BuildValue("f", value));
	}

	/**
	 * True if a registered node type
	 * @return 
	 */
	bool is_registered_node_type()
	{
		// not implemented
		return true;
	}

	/**
	 * Input socket template
	 * @param Param 'index'
	 * @return 
	 */
	NodeInternalSocketTemplate input_template(int index)
	{
		// not implemented
		return NodeInternalSocketTemplate();
	}

	/**
	 * Output socket template
	 * @param Param 'index'
	 * @return 
	 */
	NodeInternalSocketTemplate output_template(int index)
	{
		// not implemented
		return NodeInternalSocketTemplate();
	}

};

/**************** Mask ****************/

/**
 * 
 */
class CompositorNodeMask : public CompositorNode {
public:
	CompositorNodeMask(PyObject* pyobj) : CompositorNode(pyobj) {}

	CompositorNodeMask() : CompositorNode(0)
	{
		// not implemented
	}

	/** Getter:  */
	Mask mask();

	/** Getter: Apply an anti-aliasing filter to the mask */
	bool use_antialiasing() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_antialiasing")) == 1;
	}

	/** Setter: Apply an anti-aliasing filter to the mask */
	void use_antialiasing(bool value) {
		PyObject_SetAttrString(pyobjref, "use_antialiasing", Py_BuildValue("i", value));
	}

	/** Getter: Use feather information from the mask */
	bool use_feather() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_feather")) == 1;
	}

	/** Setter: Use feather information from the mask */
	void use_feather(bool value) {
		PyObject_SetAttrString(pyobjref, "use_feather", Py_BuildValue("i", value));
	}

	/** Getter: Use multi-sampled motion blur of the mask */
	bool use_motion_blur() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_motion_blur")) == 1;
	}

	/** Setter: Use multi-sampled motion blur of the mask */
	void use_motion_blur(bool value) {
		PyObject_SetAttrString(pyobjref, "use_motion_blur", Py_BuildValue("i", value));
	}

	/** Getter: Number of motion blur samples */
	int motion_blur_samples() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "motion_blur_samples"));
	}

	/** Setter: Number of motion blur samples */
	void motion_blur_samples(int value) {
		PyObject_SetAttrString(pyobjref, "motion_blur_samples", Py_BuildValue("i", value));
	}

	/** Getter: Exposure for motion blur as a factor of FPS */
	float motion_blur_shutter() { /* not implemented */ throw NULL; }
	/** Setter: Exposure for motion blur as a factor of FPS */
	void motion_blur_shutter(float value) {
		PyObject_SetAttrString(pyobjref, "motion_blur_shutter", Py_BuildValue("f", value));
	}

	enum size_source_enum {
		size_source_SCENE = 0,
		size_source_FIXED = 256,
		size_source_FIXED_SCENE = 512,
	};

	/** Getter: Where to get the mask size from for aspect/size information */
	size_source_enum size_source() { /* not implemented */ throw NULL; }
	/** Setter: Where to get the mask size from for aspect/size information */
	void size_source(size_source_enum value) { /* not implemented */ }

	/** Getter:  */
	int size_x() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "size_x"));
	}

	/** Setter:  */
	void size_x(int value) {
		PyObject_SetAttrString(pyobjref, "size_x", Py_BuildValue("i", value));
	}

	/** Getter:  */
	int size_y() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "size_y"));
	}

	/** Setter:  */
	void size_y(int value) {
		PyObject_SetAttrString(pyobjref, "size_y", Py_BuildValue("i", value));
	}

	/**
	 * True if a registered node type
	 * @return 
	 */
	bool is_registered_node_type()
	{
		// not implemented
		return true;
	}

	/**
	 * Input socket template
	 * @param Param 'index'
	 * @return 
	 */
	NodeInternalSocketTemplate input_template(int index)
	{
		// not implemented
		return NodeInternalSocketTemplate();
	}

	/**
	 * Output socket template
	 * @param Param 'index'
	 * @return 
	 */
	NodeInternalSocketTemplate output_template(int index)
	{
		// not implemented
		return NodeInternalSocketTemplate();
	}

};

/**************** Keying Screen ****************/

/**
 * 
 */
class CompositorNodeKeyingScreen : public CompositorNode {
public:
	CompositorNodeKeyingScreen(PyObject* pyobj) : CompositorNode(pyobj) {}

	CompositorNodeKeyingScreen() : CompositorNode(0)
	{
		// not implemented
	}

	/** Getter:  */
	MovieClip clip();

	/** Getter:  */
	std::string tracking_object() { /* not implemented */ throw NULL; }
	/** Setter:  */
	void tracking_object(const std::string& value) { /* not implemented */ }

	/**
	 * True if a registered node type
	 * @return 
	 */
	bool is_registered_node_type()
	{
		// not implemented
		return true;
	}

	/**
	 * Input socket template
	 * @param Param 'index'
	 * @return 
	 */
	NodeInternalSocketTemplate input_template(int index)
	{
		// not implemented
		return NodeInternalSocketTemplate();
	}

	/**
	 * Output socket template
	 * @param Param 'index'
	 * @return 
	 */
	NodeInternalSocketTemplate output_template(int index)
	{
		// not implemented
		return NodeInternalSocketTemplate();
	}

};

/**************** Keying ****************/

/**
 * 
 */
class CompositorNodeKeying : public CompositorNode {
public:
	CompositorNodeKeying(PyObject* pyobj) : CompositorNode(pyobj) {}

	CompositorNodeKeying() : CompositorNode(0)
	{
		// not implemented
	}

	/** Getter: Balance between two non-primary channels primary channel is comparing against */
	float screen_balance() { /* not implemented */ throw NULL; }
	/** Setter: Balance between two non-primary channels primary channel is comparing against */
	void screen_balance(float value) {
		PyObject_SetAttrString(pyobjref, "screen_balance", Py_BuildValue("f", value));
	}

	/** Getter: Factor of despilling screen color from image */
	float despill_factor() { /* not implemented */ throw NULL; }
	/** Setter: Factor of despilling screen color from image */
	void despill_factor(float value) {
		PyObject_SetAttrString(pyobjref, "despill_factor", Py_BuildValue("f", value));
	}

	/** Getter: Balance between non-key colors used to detect amount of key color to be removed */
	float despill_balance() { /* not implemented */ throw NULL; }
	/** Setter: Balance between non-key colors used to detect amount of key color to be removed */
	void despill_balance(float value) {
		PyObject_SetAttrString(pyobjref, "despill_balance", Py_BuildValue("f", value));
	}

	/** Getter: Value of non-scaled matte pixel which considers as fully background pixel */
	float clip_black() { /* not implemented */ throw NULL; }
	/** Setter: Value of non-scaled matte pixel which considers as fully background pixel */
	void clip_black(float value) {
		PyObject_SetAttrString(pyobjref, "clip_black", Py_BuildValue("f", value));
	}

	/** Getter: Value of non-scaled matte pixel which considers as fully foreground pixel */
	float clip_white() { /* not implemented */ throw NULL; }
	/** Setter: Value of non-scaled matte pixel which considers as fully foreground pixel */
	void clip_white(float value) {
		PyObject_SetAttrString(pyobjref, "clip_white", Py_BuildValue("f", value));
	}

	/** Getter: Chroma pre-blur size which applies before running keyer */
	int blur_pre() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "blur_pre"));
	}

	/** Setter: Chroma pre-blur size which applies before running keyer */
	void blur_pre(int value) {
		PyObject_SetAttrString(pyobjref, "blur_pre", Py_BuildValue("i", value));
	}

	/** Getter: Matte blur size which applies after clipping and dilate/eroding */
	int blur_post() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "blur_post"));
	}

	/** Setter: Matte blur size which applies after clipping and dilate/eroding */
	void blur_post(int value) {
		PyObject_SetAttrString(pyobjref, "blur_post", Py_BuildValue("i", value));
	}

	/** Getter: Matte dilate/erode side */
	int dilate_distance() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "dilate_distance"));
	}

	/** Setter: Matte dilate/erode side */
	void dilate_distance(int value) {
		PyObject_SetAttrString(pyobjref, "dilate_distance", Py_BuildValue("i", value));
	}

	/** Getter: Radius of kernel used to detect whether pixel belongs to edge */
	int edge_kernel_radius() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "edge_kernel_radius"));
	}

	/** Setter: Radius of kernel used to detect whether pixel belongs to edge */
	void edge_kernel_radius(int value) {
		PyObject_SetAttrString(pyobjref, "edge_kernel_radius", Py_BuildValue("i", value));
	}

	/** Getter: Tolerance to pixels inside kernel which are treating as belonging to the same plane */
	float edge_kernel_tolerance() { /* not implemented */ throw NULL; }
	/** Setter: Tolerance to pixels inside kernel which are treating as belonging to the same plane */
	void edge_kernel_tolerance(float value) {
		PyObject_SetAttrString(pyobjref, "edge_kernel_tolerance", Py_BuildValue("f", value));
	}

	enum feather_falloff_enum {
		feather_falloff_SMOOTH = 0,
		feather_falloff_SPHERE = 1,
		feather_falloff_ROOT = 2,
		feather_falloff_INVERSE_SQUARE = 7,
		feather_falloff_SHARP = 3,
		feather_falloff_LINEAR = 4,
	};

	/** Getter: Falloff type the feather */
	feather_falloff_enum feather_falloff() { /* not implemented */ throw NULL; }
	/** Setter: Falloff type the feather */
	void feather_falloff(feather_falloff_enum value) { /* not implemented */ }

	/** Getter: Distance to grow/shrink the feather */
	int feather_distance() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "feather_distance"));
	}

	/** Setter: Distance to grow/shrink the feather */
	void feather_distance(int value) {
		PyObject_SetAttrString(pyobjref, "feather_distance", Py_BuildValue("i", value));
	}

	/**
	 * True if a registered node type
	 * @return 
	 */
	bool is_registered_node_type()
	{
		// not implemented
		return true;
	}

	/**
	 * Input socket template
	 * @param Param 'index'
	 * @return 
	 */
	NodeInternalSocketTemplate input_template(int index)
	{
		// not implemented
		return NodeInternalSocketTemplate();
	}

	/**
	 * Output socket template
	 * @param Param 'index'
	 * @return 
	 */
	NodeInternalSocketTemplate output_template(int index)
	{
		// not implemented
		return NodeInternalSocketTemplate();
	}

};

/**************** Track Position ****************/

/**
 * 
 */
class CompositorNodeTrackPos : public CompositorNode {
public:
	CompositorNodeTrackPos(PyObject* pyobj) : CompositorNode(pyobj) {}

	CompositorNodeTrackPos() : CompositorNode(0)
	{
		// not implemented
	}

	/** Getter:  */
	MovieClip clip();

	enum position_enum {
		position_ABSOLUTE = 0,
		position_RELATIVE_START = 1,
		position_RELATIVE_FRAME = 2,
		position_ABSOLUTE_FRAME = 3,
	};

	/** Getter: Which marker position to use for output */
	position_enum position() { /* not implemented */ throw NULL; }
	/** Setter: Which marker position to use for output */
	void position(position_enum value) { /* not implemented */ }

	/** Getter: Frame to be used for relative position */
	int frame_relative() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "frame_relative"));
	}

	/** Setter: Frame to be used for relative position */
	void frame_relative(int value) {
		PyObject_SetAttrString(pyobjref, "frame_relative", Py_BuildValue("i", value));
	}

	/** Getter:  */
	std::string tracking_object() { /* not implemented */ throw NULL; }
	/** Setter:  */
	void tracking_object(const std::string& value) { /* not implemented */ }

	/** Getter:  */
	std::string track_name() { /* not implemented */ throw NULL; }
	/** Setter:  */
	void track_name(const std::string& value) { /* not implemented */ }

	/**
	 * True if a registered node type
	 * @return 
	 */
	bool is_registered_node_type()
	{
		// not implemented
		return true;
	}

	/**
	 * Input socket template
	 * @param Param 'index'
	 * @return 
	 */
	NodeInternalSocketTemplate input_template(int index)
	{
		// not implemented
		return NodeInternalSocketTemplate();
	}

	/**
	 * Output socket template
	 * @param Param 'index'
	 * @return 
	 */
	NodeInternalSocketTemplate output_template(int index)
	{
		// not implemented
		return NodeInternalSocketTemplate();
	}

};

/**************** Pixelate ****************/

/**
 * 
 */
class CompositorNodePixelate : public CompositorNode {
public:
	CompositorNodePixelate(PyObject* pyobj) : CompositorNode(pyobj) {}

	CompositorNodePixelate() : CompositorNode(0)
	{
		// not implemented
	}

	/**
	 * True if a registered node type
	 * @return 
	 */
	bool is_registered_node_type()
	{
		// not implemented
		return true;
	}

	/**
	 * Input socket template
	 * @param Param 'index'
	 * @return 
	 */
	NodeInternalSocketTemplate input_template(int index)
	{
		// not implemented
		return NodeInternalSocketTemplate();
	}

	/**
	 * Output socket template
	 * @param Param 'index'
	 * @return 
	 */
	NodeInternalSocketTemplate output_template(int index)
	{
		// not implemented
		return NodeInternalSocketTemplate();
	}

};

/**************** Plane Track Deform ****************/

/**
 * 
 */
class CompositorNodePlaneTrackDeform : public CompositorNode {
public:
	CompositorNodePlaneTrackDeform(PyObject* pyobj) : CompositorNode(pyobj) {}

	CompositorNodePlaneTrackDeform() : CompositorNode(0)
	{
		// not implemented
	}

	/** Getter:  */
	MovieClip clip();

	/** Getter:  */
	std::string tracking_object() { /* not implemented */ throw NULL; }
	/** Setter:  */
	void tracking_object(const std::string& value) { /* not implemented */ }

	/** Getter:  */
	std::string plane_track_name() { /* not implemented */ throw NULL; }
	/** Setter:  */
	void plane_track_name(const std::string& value) { /* not implemented */ }

	/** Getter: Use multi-sampled motion blur of the mask */
	bool use_motion_blur() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_motion_blur")) == 1;
	}

	/** Setter: Use multi-sampled motion blur of the mask */
	void use_motion_blur(bool value) {
		PyObject_SetAttrString(pyobjref, "use_motion_blur", Py_BuildValue("i", value));
	}

	/** Getter: Number of motion blur samples */
	int motion_blur_samples() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "motion_blur_samples"));
	}

	/** Setter: Number of motion blur samples */
	void motion_blur_samples(int value) {
		PyObject_SetAttrString(pyobjref, "motion_blur_samples", Py_BuildValue("i", value));
	}

	/** Getter: Exposure for motion blur as a factor of FPS */
	float motion_blur_shutter() { /* not implemented */ throw NULL; }
	/** Setter: Exposure for motion blur as a factor of FPS */
	void motion_blur_shutter(float value) {
		PyObject_SetAttrString(pyobjref, "motion_blur_shutter", Py_BuildValue("f", value));
	}

	/**
	 * True if a registered node type
	 * @return 
	 */
	bool is_registered_node_type()
	{
		// not implemented
		return true;
	}

	/**
	 * Input socket template
	 * @param Param 'index'
	 * @return 
	 */
	NodeInternalSocketTemplate input_template(int index)
	{
		// not implemented
		return NodeInternalSocketTemplate();
	}

	/**
	 * Output socket template
	 * @param Param 'index'
	 * @return 
	 */
	NodeInternalSocketTemplate output_template(int index)
	{
		// not implemented
		return NodeInternalSocketTemplate();
	}

};

/**************** Corner Pin ****************/

/**
 * 
 */
class CompositorNodeCornerPin : public CompositorNode {
public:
	CompositorNodeCornerPin(PyObject* pyobj) : CompositorNode(pyobj) {}

	CompositorNodeCornerPin() : CompositorNode(0)
	{
		// not implemented
	}

	/**
	 * True if a registered node type
	 * @return 
	 */
	bool is_registered_node_type()
	{
		// not implemented
		return true;
	}

	/**
	 * Input socket template
	 * @param Param 'index'
	 * @return 
	 */
	NodeInternalSocketTemplate input_template(int index)
	{
		// not implemented
		return NodeInternalSocketTemplate();
	}

	/**
	 * Output socket template
	 * @param Param 'index'
	 * @return 
	 */
	NodeInternalSocketTemplate output_template(int index)
	{
		// not implemented
		return NodeInternalSocketTemplate();
	}

};

/**************** Sun Beams ****************/

/**
 * 
 */
class CompositorNodeSunBeams : public CompositorNode {
public:
	CompositorNodeSunBeams(PyObject* pyobj) : CompositorNode(pyobj) {}

	CompositorNodeSunBeams() : CompositorNode(0)
	{
		// not implemented
	}

	/** Getter: Source point of rays as a factor of the image width & height */
	std::array<float, 2> source() {
		// TODO: MISSING DEREF! USE #DEFINE!
		PyObject *seqval = PyObject_GetAttrString(pyobjref, "source");
		std::array<float, 2> resarr;
		for (int i = 0; i < 2; i++)
			resarr[i] = (float)PyFloat_AsDouble(PySequence_GetItem(seqval, i));
		return resarr;
	}

	/** Setter: Source point of rays as a factor of the image width & height */
	void source(float values[2]) { /* not implemented */ }

	/** Getter: Length of rays as a factor of the image size */
	float ray_length() { /* not implemented */ throw NULL; }
	/** Setter: Length of rays as a factor of the image size */
	void ray_length(float value) {
		PyObject_SetAttrString(pyobjref, "ray_length", Py_BuildValue("f", value));
	}

	/**
	 * True if a registered node type
	 * @return 
	 */
	bool is_registered_node_type()
	{
		// not implemented
		return true;
	}

	/**
	 * Input socket template
	 * @param Param 'index'
	 * @return 
	 */
	NodeInternalSocketTemplate input_template(int index)
	{
		// not implemented
		return NodeInternalSocketTemplate();
	}

	/**
	 * Output socket template
	 * @param Param 'index'
	 * @return 
	 */
	NodeInternalSocketTemplate output_template(int index)
	{
		// not implemented
		return NodeInternalSocketTemplate();
	}

};

/**************** Output ****************/

/**
 * 
 */
class TextureNodeOutput : public TextureNode {
public:
	TextureNodeOutput(PyObject* pyobj) : TextureNode(pyobj) {}

	TextureNodeOutput() : TextureNode(0)
	{
		// not implemented
	}

	/** Getter:  */
	std::string filepath() { /* not implemented */ throw NULL; }
	/** Setter:  */
	void filepath(const std::string& value) { /* not implemented */ }

	/**
	 * True if a registered node type
	 * @return 
	 */
	bool is_registered_node_type()
	{
		// not implemented
		return true;
	}

	/**
	 * Input socket template
	 * @param Param 'index'
	 * @return 
	 */
	NodeInternalSocketTemplate input_template(int index)
	{
		// not implemented
		return NodeInternalSocketTemplate();
	}

	/**
	 * Output socket template
	 * @param Param 'index'
	 * @return 
	 */
	NodeInternalSocketTemplate output_template(int index)
	{
		// not implemented
		return NodeInternalSocketTemplate();
	}

};

/**************** Checker ****************/

/**
 * 
 */
class TextureNodeChecker : public TextureNode {
public:
	TextureNodeChecker(PyObject* pyobj) : TextureNode(pyobj) {}

	TextureNodeChecker() : TextureNode(0)
	{
		// not implemented
	}

	/**
	 * True if a registered node type
	 * @return 
	 */
	bool is_registered_node_type()
	{
		// not implemented
		return true;
	}

	/**
	 * Input socket template
	 * @param Param 'index'
	 * @return 
	 */
	NodeInternalSocketTemplate input_template(int index)
	{
		// not implemented
		return NodeInternalSocketTemplate();
	}

	/**
	 * Output socket template
	 * @param Param 'index'
	 * @return 
	 */
	NodeInternalSocketTemplate output_template(int index)
	{
		// not implemented
		return NodeInternalSocketTemplate();
	}

};

/**************** Texture ****************/

/**
 * 
 */
class TextureNodeTexture : public TextureNode {
public:
	TextureNodeTexture(PyObject* pyobj) : TextureNode(pyobj) {}

	TextureNodeTexture() : TextureNode(0)
	{
		// not implemented
	}

	/** Getter:  */
	Texture texture() {
		/* not implemented */ throw NULL;
	}

	/** Getter: For node-based textures, which output node to use */
	int node_output() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "node_output"));
	}

	/** Setter: For node-based textures, which output node to use */
	void node_output(int value) {
		PyObject_SetAttrString(pyobjref, "node_output", Py_BuildValue("i", value));
	}

	/**
	 * True if a registered node type
	 * @return 
	 */
	bool is_registered_node_type()
	{
		// not implemented
		return true;
	}

	/**
	 * Input socket template
	 * @param Param 'index'
	 * @return 
	 */
	NodeInternalSocketTemplate input_template(int index)
	{
		// not implemented
		return NodeInternalSocketTemplate();
	}

	/**
	 * Output socket template
	 * @param Param 'index'
	 * @return 
	 */
	NodeInternalSocketTemplate output_template(int index)
	{
		// not implemented
		return NodeInternalSocketTemplate();
	}

};

/**************** Bricks ****************/

/**
 * 
 */
class TextureNodeBricks : public TextureNode {
public:
	TextureNodeBricks(PyObject* pyobj) : TextureNode(pyobj) {}

	TextureNodeBricks() : TextureNode(0)
	{
		// not implemented
	}

	/** Getter:  */
	float offset() { /* not implemented */ throw NULL; }
	/** Setter:  */
	void offset(float value) {
		PyObject_SetAttrString(pyobjref, "offset", Py_BuildValue("f", value));
	}

	/** Getter: Offset every N rows */
	int offset_frequency() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "offset_frequency"));
	}

	/** Setter: Offset every N rows */
	void offset_frequency(int value) {
		PyObject_SetAttrString(pyobjref, "offset_frequency", Py_BuildValue("i", value));
	}

	/** Getter:  */
	float squash() { /* not implemented */ throw NULL; }
	/** Setter:  */
	void squash(float value) {
		PyObject_SetAttrString(pyobjref, "squash", Py_BuildValue("f", value));
	}

	/** Getter: Squash every N rows */
	int squash_frequency() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "squash_frequency"));
	}

	/** Setter: Squash every N rows */
	void squash_frequency(int value) {
		PyObject_SetAttrString(pyobjref, "squash_frequency", Py_BuildValue("i", value));
	}

	/**
	 * True if a registered node type
	 * @return 
	 */
	bool is_registered_node_type()
	{
		// not implemented
		return true;
	}

	/**
	 * Input socket template
	 * @param Param 'index'
	 * @return 
	 */
	NodeInternalSocketTemplate input_template(int index)
	{
		// not implemented
		return NodeInternalSocketTemplate();
	}

	/**
	 * Output socket template
	 * @param Param 'index'
	 * @return 
	 */
	NodeInternalSocketTemplate output_template(int index)
	{
		// not implemented
		return NodeInternalSocketTemplate();
	}

};

/**************** Math ****************/

/**
 * 
 */
class TextureNodeMath : public TextureNode {
public:
	TextureNodeMath(PyObject* pyobj) : TextureNode(pyobj) {}

	TextureNodeMath() : TextureNode(0)
	{
		// not implemented
	}

	enum operation_enum {
		operation_ADD = 0,
		operation_SUBTRACT = 1,
		operation_MULTIPLY = 2,
		operation_DIVIDE = 3,
		operation_SINE = 4,
		operation_COSINE = 5,
		operation_TANGENT = 6,
		operation_ARCSINE = 7,
		operation_ARCCOSINE = 8,
		operation_ARCTANGENT = 9,
		operation_POWER = 10,
		operation_LOGARITHM = 11,
		operation_MINIMUM = 12,
		operation_MAXIMUM = 13,
		operation_ROUND = 14,
		operation_LESS_THAN = 15,
		operation_GREATER_THAN = 16,
		operation_MODULO = 17,
		operation_ABSOLUTE = 18,
	};

	/** Getter:  */
	operation_enum operation() { /* not implemented */ throw NULL; }
	/** Setter:  */
	void operation(operation_enum value) { /* not implemented */ }

	/** Getter: Clamp result of the node to 0..1 range */
	bool use_clamp() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_clamp")) == 1;
	}

	/** Setter: Clamp result of the node to 0..1 range */
	void use_clamp(bool value) {
		PyObject_SetAttrString(pyobjref, "use_clamp", Py_BuildValue("i", value));
	}

	/**
	 * True if a registered node type
	 * @return 
	 */
	bool is_registered_node_type()
	{
		// not implemented
		return true;
	}

	/**
	 * Input socket template
	 * @param Param 'index'
	 * @return 
	 */
	NodeInternalSocketTemplate input_template(int index)
	{
		// not implemented
		return NodeInternalSocketTemplate();
	}

	/**
	 * Output socket template
	 * @param Param 'index'
	 * @return 
	 */
	NodeInternalSocketTemplate output_template(int index)
	{
		// not implemented
		return NodeInternalSocketTemplate();
	}

};

/**************** Mix RGB ****************/

/**
 * 
 */
class TextureNodeMixRGB : public TextureNode {
public:
	TextureNodeMixRGB(PyObject* pyobj) : TextureNode(pyobj) {}

	TextureNodeMixRGB() : TextureNode(0)
	{
		// not implemented
	}

	enum blend_type_enum {
		blend_type_MIX = 0,
		blend_type_ADD = 1,
		blend_type_MULTIPLY = 2,
		blend_type_SUBTRACT = 3,
		blend_type_SCREEN = 4,
		blend_type_DIVIDE = 5,
		blend_type_DIFFERENCE = 6,
		blend_type_DARKEN = 7,
		blend_type_LIGHTEN = 8,
		blend_type_OVERLAY = 9,
		blend_type_DODGE = 10,
		blend_type_BURN = 11,
		blend_type_HUE = 12,
		blend_type_SATURATION = 13,
		blend_type_VALUE = 14,
		blend_type_COLOR = 15,
		blend_type_SOFT_LIGHT = 16,
		blend_type_LINEAR_LIGHT = 17,
	};

	/** Getter:  */
	blend_type_enum blend_type() { /* not implemented */ throw NULL; }
	/** Setter:  */
	void blend_type(blend_type_enum value) { /* not implemented */ }

	/** Getter: Include alpha of second input in this operation */
	bool use_alpha() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_alpha")) == 1;
	}

	/** Setter: Include alpha of second input in this operation */
	void use_alpha(bool value) {
		PyObject_SetAttrString(pyobjref, "use_alpha", Py_BuildValue("i", value));
	}

	/** Getter: Clamp result of the node to 0..1 range */
	bool use_clamp() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_clamp")) == 1;
	}

	/** Setter: Clamp result of the node to 0..1 range */
	void use_clamp(bool value) {
		PyObject_SetAttrString(pyobjref, "use_clamp", Py_BuildValue("i", value));
	}

	/**
	 * True if a registered node type
	 * @return 
	 */
	bool is_registered_node_type()
	{
		// not implemented
		return true;
	}

	/**
	 * Input socket template
	 * @param Param 'index'
	 * @return 
	 */
	NodeInternalSocketTemplate input_template(int index)
	{
		// not implemented
		return NodeInternalSocketTemplate();
	}

	/**
	 * Output socket template
	 * @param Param 'index'
	 * @return 
	 */
	NodeInternalSocketTemplate output_template(int index)
	{
		// not implemented
		return NodeInternalSocketTemplate();
	}

};

/**************** RGB to BW ****************/

/**
 * 
 */
class TextureNodeRGBToBW : public TextureNode {
public:
	TextureNodeRGBToBW(PyObject* pyobj) : TextureNode(pyobj) {}

	TextureNodeRGBToBW() : TextureNode(0)
	{
		// not implemented
	}

	/**
	 * True if a registered node type
	 * @return 
	 */
	bool is_registered_node_type()
	{
		// not implemented
		return true;
	}

	/**
	 * Input socket template
	 * @param Param 'index'
	 * @return 
	 */
	NodeInternalSocketTemplate input_template(int index)
	{
		// not implemented
		return NodeInternalSocketTemplate();
	}

	/**
	 * Output socket template
	 * @param Param 'index'
	 * @return 
	 */
	NodeInternalSocketTemplate output_template(int index)
	{
		// not implemented
		return NodeInternalSocketTemplate();
	}

};

/**************** ColorRamp ****************/

/**
 * 
 */
class TextureNodeValToRGB : public TextureNode {
public:
	TextureNodeValToRGB(PyObject* pyobj) : TextureNode(pyobj) {}

	TextureNodeValToRGB() : TextureNode(0)
	{
		// not implemented
	}

	/** Getter:  */
	ColorRamp color_ramp() {
		/* not implemented */ throw NULL;
	}

	/**
	 * True if a registered node type
	 * @return 
	 */
	bool is_registered_node_type()
	{
		// not implemented
		return true;
	}

	/**
	 * Input socket template
	 * @param Param 'index'
	 * @return 
	 */
	NodeInternalSocketTemplate input_template(int index)
	{
		// not implemented
		return NodeInternalSocketTemplate();
	}

	/**
	 * Output socket template
	 * @param Param 'index'
	 * @return 
	 */
	NodeInternalSocketTemplate output_template(int index)
	{
		// not implemented
		return NodeInternalSocketTemplate();
	}

};

/**************** Image ****************/

/**
 * 
 */
class TextureNodeImage : public TextureNode {
public:
	TextureNodeImage(PyObject* pyobj) : TextureNode(pyobj) {}

	TextureNodeImage() : TextureNode(0)
	{
		// not implemented
	}

	/** Getter:  */
	Image image() {
		/* not implemented */ throw NULL;
	}

	/**
	 * True if a registered node type
	 * @return 
	 */
	bool is_registered_node_type()
	{
		// not implemented
		return true;
	}

	/**
	 * Input socket template
	 * @param Param 'index'
	 * @return 
	 */
	NodeInternalSocketTemplate input_template(int index)
	{
		// not implemented
		return NodeInternalSocketTemplate();
	}

	/**
	 * Output socket template
	 * @param Param 'index'
	 * @return 
	 */
	NodeInternalSocketTemplate output_template(int index)
	{
		// not implemented
		return NodeInternalSocketTemplate();
	}

};

/**************** RGB Curves ****************/

/**
 * 
 */
class TextureNodeCurveRGB : public TextureNode {
public:
	TextureNodeCurveRGB(PyObject* pyobj) : TextureNode(pyobj) {}

	TextureNodeCurveRGB() : TextureNode(0)
	{
		// not implemented
	}

	/** Getter:  */
	CurveMapping mapping() {
		/* not implemented */ throw NULL;
	}

	/**
	 * True if a registered node type
	 * @return 
	 */
	bool is_registered_node_type()
	{
		// not implemented
		return true;
	}

	/**
	 * Input socket template
	 * @param Param 'index'
	 * @return 
	 */
	NodeInternalSocketTemplate input_template(int index)
	{
		// not implemented
		return NodeInternalSocketTemplate();
	}

	/**
	 * Output socket template
	 * @param Param 'index'
	 * @return 
	 */
	NodeInternalSocketTemplate output_template(int index)
	{
		// not implemented
		return NodeInternalSocketTemplate();
	}

};

/**************** Invert ****************/

/**
 * 
 */
class TextureNodeInvert : public TextureNode {
public:
	TextureNodeInvert(PyObject* pyobj) : TextureNode(pyobj) {}

	TextureNodeInvert() : TextureNode(0)
	{
		// not implemented
	}

	/**
	 * True if a registered node type
	 * @return 
	 */
	bool is_registered_node_type()
	{
		// not implemented
		return true;
	}

	/**
	 * Input socket template
	 * @param Param 'index'
	 * @return 
	 */
	NodeInternalSocketTemplate input_template(int index)
	{
		// not implemented
		return NodeInternalSocketTemplate();
	}

	/**
	 * Output socket template
	 * @param Param 'index'
	 * @return 
	 */
	NodeInternalSocketTemplate output_template(int index)
	{
		// not implemented
		return NodeInternalSocketTemplate();
	}

};

/**************** Hue/Saturation ****************/

/**
 * 
 */
class TextureNodeHueSaturation : public TextureNode {
public:
	TextureNodeHueSaturation(PyObject* pyobj) : TextureNode(pyobj) {}

	TextureNodeHueSaturation() : TextureNode(0)
	{
		// not implemented
	}

	/**
	 * True if a registered node type
	 * @return 
	 */
	bool is_registered_node_type()
	{
		// not implemented
		return true;
	}

	/**
	 * Input socket template
	 * @param Param 'index'
	 * @return 
	 */
	NodeInternalSocketTemplate input_template(int index)
	{
		// not implemented
		return NodeInternalSocketTemplate();
	}

	/**
	 * Output socket template
	 * @param Param 'index'
	 * @return 
	 */
	NodeInternalSocketTemplate output_template(int index)
	{
		// not implemented
		return NodeInternalSocketTemplate();
	}

};

/**************** Curve Time ****************/

/**
 * 
 */
class TextureNodeCurveTime : public TextureNode {
public:
	TextureNodeCurveTime(PyObject* pyobj) : TextureNode(pyobj) {}

	TextureNodeCurveTime() : TextureNode(0)
	{
		// not implemented
	}

	/** Getter:  */
	CurveMapping curve() {
		/* not implemented */ throw NULL;
	}

	/** Getter:  */
	int frame_start() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "frame_start"));
	}

	/** Setter:  */
	void frame_start(int value) {
		PyObject_SetAttrString(pyobjref, "frame_start", Py_BuildValue("i", value));
	}

	/** Getter:  */
	int frame_end() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "frame_end"));
	}

	/** Setter:  */
	void frame_end(int value) {
		PyObject_SetAttrString(pyobjref, "frame_end", Py_BuildValue("i", value));
	}

	/**
	 * True if a registered node type
	 * @return 
	 */
	bool is_registered_node_type()
	{
		// not implemented
		return true;
	}

	/**
	 * Input socket template
	 * @param Param 'index'
	 * @return 
	 */
	NodeInternalSocketTemplate input_template(int index)
	{
		// not implemented
		return NodeInternalSocketTemplate();
	}

	/**
	 * Output socket template
	 * @param Param 'index'
	 * @return 
	 */
	NodeInternalSocketTemplate output_template(int index)
	{
		// not implemented
		return NodeInternalSocketTemplate();
	}

};

/**************** Rotate ****************/

/**
 * 
 */
class TextureNodeRotate : public TextureNode {
public:
	TextureNodeRotate(PyObject* pyobj) : TextureNode(pyobj) {}

	TextureNodeRotate() : TextureNode(0)
	{
		// not implemented
	}

	/**
	 * True if a registered node type
	 * @return 
	 */
	bool is_registered_node_type()
	{
		// not implemented
		return true;
	}

	/**
	 * Input socket template
	 * @param Param 'index'
	 * @return 
	 */
	NodeInternalSocketTemplate input_template(int index)
	{
		// not implemented
		return NodeInternalSocketTemplate();
	}

	/**
	 * Output socket template
	 * @param Param 'index'
	 * @return 
	 */
	NodeInternalSocketTemplate output_template(int index)
	{
		// not implemented
		return NodeInternalSocketTemplate();
	}

};

/**************** Viewer ****************/

/**
 * 
 */
class TextureNodeViewer : public TextureNode {
public:
	TextureNodeViewer(PyObject* pyobj) : TextureNode(pyobj) {}

	TextureNodeViewer() : TextureNode(0)
	{
		// not implemented
	}

	/**
	 * True if a registered node type
	 * @return 
	 */
	bool is_registered_node_type()
	{
		// not implemented
		return true;
	}

	/**
	 * Input socket template
	 * @param Param 'index'
	 * @return 
	 */
	NodeInternalSocketTemplate input_template(int index)
	{
		// not implemented
		return NodeInternalSocketTemplate();
	}

	/**
	 * Output socket template
	 * @param Param 'index'
	 * @return 
	 */
	NodeInternalSocketTemplate output_template(int index)
	{
		// not implemented
		return NodeInternalSocketTemplate();
	}

};

/**************** Translate ****************/

/**
 * 
 */
class TextureNodeTranslate : public TextureNode {
public:
	TextureNodeTranslate(PyObject* pyobj) : TextureNode(pyobj) {}

	TextureNodeTranslate() : TextureNode(0)
	{
		// not implemented
	}

	/**
	 * True if a registered node type
	 * @return 
	 */
	bool is_registered_node_type()
	{
		// not implemented
		return true;
	}

	/**
	 * Input socket template
	 * @param Param 'index'
	 * @return 
	 */
	NodeInternalSocketTemplate input_template(int index)
	{
		// not implemented
		return NodeInternalSocketTemplate();
	}

	/**
	 * Output socket template
	 * @param Param 'index'
	 * @return 
	 */
	NodeInternalSocketTemplate output_template(int index)
	{
		// not implemented
		return NodeInternalSocketTemplate();
	}

};

/**************** Coordinates ****************/

/**
 * 
 */
class TextureNodeCoordinates : public TextureNode {
public:
	TextureNodeCoordinates(PyObject* pyobj) : TextureNode(pyobj) {}

	TextureNodeCoordinates() : TextureNode(0)
	{
		// not implemented
	}

	/**
	 * True if a registered node type
	 * @return 
	 */
	bool is_registered_node_type()
	{
		// not implemented
		return true;
	}

	/**
	 * Input socket template
	 * @param Param 'index'
	 * @return 
	 */
	NodeInternalSocketTemplate input_template(int index)
	{
		// not implemented
		return NodeInternalSocketTemplate();
	}

	/**
	 * Output socket template
	 * @param Param 'index'
	 * @return 
	 */
	NodeInternalSocketTemplate output_template(int index)
	{
		// not implemented
		return NodeInternalSocketTemplate();
	}

};

/**************** Distance ****************/

/**
 * 
 */
class TextureNodeDistance : public TextureNode {
public:
	TextureNodeDistance(PyObject* pyobj) : TextureNode(pyobj) {}

	TextureNodeDistance() : TextureNode(0)
	{
		// not implemented
	}

	/**
	 * True if a registered node type
	 * @return 
	 */
	bool is_registered_node_type()
	{
		// not implemented
		return true;
	}

	/**
	 * Input socket template
	 * @param Param 'index'
	 * @return 
	 */
	NodeInternalSocketTemplate input_template(int index)
	{
		// not implemented
		return NodeInternalSocketTemplate();
	}

	/**
	 * Output socket template
	 * @param Param 'index'
	 * @return 
	 */
	NodeInternalSocketTemplate output_template(int index)
	{
		// not implemented
		return NodeInternalSocketTemplate();
	}

};

/**************** Combine RGBA ****************/

/**
 * 
 */
class TextureNodeCompose : public TextureNode {
public:
	TextureNodeCompose(PyObject* pyobj) : TextureNode(pyobj) {}

	TextureNodeCompose() : TextureNode(0)
	{
		// not implemented
	}

	/**
	 * True if a registered node type
	 * @return 
	 */
	bool is_registered_node_type()
	{
		// not implemented
		return true;
	}

	/**
	 * Input socket template
	 * @param Param 'index'
	 * @return 
	 */
	NodeInternalSocketTemplate input_template(int index)
	{
		// not implemented
		return NodeInternalSocketTemplate();
	}

	/**
	 * Output socket template
	 * @param Param 'index'
	 * @return 
	 */
	NodeInternalSocketTemplate output_template(int index)
	{
		// not implemented
		return NodeInternalSocketTemplate();
	}

};

/**************** Separate RGBA ****************/

/**
 * 
 */
class TextureNodeDecompose : public TextureNode {
public:
	TextureNodeDecompose(PyObject* pyobj) : TextureNode(pyobj) {}

	TextureNodeDecompose() : TextureNode(0)
	{
		// not implemented
	}

	/**
	 * True if a registered node type
	 * @return 
	 */
	bool is_registered_node_type()
	{
		// not implemented
		return true;
	}

	/**
	 * Input socket template
	 * @param Param 'index'
	 * @return 
	 */
	NodeInternalSocketTemplate input_template(int index)
	{
		// not implemented
		return NodeInternalSocketTemplate();
	}

	/**
	 * Output socket template
	 * @param Param 'index'
	 * @return 
	 */
	NodeInternalSocketTemplate output_template(int index)
	{
		// not implemented
		return NodeInternalSocketTemplate();
	}

};

/**************** Value to Normal ****************/

/**
 * 
 */
class TextureNodeValToNor : public TextureNode {
public:
	TextureNodeValToNor(PyObject* pyobj) : TextureNode(pyobj) {}

	TextureNodeValToNor() : TextureNode(0)
	{
		// not implemented
	}

	/**
	 * True if a registered node type
	 * @return 
	 */
	bool is_registered_node_type()
	{
		// not implemented
		return true;
	}

	/**
	 * Input socket template
	 * @param Param 'index'
	 * @return 
	 */
	NodeInternalSocketTemplate input_template(int index)
	{
		// not implemented
		return NodeInternalSocketTemplate();
	}

	/**
	 * Output socket template
	 * @param Param 'index'
	 * @return 
	 */
	NodeInternalSocketTemplate output_template(int index)
	{
		// not implemented
		return NodeInternalSocketTemplate();
	}

};

/**************** Scale ****************/

/**
 * 
 */
class TextureNodeScale : public TextureNode {
public:
	TextureNodeScale(PyObject* pyobj) : TextureNode(pyobj) {}

	TextureNodeScale() : TextureNode(0)
	{
		// not implemented
	}

	/**
	 * True if a registered node type
	 * @return 
	 */
	bool is_registered_node_type()
	{
		// not implemented
		return true;
	}

	/**
	 * Input socket template
	 * @param Param 'index'
	 * @return 
	 */
	NodeInternalSocketTemplate input_template(int index)
	{
		// not implemented
		return NodeInternalSocketTemplate();
	}

	/**
	 * Output socket template
	 * @param Param 'index'
	 * @return 
	 */
	NodeInternalSocketTemplate output_template(int index)
	{
		// not implemented
		return NodeInternalSocketTemplate();
	}

};

/**************** At ****************/

/**
 * 
 */
class TextureNodeAt : public TextureNode {
public:
	TextureNodeAt(PyObject* pyobj) : TextureNode(pyobj) {}

	TextureNodeAt() : TextureNode(0)
	{
		// not implemented
	}

	/**
	 * True if a registered node type
	 * @return 
	 */
	bool is_registered_node_type()
	{
		// not implemented
		return true;
	}

	/**
	 * Input socket template
	 * @param Param 'index'
	 * @return 
	 */
	NodeInternalSocketTemplate input_template(int index)
	{
		// not implemented
		return NodeInternalSocketTemplate();
	}

	/**
	 * Output socket template
	 * @param Param 'index'
	 * @return 
	 */
	NodeInternalSocketTemplate output_template(int index)
	{
		// not implemented
		return NodeInternalSocketTemplate();
	}

};

/**************** Voronoi ****************/

/**
 * 
 */
class TextureNodeTexVoronoi : public TextureNode {
public:
	TextureNodeTexVoronoi(PyObject* pyobj) : TextureNode(pyobj) {}

	TextureNodeTexVoronoi() : TextureNode(0)
	{
		// not implemented
	}

	/**
	 * True if a registered node type
	 * @return 
	 */
	bool is_registered_node_type()
	{
		// not implemented
		return true;
	}

	/**
	 * Input socket template
	 * @param Param 'index'
	 * @return 
	 */
	NodeInternalSocketTemplate input_template(int index)
	{
		// not implemented
		return NodeInternalSocketTemplate();
	}

	/**
	 * Output socket template
	 * @param Param 'index'
	 * @return 
	 */
	NodeInternalSocketTemplate output_template(int index)
	{
		// not implemented
		return NodeInternalSocketTemplate();
	}

};

/**************** Blend ****************/

/**
 * 
 */
class TextureNodeTexBlend : public TextureNode {
public:
	TextureNodeTexBlend(PyObject* pyobj) : TextureNode(pyobj) {}

	TextureNodeTexBlend() : TextureNode(0)
	{
		// not implemented
	}

	/**
	 * True if a registered node type
	 * @return 
	 */
	bool is_registered_node_type()
	{
		// not implemented
		return true;
	}

	/**
	 * Input socket template
	 * @param Param 'index'
	 * @return 
	 */
	NodeInternalSocketTemplate input_template(int index)
	{
		// not implemented
		return NodeInternalSocketTemplate();
	}

	/**
	 * Output socket template
	 * @param Param 'index'
	 * @return 
	 */
	NodeInternalSocketTemplate output_template(int index)
	{
		// not implemented
		return NodeInternalSocketTemplate();
	}

};

/**************** Magic ****************/

/**
 * 
 */
class TextureNodeTexMagic : public TextureNode {
public:
	TextureNodeTexMagic(PyObject* pyobj) : TextureNode(pyobj) {}

	TextureNodeTexMagic() : TextureNode(0)
	{
		// not implemented
	}

	/**
	 * True if a registered node type
	 * @return 
	 */
	bool is_registered_node_type()
	{
		// not implemented
		return true;
	}

	/**
	 * Input socket template
	 * @param Param 'index'
	 * @return 
	 */
	NodeInternalSocketTemplate input_template(int index)
	{
		// not implemented
		return NodeInternalSocketTemplate();
	}

	/**
	 * Output socket template
	 * @param Param 'index'
	 * @return 
	 */
	NodeInternalSocketTemplate output_template(int index)
	{
		// not implemented
		return NodeInternalSocketTemplate();
	}

};

/**************** Marble ****************/

/**
 * 
 */
class TextureNodeTexMarble : public TextureNode {
public:
	TextureNodeTexMarble(PyObject* pyobj) : TextureNode(pyobj) {}

	TextureNodeTexMarble() : TextureNode(0)
	{
		// not implemented
	}

	/**
	 * True if a registered node type
	 * @return 
	 */
	bool is_registered_node_type()
	{
		// not implemented
		return true;
	}

	/**
	 * Input socket template
	 * @param Param 'index'
	 * @return 
	 */
	NodeInternalSocketTemplate input_template(int index)
	{
		// not implemented
		return NodeInternalSocketTemplate();
	}

	/**
	 * Output socket template
	 * @param Param 'index'
	 * @return 
	 */
	NodeInternalSocketTemplate output_template(int index)
	{
		// not implemented
		return NodeInternalSocketTemplate();
	}

};

/**************** Clouds ****************/

/**
 * 
 */
class TextureNodeTexClouds : public TextureNode {
public:
	TextureNodeTexClouds(PyObject* pyobj) : TextureNode(pyobj) {}

	TextureNodeTexClouds() : TextureNode(0)
	{
		// not implemented
	}

	/**
	 * True if a registered node type
	 * @return 
	 */
	bool is_registered_node_type()
	{
		// not implemented
		return true;
	}

	/**
	 * Input socket template
	 * @param Param 'index'
	 * @return 
	 */
	NodeInternalSocketTemplate input_template(int index)
	{
		// not implemented
		return NodeInternalSocketTemplate();
	}

	/**
	 * Output socket template
	 * @param Param 'index'
	 * @return 
	 */
	NodeInternalSocketTemplate output_template(int index)
	{
		// not implemented
		return NodeInternalSocketTemplate();
	}

};

/**************** Wood ****************/

/**
 * 
 */
class TextureNodeTexWood : public TextureNode {
public:
	TextureNodeTexWood(PyObject* pyobj) : TextureNode(pyobj) {}

	TextureNodeTexWood() : TextureNode(0)
	{
		// not implemented
	}

	/**
	 * True if a registered node type
	 * @return 
	 */
	bool is_registered_node_type()
	{
		// not implemented
		return true;
	}

	/**
	 * Input socket template
	 * @param Param 'index'
	 * @return 
	 */
	NodeInternalSocketTemplate input_template(int index)
	{
		// not implemented
		return NodeInternalSocketTemplate();
	}

	/**
	 * Output socket template
	 * @param Param 'index'
	 * @return 
	 */
	NodeInternalSocketTemplate output_template(int index)
	{
		// not implemented
		return NodeInternalSocketTemplate();
	}

};

/**************** Musgrave ****************/

/**
 * 
 */
class TextureNodeTexMusgrave : public TextureNode {
public:
	TextureNodeTexMusgrave(PyObject* pyobj) : TextureNode(pyobj) {}

	TextureNodeTexMusgrave() : TextureNode(0)
	{
		// not implemented
	}

	/**
	 * True if a registered node type
	 * @return 
	 */
	bool is_registered_node_type()
	{
		// not implemented
		return true;
	}

	/**
	 * Input socket template
	 * @param Param 'index'
	 * @return 
	 */
	NodeInternalSocketTemplate input_template(int index)
	{
		// not implemented
		return NodeInternalSocketTemplate();
	}

	/**
	 * Output socket template
	 * @param Param 'index'
	 * @return 
	 */
	NodeInternalSocketTemplate output_template(int index)
	{
		// not implemented
		return NodeInternalSocketTemplate();
	}

};

/**************** Noise ****************/

/**
 * 
 */
class TextureNodeTexNoise : public TextureNode {
public:
	TextureNodeTexNoise(PyObject* pyobj) : TextureNode(pyobj) {}

	TextureNodeTexNoise() : TextureNode(0)
	{
		// not implemented
	}

	/**
	 * True if a registered node type
	 * @return 
	 */
	bool is_registered_node_type()
	{
		// not implemented
		return true;
	}

	/**
	 * Input socket template
	 * @param Param 'index'
	 * @return 
	 */
	NodeInternalSocketTemplate input_template(int index)
	{
		// not implemented
		return NodeInternalSocketTemplate();
	}

	/**
	 * Output socket template
	 * @param Param 'index'
	 * @return 
	 */
	NodeInternalSocketTemplate output_template(int index)
	{
		// not implemented
		return NodeInternalSocketTemplate();
	}

};

/**************** Stucci ****************/

/**
 * 
 */
class TextureNodeTexStucci : public TextureNode {
public:
	TextureNodeTexStucci(PyObject* pyobj) : TextureNode(pyobj) {}

	TextureNodeTexStucci() : TextureNode(0)
	{
		// not implemented
	}

	/**
	 * True if a registered node type
	 * @return 
	 */
	bool is_registered_node_type()
	{
		// not implemented
		return true;
	}

	/**
	 * Input socket template
	 * @param Param 'index'
	 * @return 
	 */
	NodeInternalSocketTemplate input_template(int index)
	{
		// not implemented
		return NodeInternalSocketTemplate();
	}

	/**
	 * Output socket template
	 * @param Param 'index'
	 * @return 
	 */
	NodeInternalSocketTemplate output_template(int index)
	{
		// not implemented
		return NodeInternalSocketTemplate();
	}

};

/**************** Distorted Noise ****************/

/**
 * 
 */
class TextureNodeTexDistNoise : public TextureNode {
public:
	TextureNodeTexDistNoise(PyObject* pyobj) : TextureNode(pyobj) {}

	TextureNodeTexDistNoise() : TextureNode(0)
	{
		// not implemented
	}

	/**
	 * True if a registered node type
	 * @return 
	 */
	bool is_registered_node_type()
	{
		// not implemented
		return true;
	}

	/**
	 * Input socket template
	 * @param Param 'index'
	 * @return 
	 */
	NodeInternalSocketTemplate input_template(int index)
	{
		// not implemented
		return NodeInternalSocketTemplate();
	}

	/**
	 * Output socket template
	 * @param Param 'index'
	 * @return 
	 */
	NodeInternalSocketTemplate output_template(int index)
	{
		// not implemented
		return NodeInternalSocketTemplate();
	}

};

/**************** Group ****************/

/**
 * 
 */
class ShaderNodeGroup : public ShaderNode {
public:
	ShaderNodeGroup(PyObject* pyobj) : ShaderNode(pyobj) {}

	ShaderNodeGroup() : ShaderNode(0)
	{
		// not implemented
	}

	/** Getter:  */
	NodeTree node_tree() {
		/* not implemented */ throw NULL;
	}

	/** Getter: Interface socket data */
	PropertyGroup interface_value() {
		/* not implemented */ throw NULL;
	}

	/**
	 * True if a registered node type
	 * @return 
	 */
	bool is_registered_node_type()
	{
		// not implemented
		return true;
	}

	/**
	 * Input socket template
	 * @param Param 'index'
	 * @return 
	 */
	NodeInternalSocketTemplate input_template(int index)
	{
		// not implemented
		return NodeInternalSocketTemplate();
	}

	/**
	 * Output socket template
	 * @param Param 'index'
	 * @return 
	 */
	NodeInternalSocketTemplate output_template(int index)
	{
		// not implemented
		return NodeInternalSocketTemplate();
	}

};

/**************** Group ****************/

/**
 * 
 */
class CompositorNodeGroup : public CompositorNode {
public:
	CompositorNodeGroup(PyObject* pyobj) : CompositorNode(pyobj) {}

	CompositorNodeGroup() : CompositorNode(0)
	{
		// not implemented
	}

	/** Getter:  */
	NodeTree node_tree() {
		/* not implemented */ throw NULL;
	}

	/** Getter: Interface socket data */
	PropertyGroup interface_value() {
		/* not implemented */ throw NULL;
	}

	/**
	 * True if a registered node type
	 * @return 
	 */
	bool is_registered_node_type()
	{
		// not implemented
		return true;
	}

	/**
	 * Input socket template
	 * @param Param 'index'
	 * @return 
	 */
	NodeInternalSocketTemplate input_template(int index)
	{
		// not implemented
		return NodeInternalSocketTemplate();
	}

	/**
	 * Output socket template
	 * @param Param 'index'
	 * @return 
	 */
	NodeInternalSocketTemplate output_template(int index)
	{
		// not implemented
		return NodeInternalSocketTemplate();
	}

};

/**************** Group ****************/

/**
 * 
 */
class TextureNodeGroup : public TextureNode {
public:
	TextureNodeGroup(PyObject* pyobj) : TextureNode(pyobj) {}

	TextureNodeGroup() : TextureNode(0)
	{
		// not implemented
	}

	/** Getter:  */
	NodeTree node_tree() {
		/* not implemented */ throw NULL;
	}

	/** Getter: Interface socket data */
	PropertyGroup interface_value() {
		/* not implemented */ throw NULL;
	}

	/**
	 * True if a registered node type
	 * @return 
	 */
	bool is_registered_node_type()
	{
		// not implemented
		return true;
	}

	/**
	 * Input socket template
	 * @param Param 'index'
	 * @return 
	 */
	NodeInternalSocketTemplate input_template(int index)
	{
		// not implemented
		return NodeInternalSocketTemplate();
	}

	/**
	 * Output socket template
	 * @param Param 'index'
	 * @return 
	 */
	NodeInternalSocketTemplate output_template(int index)
	{
		// not implemented
		return NodeInternalSocketTemplate();
	}

};

/**************** Custom Group ****************/

/**
 * Base node type for custom registered node group types
 */
class NodeCustomGroup : public Node {
public:
	NodeCustomGroup(PyObject* pyobj) : Node(pyobj) {}

	NodeCustomGroup() : Node(0)
	{
		// not implemented
	}

	/** Getter:  */
	NodeTree node_tree() {
		/* not implemented */ throw NULL;
	}

	/** Getter: Interface socket data */
	PropertyGroup interface_value() {
		/* not implemented */ throw NULL;
	}

};

/**************** Output File Slot ****************/

/**
 * Single layer file slot of the file output node
 */
class NodeOutputFileSlotFile : public pyUniplug {
public:
	NodeOutputFileSlotFile(PyObject* pyobj) : pyUniplug(pyobj) {}

	NodeOutputFileSlotFile() : pyUniplug(0)
	{
		// not implemented
	}

	/** Getter:  */
	bool use_node_format() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_node_format")) == 1;
	}

	/** Setter:  */
	void use_node_format(bool value) {
		PyObject_SetAttrString(pyobjref, "use_node_format", Py_BuildValue("i", value));
	}

	/** Getter:  */
	ImageFormatSettings format();

	/** Getter: Subpath used for this slot */
	std::string path() { /* not implemented */ throw NULL; }
	/** Setter: Subpath used for this slot */
	void path(const std::string& value) { /* not implemented */ }

};

/**************** Output File Layer Slot ****************/

/**
 * Multilayer slot of the file output node
 */
class NodeOutputFileSlotLayer : public pyUniplug {
public:
	NodeOutputFileSlotLayer(PyObject* pyobj) : pyUniplug(pyobj) {}

	NodeOutputFileSlotLayer() : pyUniplug(0)
	{
		// not implemented
	}

	/** Getter: OpenEXR layer name used for this slot */
	std::string name() { /* not implemented */ throw NULL; }
	/** Setter: OpenEXR layer name used for this slot */
	void name(const std::string& value) { /* not implemented */ }

};

/**************** Node Instance Hash ****************/

/**
 * Hash table containing node instance data
 */
class NodeInstanceHash : public pyUniplug {
public:
	NodeInstanceHash(PyObject* pyobj) : pyUniplug(pyobj) {}

	NodeInstanceHash() : pyUniplug(0)
	{
		// not implemented
	}

};

/**************** Object ****************/

/**
 * Object datablock defining an object in a scene
 */
class Object : public ID {
public:
	Object(PyObject* pyobj) : ID(pyobj) {}

	Object() : ID(0)
	{
		// not implemented
	}

	/** Getter: Object data */
	ID data() {
		/* not implemented */ throw NULL;
	}

	enum type_enum {
		type_MESH = 1,
		type_CURVE = 2,
		type_SURFACE = 3,
		type_META = 5,
		type_FONT = 4,
		type_ARMATURE = 25,
		type_LATTICE = 22,
		type_EMPTY = 0,
		type_CAMERA = 11,
		type_LAMP = 10,
		type_SPEAKER = 12,
	};

	/** Getter: Type of Object */
	type_enum type() { /* not implemented */ throw NULL; }
	/** Setter: Type of Object */
	void type(type_enum value) { /* not implemented */ }

	enum mode_enum {
		mode_OBJECT = 0,
		mode_EDIT = 1,
		mode_POSE = 64,
		mode_SCULPT = 2,
		mode_VERTEX_PAINT = 4,
		mode_WEIGHT_PAINT = 8,
		mode_TEXTURE_PAINT = 16,
		mode_PARTICLE_EDIT = 32,
	};

	/** Getter: Object interaction mode */
	mode_enum mode() { /* not implemented */ throw NULL; }
	/** Setter: Object interaction mode */
	void mode(mode_enum value) { /* not implemented */ }

	/** Getter: Layers the object is on */
	std::array<bool, 20> layers() {
		// TODO: MISSING DEREF! USE #DEFINE!
		PyObject *seqval = PyObject_GetAttrString(pyobjref, "layers");
		std::array<bool, 20> resarr;
		for (int i = 0; i < 20; i++)
			resarr[i] = PyLong_AsLong(PySequence_GetItem(seqval, i)) == 1;
		return resarr;
	}

	/** Setter: Layers the object is on */
	void layers(bool values[20]) { /* not implemented */ }

	/** Getter: 3D local view layers the object is on */
	std::array<bool, 8> layers_local_view() {
		// TODO: MISSING DEREF! USE #DEFINE!
		PyObject *seqval = PyObject_GetAttrString(pyobjref, "layers_local_view");
		std::array<bool, 8> resarr;
		for (int i = 0; i < 8; i++)
			resarr[i] = PyLong_AsLong(PySequence_GetItem(seqval, i)) == 1;
		return resarr;
	}

	/** Setter: 3D local view layers the object is on */
	void layers_local_view(bool values[8]) { /* not implemented */ }

	/** Getter: Object selection state */
	bool select() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "select")) == 1;
	}

	/** Setter: Object selection state */
	void select(bool value) {
		PyObject_SetAttrString(pyobjref, "select", Py_BuildValue("i", value));
	}

	/** Getter: Object's bounding box in object-space coordinates, all values are -1.0 when not available */
	std::array<float, 24> bound_box() {
		// TODO: MISSING DEREF! USE #DEFINE!
		PyObject *seqval = PyObject_GetAttrString(pyobjref, "bound_box");
		std::array<float, 24> resarr;
		for (int i = 0; i < 24; i++)
			resarr[i] = (float)PyFloat_AsDouble(PySequence_GetItem(seqval, i));
		return resarr;
	}

	/** Setter: Object's bounding box in object-space coordinates, all values are -1.0 when not available */
	void bound_box(float values[24]) { /* not implemented */ }

	/** Getter: Parent Object */
	Object parent() {
		/* not implemented */ throw NULL;
	}

	enum parent_type_enum {
		parent_type_OBJECT = 0,
		parent_type_CURVE = 1,
		parent_type_KEY = 2,
		parent_type_ARMATURE = 4,
		parent_type_LATTICE = 4,
		parent_type_VERTEX = 5,
		parent_type_VERTEX_3 = 6,
		parent_type_BONE = 7,
	};

	/** Getter: Type of parent relation */
	parent_type_enum parent_type() { /* not implemented */ throw NULL; }
	/** Setter: Type of parent relation */
	void parent_type(parent_type_enum value) { /* not implemented */ }

	/** Getter: Indices of vertices in case of a vertex parenting relation */
	std::array<int, 3> parent_vertices() {
		// TODO: MISSING DEREF! USE #DEFINE!
		PyObject *seqval = PyObject_GetAttrString(pyobjref, "parent_vertices");
		std::array<int, 3> resarr;
		for (int i = 0; i < 3; i++)
			resarr[i] = PyLong_AsLong(PySequence_GetItem(seqval, i));
		return resarr;
	}

	/** Setter: Indices of vertices in case of a vertex parenting relation */
	void parent_vertices(int values[3]) { /* not implemented */ }

	/** Getter: Name of parent bone in case of a bone parenting relation */
	std::string parent_bone() { /* not implemented */ throw NULL; }
	/** Setter: Name of parent bone in case of a bone parenting relation */
	void parent_bone(const std::string& value) { /* not implemented */ }

	enum track_axis_enum {
		track_axis_POS_X = 0,
		track_axis_POS_Y = 1,
		track_axis_POS_Z = 2,
		track_axis_NEG_X = 3,
		track_axis_NEG_Y = 4,
		track_axis_NEG_Z = 5,
	};

	/** Getter: Axis that points in 'forward' direction (applies to DupliFrame when parent 'Follow' is enabled) */
	track_axis_enum track_axis() { /* not implemented */ throw NULL; }
	/** Setter: Axis that points in 'forward' direction (applies to DupliFrame when parent 'Follow' is enabled) */
	void track_axis(track_axis_enum value) { /* not implemented */ }

	enum up_axis_enum {
		up_axis_X = 0,
		up_axis_Y = 1,
		up_axis_Z = 2,
	};

	/** Getter: Axis that points in the upward direction (applies to DupliFrame when parent 'Follow' is enabled) */
	up_axis_enum up_axis() { /* not implemented */ throw NULL; }
	/** Setter: Axis that points in the upward direction (applies to DupliFrame when parent 'Follow' is enabled) */
	void up_axis(up_axis_enum value) { /* not implemented */ }

	/** Getter: Library object this proxy object controls */
	Object proxy() {
		/* not implemented */ throw NULL;
	}

	/** Getter: Library group duplicator object this proxy object controls */
	Object proxy_group() {
		/* not implemented */ throw NULL;
	}

	/** Getter: Material slots in the object */
	std::map<std::string, MaterialSlot> material_slots();
	/** Setter: Material slots in the object */
	void material_slots(std::map<std::string, MaterialSlot> value);

	/** Getter: Active material being displayed */
	Material active_material() {
		/* not implemented */ throw NULL;
	}

	/** Getter: Index of active material slot */
	int active_material_index() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "active_material_index"));
	}

	/** Setter: Index of active material slot */
	void active_material_index(int value) {
		PyObject_SetAttrString(pyobjref, "active_material_index", Py_BuildValue("i", value));
	}

	/** Getter: Location of the object */
	std::array<float, 3> location() {
		// TODO: MISSING DEREF! USE #DEFINE!
		PyObject *seqval = PyObject_GetAttrString(pyobjref, "location");
		std::array<float, 3> resarr;
		for (int i = 0; i < 3; i++)
			resarr[i] = (float)PyFloat_AsDouble(PySequence_GetItem(seqval, i));
		return resarr;
	}

	/** Setter: Location of the object */
	void location(float values[3]) { /* not implemented */ }

	/** Getter: Rotation in Quaternions */
	std::array<float, 4> rotation_quaternion() {
		// TODO: MISSING DEREF! USE #DEFINE!
		PyObject *seqval = PyObject_GetAttrString(pyobjref, "rotation_quaternion");
		std::array<float, 4> resarr;
		for (int i = 0; i < 4; i++)
			resarr[i] = (float)PyFloat_AsDouble(PySequence_GetItem(seqval, i));
		return resarr;
	}

	/** Setter: Rotation in Quaternions */
	void rotation_quaternion(float values[4]) { /* not implemented */ }

	/** Getter: Angle of Rotation for Axis-Angle rotation representation */
	std::array<float, 4> rotation_axis_angle() {
		// TODO: MISSING DEREF! USE #DEFINE!
		PyObject *seqval = PyObject_GetAttrString(pyobjref, "rotation_axis_angle");
		std::array<float, 4> resarr;
		for (int i = 0; i < 4; i++)
			resarr[i] = (float)PyFloat_AsDouble(PySequence_GetItem(seqval, i));
		return resarr;
	}

	/** Setter: Angle of Rotation for Axis-Angle rotation representation */
	void rotation_axis_angle(float values[4]) { /* not implemented */ }

	/** Getter: Rotation in Eulers */
	std::array<float, 3> rotation_euler() {
		// TODO: MISSING DEREF! USE #DEFINE!
		PyObject *seqval = PyObject_GetAttrString(pyobjref, "rotation_euler");
		std::array<float, 3> resarr;
		for (int i = 0; i < 3; i++)
			resarr[i] = (float)PyFloat_AsDouble(PySequence_GetItem(seqval, i));
		return resarr;
	}

	/** Setter: Rotation in Eulers */
	void rotation_euler(float values[3]) { /* not implemented */ }

	enum rotation_mode_enum {
		rotation_mode_QUATERNION = 0,
		rotation_mode_XYZ = 1,
		rotation_mode_XZY = 2,
		rotation_mode_YXZ = 3,
		rotation_mode_YZX = 4,
		rotation_mode_ZXY = 5,
		rotation_mode_ZYX = 6,
		rotation_mode_AXIS_ANGLE = -1,
	};

	/** Getter:  */
	rotation_mode_enum rotation_mode() { /* not implemented */ throw NULL; }
	/** Setter:  */
	void rotation_mode(rotation_mode_enum value) { /* not implemented */ }

	/** Getter: Scaling of the object */
	std::array<float, 3> scale() {
		// TODO: MISSING DEREF! USE #DEFINE!
		PyObject *seqval = PyObject_GetAttrString(pyobjref, "scale");
		std::array<float, 3> resarr;
		for (int i = 0; i < 3; i++)
			resarr[i] = (float)PyFloat_AsDouble(PySequence_GetItem(seqval, i));
		return resarr;
	}

	/** Setter: Scaling of the object */
	void scale(float values[3]) { /* not implemented */ }

	/** Getter: Absolute bounding box dimensions of the object */
	std::array<float, 3> dimensions() {
		// TODO: MISSING DEREF! USE #DEFINE!
		PyObject *seqval = PyObject_GetAttrString(pyobjref, "dimensions");
		std::array<float, 3> resarr;
		for (int i = 0; i < 3; i++)
			resarr[i] = (float)PyFloat_AsDouble(PySequence_GetItem(seqval, i));
		return resarr;
	}

	/** Setter: Absolute bounding box dimensions of the object */
	void dimensions(float values[3]) { /* not implemented */ }

	/** Getter: Extra translation added to the location of the object */
	std::array<float, 3> delta_location() {
		// TODO: MISSING DEREF! USE #DEFINE!
		PyObject *seqval = PyObject_GetAttrString(pyobjref, "delta_location");
		std::array<float, 3> resarr;
		for (int i = 0; i < 3; i++)
			resarr[i] = (float)PyFloat_AsDouble(PySequence_GetItem(seqval, i));
		return resarr;
	}

	/** Setter: Extra translation added to the location of the object */
	void delta_location(float values[3]) { /* not implemented */ }

	/** Getter: Extra rotation added to the rotation of the object (when using Euler rotations) */
	std::array<float, 3> delta_rotation_euler() {
		// TODO: MISSING DEREF! USE #DEFINE!
		PyObject *seqval = PyObject_GetAttrString(pyobjref, "delta_rotation_euler");
		std::array<float, 3> resarr;
		for (int i = 0; i < 3; i++)
			resarr[i] = (float)PyFloat_AsDouble(PySequence_GetItem(seqval, i));
		return resarr;
	}

	/** Setter: Extra rotation added to the rotation of the object (when using Euler rotations) */
	void delta_rotation_euler(float values[3]) { /* not implemented */ }

	/** Getter: Extra rotation added to the rotation of the object (when using Quaternion rotations) */
	std::array<float, 4> delta_rotation_quaternion() {
		// TODO: MISSING DEREF! USE #DEFINE!
		PyObject *seqval = PyObject_GetAttrString(pyobjref, "delta_rotation_quaternion");
		std::array<float, 4> resarr;
		for (int i = 0; i < 4; i++)
			resarr[i] = (float)PyFloat_AsDouble(PySequence_GetItem(seqval, i));
		return resarr;
	}

	/** Setter: Extra rotation added to the rotation of the object (when using Quaternion rotations) */
	void delta_rotation_quaternion(float values[4]) { /* not implemented */ }

	/** Getter: Extra scaling added to the scale of the object */
	std::array<float, 3> delta_scale() {
		// TODO: MISSING DEREF! USE #DEFINE!
		PyObject *seqval = PyObject_GetAttrString(pyobjref, "delta_scale");
		std::array<float, 3> resarr;
		for (int i = 0; i < 3; i++)
			resarr[i] = (float)PyFloat_AsDouble(PySequence_GetItem(seqval, i));
		return resarr;
	}

	/** Setter: Extra scaling added to the scale of the object */
	void delta_scale(float values[3]) { /* not implemented */ }

	/** Getter: Lock editing of location in the interface */
	std::array<bool, 3> lock_location() {
		// TODO: MISSING DEREF! USE #DEFINE!
		PyObject *seqval = PyObject_GetAttrString(pyobjref, "lock_location");
		std::array<bool, 3> resarr;
		for (int i = 0; i < 3; i++)
			resarr[i] = PyLong_AsLong(PySequence_GetItem(seqval, i)) == 1;
		return resarr;
	}

	/** Setter: Lock editing of location in the interface */
	void lock_location(bool values[3]) { /* not implemented */ }

	/** Getter: Lock editing of rotation in the interface */
	std::array<bool, 3> lock_rotation() {
		// TODO: MISSING DEREF! USE #DEFINE!
		PyObject *seqval = PyObject_GetAttrString(pyobjref, "lock_rotation");
		std::array<bool, 3> resarr;
		for (int i = 0; i < 3; i++)
			resarr[i] = PyLong_AsLong(PySequence_GetItem(seqval, i)) == 1;
		return resarr;
	}

	/** Setter: Lock editing of rotation in the interface */
	void lock_rotation(bool values[3]) { /* not implemented */ }

	/** Getter: Lock editing of 'angle' component of four-component rotations in the interface */
	bool lock_rotation_w() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "lock_rotation_w")) == 1;
	}

	/** Setter: Lock editing of 'angle' component of four-component rotations in the interface */
	void lock_rotation_w(bool value) {
		PyObject_SetAttrString(pyobjref, "lock_rotation_w", Py_BuildValue("i", value));
	}

	/** Getter: Lock editing of four component rotations by components (instead of as Eulers) */
	bool lock_rotations_4d() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "lock_rotations_4d")) == 1;
	}

	/** Setter: Lock editing of four component rotations by components (instead of as Eulers) */
	void lock_rotations_4d(bool value) {
		PyObject_SetAttrString(pyobjref, "lock_rotations_4d", Py_BuildValue("i", value));
	}

	/** Getter: Lock editing of scale in the interface */
	std::array<bool, 3> lock_scale() {
		// TODO: MISSING DEREF! USE #DEFINE!
		PyObject *seqval = PyObject_GetAttrString(pyobjref, "lock_scale");
		std::array<bool, 3> resarr;
		for (int i = 0; i < 3; i++)
			resarr[i] = PyLong_AsLong(PySequence_GetItem(seqval, i)) == 1;
		return resarr;
	}

	/** Setter: Lock editing of scale in the interface */
	void lock_scale(bool values[3]) { /* not implemented */ }

	/** Getter: Worldspace transformation matrix */
	std::array<float, 16> matrix_world() {
		// TODO: MISSING DEREF! USE #DEFINE!
		PyObject *seqval = PyObject_GetAttrString(pyobjref, "matrix_world");
		std::array<float, 16> resarr;
		for (int i = 0; i < 16; i++)
			resarr[i] = (float)PyFloat_AsDouble(PySequence_GetItem(seqval, i));
		return resarr;
	}

	/** Setter: Worldspace transformation matrix */
	void matrix_world(float values[16]) { /* not implemented */ }

	/** Getter: Parent relative transformation matrix - WARNING: Only takes into account 'Object' parenting, so e.g. in case of bone parenting you get a matrix relative to the Armature object, not to the actual parent bone */
	std::array<float, 16> matrix_local() {
		// TODO: MISSING DEREF! USE #DEFINE!
		PyObject *seqval = PyObject_GetAttrString(pyobjref, "matrix_local");
		std::array<float, 16> resarr;
		for (int i = 0; i < 16; i++)
			resarr[i] = (float)PyFloat_AsDouble(PySequence_GetItem(seqval, i));
		return resarr;
	}

	/** Setter: Parent relative transformation matrix - WARNING: Only takes into account 'Object' parenting, so e.g. in case of bone parenting you get a matrix relative to the Armature object, not to the actual parent bone */
	void matrix_local(float values[16]) { /* not implemented */ }

	/** Getter: Matrix access to location, rotation and scale (including deltas), before constraints and parenting are applied */
	std::array<float, 16> matrix_basis() {
		// TODO: MISSING DEREF! USE #DEFINE!
		PyObject *seqval = PyObject_GetAttrString(pyobjref, "matrix_basis");
		std::array<float, 16> resarr;
		for (int i = 0; i < 16; i++)
			resarr[i] = (float)PyFloat_AsDouble(PySequence_GetItem(seqval, i));
		return resarr;
	}

	/** Setter: Matrix access to location, rotation and scale (including deltas), before constraints and parenting are applied */
	void matrix_basis(float values[16]) { /* not implemented */ }

	/** Getter: Inverse of object's parent matrix at time of parenting */
	std::array<float, 16> matrix_parent_inverse() {
		// TODO: MISSING DEREF! USE #DEFINE!
		PyObject *seqval = PyObject_GetAttrString(pyobjref, "matrix_parent_inverse");
		std::array<float, 16> resarr;
		for (int i = 0; i < 16; i++)
			resarr[i] = (float)PyFloat_AsDouble(PySequence_GetItem(seqval, i));
		return resarr;
	}

	/** Setter: Inverse of object's parent matrix at time of parenting */
	void matrix_parent_inverse(float values[16]) { /* not implemented */ }

	/** Getter: Modifiers affecting the geometric data of the object */
	std::map<std::string, Modifier> modifiers() {
		// TODO: MISSING DEREF! USE #DEFINE!
		PyObject *seqval = PyObject_GetAttrString(pyobjref, "modifiers");
		PyObject *seqkeys = PyObject_CallMethod(seqval, "keys", NULL);
		std::map<std::string, Modifier> resmap;
		for (int i = 0; i < PySequence_Length(seqval); i++) {
			PyObject *keyobj = PySequence_GetItem(seqkeys, i);
			std::string key = PyBytes_AsString(PyUnicode_AsASCIIString(keyobj));
			Modifier value = Modifier(PySequence_GetItem(seqval, i));
			resmap.insert(std::pair<std::string,Modifier>(key, value));
		}
		return resmap;
	}

	/** Setter: Modifiers affecting the geometric data of the object */
	void modifiers(std::map<std::string, Modifier> value) { /* not implemented */ }

	/** Getter: Constraints affecting the transformation of the object */
	std::map<std::string, Constraint> constraints() {
		// TODO: MISSING DEREF! USE #DEFINE!
		PyObject *seqval = PyObject_GetAttrString(pyobjref, "constraints");
		PyObject *seqkeys = PyObject_CallMethod(seqval, "keys", NULL);
		std::map<std::string, Constraint> resmap;
		for (int i = 0; i < PySequence_Length(seqval); i++) {
			PyObject *keyobj = PySequence_GetItem(seqkeys, i);
			std::string key = PyBytes_AsString(PyUnicode_AsASCIIString(keyobj));
			Constraint value = Constraint(PySequence_GetItem(seqval, i));
			resmap.insert(std::pair<std::string,Constraint>(key, value));
		}
		return resmap;
	}

	/** Setter: Constraints affecting the transformation of the object */
	void constraints(std::map<std::string, Constraint> value) { /* not implemented */ }

	/** Getter: Game engine related settings for the object */
	GameObjectSettings game();

	/** Getter: Vertex groups of the object */
	std::map<std::string, VertexGroup> vertex_groups();
	/** Setter: Vertex groups of the object */
	void vertex_groups(std::map<std::string, VertexGroup> value);

	enum empty_draw_type_enum {
		empty_draw_type_PLAIN_AXES = 2,
		empty_draw_type_ARROWS = 1,
		empty_draw_type_SINGLE_ARROW = 4,
		empty_draw_type_CIRCLE = 3,
		empty_draw_type_CUBE = 5,
		empty_draw_type_SPHERE = 6,
		empty_draw_type_CONE = 7,
		empty_draw_type_IMAGE = 8,
	};

	/** Getter: Viewport display style for empties */
	empty_draw_type_enum empty_draw_type() { /* not implemented */ throw NULL; }
	/** Setter: Viewport display style for empties */
	void empty_draw_type(empty_draw_type_enum value) { /* not implemented */ }

	/** Getter: Size of display for empties in the viewport */
	float empty_draw_size() { /* not implemented */ throw NULL; }
	/** Setter: Size of display for empties in the viewport */
	void empty_draw_size(float value) {
		PyObject_SetAttrString(pyobjref, "empty_draw_size", Py_BuildValue("f", value));
	}

	/** Getter: Origin offset distance */
	std::array<float, 2> empty_image_offset() {
		// TODO: MISSING DEREF! USE #DEFINE!
		PyObject *seqval = PyObject_GetAttrString(pyobjref, "empty_image_offset");
		std::array<float, 2> resarr;
		for (int i = 0; i < 2; i++)
			resarr[i] = (float)PyFloat_AsDouble(PySequence_GetItem(seqval, i));
		return resarr;
	}

	/** Setter: Origin offset distance */
	void empty_image_offset(float values[2]) { /* not implemented */ }

	/** Getter: Parameters defining which layer, pass and frame of the image is displayed */
	ImageUser image_user() {
		/* not implemented */ throw NULL;
	}

	/** Getter: Index number for the IndexOB render pass */
	int pass_index() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "pass_index"));
	}

	/** Setter: Index number for the IndexOB render pass */
	void pass_index(int value) {
		PyObject_SetAttrString(pyobjref, "pass_index", Py_BuildValue("i", value));
	}

	/** Getter: Object color and alpha, used when faces have the ObColor mode enabled */
	std::array<float, 4> color() {
		// TODO: MISSING DEREF! USE #DEFINE!
		PyObject *seqval = PyObject_GetAttrString(pyobjref, "color");
		std::array<float, 4> resarr;
		for (int i = 0; i < 4; i++)
			resarr[i] = (float)PyFloat_AsDouble(PySequence_GetItem(seqval, i));
		return resarr;
	}

	/** Setter: Object color and alpha, used when faces have the ObColor mode enabled */
	void color(float values[4]) { /* not implemented */ }

	/** Getter: Settings for using the object as a field in physics simulation */
	FieldSettings field();

	/** Getter: Settings for using the object as a collider in physics simulation */
	CollisionSettings collision();

	/** Getter: Settings for soft body simulation */
	SoftBodySettings soft_body();

	/** Getter: Particle systems emitted from the object */
	std::map<std::string, ParticleSystem> particle_systems();
	/** Setter: Particle systems emitted from the object */
	void particle_systems(std::map<std::string, ParticleSystem> value);

	/** Getter: Settings for rigid body simulation */
	RigidBodyObject rigid_body();

	/** Getter: Constraint constraining rigid bodies */
	RigidBodyConstraint rigid_body_constraint();

	/** Getter: Restrict visibility in the viewport */
	bool hide() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "hide")) == 1;
	}

	/** Setter: Restrict visibility in the viewport */
	void hide(bool value) {
		PyObject_SetAttrString(pyobjref, "hide", Py_BuildValue("i", value));
	}

	/** Getter: Restrict selection in the viewport */
	bool hide_select() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "hide_select")) == 1;
	}

	/** Setter: Restrict selection in the viewport */
	void hide_select(bool value) {
		PyObject_SetAttrString(pyobjref, "hide_select", Py_BuildValue("i", value));
	}

	/** Getter: Restrict renderability */
	bool hide_render() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "hide_render")) == 1;
	}

	/** Setter: Restrict renderability */
	void hide_render(bool value) {
		PyObject_SetAttrString(pyobjref, "hide_render", Py_BuildValue("i", value));
	}

	/** Getter: Animation data for this datablock */
	AnimData animation_data() {
		/* not implemented */ throw NULL;
	}

	/** Getter: Animation data for this datablock */
	AnimViz animation_visualization() {
		/* not implemented */ throw NULL;
	}

	/** Getter: Motion Path for this element */
	MotionPath motion_path() {
		/* not implemented */ throw NULL;
	}

	/** Getter: Create a delay in the parent relationship (beware: this isn't renderfarm safe and may be invalid after jumping around the timeline) */
	bool use_slow_parent() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_slow_parent")) == 1;
	}

	/** Setter: Create a delay in the parent relationship (beware: this isn't renderfarm safe and may be invalid after jumping around the timeline) */
	void use_slow_parent(bool value) {
		PyObject_SetAttrString(pyobjref, "use_slow_parent", Py_BuildValue("i", value));
	}

	/** Getter: Delay in the parent relationship */
	float slow_parent_offset() { /* not implemented */ throw NULL; }
	/** Setter: Delay in the parent relationship */
	void slow_parent_offset(float value) {
		PyObject_SetAttrString(pyobjref, "slow_parent_offset", Py_BuildValue("f", value));
	}

	/** Getter: Refresh this object again on frame changes, dependency graph hack */
	bool use_extra_recalc_object() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_extra_recalc_object")) == 1;
	}

	/** Setter: Refresh this object again on frame changes, dependency graph hack */
	void use_extra_recalc_object(bool value) {
		PyObject_SetAttrString(pyobjref, "use_extra_recalc_object", Py_BuildValue("i", value));
	}

	/** Getter: Refresh this object's data again on frame changes, dependency graph hack */
	bool use_extra_recalc_data() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_extra_recalc_data")) == 1;
	}

	/** Setter: Refresh this object's data again on frame changes, dependency graph hack */
	void use_extra_recalc_data(bool value) {
		PyObject_SetAttrString(pyobjref, "use_extra_recalc_data", Py_BuildValue("i", value));
	}

	enum dupli_type_enum {
		dupli_type_NONE = 0,
		dupli_type_FRAMES = 8,
		dupli_type_VERTS = 16,
		dupli_type_FACES = 512,
		dupli_type_GROUP = 256,
	};

	/** Getter: If not None, object duplication method to use */
	dupli_type_enum dupli_type() { /* not implemented */ throw NULL; }
	/** Setter: If not None, object duplication method to use */
	void dupli_type(dupli_type_enum value) { /* not implemented */ }

	/** Getter: Set dupliframes to use the current frame instead of parent curve's evaluation time */
	bool use_dupli_frames_speed() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_dupli_frames_speed")) == 1;
	}

	/** Setter: Set dupliframes to use the current frame instead of parent curve's evaluation time */
	void use_dupli_frames_speed(bool value) {
		PyObject_SetAttrString(pyobjref, "use_dupli_frames_speed", Py_BuildValue("i", value));
	}

	/** Getter: Rotate dupli according to vertex normal */
	bool use_dupli_vertices_rotation() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_dupli_vertices_rotation")) == 1;
	}

	/** Setter: Rotate dupli according to vertex normal */
	void use_dupli_vertices_rotation(bool value) {
		PyObject_SetAttrString(pyobjref, "use_dupli_vertices_rotation", Py_BuildValue("i", value));
	}

	/** Getter: Scale dupli based on face size */
	bool use_dupli_faces_scale() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_dupli_faces_scale")) == 1;
	}

	/** Setter: Scale dupli based on face size */
	void use_dupli_faces_scale(bool value) {
		PyObject_SetAttrString(pyobjref, "use_dupli_faces_scale", Py_BuildValue("i", value));
	}

	/** Getter: Scale the DupliFace objects */
	float dupli_faces_scale() { /* not implemented */ throw NULL; }
	/** Setter: Scale the DupliFace objects */
	void dupli_faces_scale(float value) {
		PyObject_SetAttrString(pyobjref, "dupli_faces_scale", Py_BuildValue("f", value));
	}

	/** Getter: Instance an existing group */
	Group dupli_group() {
		/* not implemented */ throw NULL;
	}

	/** Getter: Start frame for DupliFrames */
	int dupli_frames_start() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "dupli_frames_start"));
	}

	/** Setter: Start frame for DupliFrames */
	void dupli_frames_start(int value) {
		PyObject_SetAttrString(pyobjref, "dupli_frames_start", Py_BuildValue("i", value));
	}

	/** Getter: End frame for DupliFrames */
	int dupli_frames_end() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "dupli_frames_end"));
	}

	/** Setter: End frame for DupliFrames */
	void dupli_frames_end(int value) {
		PyObject_SetAttrString(pyobjref, "dupli_frames_end", Py_BuildValue("i", value));
	}

	/** Getter: Number of frames to use between DupOff frames */
	int dupli_frames_on() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "dupli_frames_on"));
	}

	/** Setter: Number of frames to use between DupOff frames */
	void dupli_frames_on(int value) {
		PyObject_SetAttrString(pyobjref, "dupli_frames_on", Py_BuildValue("i", value));
	}

	/** Getter: Recurring frames to exclude from the Dupliframes */
	int dupli_frames_off() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "dupli_frames_off"));
	}

	/** Setter: Recurring frames to exclude from the Dupliframes */
	void dupli_frames_off(int value) {
		PyObject_SetAttrString(pyobjref, "dupli_frames_off", Py_BuildValue("i", value));
	}

	/** Getter: Object duplis */
	std::map<std::string, DupliObject> dupli_list();
	/** Setter: Object duplis */
	void dupli_list(std::map<std::string, DupliObject> value);

	/** Getter:  */
	bool is_duplicator() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "is_duplicator")) == 1;
	}

	/** Setter:  */
	void is_duplicator(bool value) {
		PyObject_SetAttrString(pyobjref, "is_duplicator", Py_BuildValue("i", value));
	}

	enum draw_type_enum {
		draw_type_BOUNDS = 1,
		draw_type_WIRE = 2,
		draw_type_SOLID = 3,
		draw_type_TEXTURED = 5,
	};

	/** Getter: Maximum draw type to display object with in viewport */
	draw_type_enum draw_type() { /* not implemented */ throw NULL; }
	/** Setter: Maximum draw type to display object with in viewport */
	void draw_type(draw_type_enum value) { /* not implemented */ }

	/** Getter: Display the object's bounds */
	bool show_bounds() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "show_bounds")) == 1;
	}

	/** Setter: Display the object's bounds */
	void show_bounds(bool value) {
		PyObject_SetAttrString(pyobjref, "show_bounds", Py_BuildValue("i", value));
	}

	enum draw_bounds_type_enum {
		draw_bounds_type_BOX = 0,
		draw_bounds_type_SPHERE = 1,
		draw_bounds_type_CYLINDER = 2,
		draw_bounds_type_CONE = 3,
		draw_bounds_type_CAPSULE = 7,
	};

	/** Getter: Object boundary display type */
	draw_bounds_type_enum draw_bounds_type() { /* not implemented */ throw NULL; }
	/** Setter: Object boundary display type */
	void draw_bounds_type(draw_bounds_type_enum value) { /* not implemented */ }

	/** Getter: Display the object's name */
	bool show_name() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "show_name")) == 1;
	}

	/** Setter: Display the object's name */
	void show_name(bool value) {
		PyObject_SetAttrString(pyobjref, "show_name", Py_BuildValue("i", value));
	}

	/** Getter: Display the object's origin and axes */
	bool show_axis() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "show_axis")) == 1;
	}

	/** Setter: Display the object's origin and axes */
	void show_axis(bool value) {
		PyObject_SetAttrString(pyobjref, "show_axis", Py_BuildValue("i", value));
	}

	/** Getter: Display the object's texture space */
	bool show_texture_space() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "show_texture_space")) == 1;
	}

	/** Setter: Display the object's texture space */
	void show_texture_space(bool value) {
		PyObject_SetAttrString(pyobjref, "show_texture_space", Py_BuildValue("i", value));
	}

	/** Getter: Add the object's wireframe over solid drawing */
	bool show_wire() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "show_wire")) == 1;
	}

	/** Setter: Add the object's wireframe over solid drawing */
	void show_wire(bool value) {
		PyObject_SetAttrString(pyobjref, "show_wire", Py_BuildValue("i", value));
	}

	/** Getter: Display all edges for mesh objects */
	bool show_all_edges() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "show_all_edges")) == 1;
	}

	/** Setter: Display all edges for mesh objects */
	void show_all_edges(bool value) {
		PyObject_SetAttrString(pyobjref, "show_all_edges", Py_BuildValue("i", value));
	}

	/** Getter: Display material transparency in the object (unsupported for duplicator drawing) */
	bool show_transparent() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "show_transparent")) == 1;
	}

	/** Setter: Display material transparency in the object (unsupported for duplicator drawing) */
	void show_transparent(bool value) {
		PyObject_SetAttrString(pyobjref, "show_transparent", Py_BuildValue("i", value));
	}

	/** Getter: Make the object draw in front of others (unsupported for duplicator drawing) */
	bool show_x_ray() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "show_x_ray")) == 1;
	}

	/** Setter: Make the object draw in front of others (unsupported for duplicator drawing) */
	void show_x_ray(bool value) {
		PyObject_SetAttrString(pyobjref, "show_x_ray", Py_BuildValue("i", value));
	}

	/** Getter: Grease Pencil datablock */
	GreasePencil grease_pencil() {
		/* not implemented */ throw NULL;
	}

	/** Getter: Action used as a pose library for armatures */
	Action pose_library() {
		/* not implemented */ throw NULL;
	}

	/** Getter: Current pose for armatures */
	Pose pose();

	/** Getter: Always show the current Shape for this Object */
	bool show_only_shape_key() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "show_only_shape_key")) == 1;
	}

	/** Setter: Always show the current Shape for this Object */
	void show_only_shape_key(bool value) {
		PyObject_SetAttrString(pyobjref, "show_only_shape_key", Py_BuildValue("i", value));
	}

	/** Getter: Apply shape keys in edit mode (for Meshes only) */
	bool use_shape_key_edit_mode() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_shape_key_edit_mode")) == 1;
	}

	/** Setter: Apply shape keys in edit mode (for Meshes only) */
	void use_shape_key_edit_mode(bool value) {
		PyObject_SetAttrString(pyobjref, "use_shape_key_edit_mode", Py_BuildValue("i", value));
	}

	/** Getter: Current shape key */
	ShapeKey active_shape_key() {
		/* not implemented */ throw NULL;
	}

	/** Getter: Current shape key index */
	int active_shape_key_index() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "active_shape_key_index"));
	}

	/** Setter: Current shape key index */
	void active_shape_key_index(int value) {
		PyObject_SetAttrString(pyobjref, "active_shape_key_index", Py_BuildValue("i", value));
	}

	/** Getter: (null) */
	bool use_dynamic_topology_sculpting() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_dynamic_topology_sculpting")) == 1;
	}

	/** Setter: (null) */
	void use_dynamic_topology_sculpting(bool value) {
		PyObject_SetAttrString(pyobjref, "use_dynamic_topology_sculpting", Py_BuildValue("i", value));
	}

	/** Getter: A collection of detail levels to automatically switch between */
	std::map<std::string, LodLevel> lod_levels();
	/** Setter: A collection of detail levels to automatically switch between */
	void lod_levels(std::map<std::string, LodLevel> value);

	/**
	 * Enum: space_items
	 */
	enum space_items {
		space_items_WORLD = 0,	/**< The most gobal space in Blender */
		space_items_POSE = 2,	/**< The pose space of a bone (its armature's object space) */
		space_items_LOCAL_WITH_PARENT = 3,	/**< The local space of a bone's parent bone */
		space_items_LOCAL = 1	/**< The local space of an object/bone */
	};

	/**
	 * Convert (transform) the given matrix from one space to another
	 * @param Bone to use to define spaces (may be None, in which case only the two 'WORLD' and 'LOCAL' spaces are usable)
	 * @param The matrix to transform
	 * @return The transformed matrix
	 * @param The space in which 'matrix' is currently
	 * @param The space to which you want to transform 'matrix'
	 */
	std::array<float, 16> convert_space(PoseBone pose_bone, float matrix[16], space_items from_space = space_items_WORLD, space_items to_space = space_items_WORLD);

	/**
	 * Generate the camera projection matrix of this object (mostly useful for Camera and Lamp types)
	 * @return The camera projection matrix
	 * @param Width of the render area
	 * @param Height of the render area
	 * @param Width scaling factor
	 * @param height scaling factor
	 */
	std::array<float, 16> calc_matrix_camera(int x = 1, int y = 1, float scale_x = 1.000000f, float scale_y = 1.000000f)
	{
		// not implemented
		throw NULL;
	}

	/**
	 * Container for the output of camera_fit_coords()
	 */
	struct camera_fit_coords_result {
		float co_return;	/**< The location to aim to be able to see all given points */
		float scale_return;	/**< The ortho scale to aim to be able to see all given points (if relevant) */
	};

	/**
	 * Compute the coordinate (and scale for ortho cameras) given object should be to 'see' all given coordinates
	 * @param Scene to get render size information from, if available
	 * @param Coordinates to fit in
	 * @return A camera_fit_coords_result struct containing the output of this function
	 */
	camera_fit_coords_result camera_fit_coords(Scene scene, int coordinates_len, float coordinates);

	/**
	 * Enum: mesh_type_items
	 */
	enum mesh_type_items {
		mesh_type_items_PREVIEW = 1,	/**< Apply modifier preview settings */
		mesh_type_items_RENDER = 2	/**< Apply modifier render settings */
	};

	/**
	 * Create a Mesh datablock with modifiers applied
	 * @param Scene within which to evaluate modifiers
	 * @param Apply modifiers
	 * @param Modifier settings to apply
	 * @param Calculate tessellation faces
	 * @param Calculate undeformed vertex coordinates
	 * @return Mesh created from object, remove it if it is only used for export
	 */
	Mesh to_mesh(Scene scene, bool apply_modifiers, mesh_type_items settings, bool calc_tessface = true, bool calc_undeformed = false);

	/**
	 * Enum: dupli_eval_mode_items
	 */
	enum dupli_eval_mode_items {
		dupli_eval_mode_items_VIEWPORT = 0,	/**< Generate duplis using viewport settings */
		dupli_eval_mode_items_PREVIEW = 1,	/**< Generate duplis using preview settings */
		dupli_eval_mode_items_RENDER = 2	/**< Generate duplis using render settings */
	};

	/**
	 * Create a list of dupli objects for this object, needs to be freed manually with free_dupli_list to restore the objects real matrix and layers
	 * @param Scene within which to evaluate duplis
	 * @param Generate texture coordinates for rendering
	 */
	void dupli_list_create(Scene scene, dupli_eval_mode_items settings = dupli_eval_mode_items_VIEWPORT);

	/**
	 * Free the list of dupli objects
	 */
	void dupli_list_clear()
	{
		// not implemented
	}

	/**
	 * Find armature influencing this object as a parent or via a modifier
	 * @return Armature object influencing this object or NULL
	 */
	Object find_armature()
	{
		// not implemented
		return Object();
	}

	/**
	 * Add shape key to an object
	 * @param Unique name for the new keyblock
	 * @param Create new shape from existing mix of shapes
	 * @return New shape keyblock
	 */
	ShapeKey shape_key_add(const std::string name = "Key", bool from_mix = true)
	{
		// not implemented
		return ShapeKey();
	}

	/**
	 * Container for the output of ray_cast()
	 */
	struct ray_cast_result {
		float location;	/**< The hit location of this ray cast */
		float normal;	/**< The face normal at the ray cast hit location */
		int index;	/**< The face index, -1 when no intersection is found */
	};

	/**
	 * Cast a ray onto in object space
	 * @param Param 'start'
	 * @param Param 'end'
	 * @return A ray_cast_result struct containing the output of this function
	 */
	ray_cast_result ray_cast(float start[3], float end[3])
	{
		// not implemented
		return ray_cast_result();
	}

	/**
	 * Container for the output of closest_point_on_mesh()
	 */
	struct closest_point_on_mesh_result {
		float location;	/**< The location on the object closest to the point */
		float normal;	/**< The face normal at the closest point */
		int index;	/**< The face index, -1 when no closest point is found */
	};

	/**
	 * Find the nearest point on the object
	 * @param Param 'point'
	 * @param Param 'max_dist'
	 * @return A closest_point_on_mesh_result struct containing the output of this function
	 */
	closest_point_on_mesh_result closest_point_on_mesh(float point[3], float max_dist = 1.844674e+019f)
	{
		// not implemented
		return closest_point_on_mesh_result();
	}

	/**
	 * Determine if object is visible in a given scene
	 * @param Param 'scene'
	 * @return Object visibility
	 */
	bool is_visible(Scene scene);

	/**
	 * Determine if this object is modified from the base mesh data
	 * @param Param 'scene'
	 * @param Modifier settings to apply
	 * @return Object visibility
	 */
	bool is_modified(Scene scene, mesh_type_items settings);

	/**
	 * Determine if this object is modified by a deformation from the base mesh data
	 * @param Param 'scene'
	 * @param Modifier settings to apply
	 * @return Object visibility
	 */
	bool is_deform_modified(Scene scene, mesh_type_items settings);

	/**
	 * Enum: mesh_dm_info_items
	 */
	enum mesh_dm_info_items {
		mesh_dm_info_items_SOURCE = 0,	/**< Source mesh */
		mesh_dm_info_items_DEFORM = 1,	/**< Objects deform mesh */
		mesh_dm_info_items_FINAL = 2	/**< Objects final mesh */
	};

	/**
	 * Returns a string for derived mesh data
	 * @param Modifier settings to apply
	 * @return 
	 */
	std::string dm_info(mesh_dm_info_items type)
	{
		// not implemented
		throw NULL;
	}

	/**
	 * Load the objects edit-mode data intp the object data
	 * @return Success
	 */
	bool update_from_editmode()
	{
		// not implemented
		return true;
	}

	/**
	 * Release memory used by caches associated with this object. Intended to be used by render engines only
	 */
	void cache_release()
	{
		// not implemented
	}

};

/**************** Game Object Settings ****************/

/**
 * Game engine related settings for the object
 */
class GameObjectSettings : public pyUniplug {
public:
	GameObjectSettings(PyObject* pyobj) : pyUniplug(pyobj) {}

	GameObjectSettings() : pyUniplug(0)
	{
		// not implemented
	}

	/** Getter: Game engine sensor to detect events */
	std::map<std::string, Sensor> sensors();
	/** Setter: Game engine sensor to detect events */
	void sensors(std::map<std::string, Sensor> value);

	/** Getter: Game engine controllers to process events, connecting sensors to actuators */
	std::map<std::string, Controller> controllers() {
		// TODO: MISSING DEREF! USE #DEFINE!
		PyObject *seqval = PyObject_GetAttrString(pyobjref, "controllers");
		PyObject *seqkeys = PyObject_CallMethod(seqval, "keys", NULL);
		std::map<std::string, Controller> resmap;
		for (int i = 0; i < PySequence_Length(seqval); i++) {
			PyObject *keyobj = PySequence_GetItem(seqkeys, i);
			std::string key = PyBytes_AsString(PyUnicode_AsASCIIString(keyobj));
			Controller value = Controller(PySequence_GetItem(seqval, i));
			resmap.insert(std::pair<std::string,Controller>(key, value));
		}
		return resmap;
	}

	/** Setter: Game engine controllers to process events, connecting sensors to actuators */
	void controllers(std::map<std::string, Controller> value) { /* not implemented */ }

	/** Getter: Game engine actuators to act on events */
	std::map<std::string, Actuator> actuators() {
		// TODO: MISSING DEREF! USE #DEFINE!
		PyObject *seqval = PyObject_GetAttrString(pyobjref, "actuators");
		PyObject *seqkeys = PyObject_CallMethod(seqval, "keys", NULL);
		std::map<std::string, Actuator> resmap;
		for (int i = 0; i < PySequence_Length(seqval); i++) {
			PyObject *keyobj = PySequence_GetItem(seqkeys, i);
			std::string key = PyBytes_AsString(PyUnicode_AsASCIIString(keyobj));
			Actuator value = Actuator(PySequence_GetItem(seqval, i));
			resmap.insert(std::pair<std::string,Actuator>(key, value));
		}
		return resmap;
	}

	/** Setter: Game engine actuators to act on events */
	void actuators(std::map<std::string, Actuator> value) { /* not implemented */ }

	/** Getter: Game engine properties */
	std::map<std::string, GameProperty> properties();
	/** Setter: Game engine properties */
	void properties(std::map<std::string, GameProperty> value);

	/** Getter: Shows sensors for this object in the user interface */
	bool show_sensors() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "show_sensors")) == 1;
	}

	/** Setter: Shows sensors for this object in the user interface */
	void show_sensors(bool value) {
		PyObject_SetAttrString(pyobjref, "show_sensors", Py_BuildValue("i", value));
	}

	/** Getter: Shows controllers for this object in the user interface */
	bool show_controllers() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "show_controllers")) == 1;
	}

	/** Setter: Shows controllers for this object in the user interface */
	void show_controllers(bool value) {
		PyObject_SetAttrString(pyobjref, "show_controllers", Py_BuildValue("i", value));
	}

	/** Getter: Shows actuators for this object in the user interface */
	bool show_actuators() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "show_actuators")) == 1;
	}

	/** Setter: Shows actuators for this object in the user interface */
	void show_actuators(bool value) {
		PyObject_SetAttrString(pyobjref, "show_actuators", Py_BuildValue("i", value));
	}

	enum physics_type_enum {
		physics_type_NO_COLLISION = 0,
		physics_type_STATIC = 1,
		physics_type_DYNAMIC = 2,
		physics_type_RIGID_BODY = 3,
		physics_type_SOFT_BODY = 4,
		physics_type_OCCLUDER = 5,
		physics_type_SENSOR = 6,
		physics_type_NAVMESH = 7,
		physics_type_CHARACTER = 8,
	};

	/** Getter: Select the type of physical representation */
	physics_type_enum physics_type() { /* not implemented */ throw NULL; }
	/** Setter: Select the type of physical representation */
	void physics_type(physics_type_enum value) { /* not implemented */ }

	/** Getter: Record animation objects without physics */
	bool use_record_animation() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_record_animation")) == 1;
	}

	/** Setter: Record animation objects without physics */
	void use_record_animation(bool value) {
		PyObject_SetAttrString(pyobjref, "use_record_animation", Py_BuildValue("i", value));
	}

	/** Getter: Object is detected by the Near and Radar sensor */
	bool use_actor() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_actor")) == 1;
	}

	/** Setter: Object is detected by the Near and Radar sensor */
	void use_actor(bool value) {
		PyObject_SetAttrString(pyobjref, "use_actor", Py_BuildValue("i", value));
	}

	/** Getter: Object does not react to collisions, like a ghost */
	bool use_ghost() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_ghost")) == 1;
	}

	/** Setter: Object does not react to collisions, like a ghost */
	void use_ghost(bool value) {
		PyObject_SetAttrString(pyobjref, "use_ghost", Py_BuildValue("i", value));
	}

	/** Getter: Mass of the object */
	float mass() { /* not implemented */ throw NULL; }
	/** Setter: Mass of the object */
	void mass(float value) {
		PyObject_SetAttrString(pyobjref, "mass", Py_BuildValue("f", value));
	}

	/** Getter: Radius of bounding sphere and material physics */
	float radius() { /* not implemented */ throw NULL; }
	/** Setter: Radius of bounding sphere and material physics */
	void radius(float value) {
		PyObject_SetAttrString(pyobjref, "radius", Py_BuildValue("f", value));
	}

	/** Getter: Disable auto (de)activation in physics simulation */
	bool use_sleep() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_sleep")) == 1;
	}

	/** Setter: Disable auto (de)activation in physics simulation */
	void use_sleep(bool value) {
		PyObject_SetAttrString(pyobjref, "use_sleep", Py_BuildValue("i", value));
	}

	/** Getter: General movement damping */
	float damping() { /* not implemented */ throw NULL; }
	/** Setter: General movement damping */
	void damping(float value) {
		PyObject_SetAttrString(pyobjref, "damping", Py_BuildValue("f", value));
	}

	/** Getter: General rotation damping */
	float rotation_damping() { /* not implemented */ throw NULL; }
	/** Setter: General rotation damping */
	void rotation_damping(float value) {
		PyObject_SetAttrString(pyobjref, "rotation_damping", Py_BuildValue("f", value));
	}

	/** Getter: Clamp velocity to this minimum speed (except when totally still) */
	float velocity_min() { /* not implemented */ throw NULL; }
	/** Setter: Clamp velocity to this minimum speed (except when totally still) */
	void velocity_min(float value) {
		PyObject_SetAttrString(pyobjref, "velocity_min", Py_BuildValue("f", value));
	}

	/** Getter: Clamp velocity to this maximum speed */
	float velocity_max() { /* not implemented */ throw NULL; }
	/** Setter: Clamp velocity to this maximum speed */
	void velocity_max(float value) {
		PyObject_SetAttrString(pyobjref, "velocity_max", Py_BuildValue("f", value));
	}

	/** Getter: Maximum height of steps the character can run over */
	float step_height() { /* not implemented */ throw NULL; }
	/** Setter: Maximum height of steps the character can run over */
	void step_height(float value) {
		PyObject_SetAttrString(pyobjref, "step_height", Py_BuildValue("f", value));
	}

	/** Getter: Upward velocity applied to the character when jumping */
	float jump_speed() { /* not implemented */ throw NULL; }
	/** Setter: Upward velocity applied to the character when jumping */
	void jump_speed(float value) {
		PyObject_SetAttrString(pyobjref, "jump_speed", Py_BuildValue("f", value));
	}

	/** Getter: Maximum speed at which the character will fall */
	float fall_speed() { /* not implemented */ throw NULL; }
	/** Setter: Maximum speed at which the character will fall */
	void fall_speed(float value) {
		PyObject_SetAttrString(pyobjref, "fall_speed", Py_BuildValue("f", value));
	}

	/** Getter: The collision group of the object */
	std::array<bool, 16> collision_group() {
		// TODO: MISSING DEREF! USE #DEFINE!
		PyObject *seqval = PyObject_GetAttrString(pyobjref, "collision_group");
		std::array<bool, 16> resarr;
		for (int i = 0; i < 16; i++)
			resarr[i] = PyLong_AsLong(PySequence_GetItem(seqval, i)) == 1;
		return resarr;
	}

	/** Setter: The collision group of the object */
	void collision_group(bool values[16]) { /* not implemented */ }

	/** Getter: The groups this object can collide with */
	std::array<bool, 16> collision_mask() {
		// TODO: MISSING DEREF! USE #DEFINE!
		PyObject *seqval = PyObject_GetAttrString(pyobjref, "collision_mask");
		std::array<bool, 16> resarr;
		for (int i = 0; i < 16; i++)
			resarr[i] = PyLong_AsLong(PySequence_GetItem(seqval, i)) == 1;
		return resarr;
	}

	/** Setter: The groups this object can collide with */
	void collision_mask(bool values[16]) { /* not implemented */ }

	/** Getter: Disable simulation of linear motion along the X axis */
	bool lock_location_x() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "lock_location_x")) == 1;
	}

	/** Setter: Disable simulation of linear motion along the X axis */
	void lock_location_x(bool value) {
		PyObject_SetAttrString(pyobjref, "lock_location_x", Py_BuildValue("i", value));
	}

	/** Getter: Disable simulation of linear motion along the Y axis */
	bool lock_location_y() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "lock_location_y")) == 1;
	}

	/** Setter: Disable simulation of linear motion along the Y axis */
	void lock_location_y(bool value) {
		PyObject_SetAttrString(pyobjref, "lock_location_y", Py_BuildValue("i", value));
	}

	/** Getter: Disable simulation of linear motion along the Z axis */
	bool lock_location_z() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "lock_location_z")) == 1;
	}

	/** Setter: Disable simulation of linear motion along the Z axis */
	void lock_location_z(bool value) {
		PyObject_SetAttrString(pyobjref, "lock_location_z", Py_BuildValue("i", value));
	}

	/** Getter: Disable simulation of angular motion along the X axis */
	bool lock_rotation_x() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "lock_rotation_x")) == 1;
	}

	/** Setter: Disable simulation of angular motion along the X axis */
	void lock_rotation_x(bool value) {
		PyObject_SetAttrString(pyobjref, "lock_rotation_x", Py_BuildValue("i", value));
	}

	/** Getter: Disable simulation of angular motion along the Y axis */
	bool lock_rotation_y() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "lock_rotation_y")) == 1;
	}

	/** Setter: Disable simulation of angular motion along the Y axis */
	void lock_rotation_y(bool value) {
		PyObject_SetAttrString(pyobjref, "lock_rotation_y", Py_BuildValue("i", value));
	}

	/** Getter: Disable simulation of angular motion along the Z axis */
	bool lock_rotation_z() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "lock_rotation_z")) == 1;
	}

	/** Setter: Disable simulation of angular motion along the Z axis */
	void lock_rotation_z(bool value) {
		PyObject_SetAttrString(pyobjref, "lock_rotation_z", Py_BuildValue("i", value));
	}

	/** Getter: Disable simulation of angular motion along the Z axis */
	bool use_activity_culling() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_activity_culling")) == 1;
	}

	/** Setter: Disable simulation of angular motion along the Z axis */
	void use_activity_culling(bool value) {
		PyObject_SetAttrString(pyobjref, "use_activity_culling", Py_BuildValue("i", value));
	}

	/** Getter: React to force field physics settings in materials */
	bool use_material_physics_fh() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_material_physics_fh")) == 1;
	}

	/** Setter: React to force field physics settings in materials */
	void use_material_physics_fh(bool value) {
		PyObject_SetAttrString(pyobjref, "use_material_physics_fh", Py_BuildValue("i", value));
	}

	/** Getter: Use face normal to rotate object, so that it points away from the surface */
	bool use_rotate_from_normal() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_rotate_from_normal")) == 1;
	}

	/** Setter: Use face normal to rotate object, so that it points away from the surface */
	void use_rotate_from_normal(bool value) {
		PyObject_SetAttrString(pyobjref, "use_rotate_from_normal", Py_BuildValue("i", value));
	}

	/** Getter: Form factor scales the inertia tensor */
	float form_factor() { /* not implemented */ throw NULL; }
	/** Setter: Form factor scales the inertia tensor */
	void form_factor(float value) {
		PyObject_SetAttrString(pyobjref, "form_factor", Py_BuildValue("f", value));
	}

	/** Getter: Enable anisotropic friction */
	bool use_anisotropic_friction() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_anisotropic_friction")) == 1;
	}

	/** Setter: Enable anisotropic friction */
	void use_anisotropic_friction(bool value) {
		PyObject_SetAttrString(pyobjref, "use_anisotropic_friction", Py_BuildValue("i", value));
	}

	/** Getter: Relative friction coefficients in the in the X, Y and Z directions, when anisotropic friction is enabled */
	std::array<float, 3> friction_coefficients() {
		// TODO: MISSING DEREF! USE #DEFINE!
		PyObject *seqval = PyObject_GetAttrString(pyobjref, "friction_coefficients");
		std::array<float, 3> resarr;
		for (int i = 0; i < 3; i++)
			resarr[i] = (float)PyFloat_AsDouble(PySequence_GetItem(seqval, i));
		return resarr;
	}

	/** Setter: Relative friction coefficients in the in the X, Y and Z directions, when anisotropic friction is enabled */
	void friction_coefficients(float values[3]) { /* not implemented */ }

	/** Getter: Specify a collision bounds type other than the default */
	bool use_collision_bounds() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_collision_bounds")) == 1;
	}

	/** Setter: Specify a collision bounds type other than the default */
	void use_collision_bounds(bool value) {
		PyObject_SetAttrString(pyobjref, "use_collision_bounds", Py_BuildValue("i", value));
	}

	enum collision_bounds_type_enum {
		collision_bounds_type_BOX = 0,
		collision_bounds_type_SPHERE = 1,
		collision_bounds_type_CYLINDER = 2,
		collision_bounds_type_CONE = 3,
		collision_bounds_type_CONVEX_HULL = 5,
		collision_bounds_type_TRIANGLE_MESH = 4,
		collision_bounds_type_CAPSULE = 7,
	};

	/** Getter: Select the collision shape that better fits the object */
	collision_bounds_type_enum collision_bounds_type() { /* not implemented */ throw NULL; }
	/** Setter: Select the collision shape that better fits the object */
	void collision_bounds_type(collision_bounds_type_enum value) { /* not implemented */ }

	/** Getter: Add children to form a compound collision object */
	bool use_collision_compound() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_collision_compound")) == 1;
	}

	/** Setter: Add children to form a compound collision object */
	void use_collision_compound(bool value) {
		PyObject_SetAttrString(pyobjref, "use_collision_compound", Py_BuildValue("i", value));
	}

	/** Getter: Extra margin around object for collision detection, small amount required for stability */
	float collision_margin() { /* not implemented */ throw NULL; }
	/** Setter: Extra margin around object for collision detection, small amount required for stability */
	void collision_margin(float value) {
		PyObject_SetAttrString(pyobjref, "collision_margin", Py_BuildValue("f", value));
	}

	/** Getter: Settings for Bullet soft body simulation */
	GameSoftBodySettings soft_body();

	/** Getter: Create representation for obstacle simulation */
	bool use_obstacle_create() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_obstacle_create")) == 1;
	}

	/** Setter: Create representation for obstacle simulation */
	void use_obstacle_create(bool value) {
		PyObject_SetAttrString(pyobjref, "use_obstacle_create", Py_BuildValue("i", value));
	}

	/** Getter: Radius of object representation in obstacle simulation */
	float obstacle_radius() { /* not implemented */ throw NULL; }
	/** Setter: Radius of object representation in obstacle simulation */
	void obstacle_radius(float value) {
		PyObject_SetAttrString(pyobjref, "obstacle_radius", Py_BuildValue("f", value));
	}

	/** Getter: State determining which controllers are displayed */
	std::array<bool, 30> states_visible() {
		// TODO: MISSING DEREF! USE #DEFINE!
		PyObject *seqval = PyObject_GetAttrString(pyobjref, "states_visible");
		std::array<bool, 30> resarr;
		for (int i = 0; i < 30; i++)
			resarr[i] = PyLong_AsLong(PySequence_GetItem(seqval, i)) == 1;
		return resarr;
	}

	/** Setter: State determining which controllers are displayed */
	void states_visible(bool values[30]) { /* not implemented */ }

	/** Getter: States which are being used by controllers */
	std::array<bool, 30> used_states() {
		// TODO: MISSING DEREF! USE #DEFINE!
		PyObject *seqval = PyObject_GetAttrString(pyobjref, "used_states");
		std::array<bool, 30> resarr;
		for (int i = 0; i < 30; i++)
			resarr[i] = PyLong_AsLong(PySequence_GetItem(seqval, i)) == 1;
		return resarr;
	}

	/** Setter: States which are being used by controllers */
	void used_states(bool values[30]) { /* not implemented */ }

	/** Getter: Initial state when the game starts */
	std::array<bool, 30> states_initial() {
		// TODO: MISSING DEREF! USE #DEFINE!
		PyObject *seqval = PyObject_GetAttrString(pyobjref, "states_initial");
		std::array<bool, 30> resarr;
		for (int i = 0; i < 30; i++)
			resarr[i] = PyLong_AsLong(PySequence_GetItem(seqval, i)) == 1;
		return resarr;
	}

	/** Setter: Initial state when the game starts */
	void states_initial(bool values[30]) { /* not implemented */ }

	/** Getter: Print state debug info in the game engine */
	bool show_debug_state() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "show_debug_state")) == 1;
	}

	/** Setter: Print state debug info in the game engine */
	void show_debug_state(bool value) {
		PyObject_SetAttrString(pyobjref, "show_debug_state", Py_BuildValue("i", value));
	}

	/** Getter: Set all state bits */
	bool use_all_states() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_all_states")) == 1;
	}

	/** Setter: Set all state bits */
	void use_all_states(bool value) {
		PyObject_SetAttrString(pyobjref, "use_all_states", Py_BuildValue("i", value));
	}

	/** Getter: Show state panel */
	bool show_state_panel() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "show_state_panel")) == 1;
	}

	/** Setter: Show state panel */
	void show_state_panel(bool value) {
		PyObject_SetAttrString(pyobjref, "show_state_panel", Py_BuildValue("i", value));
	}

};

/**************** Object Base ****************/

/**
 * An object instance in a scene
 */
class ObjectBase : public pyUniplug {
public:
	ObjectBase(PyObject* pyobj) : pyUniplug(pyobj) {}

	ObjectBase() : pyUniplug(0)
	{
		// not implemented
	}

	/** Getter: Object this base links to */
	Object object_value() {
		/* not implemented */ throw NULL;
	}

	/** Getter: Layers the object base is on */
	std::array<bool, 20> layers() {
		// TODO: MISSING DEREF! USE #DEFINE!
		PyObject *seqval = PyObject_GetAttrString(pyobjref, "layers");
		std::array<bool, 20> resarr;
		for (int i = 0; i < 20; i++)
			resarr[i] = PyLong_AsLong(PySequence_GetItem(seqval, i)) == 1;
		return resarr;
	}

	/** Setter: Layers the object base is on */
	void layers(bool values[20]) { /* not implemented */ }

	/** Getter: 3D local view layers the object base is on */
	std::array<bool, 8> layers_local_view() {
		// TODO: MISSING DEREF! USE #DEFINE!
		PyObject *seqval = PyObject_GetAttrString(pyobjref, "layers_local_view");
		std::array<bool, 8> resarr;
		for (int i = 0; i < 8; i++)
			resarr[i] = PyLong_AsLong(PySequence_GetItem(seqval, i)) == 1;
		return resarr;
	}

	/** Setter: 3D local view layers the object base is on */
	void layers_local_view(bool values[8]) { /* not implemented */ }

	/** Getter: Object base selection state */
	bool select() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "select")) == 1;
	}

	/** Setter: Object base selection state */
	void select(bool value) {
		PyObject_SetAttrString(pyobjref, "select", Py_BuildValue("i", value));
	}

	/**
	 * Sets the object layers from a 3D View (use when adding an object in local view)
	 * @param Param 'view'
	 */
	void layers_from_view(SpaceView3D view);

};

/**************** Vertex Group ****************/

/**
 * Group of vertices, used for armature deform and other purposes
 */
class VertexGroup : public pyUniplug {
public:
	VertexGroup(PyObject* pyobj) : pyUniplug(pyobj) {}

	VertexGroup() : pyUniplug(0)
	{
		// not implemented
	}

	/** Getter: Vertex group name */
	std::string name() { /* not implemented */ throw NULL; }
	/** Setter: Vertex group name */
	void name(const std::string& value) { /* not implemented */ }

	/** Getter: Maintain the relative weights for the group */
	bool lock_weight() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "lock_weight")) == 1;
	}

	/** Setter: Maintain the relative weights for the group */
	void lock_weight(bool value) {
		PyObject_SetAttrString(pyobjref, "lock_weight", Py_BuildValue("i", value));
	}

	/** Getter: Index number of the vertex group */
	int index() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "index"));
	}

	/** Setter: Index number of the vertex group */
	void index(int value) {
		PyObject_SetAttrString(pyobjref, "index", Py_BuildValue("i", value));
	}

	/**
	 * Enum: assign_mode_items
	 */
	enum assign_mode_items {
		assign_mode_items_REPLACE = 1,	/**< Replace */
		assign_mode_items_ADD = 2,	/**< Add */
		assign_mode_items_SUBTRACT = 3	/**< Subtract */
	};

	/**
	 * Add vertices to the group
	 * @param Index List
	 * @param Vertex weight
	 * @param Vertex assign mode
	 */
	void add(int index_len, int index, float weight, assign_mode_items type)
	{
		// not implemented
	}

	/**
	 * Remove a vertex from the group
	 * @param Index List
	 */
	void remove(int index_len, int index)
	{
		// not implemented
	}

	/**
	 * Get a vertex weight from the group
	 * @param The index of the vertex
	 * @return Vertex weight
	 */
	float weight(int index)
	{
		// not implemented
		throw NULL;
	}

};

/**************** Material Slot ****************/

/**
 * Material slot in an object
 */
class MaterialSlot : public pyUniplug {
public:
	MaterialSlot(PyObject* pyobj) : pyUniplug(pyobj) {}

	MaterialSlot() : pyUniplug(0)
	{
		// not implemented
	}

	/** Getter: Material datablock used by this material slot */
	Material material() {
		/* not implemented */ throw NULL;
	}

	enum link_enum {
		link_OBJECT = 1,
		link_DATA = 0,
	};

	/** Getter: Link material to object or the object's data */
	link_enum link() { /* not implemented */ throw NULL; }
	/** Setter: Link material to object or the object's data */
	void link(link_enum value) { /* not implemented */ }

	/** Getter: Material slot name */
	std::string name() { /* not implemented */ throw NULL; }
	/** Setter: Material slot name */
	void name(const std::string& value) { /* not implemented */ }

};

/**************** Object Duplicate ****************/

/**
 * An object duplicate
 */
class DupliObject : public pyUniplug {
public:
	DupliObject(PyObject* pyobj) : pyUniplug(pyobj) {}

	DupliObject() : pyUniplug(0)
	{
		// not implemented
	}

	/** Getter: Object being duplicated */
	Object object_value() {
		/* not implemented */ throw NULL;
	}

	/** Getter: Object duplicate transformation matrix */
	std::array<float, 16> matrix() {
		// TODO: MISSING DEREF! USE #DEFINE!
		PyObject *seqval = PyObject_GetAttrString(pyobjref, "matrix");
		std::array<float, 16> resarr;
		for (int i = 0; i < 16; i++)
			resarr[i] = (float)PyFloat_AsDouble(PySequence_GetItem(seqval, i));
		return resarr;
	}

	/** Setter: Object duplicate transformation matrix */
	void matrix(float values[16]) { /* not implemented */ }

	/** Getter: Don't show dupli object in viewport or render */
	bool hide() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "hide")) == 1;
	}

	/** Setter: Don't show dupli object in viewport or render */
	void hide(bool value) {
		PyObject_SetAttrString(pyobjref, "hide", Py_BuildValue("i", value));
	}

	/** Getter: Index in the lowest-level dupli list */
	int index() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "index"));
	}

	/** Setter: Index in the lowest-level dupli list */
	void index(int value) {
		PyObject_SetAttrString(pyobjref, "index", Py_BuildValue("i", value));
	}

	/** Getter: Persistent identifier for inter-frame matching of objects with motion blur */
	std::array<int, 8> persistent_id() {
		// TODO: MISSING DEREF! USE #DEFINE!
		PyObject *seqval = PyObject_GetAttrString(pyobjref, "persistent_id");
		std::array<int, 8> resarr;
		for (int i = 0; i < 8; i++)
			resarr[i] = PyLong_AsLong(PySequence_GetItem(seqval, i));
		return resarr;
	}

	/** Setter: Persistent identifier for inter-frame matching of objects with motion blur */
	void persistent_id(int values[8]) { /* not implemented */ }

	/** Getter: Particle system that this dupli object was instanced from */
	ParticleSystem particle_system();

	/** Getter: Generated coordinates in parent object space */
	std::array<float, 3> orco() {
		// TODO: MISSING DEREF! USE #DEFINE!
		PyObject *seqval = PyObject_GetAttrString(pyobjref, "orco");
		std::array<float, 3> resarr;
		for (int i = 0; i < 3; i++)
			resarr[i] = (float)PyFloat_AsDouble(PySequence_GetItem(seqval, i));
		return resarr;
	}

	/** Setter: Generated coordinates in parent object space */
	void orco(float values[3]) { /* not implemented */ }

	/** Getter: UV coordinates in parent object space */
	std::array<float, 2> uv() {
		// TODO: MISSING DEREF! USE #DEFINE!
		PyObject *seqval = PyObject_GetAttrString(pyobjref, "uv");
		std::array<float, 2> resarr;
		for (int i = 0; i < 2; i++)
			resarr[i] = (float)PyFloat_AsDouble(PySequence_GetItem(seqval, i));
		return resarr;
	}

	/** Setter: UV coordinates in parent object space */
	void uv(float values[2]) { /* not implemented */ }

	enum type_enum {
		type_NONE = 0,
		type_FRAMES = 8,
		type_VERTS = 16,
		type_FACES = 512,
		type_GROUP = 256,
	};

	/** Getter: Duplicator type that generated this dupli object */
	type_enum type() { /* not implemented */ throw NULL; }
	/** Setter: Duplicator type that generated this dupli object */
	void type(type_enum value) { /* not implemented */ }

};

/**************** LodLevel ****************/

/**
 * 
 */
class LodLevel : public pyUniplug {
public:
	LodLevel(PyObject* pyobj) : pyUniplug(pyobj) {}

	LodLevel() : pyUniplug(0)
	{
		// not implemented
	}

	/** Getter: Distance to begin using this level of detail */
	float distance() { /* not implemented */ throw NULL; }
	/** Setter: Distance to begin using this level of detail */
	void distance(float value) {
		PyObject_SetAttrString(pyobjref, "distance", Py_BuildValue("f", value));
	}

	/** Getter: Minimum distance change required to transition to the previous level of detail */
	int object_hysteresis_percentage() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "object_hysteresis_percentage"));
	}

	/** Setter: Minimum distance change required to transition to the previous level of detail */
	void object_hysteresis_percentage(int value) {
		PyObject_SetAttrString(pyobjref, "object_hysteresis_percentage", Py_BuildValue("i", value));
	}

	/** Getter: Object to use for this level of detail */
	Object object_value() {
		/* not implemented */ throw NULL;
	}

	/** Getter: Use the mesh from this object at this level of detail */
	bool use_mesh() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_mesh")) == 1;
	}

	/** Setter: Use the mesh from this object at this level of detail */
	void use_mesh(bool value) {
		PyObject_SetAttrString(pyobjref, "use_mesh", Py_BuildValue("i", value));
	}

	/** Getter: Use the material from this object at this level of detail */
	bool use_material() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_material")) == 1;
	}

	/** Setter: Use the material from this object at this level of detail */
	void use_material(bool value) {
		PyObject_SetAttrString(pyobjref, "use_material", Py_BuildValue("i", value));
	}

	/** Getter: Override LoD Hysteresis scene setting for this LoD level */
	bool use_object_hysteresis() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_object_hysteresis")) == 1;
	}

	/** Setter: Override LoD Hysteresis scene setting for this LoD level */
	void use_object_hysteresis(bool value) {
		PyObject_SetAttrString(pyobjref, "use_object_hysteresis", Py_BuildValue("i", value));
	}

};

/**************** Point Cache ****************/

/**
 * Point cache for physics simulations
 */
class PointCache : public pyUniplug {
public:
	PointCache(PyObject* pyobj) : pyUniplug(pyobj) {}

	PointCache() : pyUniplug(0)
	{
		// not implemented
	}

	/** Getter: Frame on which the simulation starts */
	int frame_start() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "frame_start"));
	}

	/** Setter: Frame on which the simulation starts */
	void frame_start(int value) {
		PyObject_SetAttrString(pyobjref, "frame_start", Py_BuildValue("i", value));
	}

	/** Getter: Frame on which the simulation stops */
	int frame_end() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "frame_end"));
	}

	/** Setter: Frame on which the simulation stops */
	void frame_end(int value) {
		PyObject_SetAttrString(pyobjref, "frame_end", Py_BuildValue("i", value));
	}

	/** Getter: Number of frames between cached frames */
	int frame_step() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "frame_step"));
	}

	/** Setter: Number of frames between cached frames */
	void frame_step(int value) {
		PyObject_SetAttrString(pyobjref, "frame_step", Py_BuildValue("i", value));
	}

	/** Getter: Index number of cache files */
	int index() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "index"));
	}

	/** Setter: Index number of cache files */
	void index(int value) {
		PyObject_SetAttrString(pyobjref, "index", Py_BuildValue("i", value));
	}

	enum compression_enum {
		compression_NO = 0,
		compression_LIGHT = 1,
		compression_HEAVY = 2,
	};

	/** Getter: Compression method to be used */
	compression_enum compression() { /* not implemented */ throw NULL; }
	/** Setter: Compression method to be used */
	void compression(compression_enum value) { /* not implemented */ }

	/** Getter:  */
	bool is_baked() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "is_baked")) == 1;
	}

	/** Setter:  */
	void is_baked(bool value) {
		PyObject_SetAttrString(pyobjref, "is_baked", Py_BuildValue("i", value));
	}

	/** Getter:  */
	bool is_baking() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "is_baking")) == 1;
	}

	/** Setter:  */
	void is_baking(bool value) {
		PyObject_SetAttrString(pyobjref, "is_baking", Py_BuildValue("i", value));
	}

	/** Getter: Save cache files to disk (.blend file must be saved first) */
	bool use_disk_cache() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_disk_cache")) == 1;
	}

	/** Setter: Save cache files to disk (.blend file must be saved first) */
	void use_disk_cache(bool value) {
		PyObject_SetAttrString(pyobjref, "use_disk_cache", Py_BuildValue("i", value));
	}

	/** Getter:  */
	bool is_outdated() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "is_outdated")) == 1;
	}

	/** Setter:  */
	void is_outdated(bool value) {
		PyObject_SetAttrString(pyobjref, "is_outdated", Py_BuildValue("i", value));
	}

	/** Getter:  */
	bool is_frame_skip() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "is_frame_skip")) == 1;
	}

	/** Setter:  */
	void is_frame_skip(bool value) {
		PyObject_SetAttrString(pyobjref, "is_frame_skip", Py_BuildValue("i", value));
	}

	/** Getter: Cache name */
	std::string name() { /* not implemented */ throw NULL; }
	/** Setter: Cache name */
	void name(const std::string& value) { /* not implemented */ }

	/** Getter: Cache file path */
	std::string filepath() { /* not implemented */ throw NULL; }
	/** Setter: Cache file path */
	void filepath(const std::string& value) { /* not implemented */ }

	/** Getter: Info on current cache status */
	std::string info() { /* not implemented */ throw NULL; }
	/** Setter: Info on current cache status */
	void info(const std::string& value) { /* not implemented */ }

	/** Getter: Read cache from an external location */
	bool use_external() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_external")) == 1;
	}

	/** Setter: Read cache from an external location */
	void use_external(bool value) {
		PyObject_SetAttrString(pyobjref, "use_external", Py_BuildValue("i", value));
	}

	/** Getter: Use this file's path for the disk cache when library linked into another file (for local bakes per scene file, disable this option) */
	bool use_library_path() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_library_path")) == 1;
	}

	/** Setter: Use this file's path for the disk cache when library linked into another file (for local bakes per scene file, disable this option) */
	void use_library_path(bool value) {
		PyObject_SetAttrString(pyobjref, "use_library_path", Py_BuildValue("i", value));
	}

	/** Getter: Point cache list */
	std::map<std::string, PointCache> point_caches() {
		// TODO: MISSING DEREF! USE #DEFINE!
		PyObject *seqval = PyObject_GetAttrString(pyobjref, "point_caches");
		PyObject *seqkeys = PyObject_CallMethod(seqval, "keys", NULL);
		std::map<std::string, PointCache> resmap;
		for (int i = 0; i < PySequence_Length(seqval); i++) {
			PyObject *keyobj = PySequence_GetItem(seqkeys, i);
			std::string key = PyBytes_AsString(PyUnicode_AsASCIIString(keyobj));
			PointCache value = PointCache(PySequence_GetItem(seqval, i));
			resmap.insert(std::pair<std::string,PointCache>(key, value));
		}
		return resmap;
	}

	/** Setter: Point cache list */
	void point_caches(std::map<std::string, PointCache> value) { /* not implemented */ }

};

/**************** Collision Settings ****************/

/**
 * Collision settings for object in physics simulation
 */
class CollisionSettings : public pyUniplug {
public:
	CollisionSettings(PyObject* pyobj) : pyUniplug(pyobj) {}

	CollisionSettings() : pyUniplug(0)
	{
		// not implemented
	}

	/** Getter: Enable this objects as a collider for physics systems */
	bool use() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use")) == 1;
	}

	/** Setter: Enable this objects as a collider for physics systems */
	void use(bool value) {
		PyObject_SetAttrString(pyobjref, "use", Py_BuildValue("i", value));
	}

	/** Getter: Amount of damping during particle collision */
	float damping_factor() { /* not implemented */ throw NULL; }
	/** Setter: Amount of damping during particle collision */
	void damping_factor(float value) {
		PyObject_SetAttrString(pyobjref, "damping_factor", Py_BuildValue("f", value));
	}

	/** Getter: Random variation of damping */
	float damping_random() { /* not implemented */ throw NULL; }
	/** Setter: Random variation of damping */
	void damping_random(float value) {
		PyObject_SetAttrString(pyobjref, "damping_random", Py_BuildValue("f", value));
	}

	/** Getter: Amount of friction during particle collision */
	float friction_factor() { /* not implemented */ throw NULL; }
	/** Setter: Amount of friction during particle collision */
	void friction_factor(float value) {
		PyObject_SetAttrString(pyobjref, "friction_factor", Py_BuildValue("f", value));
	}

	/** Getter: Random variation of friction */
	float friction_random() { /* not implemented */ throw NULL; }
	/** Setter: Random variation of friction */
	void friction_random(float value) {
		PyObject_SetAttrString(pyobjref, "friction_random", Py_BuildValue("f", value));
	}

	/** Getter: Chance that the particle will pass through the mesh */
	float permeability() { /* not implemented */ throw NULL; }
	/** Setter: Chance that the particle will pass through the mesh */
	void permeability(float value) {
		PyObject_SetAttrString(pyobjref, "permeability", Py_BuildValue("f", value));
	}

	/** Getter: Kill collided particles */
	bool use_particle_kill() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_particle_kill")) == 1;
	}

	/** Setter: Kill collided particles */
	void use_particle_kill(bool value) {
		PyObject_SetAttrString(pyobjref, "use_particle_kill", Py_BuildValue("i", value));
	}

	/** Getter: Amount of stickiness to surface collision */
	float stickiness() { /* not implemented */ throw NULL; }
	/** Setter: Amount of stickiness to surface collision */
	void stickiness(float value) {
		PyObject_SetAttrString(pyobjref, "stickiness", Py_BuildValue("f", value));
	}

	/** Getter: Inner face thickness (only used by softbodies) */
	float thickness_inner() { /* not implemented */ throw NULL; }
	/** Setter: Inner face thickness (only used by softbodies) */
	void thickness_inner(float value) {
		PyObject_SetAttrString(pyobjref, "thickness_inner", Py_BuildValue("f", value));
	}

	/** Getter: Outer face thickness */
	float thickness_outer() { /* not implemented */ throw NULL; }
	/** Setter: Outer face thickness */
	void thickness_outer(float value) {
		PyObject_SetAttrString(pyobjref, "thickness_outer", Py_BuildValue("f", value));
	}

	/** Getter: Amount of damping during collision */
	float damping() { /* not implemented */ throw NULL; }
	/** Setter: Amount of damping during collision */
	void damping(float value) {
		PyObject_SetAttrString(pyobjref, "damping", Py_BuildValue("f", value));
	}

	/** Getter: How much of effector force gets lost during collision with this object (in percent) */
	float absorption() { /* not implemented */ throw NULL; }
	/** Setter: How much of effector force gets lost during collision with this object (in percent) */
	void absorption(float value) {
		PyObject_SetAttrString(pyobjref, "absorption", Py_BuildValue("f", value));
	}

};

/**************** Effector Weights ****************/

/**
 * Effector weights for physics simulation
 */
class EffectorWeights : public pyUniplug {
public:
	EffectorWeights(PyObject* pyobj) : pyUniplug(pyobj) {}

	EffectorWeights() : pyUniplug(0)
	{
		// not implemented
	}

	/** Getter: Use force fields when growing hair */
	bool apply_to_hair_growing() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "apply_to_hair_growing")) == 1;
	}

	/** Setter: Use force fields when growing hair */
	void apply_to_hair_growing(bool value) {
		PyObject_SetAttrString(pyobjref, "apply_to_hair_growing", Py_BuildValue("i", value));
	}

	/** Getter: Limit effectors to this Group */
	Group group() {
		/* not implemented */ throw NULL;
	}

	/** Getter: Global gravity weight */
	float gravity() { /* not implemented */ throw NULL; }
	/** Setter: Global gravity weight */
	void gravity(float value) {
		PyObject_SetAttrString(pyobjref, "gravity", Py_BuildValue("f", value));
	}

	/** Getter: All effector's weight */
	float all() { /* not implemented */ throw NULL; }
	/** Setter: All effector's weight */
	void all(float value) {
		PyObject_SetAttrString(pyobjref, "all", Py_BuildValue("f", value));
	}

	/** Getter: Force effector weight */
	float force() { /* not implemented */ throw NULL; }
	/** Setter: Force effector weight */
	void force(float value) {
		PyObject_SetAttrString(pyobjref, "force", Py_BuildValue("f", value));
	}

	/** Getter: Vortex effector weight */
	float vortex() { /* not implemented */ throw NULL; }
	/** Setter: Vortex effector weight */
	void vortex(float value) {
		PyObject_SetAttrString(pyobjref, "vortex", Py_BuildValue("f", value));
	}

	/** Getter: Magnetic effector weight */
	float magnetic() { /* not implemented */ throw NULL; }
	/** Setter: Magnetic effector weight */
	void magnetic(float value) {
		PyObject_SetAttrString(pyobjref, "magnetic", Py_BuildValue("f", value));
	}

	/** Getter: Wind effector weight */
	float wind() { /* not implemented */ throw NULL; }
	/** Setter: Wind effector weight */
	void wind(float value) {
		PyObject_SetAttrString(pyobjref, "wind", Py_BuildValue("f", value));
	}

	/** Getter: Curve guide effector weight */
	float curve_guide() { /* not implemented */ throw NULL; }
	/** Setter: Curve guide effector weight */
	void curve_guide(float value) {
		PyObject_SetAttrString(pyobjref, "curve_guide", Py_BuildValue("f", value));
	}

	/** Getter: Texture effector weight */
	float texture() { /* not implemented */ throw NULL; }
	/** Setter: Texture effector weight */
	void texture(float value) {
		PyObject_SetAttrString(pyobjref, "texture", Py_BuildValue("f", value));
	}

	/** Getter: Harmonic effector weight */
	float harmonic() { /* not implemented */ throw NULL; }
	/** Setter: Harmonic effector weight */
	void harmonic(float value) {
		PyObject_SetAttrString(pyobjref, "harmonic", Py_BuildValue("f", value));
	}

	/** Getter: Charge effector weight */
	float charge() { /* not implemented */ throw NULL; }
	/** Setter: Charge effector weight */
	void charge(float value) {
		PyObject_SetAttrString(pyobjref, "charge", Py_BuildValue("f", value));
	}

	/** Getter: Lennard-Jones effector weight */
	float lennardjones() { /* not implemented */ throw NULL; }
	/** Setter: Lennard-Jones effector weight */
	void lennardjones(float value) {
		PyObject_SetAttrString(pyobjref, "lennardjones", Py_BuildValue("f", value));
	}

	/** Getter: Boid effector weight */
	float boid() { /* not implemented */ throw NULL; }
	/** Setter: Boid effector weight */
	void boid(float value) {
		PyObject_SetAttrString(pyobjref, "boid", Py_BuildValue("f", value));
	}

	/** Getter: Turbulence effector weight */
	float turbulence() { /* not implemented */ throw NULL; }
	/** Setter: Turbulence effector weight */
	void turbulence(float value) {
		PyObject_SetAttrString(pyobjref, "turbulence", Py_BuildValue("f", value));
	}

	/** Getter: Drag effector weight */
	float drag() { /* not implemented */ throw NULL; }
	/** Setter: Drag effector weight */
	void drag(float value) {
		PyObject_SetAttrString(pyobjref, "drag", Py_BuildValue("f", value));
	}

	/** Getter: Smoke Flow effector weight */
	float smokeflow() { /* not implemented */ throw NULL; }
	/** Setter: Smoke Flow effector weight */
	void smokeflow(float value) {
		PyObject_SetAttrString(pyobjref, "smokeflow", Py_BuildValue("f", value));
	}

};

/**************** Field Settings ****************/

/**
 * Field settings for an object in physics simulation
 */
class FieldSettings : public pyUniplug {
public:
	FieldSettings(PyObject* pyobj) : pyUniplug(pyobj) {}

	FieldSettings() : pyUniplug(0)
	{
		// not implemented
	}

	enum type_enum {
		type_NONE = 0,
		type_FORCE = 1,
		type_WIND = 4,
		type_VORTEX = 2,
		type_MAGNET = 3,
		type_HARMONIC = 7,
		type_CHARGE = 8,
		type_LENNARDJ = 9,
		type_TEXTURE = 6,
		type_GUIDE = 5,
		type_BOID = 10,
		type_TURBULENCE = 11,
		type_DRAG = 12,
		type_SMOKE_FLOW = 13,
	};

	/** Getter: Type of field */
	type_enum type() { /* not implemented */ throw NULL; }
	/** Setter: Type of field */
	void type(type_enum value) { /* not implemented */ }

	enum shape_enum {
		shape_POINT = 0,
		shape_PLANE = 1,
		shape_SURFACE = 2,
		shape_POINTS = 3,
	};

	/** Getter: Which direction is used to calculate the effector force */
	shape_enum shape() { /* not implemented */ throw NULL; }
	/** Setter: Which direction is used to calculate the effector force */
	void shape(shape_enum value) { /* not implemented */ }

	enum falloff_type_enum {
		falloff_type_SPHERE = 0,
		falloff_type_TUBE = 1,
		falloff_type_CONE = 2,
	};

	/** Getter:  */
	falloff_type_enum falloff_type() { /* not implemented */ throw NULL; }
	/** Setter:  */
	void falloff_type(falloff_type_enum value) { /* not implemented */ }

	enum texture_mode_enum {
		texture_mode_RGB = 0,
		texture_mode_GRADIENT = 1,
		texture_mode_CURL = 2,
	};

	/** Getter: How the texture effect is calculated (RGB & Curl need a RGB texture, else Gradient will be used instead) */
	texture_mode_enum texture_mode() { /* not implemented */ throw NULL; }
	/** Setter: How the texture effect is calculated (RGB & Curl need a RGB texture, else Gradient will be used instead) */
	void texture_mode(texture_mode_enum value) { /* not implemented */ }

	enum z_direction_enum {
		z_direction_BOTH = 0,
		z_direction_POSITIVE = 1,
		z_direction_NEGATIVE = 2,
	};

	/** Getter: Effect in full or only positive/negative Z direction */
	z_direction_enum z_direction() { /* not implemented */ throw NULL; }
	/** Setter: Effect in full or only positive/negative Z direction */
	void z_direction(z_direction_enum value) { /* not implemented */ }

	/** Getter: Strength of force field */
	float strength() { /* not implemented */ throw NULL; }
	/** Setter: Strength of force field */
	void strength(float value) {
		PyObject_SetAttrString(pyobjref, "strength", Py_BuildValue("f", value));
	}

	/** Getter: Drag component proportional to velocity */
	float linear_drag() { /* not implemented */ throw NULL; }
	/** Setter: Drag component proportional to velocity */
	void linear_drag(float value) {
		PyObject_SetAttrString(pyobjref, "linear_drag", Py_BuildValue("f", value));
	}

	/** Getter: Damping of the harmonic force */
	float harmonic_damping() { /* not implemented */ throw NULL; }
	/** Setter: Damping of the harmonic force */
	void harmonic_damping(float value) {
		PyObject_SetAttrString(pyobjref, "harmonic_damping", Py_BuildValue("f", value));
	}

	/** Getter: Drag component proportional to the square of velocity */
	float quadratic_drag() { /* not implemented */ throw NULL; }
	/** Setter: Drag component proportional to the square of velocity */
	void quadratic_drag(float value) {
		PyObject_SetAttrString(pyobjref, "quadratic_drag", Py_BuildValue("f", value));
	}

	/** Getter: Convert effector force into air flow velocity */
	float flow() { /* not implemented */ throw NULL; }
	/** Setter: Convert effector force into air flow velocity */
	void flow(float value) {
		PyObject_SetAttrString(pyobjref, "flow", Py_BuildValue("f", value));
	}

	/** Getter: Inwards component of the vortex force */
	float inflow() { /* not implemented */ throw NULL; }
	/** Setter: Inwards component of the vortex force */
	void inflow(float value) {
		PyObject_SetAttrString(pyobjref, "inflow", Py_BuildValue("f", value));
	}

	/** Getter: Size of the turbulence */
	float size() { /* not implemented */ throw NULL; }
	/** Setter: Size of the turbulence */
	void size(float value) {
		PyObject_SetAttrString(pyobjref, "size", Py_BuildValue("f", value));
	}

	/** Getter: Rest length of the harmonic force */
	float rest_length() { /* not implemented */ throw NULL; }
	/** Setter: Rest length of the harmonic force */
	void rest_length(float value) {
		PyObject_SetAttrString(pyobjref, "rest_length", Py_BuildValue("f", value));
	}

	/** Getter: Falloff power (real gravitational falloff = 2) */
	float falloff_power() { /* not implemented */ throw NULL; }
	/** Setter: Falloff power (real gravitational falloff = 2) */
	void falloff_power(float value) {
		PyObject_SetAttrString(pyobjref, "falloff_power", Py_BuildValue("f", value));
	}

	/** Getter: Minimum distance for the field's fall-off */
	float distance_min() { /* not implemented */ throw NULL; }
	/** Setter: Minimum distance for the field's fall-off */
	void distance_min(float value) {
		PyObject_SetAttrString(pyobjref, "distance_min", Py_BuildValue("f", value));
	}

	/** Getter: Maximum distance for the field to work */
	float distance_max() { /* not implemented */ throw NULL; }
	/** Setter: Maximum distance for the field to work */
	void distance_max(float value) {
		PyObject_SetAttrString(pyobjref, "distance_max", Py_BuildValue("f", value));
	}

	/** Getter: Minimum radial distance for the field's fall-off */
	float radial_min() { /* not implemented */ throw NULL; }
	/** Setter: Minimum radial distance for the field's fall-off */
	void radial_min(float value) {
		PyObject_SetAttrString(pyobjref, "radial_min", Py_BuildValue("f", value));
	}

	/** Getter: Maximum radial distance for the field to work */
	float radial_max() { /* not implemented */ throw NULL; }
	/** Setter: Maximum radial distance for the field to work */
	void radial_max(float value) {
		PyObject_SetAttrString(pyobjref, "radial_max", Py_BuildValue("f", value));
	}

	/** Getter: Radial falloff power (real gravitational falloff = 2) */
	float radial_falloff() { /* not implemented */ throw NULL; }
	/** Setter: Radial falloff power (real gravitational falloff = 2) */
	void radial_falloff(float value) {
		PyObject_SetAttrString(pyobjref, "radial_falloff", Py_BuildValue("f", value));
	}

	/** Getter: Defines size of derivative offset used for calculating gradient and curl */
	float texture_nabla() { /* not implemented */ throw NULL; }
	/** Setter: Defines size of derivative offset used for calculating gradient and curl */
	void texture_nabla(float value) {
		PyObject_SetAttrString(pyobjref, "texture_nabla", Py_BuildValue("f", value));
	}

	/** Getter: Amount of noise for the force strength */
	float noise() { /* not implemented */ throw NULL; }
	/** Setter: Amount of noise for the force strength */
	void noise(float value) {
		PyObject_SetAttrString(pyobjref, "noise", Py_BuildValue("f", value));
	}

	/** Getter: Seed of the noise */
	int seed() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "seed"));
	}

	/** Setter: Seed of the noise */
	void seed(int value) {
		PyObject_SetAttrString(pyobjref, "seed", Py_BuildValue("i", value));
	}

	/** Getter: Use a minimum distance for the field's fall-off */
	bool use_min_distance() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_min_distance")) == 1;
	}

	/** Setter: Use a minimum distance for the field's fall-off */
	void use_min_distance(bool value) {
		PyObject_SetAttrString(pyobjref, "use_min_distance", Py_BuildValue("i", value));
	}

	/** Getter: Use a maximum distance for the field to work */
	bool use_max_distance() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_max_distance")) == 1;
	}

	/** Setter: Use a maximum distance for the field to work */
	void use_max_distance(bool value) {
		PyObject_SetAttrString(pyobjref, "use_max_distance", Py_BuildValue("i", value));
	}

	/** Getter: Use a minimum radial distance for the field's fall-off */
	bool use_radial_min() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_radial_min")) == 1;
	}

	/** Setter: Use a minimum radial distance for the field's fall-off */
	void use_radial_min(bool value) {
		PyObject_SetAttrString(pyobjref, "use_radial_min", Py_BuildValue("i", value));
	}

	/** Getter: Use a maximum radial distance for the field to work */
	bool use_radial_max() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_radial_max")) == 1;
	}

	/** Setter: Use a maximum radial distance for the field to work */
	void use_radial_max(bool value) {
		PyObject_SetAttrString(pyobjref, "use_radial_max", Py_BuildValue("i", value));
	}

	/** Getter: Use object/global coordinates for texture */
	bool use_object_coords() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_object_coords")) == 1;
	}

	/** Setter: Use object/global coordinates for texture */
	void use_object_coords(bool value) {
		PyObject_SetAttrString(pyobjref, "use_object_coords", Py_BuildValue("i", value));
	}

	/** Getter: Use effector/global coordinates for turbulence */
	bool use_global_coords() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_global_coords")) == 1;
	}

	/** Setter: Use effector/global coordinates for turbulence */
	void use_global_coords(bool value) {
		PyObject_SetAttrString(pyobjref, "use_global_coords", Py_BuildValue("i", value));
	}

	/** Getter: Apply force only in 2D */
	bool use_2d_force() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_2d_force")) == 1;
	}

	/** Setter: Apply force only in 2D */
	void use_2d_force(bool value) {
		PyObject_SetAttrString(pyobjref, "use_2d_force", Py_BuildValue("i", value));
	}

	/** Getter: Texture coordinates from root particle locations */
	bool use_root_coords() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_root_coords")) == 1;
	}

	/** Setter: Texture coordinates from root particle locations */
	void use_root_coords(bool value) {
		PyObject_SetAttrString(pyobjref, "use_root_coords", Py_BuildValue("i", value));
	}

	/** Getter: Effect particles' location */
	bool apply_to_location() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "apply_to_location")) == 1;
	}

	/** Setter: Effect particles' location */
	void apply_to_location(bool value) {
		PyObject_SetAttrString(pyobjref, "apply_to_location", Py_BuildValue("i", value));
	}

	/** Getter: Effect particles' dynamic rotation */
	bool apply_to_rotation() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "apply_to_rotation")) == 1;
	}

	/** Setter: Effect particles' dynamic rotation */
	void apply_to_rotation(bool value) {
		PyObject_SetAttrString(pyobjref, "apply_to_rotation", Py_BuildValue("i", value));
	}

	/** Getter: Force gets absorbed by collision objects */
	bool use_absorption() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_absorption")) == 1;
	}

	/** Setter: Force gets absorbed by collision objects */
	void use_absorption(bool value) {
		PyObject_SetAttrString(pyobjref, "use_absorption", Py_BuildValue("i", value));
	}

	/** Getter: Every point is effected by multiple springs */
	bool use_multiple_springs() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_multiple_springs")) == 1;
	}

	/** Setter: Every point is effected by multiple springs */
	void use_multiple_springs(bool value) {
		PyObject_SetAttrString(pyobjref, "use_multiple_springs", Py_BuildValue("i", value));
	}

	/** Getter: Adjust force strength based on smoke density */
	bool use_smoke_density() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_smoke_density")) == 1;
	}

	/** Setter: Adjust force strength based on smoke density */
	void use_smoke_density(bool value) {
		PyObject_SetAttrString(pyobjref, "use_smoke_density", Py_BuildValue("i", value));
	}

	/** Getter: Texture to use as force */
	Texture texture() {
		/* not implemented */ throw NULL;
	}

	/** Getter: Select domain object of the smoke simulation */
	Object source_object() {
		/* not implemented */ throw NULL;
	}

	/** Getter: The distance from which particles are affected fully */
	float guide_minimum() { /* not implemented */ throw NULL; }
	/** Setter: The distance from which particles are affected fully */
	void guide_minimum(float value) {
		PyObject_SetAttrString(pyobjref, "guide_minimum", Py_BuildValue("f", value));
	}

	/** Getter: Guide-free time from particle life's end */
	float guide_free() { /* not implemented */ throw NULL; }
	/** Setter: Guide-free time from particle life's end */
	void guide_free(float value) {
		PyObject_SetAttrString(pyobjref, "guide_free", Py_BuildValue("f", value));
	}

	/** Getter: Based on distance/falloff it adds a portion of the entire path */
	bool use_guide_path_add() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_guide_path_add")) == 1;
	}

	/** Setter: Based on distance/falloff it adds a portion of the entire path */
	void use_guide_path_add(bool value) {
		PyObject_SetAttrString(pyobjref, "use_guide_path_add", Py_BuildValue("i", value));
	}

	/** Getter: Use curve weights to influence the particle influence along the curve */
	bool use_guide_path_weight() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_guide_path_weight")) == 1;
	}

	/** Setter: Use curve weights to influence the particle influence along the curve */
	void use_guide_path_weight(bool value) {
		PyObject_SetAttrString(pyobjref, "use_guide_path_weight", Py_BuildValue("i", value));
	}

	/** Getter: Amount of clumping */
	float guide_clump_amount() { /* not implemented */ throw NULL; }
	/** Setter: Amount of clumping */
	void guide_clump_amount(float value) {
		PyObject_SetAttrString(pyobjref, "guide_clump_amount", Py_BuildValue("f", value));
	}

	/** Getter: Shape of clumping */
	float guide_clump_shape() { /* not implemented */ throw NULL; }
	/** Setter: Shape of clumping */
	void guide_clump_shape(float value) {
		PyObject_SetAttrString(pyobjref, "guide_clump_shape", Py_BuildValue("f", value));
	}

	enum guide_kink_type_enum {
		guide_kink_type_NONE = 0,
		guide_kink_type_CURL = 1,
		guide_kink_type_RADIAL = 2,
		guide_kink_type_WAVE = 3,
		guide_kink_type_BRAID = 4,
		guide_kink_type_ROTATION = 5,
		guide_kink_type_ROLL = 6,
	};

	/** Getter: Type of periodic offset on the curve */
	guide_kink_type_enum guide_kink_type() { /* not implemented */ throw NULL; }
	/** Setter: Type of periodic offset on the curve */
	void guide_kink_type(guide_kink_type_enum value) { /* not implemented */ }

	enum guide_kink_axis_enum {
		guide_kink_axis_X = 0,
		guide_kink_axis_Y = 1,
		guide_kink_axis_Z = 2,
	};

	/** Getter: Which axis to use for offset */
	guide_kink_axis_enum guide_kink_axis() { /* not implemented */ throw NULL; }
	/** Setter: Which axis to use for offset */
	void guide_kink_axis(guide_kink_axis_enum value) { /* not implemented */ }

	/** Getter: The frequency of the offset (1/total length) */
	float guide_kink_frequency() { /* not implemented */ throw NULL; }
	/** Setter: The frequency of the offset (1/total length) */
	void guide_kink_frequency(float value) {
		PyObject_SetAttrString(pyobjref, "guide_kink_frequency", Py_BuildValue("f", value));
	}

	/** Getter: Adjust the offset to the beginning/end */
	float guide_kink_shape() { /* not implemented */ throw NULL; }
	/** Setter: Adjust the offset to the beginning/end */
	void guide_kink_shape(float value) {
		PyObject_SetAttrString(pyobjref, "guide_kink_shape", Py_BuildValue("f", value));
	}

	/** Getter: The amplitude of the offset */
	float guide_kink_amplitude() { /* not implemented */ throw NULL; }
	/** Setter: The amplitude of the offset */
	void guide_kink_amplitude(float value) {
		PyObject_SetAttrString(pyobjref, "guide_kink_amplitude", Py_BuildValue("f", value));
	}

};

/**************** Game Soft Body Settings ****************/

/**
 * Soft body simulation settings for an object in the game engine
 */
class GameSoftBodySettings : public pyUniplug {
public:
	GameSoftBodySettings(PyObject* pyobj) : pyUniplug(pyobj) {}

	GameSoftBodySettings() : pyUniplug(0)
	{
		// not implemented
	}

	/** Getter: Linear stiffness of the soft body links */
	float linear_stiffness() { /* not implemented */ throw NULL; }
	/** Setter: Linear stiffness of the soft body links */
	void linear_stiffness(float value) {
		PyObject_SetAttrString(pyobjref, "linear_stiffness", Py_BuildValue("f", value));
	}

	/** Getter: Dynamic Friction */
	float dynamic_friction() { /* not implemented */ throw NULL; }
	/** Setter: Dynamic Friction */
	void dynamic_friction(float value) {
		PyObject_SetAttrString(pyobjref, "dynamic_friction", Py_BuildValue("f", value));
	}

	/** Getter: Shape matching threshold */
	float shape_threshold() { /* not implemented */ throw NULL; }
	/** Setter: Shape matching threshold */
	void shape_threshold(float value) {
		PyObject_SetAttrString(pyobjref, "shape_threshold", Py_BuildValue("f", value));
	}

	/** Getter: Collision margin for soft body. Small value makes the algorithm unstable */
	float collision_margin() { /* not implemented */ throw NULL; }
	/** Setter: Collision margin for soft body. Small value makes the algorithm unstable */
	void collision_margin(float value) {
		PyObject_SetAttrString(pyobjref, "collision_margin", Py_BuildValue("f", value));
	}

	/** Getter: Welding threshold: distance between nearby vertices to be considered equal => set to 0.0 to disable welding test and speed up scene loading (ok if the mesh has no duplicates) */
	float weld_threshold() { /* not implemented */ throw NULL; }
	/** Setter: Welding threshold: distance between nearby vertices to be considered equal => set to 0.0 to disable welding test and speed up scene loading (ok if the mesh has no duplicates) */
	void weld_threshold(float value) {
		PyObject_SetAttrString(pyobjref, "weld_threshold", Py_BuildValue("f", value));
	}

	/** Getter: Position solver iterations */
	int location_iterations() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "location_iterations"));
	}

	/** Setter: Position solver iterations */
	void location_iterations(int value) {
		PyObject_SetAttrString(pyobjref, "location_iterations", Py_BuildValue("i", value));
	}

	/** Getter: Number of cluster iterations */
	int cluster_iterations() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "cluster_iterations"));
	}

	/** Setter: Number of cluster iterations */
	void cluster_iterations(int value) {
		PyObject_SetAttrString(pyobjref, "cluster_iterations", Py_BuildValue("i", value));
	}

	/** Getter: Enable soft body shape matching goal */
	bool use_shape_match() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_shape_match")) == 1;
	}

	/** Setter: Enable soft body shape matching goal */
	void use_shape_match(bool value) {
		PyObject_SetAttrString(pyobjref, "use_shape_match", Py_BuildValue("i", value));
	}

	/** Getter: Enable bending constraints */
	bool use_bending_constraints() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_bending_constraints")) == 1;
	}

	/** Setter: Enable bending constraints */
	void use_bending_constraints(bool value) {
		PyObject_SetAttrString(pyobjref, "use_bending_constraints", Py_BuildValue("i", value));
	}

	/** Getter: Enable cluster collision between soft and rigid body */
	bool use_cluster_rigid_to_softbody() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_cluster_rigid_to_softbody")) == 1;
	}

	/** Setter: Enable cluster collision between soft and rigid body */
	void use_cluster_rigid_to_softbody(bool value) {
		PyObject_SetAttrString(pyobjref, "use_cluster_rigid_to_softbody", Py_BuildValue("i", value));
	}

	/** Getter: Enable cluster collision between soft and soft body */
	bool use_cluster_soft_to_softbody() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_cluster_soft_to_softbody")) == 1;
	}

	/** Setter: Enable cluster collision between soft and soft body */
	void use_cluster_soft_to_softbody(bool value) {
		PyObject_SetAttrString(pyobjref, "use_cluster_soft_to_softbody", Py_BuildValue("i", value));
	}

};

/**************** Soft Body Settings ****************/

/**
 * Soft body simulation settings for an object
 */
class SoftBodySettings : public pyUniplug {
public:
	SoftBodySettings(PyObject* pyobj) : pyUniplug(pyobj) {}

	SoftBodySettings() : pyUniplug(0)
	{
		// not implemented
	}

	/** Getter: General media friction for point movements */
	float friction() { /* not implemented */ throw NULL; }
	/** Setter: General media friction for point movements */
	void friction(float value) {
		PyObject_SetAttrString(pyobjref, "friction", Py_BuildValue("f", value));
	}

	/** Getter: General Mass value */
	float mass() { /* not implemented */ throw NULL; }
	/** Setter: General Mass value */
	void mass(float value) {
		PyObject_SetAttrString(pyobjref, "mass", Py_BuildValue("f", value));
	}

	/** Getter: Control point mass values */
	std::string vertex_group_mass() { /* not implemented */ throw NULL; }
	/** Setter: Control point mass values */
	void vertex_group_mass(const std::string& value) { /* not implemented */ }

	/** Getter: Apply gravitation to point movement */
	float gravity() { /* not implemented */ throw NULL; }
	/** Setter: Apply gravitation to point movement */
	void gravity(float value) {
		PyObject_SetAttrString(pyobjref, "gravity", Py_BuildValue("f", value));
	}

	/** Getter: Tweak timing for physics to control frequency and speed */
	float speed() { /* not implemented */ throw NULL; }
	/** Setter: Tweak timing for physics to control frequency and speed */
	void speed(float value) {
		PyObject_SetAttrString(pyobjref, "speed", Py_BuildValue("f", value));
	}

	/** Getter: Control point weight values */
	std::string vertex_group_goal() { /* not implemented */ throw NULL; }
	/** Setter: Control point weight values */
	void vertex_group_goal(const std::string& value) { /* not implemented */ }

	/** Getter: Goal minimum, vertex weights are scaled to match this range */
	float goal_min() { /* not implemented */ throw NULL; }
	/** Setter: Goal minimum, vertex weights are scaled to match this range */
	void goal_min(float value) {
		PyObject_SetAttrString(pyobjref, "goal_min", Py_BuildValue("f", value));
	}

	/** Getter: Goal maximum, vertex weights are scaled to match this range */
	float goal_max() { /* not implemented */ throw NULL; }
	/** Setter: Goal maximum, vertex weights are scaled to match this range */
	void goal_max(float value) {
		PyObject_SetAttrString(pyobjref, "goal_max", Py_BuildValue("f", value));
	}

	/** Getter: Default Goal (vertex target position) value, when no Vertex Group used */
	float goal_default() { /* not implemented */ throw NULL; }
	/** Setter: Default Goal (vertex target position) value, when no Vertex Group used */
	void goal_default(float value) {
		PyObject_SetAttrString(pyobjref, "goal_default", Py_BuildValue("f", value));
	}

	/** Getter: Goal (vertex target position) spring stiffness */
	float goal_spring() { /* not implemented */ throw NULL; }
	/** Setter: Goal (vertex target position) spring stiffness */
	void goal_spring(float value) {
		PyObject_SetAttrString(pyobjref, "goal_spring", Py_BuildValue("f", value));
	}

	/** Getter: Goal (vertex target position) friction */
	float goal_friction() { /* not implemented */ throw NULL; }
	/** Setter: Goal (vertex target position) friction */
	void goal_friction(float value) {
		PyObject_SetAttrString(pyobjref, "goal_friction", Py_BuildValue("f", value));
	}

	/** Getter: Edge spring stiffness when longer than rest length */
	float pull() { /* not implemented */ throw NULL; }
	/** Setter: Edge spring stiffness when longer than rest length */
	void pull(float value) {
		PyObject_SetAttrString(pyobjref, "pull", Py_BuildValue("f", value));
	}

	/** Getter: Edge spring stiffness when shorter than rest length */
	float push() { /* not implemented */ throw NULL; }
	/** Setter: Edge spring stiffness when shorter than rest length */
	void push(float value) {
		PyObject_SetAttrString(pyobjref, "push", Py_BuildValue("f", value));
	}

	/** Getter: Edge spring friction */
	float damping() { /* not implemented */ throw NULL; }
	/** Setter: Edge spring friction */
	void damping(float value) {
		PyObject_SetAttrString(pyobjref, "damping", Py_BuildValue("f", value));
	}

	/** Getter: Alter spring length to shrink/blow up (unit %) 0 to disable */
	int spring_length() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "spring_length"));
	}

	/** Setter: Alter spring length to shrink/blow up (unit %) 0 to disable */
	void spring_length(int value) {
		PyObject_SetAttrString(pyobjref, "spring_length", Py_BuildValue("i", value));
	}

	/** Getter: Make edges 'sail' */
	int aero() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "aero"));
	}

	/** Setter: Make edges 'sail' */
	void aero(int value) {
		PyObject_SetAttrString(pyobjref, "aero", Py_BuildValue("i", value));
	}

	/** Getter: Permanent deform */
	int plastic() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "plastic"));
	}

	/** Setter: Permanent deform */
	void plastic(int value) {
		PyObject_SetAttrString(pyobjref, "plastic", Py_BuildValue("i", value));
	}

	/** Getter: Bending Stiffness */
	float bend() { /* not implemented */ throw NULL; }
	/** Setter: Bending Stiffness */
	void bend(float value) {
		PyObject_SetAttrString(pyobjref, "bend", Py_BuildValue("f", value));
	}

	/** Getter: Shear Stiffness */
	float shear() { /* not implemented */ throw NULL; }
	/** Setter: Shear Stiffness */
	void shear(float value) {
		PyObject_SetAttrString(pyobjref, "shear", Py_BuildValue("f", value));
	}

	/** Getter: Control point spring strength values */
	std::string vertex_group_spring() { /* not implemented */ throw NULL; }
	/** Setter: Control point spring strength values */
	void vertex_group_spring(const std::string& value) { /* not implemented */ }

	enum collision_type_enum {
		collision_type_MANUAL = 0,
		collision_type_AVERAGE = 1,
		collision_type_MINIMAL = 2,
		collision_type_MAXIMAL = 3,
		collision_type_MINMAX = 4,
	};

	/** Getter: Choose Collision Type */
	collision_type_enum collision_type() { /* not implemented */ throw NULL; }
	/** Setter: Choose Collision Type */
	void collision_type(collision_type_enum value) { /* not implemented */ }

	/** Getter: Absolute ball size or factor if not manually adjusted */
	float ball_size() { /* not implemented */ throw NULL; }
	/** Setter: Absolute ball size or factor if not manually adjusted */
	void ball_size(float value) {
		PyObject_SetAttrString(pyobjref, "ball_size", Py_BuildValue("f", value));
	}

	/** Getter: Ball inflating pressure */
	float ball_stiff() { /* not implemented */ throw NULL; }
	/** Setter: Ball inflating pressure */
	void ball_stiff(float value) {
		PyObject_SetAttrString(pyobjref, "ball_stiff", Py_BuildValue("f", value));
	}

	/** Getter: Blending to inelastic collision */
	float ball_damp() { /* not implemented */ throw NULL; }
	/** Setter: Blending to inelastic collision */
	void ball_damp(float value) {
		PyObject_SetAttrString(pyobjref, "ball_damp", Py_BuildValue("f", value));
	}

	/** Getter: The Runge-Kutta ODE solver error limit, low value gives more precision, high values speed */
	float error_threshold() { /* not implemented */ throw NULL; }
	/** Setter: The Runge-Kutta ODE solver error limit, low value gives more precision, high values speed */
	void error_threshold(float value) {
		PyObject_SetAttrString(pyobjref, "error_threshold", Py_BuildValue("f", value));
	}

	/** Getter: Minimal # solver steps/frame */
	int step_min() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "step_min"));
	}

	/** Setter: Minimal # solver steps/frame */
	void step_min(int value) {
		PyObject_SetAttrString(pyobjref, "step_min", Py_BuildValue("i", value));
	}

	/** Getter: Maximal # solver steps/frame */
	int step_max() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "step_max"));
	}

	/** Setter: Maximal # solver steps/frame */
	void step_max(int value) {
		PyObject_SetAttrString(pyobjref, "step_max", Py_BuildValue("i", value));
	}

	/** Getter: 'Viscosity' inside collision target */
	int choke() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "choke"));
	}

	/** Setter: 'Viscosity' inside collision target */
	void choke(int value) {
		PyObject_SetAttrString(pyobjref, "choke", Py_BuildValue("i", value));
	}

	/** Getter: Fuzziness while on collision, high values make collision handling faster but less stable */
	int fuzzy() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "fuzzy"));
	}

	/** Setter: Fuzziness while on collision, high values make collision handling faster but less stable */
	void fuzzy(int value) {
		PyObject_SetAttrString(pyobjref, "fuzzy", Py_BuildValue("i", value));
	}

	/** Getter: Use velocities for automagic step sizes */
	bool use_auto_step() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_auto_step")) == 1;
	}

	/** Setter: Use velocities for automagic step sizes */
	void use_auto_step(bool value) {
		PyObject_SetAttrString(pyobjref, "use_auto_step", Py_BuildValue("i", value));
	}

	/** Getter: Turn on SB diagnose console prints */
	bool use_diagnose() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_diagnose")) == 1;
	}

	/** Setter: Turn on SB diagnose console prints */
	void use_diagnose(bool value) {
		PyObject_SetAttrString(pyobjref, "use_diagnose", Py_BuildValue("i", value));
	}

	/** Getter: Estimate matrix... split to COM, ROT, SCALE */
	bool use_estimate_matrix() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_estimate_matrix")) == 1;
	}

	/** Setter: Estimate matrix... split to COM, ROT, SCALE */
	void use_estimate_matrix(bool value) {
		PyObject_SetAttrString(pyobjref, "use_estimate_matrix", Py_BuildValue("i", value));
	}

	/** Getter: Location of Center of mass */
	std::array<float, 3> location_mass_center() {
		// TODO: MISSING DEREF! USE #DEFINE!
		PyObject *seqval = PyObject_GetAttrString(pyobjref, "location_mass_center");
		std::array<float, 3> resarr;
		for (int i = 0; i < 3; i++)
			resarr[i] = (float)PyFloat_AsDouble(PySequence_GetItem(seqval, i));
		return resarr;
	}

	/** Setter: Location of Center of mass */
	void location_mass_center(float values[3]) { /* not implemented */ }

	/** Getter: Estimated rotation matrix */
	std::array<float, 9> rotation_estimate() {
		// TODO: MISSING DEREF! USE #DEFINE!
		PyObject *seqval = PyObject_GetAttrString(pyobjref, "rotation_estimate");
		std::array<float, 9> resarr;
		for (int i = 0; i < 9; i++)
			resarr[i] = (float)PyFloat_AsDouble(PySequence_GetItem(seqval, i));
		return resarr;
	}

	/** Setter: Estimated rotation matrix */
	void rotation_estimate(float values[9]) { /* not implemented */ }

	/** Getter: Estimated scale matrix */
	std::array<float, 9> scale_estimate() {
		// TODO: MISSING DEREF! USE #DEFINE!
		PyObject *seqval = PyObject_GetAttrString(pyobjref, "scale_estimate");
		std::array<float, 9> resarr;
		for (int i = 0; i < 9; i++)
			resarr[i] = (float)PyFloat_AsDouble(PySequence_GetItem(seqval, i));
		return resarr;
	}

	/** Setter: Estimated scale matrix */
	void scale_estimate(float values[9]) { /* not implemented */ }

	/** Getter: Define forces for vertices to stick to animated position */
	bool use_goal() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_goal")) == 1;
	}

	/** Setter: Define forces for vertices to stick to animated position */
	void use_goal(bool value) {
		PyObject_SetAttrString(pyobjref, "use_goal", Py_BuildValue("i", value));
	}

	/** Getter: Use Edges as springs */
	bool use_edges() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_edges")) == 1;
	}

	/** Setter: Use Edges as springs */
	void use_edges(bool value) {
		PyObject_SetAttrString(pyobjref, "use_edges", Py_BuildValue("i", value));
	}

	/** Getter: Add diagonal springs on 4-gons */
	bool use_stiff_quads() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_stiff_quads")) == 1;
	}

	/** Setter: Add diagonal springs on 4-gons */
	void use_stiff_quads(bool value) {
		PyObject_SetAttrString(pyobjref, "use_stiff_quads", Py_BuildValue("i", value));
	}

	/** Getter: Edges collide too */
	bool use_edge_collision() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_edge_collision")) == 1;
	}

	/** Setter: Edges collide too */
	void use_edge_collision(bool value) {
		PyObject_SetAttrString(pyobjref, "use_edge_collision", Py_BuildValue("i", value));
	}

	/** Getter: Faces collide too, can be very slow */
	bool use_face_collision() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_face_collision")) == 1;
	}

	/** Setter: Faces collide too, can be very slow */
	void use_face_collision(bool value) {
		PyObject_SetAttrString(pyobjref, "use_face_collision", Py_BuildValue("i", value));
	}

	enum aerodynamics_type_enum {
		aerodynamics_type_SIMPLE = 0,
		aerodynamics_type_LIFT_FORCE = 1,
	};

	/** Getter: Method of calculating aerodynamic interaction */
	aerodynamics_type_enum aerodynamics_type() { /* not implemented */ throw NULL; }
	/** Setter: Method of calculating aerodynamic interaction */
	void aerodynamics_type(aerodynamics_type_enum value) { /* not implemented */ }

	/** Getter: Enable naive vertex ball self collision */
	bool use_self_collision() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_self_collision")) == 1;
	}

	/** Setter: Enable naive vertex ball self collision */
	void use_self_collision(bool value) {
		PyObject_SetAttrString(pyobjref, "use_self_collision", Py_BuildValue("i", value));
	}

	/** Getter:  */
	EffectorWeights effector_weights() {
		/* not implemented */ throw NULL;
	}

};

/**************** Packed File ****************/

/**
 * External file packed into the .blend file
 */
class PackedFile : public pyUniplug {
public:
	PackedFile(PyObject* pyobj) : pyUniplug(pyobj) {}

	PackedFile() : pyUniplug(0)
	{
		// not implemented
	}

	/** Getter: Size of packed file in bytes */
	int size() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "size"));
	}

	/** Setter: Size of packed file in bytes */
	void size(int value) {
		PyObject_SetAttrString(pyobjref, "size", Py_BuildValue("i", value));
	}

	/** Getter: Raw data (bytes, exact content of the embedded file) */
	std::string data() { /* not implemented */ throw NULL; }
	/** Setter: Raw data (bytes, exact content of the embedded file) */
	void data(const std::string& value) { /* not implemented */ }

};

/**************** Palette Color ****************/

/**
 * 
 */
class PaletteColor : public pyUniplug {
public:
	PaletteColor(PyObject* pyobj) : pyUniplug(pyobj) {}

	PaletteColor() : pyUniplug(0)
	{
		// not implemented
	}

	/** Getter:  */
	std::array<float, 3> color() {
		// TODO: MISSING DEREF! USE #DEFINE!
		PyObject *seqval = PyObject_GetAttrString(pyobjref, "color");
		std::array<float, 3> resarr;
		for (int i = 0; i < 3; i++)
			resarr[i] = (float)PyFloat_AsDouble(PySequence_GetItem(seqval, i));
		return resarr;
	}

	/** Setter:  */
	void color(float values[3]) { /* not implemented */ }

	/** Getter:  */
	float strength() { /* not implemented */ throw NULL; }
	/** Setter:  */
	void strength(float value) {
		PyObject_SetAttrString(pyobjref, "strength", Py_BuildValue("f", value));
	}

	/** Getter:  */
	float weight() { /* not implemented */ throw NULL; }
	/** Setter:  */
	void weight(float value) {
		PyObject_SetAttrString(pyobjref, "weight", Py_BuildValue("f", value));
	}

};

/**************** Palette ****************/

/**
 * 
 */
class Palette : public ID {
public:
	Palette(PyObject* pyobj) : ID(pyobj) {}

	Palette() : ID(0)
	{
		// not implemented
	}

	/** Getter:  */
	std::map<std::string, PaletteColor> colors() {
		// TODO: MISSING DEREF! USE #DEFINE!
		PyObject *seqval = PyObject_GetAttrString(pyobjref, "colors");
		PyObject *seqkeys = PyObject_CallMethod(seqval, "keys", NULL);
		std::map<std::string, PaletteColor> resmap;
		for (int i = 0; i < PySequence_Length(seqval); i++) {
			PyObject *keyobj = PySequence_GetItem(seqkeys, i);
			std::string key = PyBytes_AsString(PyUnicode_AsASCIIString(keyobj));
			PaletteColor value = PaletteColor(PySequence_GetItem(seqval, i));
			resmap.insert(std::pair<std::string,PaletteColor>(key, value));
		}
		return resmap;
	}

	/** Setter:  */
	void colors(std::map<std::string, PaletteColor> value) { /* not implemented */ }

};

/**************** Particle Target ****************/

/**
 * Target particle system
 */
class ParticleTarget : public pyUniplug {
public:
	ParticleTarget(PyObject* pyobj) : pyUniplug(pyobj) {}

	ParticleTarget() : pyUniplug(0)
	{
		// not implemented
	}

	/** Getter: Particle target name */
	std::string name() { /* not implemented */ throw NULL; }
	/** Setter: Particle target name */
	void name(const std::string& value) { /* not implemented */ }

	/** Getter: The object that has the target particle system (empty if same object) */
	Object object_value() {
		/* not implemented */ throw NULL;
	}

	/** Getter: The index of particle system on the target object */
	int system() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "system"));
	}

	/** Setter: The index of particle system on the target object */
	void system(int value) {
		PyObject_SetAttrString(pyobjref, "system", Py_BuildValue("i", value));
	}

	/** Getter:  */
	float time() { /* not implemented */ throw NULL; }
	/** Setter:  */
	void time(float value) {
		PyObject_SetAttrString(pyobjref, "time", Py_BuildValue("f", value));
	}

	/** Getter:  */
	float duration() { /* not implemented */ throw NULL; }
	/** Setter:  */
	void duration(float value) {
		PyObject_SetAttrString(pyobjref, "duration", Py_BuildValue("f", value));
	}

	/** Getter: Keyed particles target is valid */
	bool is_valid() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "is_valid")) == 1;
	}

	/** Setter: Keyed particles target is valid */
	void is_valid(bool value) {
		PyObject_SetAttrString(pyobjref, "is_valid", Py_BuildValue("i", value));
	}

	enum alliance_enum {
		alliance_FRIEND = 1,
		alliance_NEUTRAL = 0,
		alliance_ENEMY = 2,
	};

	/** Getter:  */
	alliance_enum alliance() { /* not implemented */ throw NULL; }
	/** Setter:  */
	void alliance(alliance_enum value) { /* not implemented */ }

};

/**************** SPH Fluid Settings ****************/

/**
 * Settings for particle fluids physics
 */
class SPHFluidSettings : public pyUniplug {
public:
	SPHFluidSettings(PyObject* pyobj) : pyUniplug(pyobj) {}

	SPHFluidSettings() : pyUniplug(0)
	{
		// not implemented
	}

	enum solver_enum {
		solver_DDR = 0,
		solver_CLASSICAL = 1,
	};

	/** Getter: The code used to calculate internal forces on particles */
	solver_enum solver() { /* not implemented */ throw NULL; }
	/** Setter: The code used to calculate internal forces on particles */
	void solver(solver_enum value) { /* not implemented */ }

	/** Getter: Spring force */
	float spring_force() { /* not implemented */ throw NULL; }
	/** Setter: Spring force */
	void spring_force(float value) {
		PyObject_SetAttrString(pyobjref, "spring_force", Py_BuildValue("f", value));
	}

	/** Getter: Fluid interaction radius */
	float fluid_radius() { /* not implemented */ throw NULL; }
	/** Setter: Fluid interaction radius */
	void fluid_radius(float value) {
		PyObject_SetAttrString(pyobjref, "fluid_radius", Py_BuildValue("f", value));
	}

	/** Getter: Spring rest length (factor of particle radius) */
	float rest_length() { /* not implemented */ throw NULL; }
	/** Setter: Spring rest length (factor of particle radius) */
	void rest_length(float value) {
		PyObject_SetAttrString(pyobjref, "rest_length", Py_BuildValue("f", value));
	}

	/** Getter: Use viscoelastic springs instead of Hooke's springs */
	bool use_viscoelastic_springs() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_viscoelastic_springs")) == 1;
	}

	/** Setter: Use viscoelastic springs instead of Hooke's springs */
	void use_viscoelastic_springs(bool value) {
		PyObject_SetAttrString(pyobjref, "use_viscoelastic_springs", Py_BuildValue("i", value));
	}

	/** Getter: Use the initial length as spring rest length instead of 2 * particle size */
	bool use_initial_rest_length() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_initial_rest_length")) == 1;
	}

	/** Setter: Use the initial length as spring rest length instead of 2 * particle size */
	void use_initial_rest_length(bool value) {
		PyObject_SetAttrString(pyobjref, "use_initial_rest_length", Py_BuildValue("i", value));
	}

	/** Getter: How much the spring rest length can change after the elastic limit is crossed */
	float plasticity() { /* not implemented */ throw NULL; }
	/** Setter: How much the spring rest length can change after the elastic limit is crossed */
	void plasticity(float value) {
		PyObject_SetAttrString(pyobjref, "plasticity", Py_BuildValue("f", value));
	}

	/** Getter: How much the spring has to be stretched/compressed in order to change it's rest length */
	float yield_ratio() { /* not implemented */ throw NULL; }
	/** Setter: How much the spring has to be stretched/compressed in order to change it's rest length */
	void yield_ratio(float value) {
		PyObject_SetAttrString(pyobjref, "yield_ratio", Py_BuildValue("f", value));
	}

	/** Getter: Create springs for this number of frames since particles birth (0 is always) */
	int spring_frames() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "spring_frames"));
	}

	/** Setter: Create springs for this number of frames since particles birth (0 is always) */
	void spring_frames(int value) {
		PyObject_SetAttrString(pyobjref, "spring_frames", Py_BuildValue("i", value));
	}

	/** Getter: Linear viscosity */
	float linear_viscosity() { /* not implemented */ throw NULL; }
	/** Setter: Linear viscosity */
	void linear_viscosity(float value) {
		PyObject_SetAttrString(pyobjref, "linear_viscosity", Py_BuildValue("f", value));
	}

	/** Getter: Creates viscosity for expanding fluid */
	float stiff_viscosity() { /* not implemented */ throw NULL; }
	/** Setter: Creates viscosity for expanding fluid */
	void stiff_viscosity(float value) {
		PyObject_SetAttrString(pyobjref, "stiff_viscosity", Py_BuildValue("f", value));
	}

	/** Getter: How incompressible the fluid is (speed of sound) */
	float stiffness() { /* not implemented */ throw NULL; }
	/** Setter: How incompressible the fluid is (speed of sound) */
	void stiffness(float value) {
		PyObject_SetAttrString(pyobjref, "stiffness", Py_BuildValue("f", value));
	}

	/** Getter: How strongly the fluid tries to keep from clustering (factor of stiffness) */
	float repulsion() { /* not implemented */ throw NULL; }
	/** Setter: How strongly the fluid tries to keep from clustering (factor of stiffness) */
	void repulsion(float value) {
		PyObject_SetAttrString(pyobjref, "repulsion", Py_BuildValue("f", value));
	}

	/** Getter: Fluid rest density */
	float rest_density() { /* not implemented */ throw NULL; }
	/** Setter: Fluid rest density */
	void rest_density(float value) {
		PyObject_SetAttrString(pyobjref, "rest_density", Py_BuildValue("f", value));
	}

	/** Getter: Artificial buoyancy force in negative gravity direction based on pressure differences inside the fluid */
	float buoyancy() { /* not implemented */ throw NULL; }
	/** Setter: Artificial buoyancy force in negative gravity direction based on pressure differences inside the fluid */
	void buoyancy(float value) {
		PyObject_SetAttrString(pyobjref, "buoyancy", Py_BuildValue("f", value));
	}

	/** Getter: Repulsion is a factor of stiffness */
	bool factor_repulsion() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "factor_repulsion")) == 1;
	}

	/** Setter: Repulsion is a factor of stiffness */
	void factor_repulsion(bool value) {
		PyObject_SetAttrString(pyobjref, "factor_repulsion", Py_BuildValue("i", value));
	}

	/** Getter: Density is calculated as a factor of default density (depends on particle size) */
	bool use_factor_density() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_factor_density")) == 1;
	}

	/** Setter: Density is calculated as a factor of default density (depends on particle size) */
	void use_factor_density(bool value) {
		PyObject_SetAttrString(pyobjref, "use_factor_density", Py_BuildValue("i", value));
	}

	/** Getter: Interaction radius is a factor of 4 * particle size */
	bool factor_radius() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "factor_radius")) == 1;
	}

	/** Setter: Interaction radius is a factor of 4 * particle size */
	void factor_radius(bool value) {
		PyObject_SetAttrString(pyobjref, "factor_radius", Py_BuildValue("i", value));
	}

	/** Getter: Stiff viscosity is a factor of normal viscosity */
	bool factor_stiff_viscosity() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "factor_stiff_viscosity")) == 1;
	}

	/** Setter: Stiff viscosity is a factor of normal viscosity */
	void factor_stiff_viscosity(bool value) {
		PyObject_SetAttrString(pyobjref, "factor_stiff_viscosity", Py_BuildValue("i", value));
	}

	/** Getter: Spring rest length is a factor of 2 * particle size */
	bool factor_rest_length() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "factor_rest_length")) == 1;
	}

	/** Setter: Spring rest length is a factor of 2 * particle size */
	void factor_rest_length(bool value) {
		PyObject_SetAttrString(pyobjref, "factor_rest_length", Py_BuildValue("i", value));
	}

};

/**************** Particle Hair Key ****************/

/**
 * Particle key for hair particle system
 */
class ParticleHairKey : public pyUniplug {
public:
	ParticleHairKey(PyObject* pyobj) : pyUniplug(pyobj) {}

	ParticleHairKey() : pyUniplug(0)
	{
		// not implemented
	}

	/** Getter: Relative time of key over hair length */
	float time() { /* not implemented */ throw NULL; }
	/** Setter: Relative time of key over hair length */
	void time(float value) {
		PyObject_SetAttrString(pyobjref, "time", Py_BuildValue("f", value));
	}

	/** Getter: Weight for cloth simulation */
	float weight() { /* not implemented */ throw NULL; }
	/** Setter: Weight for cloth simulation */
	void weight(float value) {
		PyObject_SetAttrString(pyobjref, "weight", Py_BuildValue("f", value));
	}

	/** Getter: Location of the hair key in object space */
	std::array<float, 3> co() {
		// TODO: MISSING DEREF! USE #DEFINE!
		PyObject *seqval = PyObject_GetAttrString(pyobjref, "co");
		std::array<float, 3> resarr;
		for (int i = 0; i < 3; i++)
			resarr[i] = (float)PyFloat_AsDouble(PySequence_GetItem(seqval, i));
		return resarr;
	}

	/** Setter: Location of the hair key in object space */
	void co(float values[3]) { /* not implemented */ }

	/** Getter: Location of the hair key in its local coordinate system, relative to the emitting face */
	std::array<float, 3> co_local() {
		// TODO: MISSING DEREF! USE #DEFINE!
		PyObject *seqval = PyObject_GetAttrString(pyobjref, "co_local");
		std::array<float, 3> resarr;
		for (int i = 0; i < 3; i++)
			resarr[i] = (float)PyFloat_AsDouble(PySequence_GetItem(seqval, i));
		return resarr;
	}

	/** Setter: Location of the hair key in its local coordinate system, relative to the emitting face */
	void co_local(float values[3]) { /* not implemented */ }

	/**
	 * Obtain hairkey location with particle and modifier data
	 * @param Object
	 * @param Particle modifier
	 * @param hair particle
	 * @return Exported hairkey location
	 */
	std::array<float, 3> co_object(Object object_value, ParticleSystemModifier modifier, Particle particle);

};

/**************** Particle Key ****************/

/**
 * Key location for a particle over time
 */
class ParticleKey : public pyUniplug {
public:
	ParticleKey(PyObject* pyobj) : pyUniplug(pyobj) {}

	ParticleKey() : pyUniplug(0)
	{
		// not implemented
	}

	/** Getter: Key location */
	std::array<float, 3> location() {
		// TODO: MISSING DEREF! USE #DEFINE!
		PyObject *seqval = PyObject_GetAttrString(pyobjref, "location");
		std::array<float, 3> resarr;
		for (int i = 0; i < 3; i++)
			resarr[i] = (float)PyFloat_AsDouble(PySequence_GetItem(seqval, i));
		return resarr;
	}

	/** Setter: Key location */
	void location(float values[3]) { /* not implemented */ }

	/** Getter: Key velocity */
	std::array<float, 3> velocity() {
		// TODO: MISSING DEREF! USE #DEFINE!
		PyObject *seqval = PyObject_GetAttrString(pyobjref, "velocity");
		std::array<float, 3> resarr;
		for (int i = 0; i < 3; i++)
			resarr[i] = (float)PyFloat_AsDouble(PySequence_GetItem(seqval, i));
		return resarr;
	}

	/** Setter: Key velocity */
	void velocity(float values[3]) { /* not implemented */ }

	/** Getter: Key rotation quaternion */
	std::array<float, 4> rotation() {
		// TODO: MISSING DEREF! USE #DEFINE!
		PyObject *seqval = PyObject_GetAttrString(pyobjref, "rotation");
		std::array<float, 4> resarr;
		for (int i = 0; i < 4; i++)
			resarr[i] = (float)PyFloat_AsDouble(PySequence_GetItem(seqval, i));
		return resarr;
	}

	/** Setter: Key rotation quaternion */
	void rotation(float values[4]) { /* not implemented */ }

	/** Getter: Key angular velocity */
	std::array<float, 3> angular_velocity() {
		// TODO: MISSING DEREF! USE #DEFINE!
		PyObject *seqval = PyObject_GetAttrString(pyobjref, "angular_velocity");
		std::array<float, 3> resarr;
		for (int i = 0; i < 3; i++)
			resarr[i] = (float)PyFloat_AsDouble(PySequence_GetItem(seqval, i));
		return resarr;
	}

	/** Setter: Key angular velocity */
	void angular_velocity(float values[3]) { /* not implemented */ }

	/** Getter: Time of key over the simulation */
	float time() { /* not implemented */ throw NULL; }
	/** Setter: Time of key over the simulation */
	void time(float value) {
		PyObject_SetAttrString(pyobjref, "time", Py_BuildValue("f", value));
	}

};

/**************** Child Particle ****************/

/**
 * Child particle interpolated from simulated or edited particles
 */
class ChildParticle : public pyUniplug {
public:
	ChildParticle(PyObject* pyobj) : pyUniplug(pyobj) {}

	ChildParticle() : pyUniplug(0)
	{
		// not implemented
	}

};

/**************** Particle ****************/

/**
 * Particle in a particle system
 */
class Particle : public pyUniplug {
public:
	Particle(PyObject* pyobj) : pyUniplug(pyobj) {}

	Particle() : pyUniplug(0)
	{
		// not implemented
	}

	/** Getter:  */
	std::array<float, 3> location() {
		// TODO: MISSING DEREF! USE #DEFINE!
		PyObject *seqval = PyObject_GetAttrString(pyobjref, "location");
		std::array<float, 3> resarr;
		for (int i = 0; i < 3; i++)
			resarr[i] = (float)PyFloat_AsDouble(PySequence_GetItem(seqval, i));
		return resarr;
	}

	/** Setter:  */
	void location(float values[3]) { /* not implemented */ }

	/** Getter:  */
	std::array<float, 3> velocity() {
		// TODO: MISSING DEREF! USE #DEFINE!
		PyObject *seqval = PyObject_GetAttrString(pyobjref, "velocity");
		std::array<float, 3> resarr;
		for (int i = 0; i < 3; i++)
			resarr[i] = (float)PyFloat_AsDouble(PySequence_GetItem(seqval, i));
		return resarr;
	}

	/** Setter:  */
	void velocity(float values[3]) { /* not implemented */ }

	/** Getter:  */
	std::array<float, 3> angular_velocity() {
		// TODO: MISSING DEREF! USE #DEFINE!
		PyObject *seqval = PyObject_GetAttrString(pyobjref, "angular_velocity");
		std::array<float, 3> resarr;
		for (int i = 0; i < 3; i++)
			resarr[i] = (float)PyFloat_AsDouble(PySequence_GetItem(seqval, i));
		return resarr;
	}

	/** Setter:  */
	void angular_velocity(float values[3]) { /* not implemented */ }

	/** Getter:  */
	std::array<float, 4> rotation() {
		// TODO: MISSING DEREF! USE #DEFINE!
		PyObject *seqval = PyObject_GetAttrString(pyobjref, "rotation");
		std::array<float, 4> resarr;
		for (int i = 0; i < 4; i++)
			resarr[i] = (float)PyFloat_AsDouble(PySequence_GetItem(seqval, i));
		return resarr;
	}

	/** Setter:  */
	void rotation(float values[4]) { /* not implemented */ }

	/** Getter:  */
	std::array<float, 3> prev_location() {
		// TODO: MISSING DEREF! USE #DEFINE!
		PyObject *seqval = PyObject_GetAttrString(pyobjref, "prev_location");
		std::array<float, 3> resarr;
		for (int i = 0; i < 3; i++)
			resarr[i] = (float)PyFloat_AsDouble(PySequence_GetItem(seqval, i));
		return resarr;
	}

	/** Setter:  */
	void prev_location(float values[3]) { /* not implemented */ }

	/** Getter:  */
	std::array<float, 3> prev_velocity() {
		// TODO: MISSING DEREF! USE #DEFINE!
		PyObject *seqval = PyObject_GetAttrString(pyobjref, "prev_velocity");
		std::array<float, 3> resarr;
		for (int i = 0; i < 3; i++)
			resarr[i] = (float)PyFloat_AsDouble(PySequence_GetItem(seqval, i));
		return resarr;
	}

	/** Setter:  */
	void prev_velocity(float values[3]) { /* not implemented */ }

	/** Getter:  */
	std::array<float, 3> prev_angular_velocity() {
		// TODO: MISSING DEREF! USE #DEFINE!
		PyObject *seqval = PyObject_GetAttrString(pyobjref, "prev_angular_velocity");
		std::array<float, 3> resarr;
		for (int i = 0; i < 3; i++)
			resarr[i] = (float)PyFloat_AsDouble(PySequence_GetItem(seqval, i));
		return resarr;
	}

	/** Setter:  */
	void prev_angular_velocity(float values[3]) { /* not implemented */ }

	/** Getter:  */
	std::array<float, 4> prev_rotation() {
		// TODO: MISSING DEREF! USE #DEFINE!
		PyObject *seqval = PyObject_GetAttrString(pyobjref, "prev_rotation");
		std::array<float, 4> resarr;
		for (int i = 0; i < 4; i++)
			resarr[i] = (float)PyFloat_AsDouble(PySequence_GetItem(seqval, i));
		return resarr;
	}

	/** Setter:  */
	void prev_rotation(float values[4]) { /* not implemented */ }

	/** Getter:  */
	std::map<std::string, ParticleHairKey> hair_keys() {
		// TODO: MISSING DEREF! USE #DEFINE!
		PyObject *seqval = PyObject_GetAttrString(pyobjref, "hair_keys");
		PyObject *seqkeys = PyObject_CallMethod(seqval, "keys", NULL);
		std::map<std::string, ParticleHairKey> resmap;
		for (int i = 0; i < PySequence_Length(seqval); i++) {
			PyObject *keyobj = PySequence_GetItem(seqkeys, i);
			std::string key = PyBytes_AsString(PyUnicode_AsASCIIString(keyobj));
			ParticleHairKey value = ParticleHairKey(PySequence_GetItem(seqval, i));
			resmap.insert(std::pair<std::string,ParticleHairKey>(key, value));
		}
		return resmap;
	}

	/** Setter:  */
	void hair_keys(std::map<std::string, ParticleHairKey> value) { /* not implemented */ }

	/** Getter:  */
	std::map<std::string, ParticleKey> particle_keys() {
		// TODO: MISSING DEREF! USE #DEFINE!
		PyObject *seqval = PyObject_GetAttrString(pyobjref, "particle_keys");
		PyObject *seqkeys = PyObject_CallMethod(seqval, "keys", NULL);
		std::map<std::string, ParticleKey> resmap;
		for (int i = 0; i < PySequence_Length(seqval); i++) {
			PyObject *keyobj = PySequence_GetItem(seqkeys, i);
			std::string key = PyBytes_AsString(PyUnicode_AsASCIIString(keyobj));
			ParticleKey value = ParticleKey(PySequence_GetItem(seqval, i));
			resmap.insert(std::pair<std::string,ParticleKey>(key, value));
		}
		return resmap;
	}

	/** Setter:  */
	void particle_keys(std::map<std::string, ParticleKey> value) { /* not implemented */ }

	/** Getter:  */
	float birth_time() { /* not implemented */ throw NULL; }
	/** Setter:  */
	void birth_time(float value) {
		PyObject_SetAttrString(pyobjref, "birth_time", Py_BuildValue("f", value));
	}

	/** Getter:  */
	float lifetime() { /* not implemented */ throw NULL; }
	/** Setter:  */
	void lifetime(float value) {
		PyObject_SetAttrString(pyobjref, "lifetime", Py_BuildValue("f", value));
	}

	/** Getter:  */
	float die_time() { /* not implemented */ throw NULL; }
	/** Setter:  */
	void die_time(float value) {
		PyObject_SetAttrString(pyobjref, "die_time", Py_BuildValue("f", value));
	}

	/** Getter:  */
	float size() { /* not implemented */ throw NULL; }
	/** Setter:  */
	void size(float value) {
		PyObject_SetAttrString(pyobjref, "size", Py_BuildValue("f", value));
	}

	/** Getter:  */
	bool is_exist() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "is_exist")) == 1;
	}

	/** Setter:  */
	void is_exist(bool value) {
		PyObject_SetAttrString(pyobjref, "is_exist", Py_BuildValue("i", value));
	}

	/** Getter:  */
	bool is_visible() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "is_visible")) == 1;
	}

	/** Setter:  */
	void is_visible(bool value) {
		PyObject_SetAttrString(pyobjref, "is_visible", Py_BuildValue("i", value));
	}

	enum alive_state_enum {
		alive_state_DEAD = 1,
		alive_state_UNBORN = 2,
		alive_state_ALIVE = 3,
		alive_state_DYING = 4,
	};

	/** Getter:  */
	alive_state_enum alive_state() { /* not implemented */ throw NULL; }
	/** Setter:  */
	void alive_state(alive_state_enum value) { /* not implemented */ }

	/**
	 * Obtain uv for particle on derived mesh
	 * @param Particle modifier
	 * @return 
	 */
	std::array<float, 2> uv_on_emitter(ParticleSystemModifier modifier)
	{
		// not implemented
		throw NULL;
	}

};

/**************** Particle Dupliobject Weight ****************/

/**
 * Weight of a particle dupliobject in a group
 */
class ParticleDupliWeight : public pyUniplug {
public:
	ParticleDupliWeight(PyObject* pyobj) : pyUniplug(pyobj) {}

	ParticleDupliWeight() : pyUniplug(0)
	{
		// not implemented
	}

	/** Getter: Particle dupliobject name */
	std::string name() { /* not implemented */ throw NULL; }
	/** Setter: Particle dupliobject name */
	void name(const std::string& value) { /* not implemented */ }

	/** Getter: The number of times this object is repeated with respect to other objects */
	int count() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "count"));
	}

	/** Setter: The number of times this object is repeated with respect to other objects */
	void count(int value) {
		PyObject_SetAttrString(pyobjref, "count", Py_BuildValue("i", value));
	}

};

/**************** Particle System ****************/

/**
 * Particle system in an object
 */
class ParticleSystem : public pyUniplug {
public:
	ParticleSystem(PyObject* pyobj) : pyUniplug(pyobj) {}

	ParticleSystem() : pyUniplug(0)
	{
		// not implemented
	}

	/** Getter: Particle system name */
	std::string name() { /* not implemented */ throw NULL; }
	/** Setter: Particle system name */
	void name(const std::string& value) { /* not implemented */ }

	/** Getter: Particle system settings */
	ParticleSettings settings();

	/** Getter: Particles generated by the particle system */
	std::map<std::string, Particle> particles() {
		// TODO: MISSING DEREF! USE #DEFINE!
		PyObject *seqval = PyObject_GetAttrString(pyobjref, "particles");
		PyObject *seqkeys = PyObject_CallMethod(seqval, "keys", NULL);
		std::map<std::string, Particle> resmap;
		for (int i = 0; i < PySequence_Length(seqval); i++) {
			PyObject *keyobj = PySequence_GetItem(seqkeys, i);
			std::string key = PyBytes_AsString(PyUnicode_AsASCIIString(keyobj));
			Particle value = Particle(PySequence_GetItem(seqval, i));
			resmap.insert(std::pair<std::string,Particle>(key, value));
		}
		return resmap;
	}

	/** Setter: Particles generated by the particle system */
	void particles(std::map<std::string, Particle> value) { /* not implemented */ }

	/** Getter: Child particles generated by the particle system */
	std::map<std::string, ChildParticle> child_particles() {
		// TODO: MISSING DEREF! USE #DEFINE!
		PyObject *seqval = PyObject_GetAttrString(pyobjref, "child_particles");
		PyObject *seqkeys = PyObject_CallMethod(seqval, "keys", NULL);
		std::map<std::string, ChildParticle> resmap;
		for (int i = 0; i < PySequence_Length(seqval); i++) {
			PyObject *keyobj = PySequence_GetItem(seqkeys, i);
			std::string key = PyBytes_AsString(PyUnicode_AsASCIIString(keyobj));
			ChildParticle value = ChildParticle(PySequence_GetItem(seqval, i));
			resmap.insert(std::pair<std::string,ChildParticle>(key, value));
		}
		return resmap;
	}

	/** Setter: Child particles generated by the particle system */
	void child_particles(std::map<std::string, ChildParticle> value) { /* not implemented */ }

	/** Getter: Offset in the random number table, to get a different randomized result */
	int seed() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "seed"));
	}

	/** Setter: Offset in the random number table, to get a different randomized result */
	void seed(int value) {
		PyObject_SetAttrString(pyobjref, "seed", Py_BuildValue("i", value));
	}

	/** Getter: Offset in the random number table for child particles, to get a different randomized result */
	int child_seed() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "child_seed"));
	}

	/** Setter: Offset in the random number table for child particles, to get a different randomized result */
	void child_seed(int value) {
		PyObject_SetAttrString(pyobjref, "child_seed", Py_BuildValue("i", value));
	}

	/** Getter: Hair keys are in global coordinate space */
	bool is_global_hair() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "is_global_hair")) == 1;
	}

	/** Setter: Hair keys are in global coordinate space */
	void is_global_hair(bool value) {
		PyObject_SetAttrString(pyobjref, "is_global_hair", Py_BuildValue("i", value));
	}

	/** Getter: Enable hair dynamics using cloth simulation */
	bool use_hair_dynamics() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_hair_dynamics")) == 1;
	}

	/** Setter: Enable hair dynamics using cloth simulation */
	void use_hair_dynamics(bool value) {
		PyObject_SetAttrString(pyobjref, "use_hair_dynamics", Py_BuildValue("i", value));
	}

	/** Getter: Cloth dynamics for hair */
	ClothModifier cloth() {
		/* not implemented */ throw NULL;
	}

	/** Getter: For reactor systems, the object that has the target particle system (empty if same object) */
	Object reactor_target_object() {
		/* not implemented */ throw NULL;
	}

	/** Getter: For reactor systems, index of particle system on the target object */
	int reactor_target_particle_system() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "reactor_target_particle_system"));
	}

	/** Setter: For reactor systems, index of particle system on the target object */
	void reactor_target_particle_system(int value) {
		PyObject_SetAttrString(pyobjref, "reactor_target_particle_system", Py_BuildValue("i", value));
	}

	/** Getter: Use key times */
	bool use_keyed_timing() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_keyed_timing")) == 1;
	}

	/** Setter: Use key times */
	void use_keyed_timing(bool value) {
		PyObject_SetAttrString(pyobjref, "use_keyed_timing", Py_BuildValue("i", value));
	}

	/** Getter: Target particle systems */
	std::map<std::string, ParticleTarget> targets() {
		// TODO: MISSING DEREF! USE #DEFINE!
		PyObject *seqval = PyObject_GetAttrString(pyobjref, "targets");
		PyObject *seqkeys = PyObject_CallMethod(seqval, "keys", NULL);
		std::map<std::string, ParticleTarget> resmap;
		for (int i = 0; i < PySequence_Length(seqval); i++) {
			PyObject *keyobj = PySequence_GetItem(seqkeys, i);
			std::string key = PyBytes_AsString(PyUnicode_AsASCIIString(keyobj));
			ParticleTarget value = ParticleTarget(PySequence_GetItem(seqval, i));
			resmap.insert(std::pair<std::string,ParticleTarget>(key, value));
		}
		return resmap;
	}

	/** Setter: Target particle systems */
	void targets(std::map<std::string, ParticleTarget> value) { /* not implemented */ }

	/** Getter:  */
	ParticleTarget active_particle_target() {
		/* not implemented */ throw NULL;
	}

	/** Getter:  */
	int active_particle_target_index() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "active_particle_target_index"));
	}

	/** Setter:  */
	void active_particle_target_index(int value) {
		PyObject_SetAttrString(pyobjref, "active_particle_target_index", Py_BuildValue("i", value));
	}

	/** Getter: UV map to control billboard normals */
	std::string billboard_normal_uv() { /* not implemented */ throw NULL; }
	/** Setter: UV map to control billboard normals */
	void billboard_normal_uv(const std::string& value) { /* not implemented */ }

	/** Getter: UV map to control billboard time index (X-Y) */
	std::string billboard_time_index_uv() { /* not implemented */ throw NULL; }
	/** Setter: UV map to control billboard time index (X-Y) */
	void billboard_time_index_uv(const std::string& value) { /* not implemented */ }

	/** Getter: UV map to control billboard splitting */
	std::string billboard_split_uv() { /* not implemented */ throw NULL; }
	/** Setter: UV map to control billboard splitting */
	void billboard_split_uv(const std::string& value) { /* not implemented */ }

	/** Getter: Vertex group to control density */
	std::string vertex_group_density() { /* not implemented */ throw NULL; }
	/** Setter: Vertex group to control density */
	void vertex_group_density(const std::string& value) { /* not implemented */ }

	/** Getter: Negate the effect of the density vertex group */
	bool invert_vertex_group_density() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "invert_vertex_group_density")) == 1;
	}

	/** Setter: Negate the effect of the density vertex group */
	void invert_vertex_group_density(bool value) {
		PyObject_SetAttrString(pyobjref, "invert_vertex_group_density", Py_BuildValue("i", value));
	}

	/** Getter: Vertex group to control velocity */
	std::string vertex_group_velocity() { /* not implemented */ throw NULL; }
	/** Setter: Vertex group to control velocity */
	void vertex_group_velocity(const std::string& value) { /* not implemented */ }

	/** Getter: Negate the effect of the velocity vertex group */
	bool invert_vertex_group_velocity() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "invert_vertex_group_velocity")) == 1;
	}

	/** Setter: Negate the effect of the velocity vertex group */
	void invert_vertex_group_velocity(bool value) {
		PyObject_SetAttrString(pyobjref, "invert_vertex_group_velocity", Py_BuildValue("i", value));
	}

	/** Getter: Vertex group to control length */
	std::string vertex_group_length() { /* not implemented */ throw NULL; }
	/** Setter: Vertex group to control length */
	void vertex_group_length(const std::string& value) { /* not implemented */ }

	/** Getter: Negate the effect of the length vertex group */
	bool invert_vertex_group_length() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "invert_vertex_group_length")) == 1;
	}

	/** Setter: Negate the effect of the length vertex group */
	void invert_vertex_group_length(bool value) {
		PyObject_SetAttrString(pyobjref, "invert_vertex_group_length", Py_BuildValue("i", value));
	}

	/** Getter: Vertex group to control clump */
	std::string vertex_group_clump() { /* not implemented */ throw NULL; }
	/** Setter: Vertex group to control clump */
	void vertex_group_clump(const std::string& value) { /* not implemented */ }

	/** Getter: Negate the effect of the clump vertex group */
	bool invert_vertex_group_clump() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "invert_vertex_group_clump")) == 1;
	}

	/** Setter: Negate the effect of the clump vertex group */
	void invert_vertex_group_clump(bool value) {
		PyObject_SetAttrString(pyobjref, "invert_vertex_group_clump", Py_BuildValue("i", value));
	}

	/** Getter: Vertex group to control kink */
	std::string vertex_group_kink() { /* not implemented */ throw NULL; }
	/** Setter: Vertex group to control kink */
	void vertex_group_kink(const std::string& value) { /* not implemented */ }

	/** Getter: Negate the effect of the kink vertex group */
	bool invert_vertex_group_kink() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "invert_vertex_group_kink")) == 1;
	}

	/** Setter: Negate the effect of the kink vertex group */
	void invert_vertex_group_kink(bool value) {
		PyObject_SetAttrString(pyobjref, "invert_vertex_group_kink", Py_BuildValue("i", value));
	}

	/** Getter: Vertex group to control roughness 1 */
	std::string vertex_group_roughness_1() { /* not implemented */ throw NULL; }
	/** Setter: Vertex group to control roughness 1 */
	void vertex_group_roughness_1(const std::string& value) { /* not implemented */ }

	/** Getter: Negate the effect of the roughness 1 vertex group */
	bool invert_vertex_group_roughness_1() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "invert_vertex_group_roughness_1")) == 1;
	}

	/** Setter: Negate the effect of the roughness 1 vertex group */
	void invert_vertex_group_roughness_1(bool value) {
		PyObject_SetAttrString(pyobjref, "invert_vertex_group_roughness_1", Py_BuildValue("i", value));
	}

	/** Getter: Vertex group to control roughness 2 */
	std::string vertex_group_roughness_2() { /* not implemented */ throw NULL; }
	/** Setter: Vertex group to control roughness 2 */
	void vertex_group_roughness_2(const std::string& value) { /* not implemented */ }

	/** Getter: Negate the effect of the roughness 2 vertex group */
	bool invert_vertex_group_roughness_2() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "invert_vertex_group_roughness_2")) == 1;
	}

	/** Setter: Negate the effect of the roughness 2 vertex group */
	void invert_vertex_group_roughness_2(bool value) {
		PyObject_SetAttrString(pyobjref, "invert_vertex_group_roughness_2", Py_BuildValue("i", value));
	}

	/** Getter: Vertex group to control roughness end */
	std::string vertex_group_roughness_end() { /* not implemented */ throw NULL; }
	/** Setter: Vertex group to control roughness end */
	void vertex_group_roughness_end(const std::string& value) { /* not implemented */ }

	/** Getter: Negate the effect of the roughness end vertex group */
	bool invert_vertex_group_roughness_end() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "invert_vertex_group_roughness_end")) == 1;
	}

	/** Setter: Negate the effect of the roughness end vertex group */
	void invert_vertex_group_roughness_end(bool value) {
		PyObject_SetAttrString(pyobjref, "invert_vertex_group_roughness_end", Py_BuildValue("i", value));
	}

	/** Getter: Vertex group to control size */
	std::string vertex_group_size() { /* not implemented */ throw NULL; }
	/** Setter: Vertex group to control size */
	void vertex_group_size(const std::string& value) { /* not implemented */ }

	/** Getter: Negate the effect of the size vertex group */
	bool invert_vertex_group_size() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "invert_vertex_group_size")) == 1;
	}

	/** Setter: Negate the effect of the size vertex group */
	void invert_vertex_group_size(bool value) {
		PyObject_SetAttrString(pyobjref, "invert_vertex_group_size", Py_BuildValue("i", value));
	}

	/** Getter: Vertex group to control tangent */
	std::string vertex_group_tangent() { /* not implemented */ throw NULL; }
	/** Setter: Vertex group to control tangent */
	void vertex_group_tangent(const std::string& value) { /* not implemented */ }

	/** Getter: Negate the effect of the tangent vertex group */
	bool invert_vertex_group_tangent() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "invert_vertex_group_tangent")) == 1;
	}

	/** Setter: Negate the effect of the tangent vertex group */
	void invert_vertex_group_tangent(bool value) {
		PyObject_SetAttrString(pyobjref, "invert_vertex_group_tangent", Py_BuildValue("i", value));
	}

	/** Getter: Vertex group to control rotation */
	std::string vertex_group_rotation() { /* not implemented */ throw NULL; }
	/** Setter: Vertex group to control rotation */
	void vertex_group_rotation(const std::string& value) { /* not implemented */ }

	/** Getter: Negate the effect of the rotation vertex group */
	bool invert_vertex_group_rotation() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "invert_vertex_group_rotation")) == 1;
	}

	/** Setter: Negate the effect of the rotation vertex group */
	void invert_vertex_group_rotation(bool value) {
		PyObject_SetAttrString(pyobjref, "invert_vertex_group_rotation", Py_BuildValue("i", value));
	}

	/** Getter: Vertex group to control field */
	std::string vertex_group_field() { /* not implemented */ throw NULL; }
	/** Setter: Vertex group to control field */
	void vertex_group_field(const std::string& value) { /* not implemented */ }

	/** Getter: Negate the effect of the field vertex group */
	bool invert_vertex_group_field() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "invert_vertex_group_field")) == 1;
	}

	/** Setter: Negate the effect of the field vertex group */
	void invert_vertex_group_field(bool value) {
		PyObject_SetAttrString(pyobjref, "invert_vertex_group_field", Py_BuildValue("i", value));
	}

	/** Getter:  */
	PointCache point_cache() {
		/* not implemented */ throw NULL;
	}

	/** Getter: Particle system has multiple point caches */
	bool has_multiple_caches() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "has_multiple_caches")) == 1;
	}

	/** Setter: Particle system has multiple point caches */
	void has_multiple_caches(bool value) {
		PyObject_SetAttrString(pyobjref, "has_multiple_caches", Py_BuildValue("i", value));
	}

	/** Getter: Use this object's coordinate system instead of global coordinate system */
	Object parent() {
		/* not implemented */ throw NULL;
	}

	/** Getter: Particle system can be edited in particle mode */
	bool is_editable() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "is_editable")) == 1;
	}

	/** Setter: Particle system can be edited in particle mode */
	void is_editable(bool value) {
		PyObject_SetAttrString(pyobjref, "is_editable", Py_BuildValue("i", value));
	}

	/** Getter: Particle system has been edited in particle mode */
	bool is_edited() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "is_edited")) == 1;
	}

	/** Setter: Particle system has been edited in particle mode */
	void is_edited(bool value) {
		PyObject_SetAttrString(pyobjref, "is_edited", Py_BuildValue("i", value));
	}

	/** Getter: The current simulation time step size, as a fraction of a frame */
	float dt_frac() { /* not implemented */ throw NULL; }
	/** Setter: The current simulation time step size, as a fraction of a frame */
	void dt_frac(float value) {
		PyObject_SetAttrString(pyobjref, "dt_frac", Py_BuildValue("f", value));
	}

	/**
	 * Enum: resolution_items
	 */
	enum resolution_items {
		resolution_items_PREVIEW = 1,	/**< Apply modifier preview settings */
		resolution_items_RENDER = 2	/**< Apply modifier render settings */
	};

	/**
	 * Set the resolution to use for the number of particles
	 * @param Scene
	 * @param Object
	 * @param Resolution settings to apply
	 */
	void set_resolution(Scene scene, Object object_value, resolution_items resolution = resolution_items_PREVIEW);

	/**
	 * Obtain cache hair data
	 * @param Object
	 * @param Param 'particle_no'
	 * @param Param 'step'
	 * @return Exported hairkey location
	 */
	std::array<float, 3> co_hair(Object object_value, int particle_no = 0, int step = 0)
	{
		// not implemented
		throw NULL;
	}

	/**
	 * Obtain uv for all particles
	 * @param Particle modifier
	 * @param Particle
	 * @param Param 'particle_no'
	 * @param Param 'uv_no'
	 * @return 
	 */
	std::array<float, 2> uv_on_emitter(ParticleSystemModifier modifier, Particle particle, int particle_no = 0, int uv_no = 0)
	{
		// not implemented
		throw NULL;
	}

	/**
	 * Obtain mcol for all particles
	 * @param Particle modifier
	 * @param Particle
	 * @param Param 'particle_no'
	 * @param Param 'vcol_no'
	 * @return 
	 */
	std::array<float, 3> mcol_on_emitter(ParticleSystemModifier modifier, Particle particle, int particle_no = 0, int vcol_no = 0)
	{
		// not implemented
		throw NULL;
	}

};

/**************** Particle Settings Texture Slot ****************/

/**
 * Texture slot for textures in a Particle Settings datablock
 */
class ParticleSettingsTextureSlot : public TextureSlot {
public:
	ParticleSettingsTextureSlot(PyObject* pyobj) : TextureSlot(pyobj) {}

	ParticleSettingsTextureSlot() : TextureSlot(0)
	{
		// not implemented
	}

	enum texture_coords_enum {
		texture_coords_GLOBAL = 8,
		texture_coords_OBJECT = 32,
		texture_coords_UV = 16,
		texture_coords_ORCO = 1,
		texture_coords_STRAND = 8192,
	};

	/** Getter: Texture coordinates used to map the texture onto the background */
	texture_coords_enum texture_coords() { /* not implemented */ throw NULL; }
	/** Setter: Texture coordinates used to map the texture onto the background */
	void texture_coords(texture_coords_enum value) { /* not implemented */ }

	/** Getter: Object to use for mapping with Object texture coordinates */
	Object object_value() {
		/* not implemented */ throw NULL;
	}

	/** Getter: UV map to use for mapping with UV texture coordinates */
	std::string uv_layer() { /* not implemented */ throw NULL; }
	/** Setter: UV map to use for mapping with UV texture coordinates */
	void uv_layer(const std::string& value) { /* not implemented */ }

	enum mapping_x_enum {
		mapping_x_NONE = 0,
		mapping_x_X = 1,
		mapping_x_Y = 2,
		mapping_x_Z = 3,
	};

	/** Getter:  */
	mapping_x_enum mapping_x() { /* not implemented */ throw NULL; }
	/** Setter:  */
	void mapping_x(mapping_x_enum value) { /* not implemented */ }

	enum mapping_y_enum {
		mapping_y_NONE = 0,
		mapping_y_X = 1,
		mapping_y_Y = 2,
		mapping_y_Z = 3,
	};

	/** Getter:  */
	mapping_y_enum mapping_y() { /* not implemented */ throw NULL; }
	/** Setter:  */
	void mapping_y(mapping_y_enum value) { /* not implemented */ }

	enum mapping_z_enum {
		mapping_z_NONE = 0,
		mapping_z_X = 1,
		mapping_z_Y = 2,
		mapping_z_Z = 3,
	};

	/** Getter:  */
	mapping_z_enum mapping_z() { /* not implemented */ throw NULL; }
	/** Setter:  */
	void mapping_z(mapping_z_enum value) { /* not implemented */ }

	enum mapping_enum {
		mapping_FLAT = 0,
		mapping_CUBE = 1,
		mapping_TUBE = 2,
		mapping_SPHERE = 3,
	};

	/** Getter:  */
	mapping_enum mapping() { /* not implemented */ throw NULL; }
	/** Setter:  */
	void mapping(mapping_enum value) { /* not implemented */ }

	/** Getter: Affect the emission time of the particles */
	bool use_map_time() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_map_time")) == 1;
	}

	/** Setter: Affect the emission time of the particles */
	void use_map_time(bool value) {
		PyObject_SetAttrString(pyobjref, "use_map_time", Py_BuildValue("i", value));
	}

	/** Getter: Affect the life time of the particles */
	bool use_map_life() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_map_life")) == 1;
	}

	/** Setter: Affect the life time of the particles */
	void use_map_life(bool value) {
		PyObject_SetAttrString(pyobjref, "use_map_life", Py_BuildValue("i", value));
	}

	/** Getter: Affect the density of the particles */
	bool use_map_density() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_map_density")) == 1;
	}

	/** Setter: Affect the density of the particles */
	void use_map_density(bool value) {
		PyObject_SetAttrString(pyobjref, "use_map_density", Py_BuildValue("i", value));
	}

	/** Getter: Affect the particle size */
	bool use_map_size() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_map_size")) == 1;
	}

	/** Setter: Affect the particle size */
	void use_map_size(bool value) {
		PyObject_SetAttrString(pyobjref, "use_map_size", Py_BuildValue("i", value));
	}

	/** Getter: Affect the particle initial velocity */
	bool use_map_velocity() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_map_velocity")) == 1;
	}

	/** Setter: Affect the particle initial velocity */
	void use_map_velocity(bool value) {
		PyObject_SetAttrString(pyobjref, "use_map_velocity", Py_BuildValue("i", value));
	}

	/** Getter: Affect the particle force fields */
	bool use_map_field() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_map_field")) == 1;
	}

	/** Setter: Affect the particle force fields */
	void use_map_field(bool value) {
		PyObject_SetAttrString(pyobjref, "use_map_field", Py_BuildValue("i", value));
	}

	/** Getter: Affect the particle gravity */
	bool use_map_gravity() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_map_gravity")) == 1;
	}

	/** Setter: Affect the particle gravity */
	void use_map_gravity(bool value) {
		PyObject_SetAttrString(pyobjref, "use_map_gravity", Py_BuildValue("i", value));
	}

	/** Getter: Affect the particle velocity damping */
	bool use_map_damp() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_map_damp")) == 1;
	}

	/** Setter: Affect the particle velocity damping */
	void use_map_damp(bool value) {
		PyObject_SetAttrString(pyobjref, "use_map_damp", Py_BuildValue("i", value));
	}

	/** Getter: Affect the child clumping */
	bool use_map_clump() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_map_clump")) == 1;
	}

	/** Setter: Affect the child clumping */
	void use_map_clump(bool value) {
		PyObject_SetAttrString(pyobjref, "use_map_clump", Py_BuildValue("i", value));
	}

	/** Getter: Affect the child kink amplitude */
	bool use_map_kink_amp() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_map_kink_amp")) == 1;
	}

	/** Setter: Affect the child kink amplitude */
	void use_map_kink_amp(bool value) {
		PyObject_SetAttrString(pyobjref, "use_map_kink_amp", Py_BuildValue("i", value));
	}

	/** Getter: Affect the child kink frequency */
	bool use_map_kink_freq() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_map_kink_freq")) == 1;
	}

	/** Setter: Affect the child kink frequency */
	void use_map_kink_freq(bool value) {
		PyObject_SetAttrString(pyobjref, "use_map_kink_freq", Py_BuildValue("i", value));
	}

	/** Getter: Affect the child rough */
	bool use_map_rough() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_map_rough")) == 1;
	}

	/** Setter: Affect the child rough */
	void use_map_rough(bool value) {
		PyObject_SetAttrString(pyobjref, "use_map_rough", Py_BuildValue("i", value));
	}

	/** Getter: Affect the child hair length */
	bool use_map_length() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_map_length")) == 1;
	}

	/** Setter: Affect the child hair length */
	void use_map_length(bool value) {
		PyObject_SetAttrString(pyobjref, "use_map_length", Py_BuildValue("i", value));
	}

	/** Getter: Amount texture affects particle emission time */
	float time_factor() { /* not implemented */ throw NULL; }
	/** Setter: Amount texture affects particle emission time */
	void time_factor(float value) {
		PyObject_SetAttrString(pyobjref, "time_factor", Py_BuildValue("f", value));
	}

	/** Getter: Amount texture affects particle life time */
	float life_factor() { /* not implemented */ throw NULL; }
	/** Setter: Amount texture affects particle life time */
	void life_factor(float value) {
		PyObject_SetAttrString(pyobjref, "life_factor", Py_BuildValue("f", value));
	}

	/** Getter: Amount texture affects particle density */
	float density_factor() { /* not implemented */ throw NULL; }
	/** Setter: Amount texture affects particle density */
	void density_factor(float value) {
		PyObject_SetAttrString(pyobjref, "density_factor", Py_BuildValue("f", value));
	}

	/** Getter: Amount texture affects physical particle size */
	float size_factor() { /* not implemented */ throw NULL; }
	/** Setter: Amount texture affects physical particle size */
	void size_factor(float value) {
		PyObject_SetAttrString(pyobjref, "size_factor", Py_BuildValue("f", value));
	}

	/** Getter: Amount texture affects particle initial velocity */
	float velocity_factor() { /* not implemented */ throw NULL; }
	/** Setter: Amount texture affects particle initial velocity */
	void velocity_factor(float value) {
		PyObject_SetAttrString(pyobjref, "velocity_factor", Py_BuildValue("f", value));
	}

	/** Getter: Amount texture affects particle force fields */
	float field_factor() { /* not implemented */ throw NULL; }
	/** Setter: Amount texture affects particle force fields */
	void field_factor(float value) {
		PyObject_SetAttrString(pyobjref, "field_factor", Py_BuildValue("f", value));
	}

	/** Getter: Amount texture affects particle gravity */
	float gravity_factor() { /* not implemented */ throw NULL; }
	/** Setter: Amount texture affects particle gravity */
	void gravity_factor(float value) {
		PyObject_SetAttrString(pyobjref, "gravity_factor", Py_BuildValue("f", value));
	}

	/** Getter: Amount texture affects particle damping */
	float damp_factor() { /* not implemented */ throw NULL; }
	/** Setter: Amount texture affects particle damping */
	void damp_factor(float value) {
		PyObject_SetAttrString(pyobjref, "damp_factor", Py_BuildValue("f", value));
	}

	/** Getter: Amount texture affects child hair length */
	float length_factor() { /* not implemented */ throw NULL; }
	/** Setter: Amount texture affects child hair length */
	void length_factor(float value) {
		PyObject_SetAttrString(pyobjref, "length_factor", Py_BuildValue("f", value));
	}

	/** Getter: Amount texture affects child clump */
	float clump_factor() { /* not implemented */ throw NULL; }
	/** Setter: Amount texture affects child clump */
	void clump_factor(float value) {
		PyObject_SetAttrString(pyobjref, "clump_factor", Py_BuildValue("f", value));
	}

	/** Getter: Amount texture affects child kink amplitude */
	float kink_amp_factor() { /* not implemented */ throw NULL; }
	/** Setter: Amount texture affects child kink amplitude */
	void kink_amp_factor(float value) {
		PyObject_SetAttrString(pyobjref, "kink_amp_factor", Py_BuildValue("f", value));
	}

	/** Getter: Amount texture affects child kink frequency */
	float kink_freq_factor() { /* not implemented */ throw NULL; }
	/** Setter: Amount texture affects child kink frequency */
	void kink_freq_factor(float value) {
		PyObject_SetAttrString(pyobjref, "kink_freq_factor", Py_BuildValue("f", value));
	}

	/** Getter: Amount texture affects child roughness */
	float rough_factor() { /* not implemented */ throw NULL; }
	/** Setter: Amount texture affects child roughness */
	void rough_factor(float value) {
		PyObject_SetAttrString(pyobjref, "rough_factor", Py_BuildValue("f", value));
	}

};

/**************** Particle Settings ****************/

/**
 * Particle settings, reusable by multiple particle systems
 */
class ParticleSettings : public ID {
public:
	ParticleSettings(PyObject* pyobj) : ID(pyobj) {}

	ParticleSettings() : ID(0)
	{
		// not implemented
	}

	/** Getter: Texture slots defining the mapping and influence of textures */
	std::map<std::string, ParticleSettingsTextureSlot> texture_slots() {
		// TODO: MISSING DEREF! USE #DEFINE!
		PyObject *seqval = PyObject_GetAttrString(pyobjref, "texture_slots");
		PyObject *seqkeys = PyObject_CallMethod(seqval, "keys", NULL);
		std::map<std::string, ParticleSettingsTextureSlot> resmap;
		for (int i = 0; i < PySequence_Length(seqval); i++) {
			PyObject *keyobj = PySequence_GetItem(seqkeys, i);
			std::string key = PyBytes_AsString(PyUnicode_AsASCIIString(keyobj));
			ParticleSettingsTextureSlot value = ParticleSettingsTextureSlot(PySequence_GetItem(seqval, i));
			resmap.insert(std::pair<std::string,ParticleSettingsTextureSlot>(key, value));
		}
		return resmap;
	}

	/** Setter: Texture slots defining the mapping and influence of textures */
	void texture_slots(std::map<std::string, ParticleSettingsTextureSlot> value) { /* not implemented */ }

	/** Getter: Active texture slot being displayed */
	Texture active_texture() {
		/* not implemented */ throw NULL;
	}

	/** Getter: Index of active texture slot */
	int active_texture_index() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "active_texture_index"));
	}

	/** Setter: Index of active texture slot */
	void active_texture_index(int value) {
		PyObject_SetAttrString(pyobjref, "active_texture_index", Py_BuildValue("i", value));
	}

	/** Getter: Particles were created by a fluid simulation */
	bool is_fluid() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "is_fluid")) == 1;
	}

	/** Setter: Particles were created by a fluid simulation */
	void is_fluid(bool value) {
		PyObject_SetAttrString(pyobjref, "is_fluid", Py_BuildValue("i", value));
	}

	/** Getter: Give birth to unreacted particles eventually */
	bool use_react_start_end() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_react_start_end")) == 1;
	}

	/** Setter: Give birth to unreacted particles eventually */
	void use_react_start_end(bool value) {
		PyObject_SetAttrString(pyobjref, "use_react_start_end", Py_BuildValue("i", value));
	}

	/** Getter: React multiple times */
	bool use_react_multiple() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_react_multiple")) == 1;
	}

	/** Setter: React multiple times */
	void use_react_multiple(bool value) {
		PyObject_SetAttrString(pyobjref, "use_react_multiple", Py_BuildValue("i", value));
	}

	/** Getter: Regrow hair for each frame */
	bool regrow_hair() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "regrow_hair")) == 1;
	}

	/** Setter: Regrow hair for each frame */
	void regrow_hair(bool value) {
		PyObject_SetAttrString(pyobjref, "regrow_hair", Py_BuildValue("i", value));
	}

	/** Getter: Show particles before they are emitted */
	bool show_unborn() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "show_unborn")) == 1;
	}

	/** Setter: Show particles before they are emitted */
	void show_unborn(bool value) {
		PyObject_SetAttrString(pyobjref, "show_unborn", Py_BuildValue("i", value));
	}

	/** Getter: Show particles after they have died */
	bool use_dead() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_dead")) == 1;
	}

	/** Setter: Show particles after they have died */
	void use_dead(bool value) {
		PyObject_SetAttrString(pyobjref, "use_dead", Py_BuildValue("i", value));
	}

	/** Getter: Emit in random order of elements */
	bool use_emit_random() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_emit_random")) == 1;
	}

	/** Setter: Emit in random order of elements */
	void use_emit_random(bool value) {
		PyObject_SetAttrString(pyobjref, "use_emit_random", Py_BuildValue("i", value));
	}

	/** Getter: Use even distribution from faces based on face areas or edge lengths */
	bool use_even_distribution() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_even_distribution")) == 1;
	}

	/** Setter: Use even distribution from faces based on face areas or edge lengths */
	void use_even_distribution(bool value) {
		PyObject_SetAttrString(pyobjref, "use_even_distribution", Py_BuildValue("i", value));
	}

	/** Getter: Particles die when they collide with a deflector object */
	bool use_die_on_collision() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_die_on_collision")) == 1;
	}

	/** Setter: Particles die when they collide with a deflector object */
	void use_die_on_collision(bool value) {
		PyObject_SetAttrString(pyobjref, "use_die_on_collision", Py_BuildValue("i", value));
	}

	/** Getter: Use particle's size in deflection */
	bool use_size_deflect() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_size_deflect")) == 1;
	}

	/** Setter: Use particle's size in deflection */
	void use_size_deflect(bool value) {
		PyObject_SetAttrString(pyobjref, "use_size_deflect", Py_BuildValue("i", value));
	}

	/** Getter: Calculate particle rotations */
	bool use_rotations() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_rotations")) == 1;
	}

	/** Setter: Calculate particle rotations */
	void use_rotations(bool value) {
		PyObject_SetAttrString(pyobjref, "use_rotations", Py_BuildValue("i", value));
	}

	/** Getter: Particle rotations are affected by collisions and effectors */
	bool use_dynamic_rotation() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_dynamic_rotation")) == 1;
	}

	/** Setter: Particle rotations are affected by collisions and effectors */
	void use_dynamic_rotation(bool value) {
		PyObject_SetAttrString(pyobjref, "use_dynamic_rotation", Py_BuildValue("i", value));
	}

	/** Getter: Multiply mass by particle size */
	bool use_multiply_size_mass() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_multiply_size_mass")) == 1;
	}

	/** Setter: Multiply mass by particle size */
	void use_multiply_size_mass(bool value) {
		PyObject_SetAttrString(pyobjref, "use_multiply_size_mass", Py_BuildValue("i", value));
	}

	/** Getter: Use full physics calculations for growing hair */
	bool use_advanced_hair() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_advanced_hair")) == 1;
	}

	/** Setter: Use full physics calculations for growing hair */
	void use_advanced_hair(bool value) {
		PyObject_SetAttrString(pyobjref, "use_advanced_hair", Py_BuildValue("i", value));
	}

	/** Getter: Constrain boids to a surface */
	bool lock_boids_to_surface() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "lock_boids_to_surface")) == 1;
	}

	/** Setter: Constrain boids to a surface */
	void lock_boids_to_surface(bool value) {
		PyObject_SetAttrString(pyobjref, "lock_boids_to_surface", Py_BuildValue("i", value));
	}

	/** Getter: Interpolate hair using B-Splines */
	bool use_hair_bspline() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_hair_bspline")) == 1;
	}

	/** Setter: Interpolate hair using B-Splines */
	void use_hair_bspline(bool value) {
		PyObject_SetAttrString(pyobjref, "use_hair_bspline", Py_BuildValue("i", value));
	}

	/** Getter: Invert what is considered object and what is not */
	bool invert_grid() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "invert_grid")) == 1;
	}

	/** Setter: Invert what is considered object and what is not */
	void invert_grid(bool value) {
		PyObject_SetAttrString(pyobjref, "invert_grid", Py_BuildValue("i", value));
	}

	/** Getter: Create the grid in a hexagonal pattern */
	bool hexagonal_grid() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "hexagonal_grid")) == 1;
	}

	/** Setter: Create the grid in a hexagonal pattern */
	void hexagonal_grid(bool value) {
		PyObject_SetAttrString(pyobjref, "hexagonal_grid", Py_BuildValue("i", value));
	}

	/** Getter: Apply effectors to children */
	bool apply_effector_to_children() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "apply_effector_to_children")) == 1;
	}

	/** Setter: Apply effectors to children */
	void apply_effector_to_children(bool value) {
		PyObject_SetAttrString(pyobjref, "apply_effector_to_children", Py_BuildValue("i", value));
	}

	/** Getter: Calculate children that suit long hair well */
	bool create_long_hair_children() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "create_long_hair_children")) == 1;
	}

	/** Setter: Calculate children that suit long hair well */
	void create_long_hair_children(bool value) {
		PyObject_SetAttrString(pyobjref, "create_long_hair_children", Py_BuildValue("i", value));
	}

	/** Getter:  */
	bool apply_guide_to_children() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "apply_guide_to_children")) == 1;
	}

	/** Setter:  */
	void apply_guide_to_children(bool value) {
		PyObject_SetAttrString(pyobjref, "apply_guide_to_children", Py_BuildValue("i", value));
	}

	/** Getter: Particle effectors affect themselves */
	bool use_self_effect() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_self_effect")) == 1;
	}

	/** Setter: Particle effectors affect themselves */
	void use_self_effect(bool value) {
		PyObject_SetAttrString(pyobjref, "use_self_effect", Py_BuildValue("i", value));
	}

	enum type_enum {
		type_EMITTER = 0,
		type_HAIR = 2,
	};

	/** Getter: Particle Type */
	type_enum type() { /* not implemented */ throw NULL; }
	/** Setter: Particle Type */
	void type(type_enum value) { /* not implemented */ }

	enum emit_from_enum {
		emit_from_VERT = 0,
		emit_from_FACE = 1,
		emit_from_VOLUME = 2,
	};

	/** Getter: Where to emit particles from */
	emit_from_enum emit_from() { /* not implemented */ throw NULL; }
	/** Setter: Where to emit particles from */
	void emit_from(emit_from_enum value) { /* not implemented */ }

	enum distribution_enum {
		distribution_JIT = 0,
		distribution_RAND = 1,
		distribution_GRID = 2,
	};

	/** Getter: How to distribute particles on selected element */
	distribution_enum distribution() { /* not implemented */ throw NULL; }
	/** Setter: How to distribute particles on selected element */
	void distribution(distribution_enum value) { /* not implemented */ }

	enum physics_type_enum {
		physics_type_NO = 0,
		physics_type_NEWTON = 1,
		physics_type_KEYED = 2,
		physics_type_BOIDS = 3,
		physics_type_FLUID = 4,
	};

	/** Getter: Particle physics type */
	physics_type_enum physics_type() { /* not implemented */ throw NULL; }
	/** Setter: Particle physics type */
	void physics_type(physics_type_enum value) { /* not implemented */ }

	enum rotation_mode_enum {
		rotation_mode_NONE = 0,
		rotation_mode_NOR = 1,
		rotation_mode_NOR_TAN = 9,
		rotation_mode_VEL = 2,
		rotation_mode_GLOB_X = 3,
		rotation_mode_GLOB_Y = 4,
		rotation_mode_GLOB_Z = 5,
		rotation_mode_OB_X = 6,
		rotation_mode_OB_Y = 7,
		rotation_mode_OB_Z = 8,
	};

	/** Getter: Particle orientation axis (does not affect Explode modifier's results) */
	rotation_mode_enum rotation_mode() { /* not implemented */ throw NULL; }
	/** Setter: Particle orientation axis (does not affect Explode modifier's results) */
	void rotation_mode(rotation_mode_enum value) { /* not implemented */ }

	enum angular_velocity_mode_enum {
		angular_velocity_mode_NONE = 0,
		angular_velocity_mode_VELOCITY = 1,
		angular_velocity_mode_HORIZONTAL = 3,
		angular_velocity_mode_VERTICAL = 4,
		angular_velocity_mode_GLOBAL_X = 5,
		angular_velocity_mode_GLOBAL_Y = 6,
		angular_velocity_mode_GLOBAL_Z = 7,
		angular_velocity_mode_RAND = 2,
	};

	/** Getter: What axis is used to change particle rotation with time */
	angular_velocity_mode_enum angular_velocity_mode() { /* not implemented */ throw NULL; }
	/** Setter: What axis is used to change particle rotation with time */
	void angular_velocity_mode(angular_velocity_mode_enum value) { /* not implemented */ }

	enum react_event_enum {
		react_event_DEATH = 0,
		react_event_COLLIDE = 1,
		react_event_NEAR = 2,
	};

	/** Getter: The event of target particles to react on */
	react_event_enum react_event() { /* not implemented */ throw NULL; }
	/** Setter: The event of target particles to react on */
	void react_event(react_event_enum value) { /* not implemented */ }

	/** Getter: Show guide hairs */
	bool show_guide_hairs() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "show_guide_hairs")) == 1;
	}

	/** Setter: Show guide hairs */
	void show_guide_hairs(bool value) {
		PyObject_SetAttrString(pyobjref, "show_guide_hairs", Py_BuildValue("i", value));
	}

	/** Getter: Show guide hairs */
	bool show_hair_grid() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "show_hair_grid")) == 1;
	}

	/** Setter: Show guide hairs */
	void show_hair_grid(bool value) {
		PyObject_SetAttrString(pyobjref, "show_hair_grid", Py_BuildValue("i", value));
	}

	/** Getter: Show particle velocity */
	bool show_velocity() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "show_velocity")) == 1;
	}

	/** Setter: Show particle velocity */
	void show_velocity(bool value) {
		PyObject_SetAttrString(pyobjref, "show_velocity", Py_BuildValue("i", value));
	}

	/** Getter: Show particle size */
	bool show_size() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "show_size")) == 1;
	}

	/** Setter: Show particle size */
	void show_size(bool value) {
		PyObject_SetAttrString(pyobjref, "show_size", Py_BuildValue("i", value));
	}

	/** Getter: Render emitter Object also */
	bool use_render_emitter() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_render_emitter")) == 1;
	}

	/** Setter: Render emitter Object also */
	void use_render_emitter(bool value) {
		PyObject_SetAttrString(pyobjref, "use_render_emitter", Py_BuildValue("i", value));
	}

	/** Getter: Draw boid health */
	bool show_health() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "show_health")) == 1;
	}

	/** Setter: Draw boid health */
	void show_health(bool value) {
		PyObject_SetAttrString(pyobjref, "show_health", Py_BuildValue("i", value));
	}

	/** Getter: Path timing is in absolute frames */
	bool use_absolute_path_time() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_absolute_path_time")) == 1;
	}

	/** Setter: Path timing is in absolute frames */
	void use_absolute_path_time(bool value) {
		PyObject_SetAttrString(pyobjref, "use_absolute_path_time", Py_BuildValue("i", value));
	}

	/** Getter: Render parent particles */
	bool use_parent_particles() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_parent_particles")) == 1;
	}

	/** Setter: Render parent particles */
	void use_parent_particles(bool value) {
		PyObject_SetAttrString(pyobjref, "use_parent_particles", Py_BuildValue("i", value));
	}

	/** Getter: Show particle number */
	bool show_number() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "show_number")) == 1;
	}

	/** Setter: Show particle number */
	void show_number(bool value) {
		PyObject_SetAttrString(pyobjref, "show_number", Py_BuildValue("i", value));
	}

	/** Getter: Pick objects from group randomly */
	bool use_group_pick_random() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_group_pick_random")) == 1;
	}

	/** Setter: Pick objects from group randomly */
	void use_group_pick_random(bool value) {
		PyObject_SetAttrString(pyobjref, "use_group_pick_random", Py_BuildValue("i", value));
	}

	/** Getter: Use object multiple times in the same group */
	bool use_group_count() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_group_count")) == 1;
	}

	/** Setter: Use object multiple times in the same group */
	void use_group_count(bool value) {
		PyObject_SetAttrString(pyobjref, "use_group_count", Py_BuildValue("i", value));
	}

	/** Getter: Use object's global coordinates for duplication */
	bool use_global_dupli() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_global_dupli")) == 1;
	}

	/** Setter: Use object's global coordinates for duplication */
	void use_global_dupli(bool value) {
		PyObject_SetAttrString(pyobjref, "use_global_dupli", Py_BuildValue("i", value));
	}

	/** Getter: Use object's rotation for duplication (global x-axis is aligned particle rotation axis) */
	bool use_rotation_dupli() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_rotation_dupli")) == 1;
	}

	/** Setter: Use object's rotation for duplication (global x-axis is aligned particle rotation axis) */
	void use_rotation_dupli(bool value) {
		PyObject_SetAttrString(pyobjref, "use_rotation_dupli", Py_BuildValue("i", value));
	}

	/** Getter: Use object's scale for duplication */
	bool use_scale_dupli() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_scale_dupli")) == 1;
	}

	/** Setter: Use object's scale for duplication */
	void use_scale_dupli(bool value) {
		PyObject_SetAttrString(pyobjref, "use_scale_dupli", Py_BuildValue("i", value));
	}

	/** Getter: Draw steps of the particle path */
	bool use_render_adaptive() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_render_adaptive")) == 1;
	}

	/** Setter: Draw steps of the particle path */
	void use_render_adaptive(bool value) {
		PyObject_SetAttrString(pyobjref, "use_render_adaptive", Py_BuildValue("i", value));
	}

	/** Getter: Multiply line length by particle speed */
	bool use_velocity_length() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_velocity_length")) == 1;
	}

	/** Setter: Multiply line length by particle speed */
	void use_velocity_length(bool value) {
		PyObject_SetAttrString(pyobjref, "use_velocity_length", Py_BuildValue("i", value));
	}

	/** Getter: Use whole group at once */
	bool use_whole_group() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_whole_group")) == 1;
	}

	/** Setter: Use whole group at once */
	void use_whole_group(bool value) {
		PyObject_SetAttrString(pyobjref, "use_whole_group", Py_BuildValue("i", value));
	}

	/** Getter: Use the strand primitive for rendering */
	bool use_strand_primitive() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_strand_primitive")) == 1;
	}

	/** Setter: Use the strand primitive for rendering */
	void use_strand_primitive(bool value) {
		PyObject_SetAttrString(pyobjref, "use_strand_primitive", Py_BuildValue("i", value));
	}

	enum draw_method_enum {
		draw_method_NONE = 0,
		draw_method_RENDER = 10,
		draw_method_DOT = 1,
		draw_method_CIRC = 2,
		draw_method_CROSS = 3,
		draw_method_AXIS = 4,
	};

	/** Getter: How particles are drawn in viewport */
	draw_method_enum draw_method() { /* not implemented */ throw NULL; }
	/** Setter: How particles are drawn in viewport */
	void draw_method(draw_method_enum value) { /* not implemented */ }

	enum render_type_enum {
		render_type_NONE = 0,
		render_type_HALO = 1,
		render_type_LINE = 5,
		render_type_PATH = 6,
		render_type_OBJECT = 7,
		render_type_GROUP = 8,
		render_type_BILLBOARD = 9,
	};

	/** Getter: How particles are rendered */
	render_type_enum render_type() { /* not implemented */ throw NULL; }
	/** Setter: How particles are rendered */
	void render_type(render_type_enum value) { /* not implemented */ }

	enum draw_color_enum {
		draw_color_NONE = 0,
		draw_color_MATERIAL = 1,
		draw_color_VELOCITY = 2,
		draw_color_ACCELERATION = 3,
	};

	/** Getter: Draw additional particle data as a color */
	draw_color_enum draw_color() { /* not implemented */ throw NULL; }
	/** Setter: Draw additional particle data as a color */
	void draw_color(draw_color_enum value) { /* not implemented */ }

	/** Getter: Size of particles on viewport in pixels (0=default) */
	int draw_size() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "draw_size"));
	}

	/** Setter: Size of particles on viewport in pixels (0=default) */
	void draw_size(int value) {
		PyObject_SetAttrString(pyobjref, "draw_size", Py_BuildValue("i", value));
	}

	enum child_type_enum {
		child_type_NONE = 0,
		child_type_SIMPLE = 1,
		child_type_INTERPOLATED = 2,
	};

	/** Getter: Create child particles */
	child_type_enum child_type() { /* not implemented */ throw NULL; }
	/** Setter: Create child particles */
	void child_type(child_type_enum value) { /* not implemented */ }

	/** Getter: How many steps paths are drawn with (power of 2) */
	int draw_step() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "draw_step"));
	}

	/** Setter: How many steps paths are drawn with (power of 2) */
	void draw_step(int value) {
		PyObject_SetAttrString(pyobjref, "draw_step", Py_BuildValue("i", value));
	}

	/** Getter: How many steps paths are rendered with (power of 2) */
	int render_step() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "render_step"));
	}

	/** Setter: How many steps paths are rendered with (power of 2) */
	void render_step(int value) {
		PyObject_SetAttrString(pyobjref, "render_step", Py_BuildValue("i", value));
	}

	/** Getter: Number of hair segments */
	int hair_step() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "hair_step"));
	}

	/** Setter: Number of hair segments */
	void hair_step(int value) {
		PyObject_SetAttrString(pyobjref, "hair_step", Py_BuildValue("i", value));
	}

	/** Getter: Random stiffness of hairs */
	float bending_random() { /* not implemented */ throw NULL; }
	/** Setter: Random stiffness of hairs */
	void bending_random(float value) {
		PyObject_SetAttrString(pyobjref, "bending_random", Py_BuildValue("f", value));
	}

	/** Getter:  */
	int keys_step() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "keys_step"));
	}

	/** Setter:  */
	void keys_step(int value) {
		PyObject_SetAttrString(pyobjref, "keys_step", Py_BuildValue("i", value));
	}

	/** Getter: How many degrees path has to curve to make another render segment */
	int adaptive_angle() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "adaptive_angle"));
	}

	/** Setter: How many degrees path has to curve to make another render segment */
	void adaptive_angle(int value) {
		PyObject_SetAttrString(pyobjref, "adaptive_angle", Py_BuildValue("i", value));
	}

	/** Getter: How many pixels path has to cover to make another render segment */
	int adaptive_pixel() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "adaptive_pixel"));
	}

	/** Setter: How many pixels path has to cover to make another render segment */
	void adaptive_pixel(int value) {
		PyObject_SetAttrString(pyobjref, "adaptive_pixel", Py_BuildValue("i", value));
	}

	/** Getter: Percentage of particles to display in 3D view */
	int draw_percentage() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "draw_percentage"));
	}

	/** Setter: Percentage of particles to display in 3D view */
	void draw_percentage(int value) {
		PyObject_SetAttrString(pyobjref, "draw_percentage", Py_BuildValue("i", value));
	}

	/** Getter: Index of material slot used for rendering particles */
	int material() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "material"));
	}

	/** Setter: Index of material slot used for rendering particles */
	void material(int value) {
		PyObject_SetAttrString(pyobjref, "material", Py_BuildValue("i", value));
	}

	enum material_slot_enum {
		material_slot_DUMMY = 0,
	};

	/** Getter: Material slot used for rendering particles */
	material_slot_enum material_slot() { /* not implemented */ throw NULL; }
	/** Setter: Material slot used for rendering particles */
	void material_slot(material_slot_enum value) { /* not implemented */ }

	enum integrator_enum {
		integrator_EULER = 0,
		integrator_VERLET = 3,
		integrator_MIDPOINT = 1,
		integrator_RK4 = 2,
	};

	/** Getter: Algorithm used to calculate physics, from the fastest to the most stable/accurate: Midpoint, Euler, Verlet, RK4 (Old) */
	integrator_enum integrator() { /* not implemented */ throw NULL; }
	/** Setter: Algorithm used to calculate physics, from the fastest to the most stable/accurate: Midpoint, Euler, Verlet, RK4 (Old) */
	void integrator(integrator_enum value) { /* not implemented */ }

	enum kink_enum {
		kink_NO = 0,
		kink_CURL = 1,
		kink_RADIAL = 2,
		kink_WAVE = 3,
		kink_BRAID = 4,
		kink_SPIRAL = 5,
	};

	/** Getter: Type of periodic offset on the path */
	kink_enum kink() { /* not implemented */ throw NULL; }
	/** Setter: Type of periodic offset on the path */
	void kink(kink_enum value) { /* not implemented */ }

	enum kink_axis_enum {
		kink_axis_X = 0,
		kink_axis_Y = 1,
		kink_axis_Z = 2,
	};

	/** Getter: Which axis to use for offset */
	kink_axis_enum kink_axis() { /* not implemented */ throw NULL; }
	/** Setter: Which axis to use for offset */
	void kink_axis(kink_axis_enum value) { /* not implemented */ }

	/** Getter: Lock the billboards align axis */
	bool lock_billboard() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "lock_billboard")) == 1;
	}

	/** Setter: Lock the billboards align axis */
	void lock_billboard(bool value) {
		PyObject_SetAttrString(pyobjref, "lock_billboard", Py_BuildValue("i", value));
	}

	enum billboard_align_enum {
		billboard_align_X = 0,
		billboard_align_Y = 1,
		billboard_align_Z = 2,
		billboard_align_VIEW = 3,
		billboard_align_VEL = 4,
	};

	/** Getter: In respect to what the billboards are aligned */
	billboard_align_enum billboard_align() { /* not implemented */ throw NULL; }
	/** Setter: In respect to what the billboards are aligned */
	void billboard_align(billboard_align_enum value) { /* not implemented */ }

	/** Getter: Number of rows/columns to split UV coordinates for billboards */
	int billboard_uv_split() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "billboard_uv_split"));
	}

	/** Setter: Number of rows/columns to split UV coordinates for billboards */
	void billboard_uv_split(int value) {
		PyObject_SetAttrString(pyobjref, "billboard_uv_split", Py_BuildValue("i", value));
	}

	enum billboard_animation_enum {
		billboard_animation_NONE = 0,
		billboard_animation_AGE = 1,
		billboard_animation_FRAME = 3,
		billboard_animation_ANGLE = 2,
	};

	/** Getter: How to animate billboard textures */
	billboard_animation_enum billboard_animation() { /* not implemented */ throw NULL; }
	/** Setter: How to animate billboard textures */
	void billboard_animation(billboard_animation_enum value) { /* not implemented */ }

	enum billboard_offset_split_enum {
		billboard_offset_split_NONE = 0,
		billboard_offset_split_LINEAR = 1,
		billboard_offset_split_RANDOM = 2,
	};

	/** Getter: How to offset billboard textures */
	billboard_offset_split_enum billboard_offset_split() { /* not implemented */ throw NULL; }
	/** Setter: How to offset billboard textures */
	void billboard_offset_split(billboard_offset_split_enum value) { /* not implemented */ }

	/** Getter: Tilt of the billboards */
	float billboard_tilt() { /* not implemented */ throw NULL; }
	/** Setter: Tilt of the billboards */
	void billboard_tilt(float value) {
		PyObject_SetAttrString(pyobjref, "billboard_tilt", Py_BuildValue("f", value));
	}

	/** Getter: Maximum length of the particle color vector */
	float color_maximum() { /* not implemented */ throw NULL; }
	/** Setter: Maximum length of the particle color vector */
	void color_maximum(float value) {
		PyObject_SetAttrString(pyobjref, "color_maximum", Py_BuildValue("f", value));
	}

	/** Getter: Random tilt of the billboards */
	float billboard_tilt_random() { /* not implemented */ throw NULL; }
	/** Setter: Random tilt of the billboards */
	void billboard_tilt_random(float value) {
		PyObject_SetAttrString(pyobjref, "billboard_tilt_random", Py_BuildValue("f", value));
	}

	/** Getter:  */
	std::array<float, 2> billboard_offset() {
		// TODO: MISSING DEREF! USE #DEFINE!
		PyObject *seqval = PyObject_GetAttrString(pyobjref, "billboard_offset");
		std::array<float, 2> resarr;
		for (int i = 0; i < 2; i++)
			resarr[i] = (float)PyFloat_AsDouble(PySequence_GetItem(seqval, i));
		return resarr;
	}

	/** Setter:  */
	void billboard_offset(float values[2]) { /* not implemented */ }

	/** Getter: Scale billboards relative to particle size */
	std::array<float, 2> billboard_size() {
		// TODO: MISSING DEREF! USE #DEFINE!
		PyObject *seqval = PyObject_GetAttrString(pyobjref, "billboard_size");
		std::array<float, 2> resarr;
		for (int i = 0; i < 2; i++)
			resarr[i] = (float)PyFloat_AsDouble(PySequence_GetItem(seqval, i));
		return resarr;
	}

	/** Setter: Scale billboards relative to particle size */
	void billboard_size(float values[2]) { /* not implemented */ }

	/** Getter: Scale billboards by velocity */
	float billboard_velocity_head() { /* not implemented */ throw NULL; }
	/** Setter: Scale billboards by velocity */
	void billboard_velocity_head(float value) {
		PyObject_SetAttrString(pyobjref, "billboard_velocity_head", Py_BuildValue("f", value));
	}

	/** Getter: Scale billboards by velocity */
	float billboard_velocity_tail() { /* not implemented */ throw NULL; }
	/** Setter: Scale billboards by velocity */
	void billboard_velocity_tail(float value) {
		PyObject_SetAttrString(pyobjref, "billboard_velocity_tail", Py_BuildValue("f", value));
	}

	/** Getter: Remove child strands as the object becomes smaller on the screen */
	bool use_simplify() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_simplify")) == 1;
	}

	/** Setter: Remove child strands as the object becomes smaller on the screen */
	void use_simplify(bool value) {
		PyObject_SetAttrString(pyobjref, "use_simplify", Py_BuildValue("i", value));
	}

	/** Getter:  */
	bool use_simplify_viewport() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_simplify_viewport")) == 1;
	}

	/** Setter:  */
	void use_simplify_viewport(bool value) {
		PyObject_SetAttrString(pyobjref, "use_simplify_viewport", Py_BuildValue("i", value));
	}

	/** Getter: Reference size in pixels, after which simplification begins */
	int simplify_refsize() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "simplify_refsize"));
	}

	/** Setter: Reference size in pixels, after which simplification begins */
	void simplify_refsize(int value) {
		PyObject_SetAttrString(pyobjref, "simplify_refsize", Py_BuildValue("i", value));
	}

	/** Getter: Speed of simplification */
	float simplify_rate() { /* not implemented */ throw NULL; }
	/** Setter: Speed of simplification */
	void simplify_rate(float value) {
		PyObject_SetAttrString(pyobjref, "simplify_rate", Py_BuildValue("f", value));
	}

	/** Getter: Transition period for fading out strands */
	float simplify_transition() { /* not implemented */ throw NULL; }
	/** Setter: Transition period for fading out strands */
	void simplify_transition(float value) {
		PyObject_SetAttrString(pyobjref, "simplify_transition", Py_BuildValue("f", value));
	}

	/** Getter: Speed of Simplification */
	float simplify_viewport() { /* not implemented */ throw NULL; }
	/** Setter: Speed of Simplification */
	void simplify_viewport(float value) {
		PyObject_SetAttrString(pyobjref, "simplify_viewport", Py_BuildValue("f", value));
	}

	/** Getter: Frame number to start emitting particles */
	float frame_start() { /* not implemented */ throw NULL; }
	/** Setter: Frame number to start emitting particles */
	void frame_start(float value) {
		PyObject_SetAttrString(pyobjref, "frame_start", Py_BuildValue("f", value));
	}

	/** Getter: Frame number to stop emitting particles */
	float frame_end() { /* not implemented */ throw NULL; }
	/** Setter: Frame number to stop emitting particles */
	void frame_end(float value) {
		PyObject_SetAttrString(pyobjref, "frame_end", Py_BuildValue("f", value));
	}

	/** Getter: Life span of the particles */
	float lifetime() { /* not implemented */ throw NULL; }
	/** Setter: Life span of the particles */
	void lifetime(float value) {
		PyObject_SetAttrString(pyobjref, "lifetime", Py_BuildValue("f", value));
	}

	/** Getter: Give the particle life a random variation */
	float lifetime_random() { /* not implemented */ throw NULL; }
	/** Setter: Give the particle life a random variation */
	void lifetime_random(float value) {
		PyObject_SetAttrString(pyobjref, "lifetime_random", Py_BuildValue("f", value));
	}

	/** Getter: A multiplier for physics timestep (1.0 means one frame = 1/25 seconds) */
	float time_tweak() { /* not implemented */ throw NULL; }
	/** Setter: A multiplier for physics timestep (1.0 means one frame = 1/25 seconds) */
	void time_tweak(float value) {
		PyObject_SetAttrString(pyobjref, "time_tweak", Py_BuildValue("f", value));
	}

	/** Getter: The simulation timestep per frame (seconds per frame) */
	float timestep() { /* not implemented */ throw NULL; }
	/** Setter: The simulation timestep per frame (seconds per frame) */
	void timestep(float value) {
		PyObject_SetAttrString(pyobjref, "timestep", Py_BuildValue("f", value));
	}

	/** Getter: Automatically set the number of subframes */
	bool use_adaptive_subframes() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_adaptive_subframes")) == 1;
	}

	/** Setter: Automatically set the number of subframes */
	void use_adaptive_subframes(bool value) {
		PyObject_SetAttrString(pyobjref, "use_adaptive_subframes", Py_BuildValue("i", value));
	}

	/** Getter: Subframes to simulate for improved stability and finer granularity simulations (dt = timestep / (subframes + 1)) */
	int subframes() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "subframes"));
	}

	/** Setter: Subframes to simulate for improved stability and finer granularity simulations (dt = timestep / (subframes + 1)) */
	void subframes(int value) {
		PyObject_SetAttrString(pyobjref, "subframes", Py_BuildValue("i", value));
	}

	/** Getter: The relative distance a particle can move before requiring more subframes (target Courant number); 0.01-0.3 is the recommended range */
	float courant_target() { /* not implemented */ throw NULL; }
	/** Setter: The relative distance a particle can move before requiring more subframes (target Courant number); 0.01-0.3 is the recommended range */
	void courant_target(float value) {
		PyObject_SetAttrString(pyobjref, "courant_target", Py_BuildValue("f", value));
	}

	/** Getter: Amount of jitter applied to the sampling */
	float jitter_factor() { /* not implemented */ throw NULL; }
	/** Setter: Amount of jitter applied to the sampling */
	void jitter_factor(float value) {
		PyObject_SetAttrString(pyobjref, "jitter_factor", Py_BuildValue("f", value));
	}

	/** Getter: Hair stiffness for effectors */
	float effect_hair() { /* not implemented */ throw NULL; }
	/** Setter: Hair stiffness for effectors */
	void effect_hair(float value) {
		PyObject_SetAttrString(pyobjref, "effect_hair", Py_BuildValue("f", value));
	}

	/** Getter: Total number of particles */
	int count() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "count"));
	}

	/** Setter: Total number of particles */
	void count(int value) {
		PyObject_SetAttrString(pyobjref, "count", Py_BuildValue("i", value));
	}

	/** Getter: Emission locations / face (0 = automatic) */
	int userjit() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "userjit"));
	}

	/** Setter: Emission locations / face (0 = automatic) */
	void userjit(int value) {
		PyObject_SetAttrString(pyobjref, "userjit", Py_BuildValue("i", value));
	}

	/** Getter: The resolution of the particle grid */
	int grid_resolution() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "grid_resolution"));
	}

	/** Setter: The resolution of the particle grid */
	void grid_resolution(int value) {
		PyObject_SetAttrString(pyobjref, "grid_resolution", Py_BuildValue("i", value));
	}

	/** Getter: Add random offset to the grid locations */
	float grid_random() { /* not implemented */ throw NULL; }
	/** Setter: Add random offset to the grid locations */
	void grid_random(float value) {
		PyObject_SetAttrString(pyobjref, "grid_random", Py_BuildValue("f", value));
	}

	/** Getter: How many particles are effectors (0 is all particles) */
	int effector_amount() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "effector_amount"));
	}

	/** Setter: How many particles are effectors (0 is all particles) */
	void effector_amount(int value) {
		PyObject_SetAttrString(pyobjref, "effector_amount", Py_BuildValue("i", value));
	}

	/** Getter: Let the surface normal give the particle a starting speed */
	float normal_factor() { /* not implemented */ throw NULL; }
	/** Setter: Let the surface normal give the particle a starting speed */
	void normal_factor(float value) {
		PyObject_SetAttrString(pyobjref, "normal_factor", Py_BuildValue("f", value));
	}

	/** Getter: Let the object give the particle a starting speed */
	float object_factor() { /* not implemented */ throw NULL; }
	/** Setter: Let the object give the particle a starting speed */
	void object_factor(float value) {
		PyObject_SetAttrString(pyobjref, "object_factor", Py_BuildValue("f", value));
	}

	/** Getter: Give the starting speed a random variation */
	float factor_random() { /* not implemented */ throw NULL; }
	/** Setter: Give the starting speed a random variation */
	void factor_random(float value) {
		PyObject_SetAttrString(pyobjref, "factor_random", Py_BuildValue("f", value));
	}

	/** Getter: Let the target particle give the particle a starting speed */
	float particle_factor() { /* not implemented */ throw NULL; }
	/** Setter: Let the target particle give the particle a starting speed */
	void particle_factor(float value) {
		PyObject_SetAttrString(pyobjref, "particle_factor", Py_BuildValue("f", value));
	}

	/** Getter: Let the surface tangent give the particle a starting speed */
	float tangent_factor() { /* not implemented */ throw NULL; }
	/** Setter: Let the surface tangent give the particle a starting speed */
	void tangent_factor(float value) {
		PyObject_SetAttrString(pyobjref, "tangent_factor", Py_BuildValue("f", value));
	}

	/** Getter: Rotate the surface tangent */
	float tangent_phase() { /* not implemented */ throw NULL; }
	/** Setter: Rotate the surface tangent */
	void tangent_phase(float value) {
		PyObject_SetAttrString(pyobjref, "tangent_phase", Py_BuildValue("f", value));
	}

	/** Getter: Let the vector away from the target particle's location give the particle a starting speed */
	float reactor_factor() { /* not implemented */ throw NULL; }
	/** Setter: Let the vector away from the target particle's location give the particle a starting speed */
	void reactor_factor(float value) {
		PyObject_SetAttrString(pyobjref, "reactor_factor", Py_BuildValue("f", value));
	}

	/** Getter: Let the emitter object orientation give the particle a starting speed */
	std::array<float, 3> object_align_factor() {
		// TODO: MISSING DEREF! USE #DEFINE!
		PyObject *seqval = PyObject_GetAttrString(pyobjref, "object_align_factor");
		std::array<float, 3> resarr;
		for (int i = 0; i < 3; i++)
			resarr[i] = (float)PyFloat_AsDouble(PySequence_GetItem(seqval, i));
		return resarr;
	}

	/** Setter: Let the emitter object orientation give the particle a starting speed */
	void object_align_factor(float values[3]) { /* not implemented */ }

	/** Getter: Angular velocity amount (in radians per second) */
	float angular_velocity_factor() { /* not implemented */ throw NULL; }
	/** Setter: Angular velocity amount (in radians per second) */
	void angular_velocity_factor(float value) {
		PyObject_SetAttrString(pyobjref, "angular_velocity_factor", Py_BuildValue("f", value));
	}

	/** Getter: Rotation around the chosen orientation axis */
	float phase_factor() { /* not implemented */ throw NULL; }
	/** Setter: Rotation around the chosen orientation axis */
	void phase_factor(float value) {
		PyObject_SetAttrString(pyobjref, "phase_factor", Py_BuildValue("f", value));
	}

	/** Getter: Randomize particle orientation */
	float rotation_factor_random() { /* not implemented */ throw NULL; }
	/** Setter: Randomize particle orientation */
	void rotation_factor_random(float value) {
		PyObject_SetAttrString(pyobjref, "rotation_factor_random", Py_BuildValue("f", value));
	}

	/** Getter: Randomize rotation around the chosen orientation axis */
	float phase_factor_random() { /* not implemented */ throw NULL; }
	/** Setter: Randomize rotation around the chosen orientation axis */
	void phase_factor_random(float value) {
		PyObject_SetAttrString(pyobjref, "phase_factor_random", Py_BuildValue("f", value));
	}

	/** Getter: Length of the hair */
	float hair_length() { /* not implemented */ throw NULL; }
	/** Setter: Length of the hair */
	void hair_length(float value) {
		PyObject_SetAttrString(pyobjref, "hair_length", Py_BuildValue("f", value));
	}

	/** Getter: Mass of the particles */
	float mass() { /* not implemented */ throw NULL; }
	/** Setter: Mass of the particles */
	void mass(float value) {
		PyObject_SetAttrString(pyobjref, "mass", Py_BuildValue("f", value));
	}

	/** Getter: The size of the particles */
	float particle_size() { /* not implemented */ throw NULL; }
	/** Setter: The size of the particles */
	void particle_size(float value) {
		PyObject_SetAttrString(pyobjref, "particle_size", Py_BuildValue("f", value));
	}

	/** Getter: Give the particle size a random variation */
	float size_random() { /* not implemented */ throw NULL; }
	/** Setter: Give the particle size a random variation */
	void size_random(float value) {
		PyObject_SetAttrString(pyobjref, "size_random", Py_BuildValue("f", value));
	}

	/** Getter: Amount of air-drag */
	float drag_factor() { /* not implemented */ throw NULL; }
	/** Setter: Amount of air-drag */
	void drag_factor(float value) {
		PyObject_SetAttrString(pyobjref, "drag_factor", Py_BuildValue("f", value));
	}

	/** Getter: Amount of random, erratic particle movement */
	float brownian_factor() { /* not implemented */ throw NULL; }
	/** Setter: Amount of random, erratic particle movement */
	void brownian_factor(float value) {
		PyObject_SetAttrString(pyobjref, "brownian_factor", Py_BuildValue("f", value));
	}

	/** Getter: Amount of damping */
	float damping() { /* not implemented */ throw NULL; }
	/** Setter: Amount of damping */
	void damping(float value) {
		PyObject_SetAttrString(pyobjref, "damping", Py_BuildValue("f", value));
	}

	/** Getter: Give path length a random variation */
	float length_random() { /* not implemented */ throw NULL; }
	/** Setter: Give path length a random variation */
	void length_random(float value) {
		PyObject_SetAttrString(pyobjref, "length_random", Py_BuildValue("f", value));
	}

	/** Getter: Number of children/parent */
	int child_nbr() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "child_nbr"));
	}

	/** Setter: Number of children/parent */
	void child_nbr(int value) {
		PyObject_SetAttrString(pyobjref, "child_nbr", Py_BuildValue("i", value));
	}

	/** Getter: Number of children/parent for rendering */
	int rendered_child_count() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "rendered_child_count"));
	}

	/** Setter: Number of children/parent for rendering */
	void rendered_child_count(int value) {
		PyObject_SetAttrString(pyobjref, "rendered_child_count", Py_BuildValue("i", value));
	}

	/** Getter: Relative amount of virtual parents */
	float virtual_parents() { /* not implemented */ throw NULL; }
	/** Setter: Relative amount of virtual parents */
	void virtual_parents(float value) {
		PyObject_SetAttrString(pyobjref, "virtual_parents", Py_BuildValue("f", value));
	}

	/** Getter: A multiplier for the child particle size */
	float child_size() { /* not implemented */ throw NULL; }
	/** Setter: A multiplier for the child particle size */
	void child_size(float value) {
		PyObject_SetAttrString(pyobjref, "child_size", Py_BuildValue("f", value));
	}

	/** Getter: Random variation to the size of the child particles */
	float child_size_random() { /* not implemented */ throw NULL; }
	/** Setter: Random variation to the size of the child particles */
	void child_size_random(float value) {
		PyObject_SetAttrString(pyobjref, "child_size_random", Py_BuildValue("f", value));
	}

	/** Getter: Radius of children around parent */
	float child_radius() { /* not implemented */ throw NULL; }
	/** Setter: Radius of children around parent */
	void child_radius(float value) {
		PyObject_SetAttrString(pyobjref, "child_radius", Py_BuildValue("f", value));
	}

	/** Getter: Roundness of children around parent */
	float child_roundness() { /* not implemented */ throw NULL; }
	/** Setter: Roundness of children around parent */
	void child_roundness(float value) {
		PyObject_SetAttrString(pyobjref, "child_roundness", Py_BuildValue("f", value));
	}

	/** Getter: Amount of clumping */
	float clump_factor() { /* not implemented */ throw NULL; }
	/** Setter: Amount of clumping */
	void clump_factor(float value) {
		PyObject_SetAttrString(pyobjref, "clump_factor", Py_BuildValue("f", value));
	}

	/** Getter: Shape of clumping */
	float clump_shape() { /* not implemented */ throw NULL; }
	/** Setter: Shape of clumping */
	void clump_shape(float value) {
		PyObject_SetAttrString(pyobjref, "clump_shape", Py_BuildValue("f", value));
	}

	/** Getter: Use a curve to define clump tapering */
	bool use_clump_curve() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_clump_curve")) == 1;
	}

	/** Setter: Use a curve to define clump tapering */
	void use_clump_curve(bool value) {
		PyObject_SetAttrString(pyobjref, "use_clump_curve", Py_BuildValue("i", value));
	}

	/** Getter: Curve defining clump tapering */
	CurveMapping clump_curve() {
		/* not implemented */ throw NULL;
	}

	/** Getter: Create random clumps around the parent */
	bool use_clump_noise() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_clump_noise")) == 1;
	}

	/** Setter: Create random clumps around the parent */
	void use_clump_noise(bool value) {
		PyObject_SetAttrString(pyobjref, "use_clump_noise", Py_BuildValue("i", value));
	}

	/** Getter: Size of clump noise */
	float clump_noise_size() { /* not implemented */ throw NULL; }
	/** Setter: Size of clump noise */
	void clump_noise_size(float value) {
		PyObject_SetAttrString(pyobjref, "clump_noise_size", Py_BuildValue("f", value));
	}

	/** Getter: The amplitude of the offset */
	float kink_amplitude() { /* not implemented */ throw NULL; }
	/** Setter: The amplitude of the offset */
	void kink_amplitude(float value) {
		PyObject_SetAttrString(pyobjref, "kink_amplitude", Py_BuildValue("f", value));
	}

	/** Getter: How much clump affects kink amplitude */
	float kink_amplitude_clump() { /* not implemented */ throw NULL; }
	/** Setter: How much clump affects kink amplitude */
	void kink_amplitude_clump(float value) {
		PyObject_SetAttrString(pyobjref, "kink_amplitude_clump", Py_BuildValue("f", value));
	}

	/** Getter: Random variation of the amplitude */
	float kink_amplitude_random() { /* not implemented */ throw NULL; }
	/** Setter: Random variation of the amplitude */
	void kink_amplitude_random(float value) {
		PyObject_SetAttrString(pyobjref, "kink_amplitude_random", Py_BuildValue("f", value));
	}

	/** Getter: The frequency of the offset (1/total length) */
	float kink_frequency() { /* not implemented */ throw NULL; }
	/** Setter: The frequency of the offset (1/total length) */
	void kink_frequency(float value) {
		PyObject_SetAttrString(pyobjref, "kink_frequency", Py_BuildValue("f", value));
	}

	/** Getter: Adjust the offset to the beginning/end */
	float kink_shape() { /* not implemented */ throw NULL; }
	/** Setter: Adjust the offset to the beginning/end */
	void kink_shape(float value) {
		PyObject_SetAttrString(pyobjref, "kink_shape", Py_BuildValue("f", value));
	}

	/** Getter: How flat the hairs are */
	float kink_flat() { /* not implemented */ throw NULL; }
	/** Setter: How flat the hairs are */
	void kink_flat(float value) {
		PyObject_SetAttrString(pyobjref, "kink_flat", Py_BuildValue("f", value));
	}

	/** Getter: Extra steps for resolution of special kink features */
	int kink_extra_steps() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "kink_extra_steps"));
	}

	/** Setter: Extra steps for resolution of special kink features */
	void kink_extra_steps(int value) {
		PyObject_SetAttrString(pyobjref, "kink_extra_steps", Py_BuildValue("i", value));
	}

	/** Getter: Random variation of the orientation */
	float kink_axis_random() { /* not implemented */ throw NULL; }
	/** Setter: Random variation of the orientation */
	void kink_axis_random(float value) {
		PyObject_SetAttrString(pyobjref, "kink_axis_random", Py_BuildValue("f", value));
	}

	/** Getter: Amount of location dependent rough */
	float roughness_1() { /* not implemented */ throw NULL; }
	/** Setter: Amount of location dependent rough */
	void roughness_1(float value) {
		PyObject_SetAttrString(pyobjref, "roughness_1", Py_BuildValue("f", value));
	}

	/** Getter: Size of location dependent rough */
	float roughness_1_size() { /* not implemented */ throw NULL; }
	/** Setter: Size of location dependent rough */
	void roughness_1_size(float value) {
		PyObject_SetAttrString(pyobjref, "roughness_1_size", Py_BuildValue("f", value));
	}

	/** Getter: Amount of random rough */
	float roughness_2() { /* not implemented */ throw NULL; }
	/** Setter: Amount of random rough */
	void roughness_2(float value) {
		PyObject_SetAttrString(pyobjref, "roughness_2", Py_BuildValue("f", value));
	}

	/** Getter: Size of random rough */
	float roughness_2_size() { /* not implemented */ throw NULL; }
	/** Setter: Size of random rough */
	void roughness_2_size(float value) {
		PyObject_SetAttrString(pyobjref, "roughness_2_size", Py_BuildValue("f", value));
	}

	/** Getter: Amount of particles left untouched by random rough */
	float roughness_2_threshold() { /* not implemented */ throw NULL; }
	/** Setter: Amount of particles left untouched by random rough */
	void roughness_2_threshold(float value) {
		PyObject_SetAttrString(pyobjref, "roughness_2_threshold", Py_BuildValue("f", value));
	}

	/** Getter: Amount of end point rough */
	float roughness_endpoint() { /* not implemented */ throw NULL; }
	/** Setter: Amount of end point rough */
	void roughness_endpoint(float value) {
		PyObject_SetAttrString(pyobjref, "roughness_endpoint", Py_BuildValue("f", value));
	}

	/** Getter: Shape of end point rough */
	float roughness_end_shape() { /* not implemented */ throw NULL; }
	/** Setter: Shape of end point rough */
	void roughness_end_shape(float value) {
		PyObject_SetAttrString(pyobjref, "roughness_end_shape", Py_BuildValue("f", value));
	}

	/** Getter: Use a curve to define roughness */
	bool use_roughness_curve() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_roughness_curve")) == 1;
	}

	/** Setter: Use a curve to define roughness */
	void use_roughness_curve(bool value) {
		PyObject_SetAttrString(pyobjref, "use_roughness_curve", Py_BuildValue("i", value));
	}

	/** Getter: Curve defining roughness */
	CurveMapping roughness_curve() {
		/* not implemented */ throw NULL;
	}

	/** Getter: Length of child paths */
	float child_length() { /* not implemented */ throw NULL; }
	/** Setter: Length of child paths */
	void child_length(float value) {
		PyObject_SetAttrString(pyobjref, "child_length", Py_BuildValue("f", value));
	}

	/** Getter: Amount of particles left untouched by child path length */
	float child_length_threshold() { /* not implemented */ throw NULL; }
	/** Setter: Amount of particles left untouched by child path length */
	void child_length_threshold(float value) {
		PyObject_SetAttrString(pyobjref, "child_length_threshold", Py_BuildValue("f", value));
	}

	/** Getter: Create parting in the children based on parent strands */
	float child_parting_factor() { /* not implemented */ throw NULL; }
	/** Setter: Create parting in the children based on parent strands */
	void child_parting_factor(float value) {
		PyObject_SetAttrString(pyobjref, "child_parting_factor", Py_BuildValue("f", value));
	}

	/** Getter: Minimum root to tip angle (tip distance/root distance for long hair) */
	float child_parting_min() { /* not implemented */ throw NULL; }
	/** Setter: Minimum root to tip angle (tip distance/root distance for long hair) */
	void child_parting_min(float value) {
		PyObject_SetAttrString(pyobjref, "child_parting_min", Py_BuildValue("f", value));
	}

	/** Getter: Maximum root to tip angle (tip distance/root distance for long hair) */
	float child_parting_max() { /* not implemented */ throw NULL; }
	/** Setter: Maximum root to tip angle (tip distance/root distance for long hair) */
	void child_parting_max(float value) {
		PyObject_SetAttrString(pyobjref, "child_parting_max", Py_BuildValue("f", value));
	}

	/** Getter: Threshold of branching */
	float branch_threshold() { /* not implemented */ throw NULL; }
	/** Setter: Threshold of branching */
	void branch_threshold(float value) {
		PyObject_SetAttrString(pyobjref, "branch_threshold", Py_BuildValue("f", value));
	}

	/** Getter: Length of the line's tail */
	float line_length_tail() { /* not implemented */ throw NULL; }
	/** Setter: Length of the line's tail */
	void line_length_tail(float value) {
		PyObject_SetAttrString(pyobjref, "line_length_tail", Py_BuildValue("f", value));
	}

	/** Getter: Length of the line's head */
	float line_length_head() { /* not implemented */ throw NULL; }
	/** Setter: Length of the line's head */
	void line_length_head(float value) {
		PyObject_SetAttrString(pyobjref, "line_length_head", Py_BuildValue("f", value));
	}

	/** Getter: Starting time of drawn path */
	float path_start() { /* not implemented */ throw NULL; }
	/** Setter: Starting time of drawn path */
	void path_start(float value) {
		PyObject_SetAttrString(pyobjref, "path_start", Py_BuildValue("f", value));
	}

	/** Getter: End time of drawn path */
	float path_end() { /* not implemented */ throw NULL; }
	/** Setter: End time of drawn path */
	void path_end(float value) {
		PyObject_SetAttrString(pyobjref, "path_end", Py_BuildValue("f", value));
	}

	/** Getter: Number of trail particles */
	int trail_count() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "trail_count"));
	}

	/** Setter: Number of trail particles */
	void trail_count(int value) {
		PyObject_SetAttrString(pyobjref, "trail_count", Py_BuildValue("i", value));
	}

	/** Getter: Number of times the keys are looped */
	int keyed_loops() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "keyed_loops"));
	}

	/** Setter: Number of times the keys are looped */
	void keyed_loops(int value) {
		PyObject_SetAttrString(pyobjref, "keyed_loops", Py_BuildValue("i", value));
	}

	/** Getter: Emit particles from mesh with modifiers applied (must use same subsurf level for viewport and render for correct results) */
	bool use_modifier_stack() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_modifier_stack")) == 1;
	}

	/** Setter: Emit particles from mesh with modifiers applied (must use same subsurf level for viewport and render for correct results) */
	void use_modifier_stack(bool value) {
		PyObject_SetAttrString(pyobjref, "use_modifier_stack", Py_BuildValue("i", value));
	}

	/** Getter: Show Objects in this Group in place of particles */
	Group dupli_group() {
		/* not implemented */ throw NULL;
	}

	/** Getter: Weights for all of the objects in the dupli group */
	std::map<std::string, ParticleDupliWeight> dupli_weights() {
		// TODO: MISSING DEREF! USE #DEFINE!
		PyObject *seqval = PyObject_GetAttrString(pyobjref, "dupli_weights");
		PyObject *seqkeys = PyObject_CallMethod(seqval, "keys", NULL);
		std::map<std::string, ParticleDupliWeight> resmap;
		for (int i = 0; i < PySequence_Length(seqval); i++) {
			PyObject *keyobj = PySequence_GetItem(seqkeys, i);
			std::string key = PyBytes_AsString(PyUnicode_AsASCIIString(keyobj));
			ParticleDupliWeight value = ParticleDupliWeight(PySequence_GetItem(seqval, i));
			resmap.insert(std::pair<std::string,ParticleDupliWeight>(key, value));
		}
		return resmap;
	}

	/** Setter: Weights for all of the objects in the dupli group */
	void dupli_weights(std::map<std::string, ParticleDupliWeight> value) { /* not implemented */ }

	/** Getter:  */
	ParticleDupliWeight active_dupliweight() {
		/* not implemented */ throw NULL;
	}

	/** Getter:  */
	int active_dupliweight_index() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "active_dupliweight_index"));
	}

	/** Setter:  */
	void active_dupliweight_index(int value) {
		PyObject_SetAttrString(pyobjref, "active_dupliweight_index", Py_BuildValue("i", value));
	}

	/** Getter: Show this Object in place of particles */
	Object dupli_object() {
		/* not implemented */ throw NULL;
	}

	/** Getter: Billboards face this object (default is active camera) */
	Object billboard_object() {
		/* not implemented */ throw NULL;
	}

	/** Getter:  */
	BoidSettings boids() {
		/* not implemented */ throw NULL;
	}

	/** Getter:  */
	SPHFluidSettings fluid() {
		/* not implemented */ throw NULL;
	}

	/** Getter:  */
	EffectorWeights effector_weights() {
		/* not implemented */ throw NULL;
	}

	/** Getter: Animation data for this datablock */
	AnimData animation_data() {
		/* not implemented */ throw NULL;
	}

	/** Getter:  */
	FieldSettings force_field_1() {
		/* not implemented */ throw NULL;
	}

	/** Getter:  */
	FieldSettings force_field_2() {
		/* not implemented */ throw NULL;
	}

};

/**************** Pose ****************/

/**
 * A collection of pose channels, including settings for animating bones
 */
class Pose : public pyUniplug {
public:
	Pose(PyObject* pyobj) : pyUniplug(pyobj) {}

	Pose() : pyUniplug(0)
	{
		// not implemented
	}

	/** Getter: Individual pose bones for the armature */
	std::map<std::string, PoseBone> bones();
	/** Setter: Individual pose bones for the armature */
	void bones(std::map<std::string, PoseBone> value);

	/** Getter: Groups of the bones */
	std::map<std::string, BoneGroup> bone_groups();
	/** Setter: Groups of the bones */
	void bone_groups(std::map<std::string, BoneGroup> value);

	enum ik_solver_enum {
		ik_solver_LEGACY = 0,
		ik_solver_ITASC = 1,
	};

	/** Getter: Selection of IK solver for IK chain */
	ik_solver_enum ik_solver() { /* not implemented */ throw NULL; }
	/** Setter: Selection of IK solver for IK chain */
	void ik_solver(ik_solver_enum value) { /* not implemented */ }

	/** Getter: Parameters for IK solver */
	IKParam ik_param();

	/** Getter: Animation data for this datablock */
	AnimViz animation_visualization() {
		/* not implemented */ throw NULL;
	}

};

/**************** Pose Bone ****************/

/**
 * Channel defining pose data for a bone in a Pose
 */
class PoseBone : public pyUniplug {
public:
	PoseBone(PyObject* pyobj) : pyUniplug(pyobj) {}

	PoseBone() : pyUniplug(0)
	{
		// not implemented
	}

	/** Getter: Constraints that act on this PoseChannel */
	std::map<std::string, Constraint> constraints() {
		// TODO: MISSING DEREF! USE #DEFINE!
		PyObject *seqval = PyObject_GetAttrString(pyobjref, "constraints");
		PyObject *seqkeys = PyObject_CallMethod(seqval, "keys", NULL);
		std::map<std::string, Constraint> resmap;
		for (int i = 0; i < PySequence_Length(seqval); i++) {
			PyObject *keyobj = PySequence_GetItem(seqkeys, i);
			std::string key = PyBytes_AsString(PyUnicode_AsASCIIString(keyobj));
			Constraint value = Constraint(PySequence_GetItem(seqval, i));
			resmap.insert(std::pair<std::string,Constraint>(key, value));
		}
		return resmap;
	}

	/** Setter: Constraints that act on this PoseChannel */
	void constraints(std::map<std::string, Constraint> value) { /* not implemented */ }

	/** Getter:  */
	std::string name() { /* not implemented */ throw NULL; }
	/** Setter:  */
	void name(const std::string& value) { /* not implemented */ }

	/** Getter: Motion Path for this element */
	MotionPath motion_path() {
		/* not implemented */ throw NULL;
	}

	/** Getter: Bone associated with this PoseBone */
	Bone bone() {
		/* not implemented */ throw NULL;
	}

	/** Getter: Parent of this pose bone */
	PoseBone parent() {
		/* not implemented */ throw NULL;
	}

	/** Getter: Child of this pose bone */
	PoseBone child() {
		/* not implemented */ throw NULL;
	}

	/** Getter:  */
	std::array<float, 3> location() {
		// TODO: MISSING DEREF! USE #DEFINE!
		PyObject *seqval = PyObject_GetAttrString(pyobjref, "location");
		std::array<float, 3> resarr;
		for (int i = 0; i < 3; i++)
			resarr[i] = (float)PyFloat_AsDouble(PySequence_GetItem(seqval, i));
		return resarr;
	}

	/** Setter:  */
	void location(float values[3]) { /* not implemented */ }

	/** Getter:  */
	std::array<float, 3> scale() {
		// TODO: MISSING DEREF! USE #DEFINE!
		PyObject *seqval = PyObject_GetAttrString(pyobjref, "scale");
		std::array<float, 3> resarr;
		for (int i = 0; i < 3; i++)
			resarr[i] = (float)PyFloat_AsDouble(PySequence_GetItem(seqval, i));
		return resarr;
	}

	/** Setter:  */
	void scale(float values[3]) { /* not implemented */ }

	/** Getter: Rotation in Quaternions */
	std::array<float, 4> rotation_quaternion() {
		// TODO: MISSING DEREF! USE #DEFINE!
		PyObject *seqval = PyObject_GetAttrString(pyobjref, "rotation_quaternion");
		std::array<float, 4> resarr;
		for (int i = 0; i < 4; i++)
			resarr[i] = (float)PyFloat_AsDouble(PySequence_GetItem(seqval, i));
		return resarr;
	}

	/** Setter: Rotation in Quaternions */
	void rotation_quaternion(float values[4]) { /* not implemented */ }

	/** Getter: Angle of Rotation for Axis-Angle rotation representation */
	std::array<float, 4> rotation_axis_angle() {
		// TODO: MISSING DEREF! USE #DEFINE!
		PyObject *seqval = PyObject_GetAttrString(pyobjref, "rotation_axis_angle");
		std::array<float, 4> resarr;
		for (int i = 0; i < 4; i++)
			resarr[i] = (float)PyFloat_AsDouble(PySequence_GetItem(seqval, i));
		return resarr;
	}

	/** Setter: Angle of Rotation for Axis-Angle rotation representation */
	void rotation_axis_angle(float values[4]) { /* not implemented */ }

	/** Getter: Rotation in Eulers */
	std::array<float, 3> rotation_euler() {
		// TODO: MISSING DEREF! USE #DEFINE!
		PyObject *seqval = PyObject_GetAttrString(pyobjref, "rotation_euler");
		std::array<float, 3> resarr;
		for (int i = 0; i < 3; i++)
			resarr[i] = (float)PyFloat_AsDouble(PySequence_GetItem(seqval, i));
		return resarr;
	}

	/** Setter: Rotation in Eulers */
	void rotation_euler(float values[3]) { /* not implemented */ }

	enum rotation_mode_enum {
		rotation_mode_QUATERNION = 0,
		rotation_mode_XYZ = 1,
		rotation_mode_XZY = 2,
		rotation_mode_YXZ = 3,
		rotation_mode_YZX = 4,
		rotation_mode_ZXY = 5,
		rotation_mode_ZYX = 6,
		rotation_mode_AXIS_ANGLE = -1,
	};

	/** Getter:  */
	rotation_mode_enum rotation_mode() { /* not implemented */ throw NULL; }
	/** Setter:  */
	void rotation_mode(rotation_mode_enum value) { /* not implemented */ }

	/** Getter: 4x4 matrix, before constraints */
	std::array<float, 16> matrix_channel() {
		// TODO: MISSING DEREF! USE #DEFINE!
		PyObject *seqval = PyObject_GetAttrString(pyobjref, "matrix_channel");
		std::array<float, 16> resarr;
		for (int i = 0; i < 16; i++)
			resarr[i] = (float)PyFloat_AsDouble(PySequence_GetItem(seqval, i));
		return resarr;
	}

	/** Setter: 4x4 matrix, before constraints */
	void matrix_channel(float values[16]) { /* not implemented */ }

	/** Getter: Alternative access to location/scale/rotation relative to the parent and own rest bone */
	std::array<float, 16> matrix_basis() {
		// TODO: MISSING DEREF! USE #DEFINE!
		PyObject *seqval = PyObject_GetAttrString(pyobjref, "matrix_basis");
		std::array<float, 16> resarr;
		for (int i = 0; i < 16; i++)
			resarr[i] = (float)PyFloat_AsDouble(PySequence_GetItem(seqval, i));
		return resarr;
	}

	/** Setter: Alternative access to location/scale/rotation relative to the parent and own rest bone */
	void matrix_basis(float values[16]) { /* not implemented */ }

	/** Getter: Final 4x4 matrix after constraints and drivers are applied (object space) */
	std::array<float, 16> matrix() {
		// TODO: MISSING DEREF! USE #DEFINE!
		PyObject *seqval = PyObject_GetAttrString(pyobjref, "matrix");
		std::array<float, 16> resarr;
		for (int i = 0; i < 16; i++)
			resarr[i] = (float)PyFloat_AsDouble(PySequence_GetItem(seqval, i));
		return resarr;
	}

	/** Setter: Final 4x4 matrix after constraints and drivers are applied (object space) */
	void matrix(float values[16]) { /* not implemented */ }

	/** Getter: Location of head of the channel's bone */
	std::array<float, 3> head() {
		// TODO: MISSING DEREF! USE #DEFINE!
		PyObject *seqval = PyObject_GetAttrString(pyobjref, "head");
		std::array<float, 3> resarr;
		for (int i = 0; i < 3; i++)
			resarr[i] = (float)PyFloat_AsDouble(PySequence_GetItem(seqval, i));
		return resarr;
	}

	/** Setter: Location of head of the channel's bone */
	void head(float values[3]) { /* not implemented */ }

	/** Getter: Location of tail of the channel's bone */
	std::array<float, 3> tail() {
		// TODO: MISSING DEREF! USE #DEFINE!
		PyObject *seqval = PyObject_GetAttrString(pyobjref, "tail");
		std::array<float, 3> resarr;
		for (int i = 0; i < 3; i++)
			resarr[i] = (float)PyFloat_AsDouble(PySequence_GetItem(seqval, i));
		return resarr;
	}

	/** Setter: Location of tail of the channel's bone */
	void tail(float values[3]) { /* not implemented */ }

	/** Getter: Is part of an IK chain */
	bool is_in_ik_chain() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "is_in_ik_chain")) == 1;
	}

	/** Setter: Is part of an IK chain */
	void is_in_ik_chain(bool value) {
		PyObject_SetAttrString(pyobjref, "is_in_ik_chain", Py_BuildValue("i", value));
	}

	/** Getter: Disallow movement around the X axis */
	bool lock_ik_x() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "lock_ik_x")) == 1;
	}

	/** Setter: Disallow movement around the X axis */
	void lock_ik_x(bool value) {
		PyObject_SetAttrString(pyobjref, "lock_ik_x", Py_BuildValue("i", value));
	}

	/** Getter: Disallow movement around the Y axis */
	bool lock_ik_y() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "lock_ik_y")) == 1;
	}

	/** Setter: Disallow movement around the Y axis */
	void lock_ik_y(bool value) {
		PyObject_SetAttrString(pyobjref, "lock_ik_y", Py_BuildValue("i", value));
	}

	/** Getter: Disallow movement around the Z axis */
	bool lock_ik_z() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "lock_ik_z")) == 1;
	}

	/** Setter: Disallow movement around the Z axis */
	void lock_ik_z(bool value) {
		PyObject_SetAttrString(pyobjref, "lock_ik_z", Py_BuildValue("i", value));
	}

	/** Getter: Limit movement around the X axis */
	bool use_ik_limit_x() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_ik_limit_x")) == 1;
	}

	/** Setter: Limit movement around the X axis */
	void use_ik_limit_x(bool value) {
		PyObject_SetAttrString(pyobjref, "use_ik_limit_x", Py_BuildValue("i", value));
	}

	/** Getter: Limit movement around the Y axis */
	bool use_ik_limit_y() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_ik_limit_y")) == 1;
	}

	/** Setter: Limit movement around the Y axis */
	void use_ik_limit_y(bool value) {
		PyObject_SetAttrString(pyobjref, "use_ik_limit_y", Py_BuildValue("i", value));
	}

	/** Getter: Limit movement around the Z axis */
	bool use_ik_limit_z() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_ik_limit_z")) == 1;
	}

	/** Setter: Limit movement around the Z axis */
	void use_ik_limit_z(bool value) {
		PyObject_SetAttrString(pyobjref, "use_ik_limit_z", Py_BuildValue("i", value));
	}

	/** Getter: Apply channel rotation as IK constraint */
	bool use_ik_rotation_control() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_ik_rotation_control")) == 1;
	}

	/** Setter: Apply channel rotation as IK constraint */
	void use_ik_rotation_control(bool value) {
		PyObject_SetAttrString(pyobjref, "use_ik_rotation_control", Py_BuildValue("i", value));
	}

	/** Getter: Apply channel size as IK constraint if stretching is enabled */
	bool use_ik_linear_control() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_ik_linear_control")) == 1;
	}

	/** Setter: Apply channel size as IK constraint if stretching is enabled */
	void use_ik_linear_control(bool value) {
		PyObject_SetAttrString(pyobjref, "use_ik_linear_control", Py_BuildValue("i", value));
	}

	/** Getter: Minimum angles for IK Limit */
	float ik_min_x() { /* not implemented */ throw NULL; }
	/** Setter: Minimum angles for IK Limit */
	void ik_min_x(float value) {
		PyObject_SetAttrString(pyobjref, "ik_min_x", Py_BuildValue("f", value));
	}

	/** Getter: Maximum angles for IK Limit */
	float ik_max_x() { /* not implemented */ throw NULL; }
	/** Setter: Maximum angles for IK Limit */
	void ik_max_x(float value) {
		PyObject_SetAttrString(pyobjref, "ik_max_x", Py_BuildValue("f", value));
	}

	/** Getter: Minimum angles for IK Limit */
	float ik_min_y() { /* not implemented */ throw NULL; }
	/** Setter: Minimum angles for IK Limit */
	void ik_min_y(float value) {
		PyObject_SetAttrString(pyobjref, "ik_min_y", Py_BuildValue("f", value));
	}

	/** Getter: Maximum angles for IK Limit */
	float ik_max_y() { /* not implemented */ throw NULL; }
	/** Setter: Maximum angles for IK Limit */
	void ik_max_y(float value) {
		PyObject_SetAttrString(pyobjref, "ik_max_y", Py_BuildValue("f", value));
	}

	/** Getter: Minimum angles for IK Limit */
	float ik_min_z() { /* not implemented */ throw NULL; }
	/** Setter: Minimum angles for IK Limit */
	void ik_min_z(float value) {
		PyObject_SetAttrString(pyobjref, "ik_min_z", Py_BuildValue("f", value));
	}

	/** Getter: Maximum angles for IK Limit */
	float ik_max_z() { /* not implemented */ throw NULL; }
	/** Setter: Maximum angles for IK Limit */
	void ik_max_z(float value) {
		PyObject_SetAttrString(pyobjref, "ik_max_z", Py_BuildValue("f", value));
	}

	/** Getter: IK stiffness around the X axis */
	float ik_stiffness_x() { /* not implemented */ throw NULL; }
	/** Setter: IK stiffness around the X axis */
	void ik_stiffness_x(float value) {
		PyObject_SetAttrString(pyobjref, "ik_stiffness_x", Py_BuildValue("f", value));
	}

	/** Getter: IK stiffness around the Y axis */
	float ik_stiffness_y() { /* not implemented */ throw NULL; }
	/** Setter: IK stiffness around the Y axis */
	void ik_stiffness_y(float value) {
		PyObject_SetAttrString(pyobjref, "ik_stiffness_y", Py_BuildValue("f", value));
	}

	/** Getter: IK stiffness around the Z axis */
	float ik_stiffness_z() { /* not implemented */ throw NULL; }
	/** Setter: IK stiffness around the Z axis */
	void ik_stiffness_z(float value) {
		PyObject_SetAttrString(pyobjref, "ik_stiffness_z", Py_BuildValue("f", value));
	}

	/** Getter: Allow scaling of the bone for IK */
	float ik_stretch() { /* not implemented */ throw NULL; }
	/** Setter: Allow scaling of the bone for IK */
	void ik_stretch(float value) {
		PyObject_SetAttrString(pyobjref, "ik_stretch", Py_BuildValue("f", value));
	}

	/** Getter: Weight of rotation constraint for IK */
	float ik_rotation_weight() { /* not implemented */ throw NULL; }
	/** Setter: Weight of rotation constraint for IK */
	void ik_rotation_weight(float value) {
		PyObject_SetAttrString(pyobjref, "ik_rotation_weight", Py_BuildValue("f", value));
	}

	/** Getter: Weight of scale constraint for IK */
	float ik_linear_weight() { /* not implemented */ throw NULL; }
	/** Setter: Weight of scale constraint for IK */
	void ik_linear_weight(float value) {
		PyObject_SetAttrString(pyobjref, "ik_linear_weight", Py_BuildValue("f", value));
	}

	/** Getter: Object that defines custom draw type for this bone */
	Object custom_shape() {
		/* not implemented */ throw NULL;
	}

	/** Getter: Bone that defines the display transform of this custom shape */
	PoseBone custom_shape_transform() {
		/* not implemented */ throw NULL;
	}

	/** Getter: Bone Group this pose channel belongs to (0=no group) */
	int bone_group_index() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "bone_group_index"));
	}

	/** Setter: Bone Group this pose channel belongs to (0=no group) */
	void bone_group_index(int value) {
		PyObject_SetAttrString(pyobjref, "bone_group_index", Py_BuildValue("i", value));
	}

	/** Getter: Bone Group this pose channel belongs to */
	BoneGroup bone_group();

	/** Getter: Lock editing of location in the interface */
	std::array<bool, 3> lock_location() {
		// TODO: MISSING DEREF! USE #DEFINE!
		PyObject *seqval = PyObject_GetAttrString(pyobjref, "lock_location");
		std::array<bool, 3> resarr;
		for (int i = 0; i < 3; i++)
			resarr[i] = PyLong_AsLong(PySequence_GetItem(seqval, i)) == 1;
		return resarr;
	}

	/** Setter: Lock editing of location in the interface */
	void lock_location(bool values[3]) { /* not implemented */ }

	/** Getter: Lock editing of rotation in the interface */
	std::array<bool, 3> lock_rotation() {
		// TODO: MISSING DEREF! USE #DEFINE!
		PyObject *seqval = PyObject_GetAttrString(pyobjref, "lock_rotation");
		std::array<bool, 3> resarr;
		for (int i = 0; i < 3; i++)
			resarr[i] = PyLong_AsLong(PySequence_GetItem(seqval, i)) == 1;
		return resarr;
	}

	/** Setter: Lock editing of rotation in the interface */
	void lock_rotation(bool values[3]) { /* not implemented */ }

	/** Getter: Lock editing of 'angle' component of four-component rotations in the interface */
	bool lock_rotation_w() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "lock_rotation_w")) == 1;
	}

	/** Setter: Lock editing of 'angle' component of four-component rotations in the interface */
	void lock_rotation_w(bool value) {
		PyObject_SetAttrString(pyobjref, "lock_rotation_w", Py_BuildValue("i", value));
	}

	/** Getter: Lock editing of four component rotations by components (instead of as Eulers) */
	bool lock_rotations_4d() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "lock_rotations_4d")) == 1;
	}

	/** Setter: Lock editing of four component rotations by components (instead of as Eulers) */
	void lock_rotations_4d(bool value) {
		PyObject_SetAttrString(pyobjref, "lock_rotations_4d", Py_BuildValue("i", value));
	}

	/** Getter: Lock editing of scale in the interface */
	std::array<bool, 3> lock_scale() {
		// TODO: MISSING DEREF! USE #DEFINE!
		PyObject *seqval = PyObject_GetAttrString(pyobjref, "lock_scale");
		std::array<bool, 3> resarr;
		for (int i = 0; i < 3; i++)
			resarr[i] = PyLong_AsLong(PySequence_GetItem(seqval, i)) == 1;
		return resarr;
	}

	/** Setter: Lock editing of scale in the interface */
	void lock_scale(bool values[3]) { /* not implemented */ }

	/**
	 * Calculate bone envelope at given point
	 * @param Position in 3d space to evaluate
	 * @return Envelope factor
	 */
	float evaluate_envelope(float point[3])
	{
		// not implemented
		throw NULL;
	}

};

/**************** IKParam ****************/

/**
 * Base type for IK solver parameters
 */
class IKParam : public pyUniplug {
public:
	IKParam(PyObject* pyobj) : pyUniplug(pyobj) {}

	IKParam() : pyUniplug(0)
	{
		// not implemented
	}

	enum ik_solver_enum {
		ik_solver_LEGACY = 0,
		ik_solver_ITASC = 1,
	};

	/** Getter: IK solver for which these parameters are defined */
	ik_solver_enum ik_solver() { /* not implemented */ throw NULL; }
	/** Setter: IK solver for which these parameters are defined */
	void ik_solver(ik_solver_enum value) { /* not implemented */ }

};

/**************** bItasc ****************/

/**
 * Parameters for the iTaSC IK solver
 */
class Itasc : public IKParam {
public:
	Itasc(PyObject* pyobj) : IKParam(pyobj) {}

	Itasc() : IKParam(0)
	{
		// not implemented
	}

	/** Getter: Precision of convergence in case of reiteration */
	float precision() { /* not implemented */ throw NULL; }
	/** Setter: Precision of convergence in case of reiteration */
	void precision(float value) {
		PyObject_SetAttrString(pyobjref, "precision", Py_BuildValue("f", value));
	}

	/** Getter: Maximum number of iterations for convergence in case of reiteration */
	int iterations() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "iterations"));
	}

	/** Setter: Maximum number of iterations for convergence in case of reiteration */
	void iterations(int value) {
		PyObject_SetAttrString(pyobjref, "iterations", Py_BuildValue("i", value));
	}

	/** Getter: Divide the frame interval into this many steps */
	int step_count() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "step_count"));
	}

	/** Setter: Divide the frame interval into this many steps */
	void step_count(int value) {
		PyObject_SetAttrString(pyobjref, "step_count", Py_BuildValue("i", value));
	}

	enum mode_enum {
		mode_ANIMATION = 0,
		mode_SIMULATION = 8,
	};

	/** Getter: (null) */
	mode_enum mode() { /* not implemented */ throw NULL; }
	/** Setter: (null) */
	void mode(mode_enum value) { /* not implemented */ }

	enum reiteration_method_enum {
		reiteration_method_NEVER = 0,
		reiteration_method_INITIAL = 2,
		reiteration_method_ALWAYS = 6,
	};

	/** Getter: Defines if the solver is allowed to reiterate (converge until precision is met) on none, first or all frames */
	reiteration_method_enum reiteration_method() { /* not implemented */ throw NULL; }
	/** Setter: Defines if the solver is allowed to reiterate (converge until precision is met) on none, first or all frames */
	void reiteration_method(reiteration_method_enum value) { /* not implemented */ }

	/** Getter: Automatically determine the optimal number of steps for best performance/accuracy trade off */
	bool use_auto_step() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_auto_step")) == 1;
	}

	/** Setter: Automatically determine the optimal number of steps for best performance/accuracy trade off */
	void use_auto_step(bool value) {
		PyObject_SetAttrString(pyobjref, "use_auto_step", Py_BuildValue("i", value));
	}

	/** Getter: Lower bound for timestep in second in case of automatic substeps */
	float step_min() { /* not implemented */ throw NULL; }
	/** Setter: Lower bound for timestep in second in case of automatic substeps */
	void step_min(float value) {
		PyObject_SetAttrString(pyobjref, "step_min", Py_BuildValue("f", value));
	}

	/** Getter: Higher bound for timestep in second in case of automatic substeps */
	float step_max() { /* not implemented */ throw NULL; }
	/** Setter: Higher bound for timestep in second in case of automatic substeps */
	void step_max(float value) {
		PyObject_SetAttrString(pyobjref, "step_max", Py_BuildValue("f", value));
	}

	/** Getter: Feedback coefficient for error correction, average response time is 1/feedback (default=20) */
	float feedback() { /* not implemented */ throw NULL; }
	/** Setter: Feedback coefficient for error correction, average response time is 1/feedback (default=20) */
	void feedback(float value) {
		PyObject_SetAttrString(pyobjref, "feedback", Py_BuildValue("f", value));
	}

	/** Getter: Maximum joint velocity in rad/s (default=50) */
	float velocity_max() { /* not implemented */ throw NULL; }
	/** Setter: Maximum joint velocity in rad/s (default=50) */
	void velocity_max(float value) {
		PyObject_SetAttrString(pyobjref, "velocity_max", Py_BuildValue("f", value));
	}

	enum solver_enum {
		solver_SDLS = 0,
		solver_DLS = 1,
	};

	/** Getter: Solving method selection: automatic damping or manual damping */
	solver_enum solver() { /* not implemented */ throw NULL; }
	/** Setter: Solving method selection: automatic damping or manual damping */
	void solver(solver_enum value) { /* not implemented */ }

	/** Getter: Maximum damping coefficient when singular value is nearly 0 (higher values=more stability, less reactivity - default=0.5) */
	float damping_max() { /* not implemented */ throw NULL; }
	/** Setter: Maximum damping coefficient when singular value is nearly 0 (higher values=more stability, less reactivity - default=0.5) */
	void damping_max(float value) {
		PyObject_SetAttrString(pyobjref, "damping_max", Py_BuildValue("f", value));
	}

	/** Getter: Singular value under which damping is progressively applied (higher values=more stability, less reactivity - default=0.1) */
	float damping_epsilon() { /* not implemented */ throw NULL; }
	/** Setter: Singular value under which damping is progressively applied (higher values=more stability, less reactivity - default=0.1) */
	void damping_epsilon(float value) {
		PyObject_SetAttrString(pyobjref, "damping_epsilon", Py_BuildValue("f", value));
	}

};

/**************** Bone Group ****************/

/**
 * Groups of Pose Channels (Bones)
 */
class BoneGroup : public pyUniplug {
public:
	BoneGroup(PyObject* pyobj) : pyUniplug(pyobj) {}

	BoneGroup() : pyUniplug(0)
	{
		// not implemented
	}

	/** Getter:  */
	std::string name() { /* not implemented */ throw NULL; }
	/** Setter:  */
	void name(const std::string& value) { /* not implemented */ }

	enum color_set_enum {
		color_set_DEFAULT = 0,
		color_set_THEME01 = 1,
		color_set_THEME02 = 2,
		color_set_THEME03 = 3,
		color_set_THEME04 = 4,
		color_set_THEME05 = 5,
		color_set_THEME06 = 6,
		color_set_THEME07 = 7,
		color_set_THEME08 = 8,
		color_set_THEME09 = 9,
		color_set_THEME10 = 10,
		color_set_THEME11 = 11,
		color_set_THEME12 = 12,
		color_set_THEME13 = 13,
		color_set_THEME14 = 14,
		color_set_THEME15 = 15,
		color_set_THEME16 = 16,
		color_set_THEME17 = 17,
		color_set_THEME18 = 18,
		color_set_THEME19 = 19,
		color_set_THEME20 = 20,
		color_set_CUSTOM = -1,
	};

	/** Getter: Custom color set to use */
	color_set_enum color_set() { /* not implemented */ throw NULL; }
	/** Setter: Custom color set to use */
	void color_set(color_set_enum value) { /* not implemented */ }

	/** Getter: Color set is user-defined instead of a fixed theme color set */
	bool is_custom_color_set() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "is_custom_color_set")) == 1;
	}

	/** Setter: Color set is user-defined instead of a fixed theme color set */
	void is_custom_color_set(bool value) {
		PyObject_SetAttrString(pyobjref, "is_custom_color_set", Py_BuildValue("i", value));
	}

	/** Getter: Copy of the colors associated with the group's color set */
	ThemeBoneColorSet colors();

};

/**************** Game Property ****************/

/**
 * Game engine user defined object property
 */
class GameProperty : public pyUniplug {
public:
	GameProperty(PyObject* pyobj) : pyUniplug(pyobj) {}

	GameProperty() : pyUniplug(0)
	{
		// not implemented
	}

	/** Getter: Available as GameObject attributes in the game engine's python API */
	std::string name() { /* not implemented */ throw NULL; }
	/** Setter: Available as GameObject attributes in the game engine's python API */
	void name(const std::string& value) { /* not implemented */ }

	enum type_enum {
		type_BOOL = 0,
		type_INT = 1,
		type_FLOAT = 2,
		type_STRING = 3,
		type_TIMER = 5,
	};

	/** Getter:  */
	type_enum type() { /* not implemented */ throw NULL; }
	/** Setter:  */
	void type(type_enum value) { /* not implemented */ }

	/** Getter: Print debug information for this property */
	bool show_debug() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "show_debug")) == 1;
	}

	/** Setter: Print debug information for this property */
	void show_debug(bool value) {
		PyObject_SetAttrString(pyobjref, "show_debug", Py_BuildValue("i", value));
	}

};

/**************** Game Boolean Property ****************/

/**
 * Game engine user defined Boolean property
 */
class GameBooleanProperty : public GameProperty {
public:
	GameBooleanProperty(PyObject* pyobj) : GameProperty(pyobj) {}

	GameBooleanProperty() : GameProperty(0)
	{
		// not implemented
	}

	/** Getter: Property value */
	bool value() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "value")) == 1;
	}

	/** Setter: Property value */
	void value(bool value) {
		PyObject_SetAttrString(pyobjref, "value", Py_BuildValue("i", value));
	}

};

/**************** Game Integer Property ****************/

/**
 * Game engine user defined integer number property
 */
class GameIntProperty : public GameProperty {
public:
	GameIntProperty(PyObject* pyobj) : GameProperty(pyobj) {}

	GameIntProperty() : GameProperty(0)
	{
		// not implemented
	}

	/** Getter: Property value */
	int value() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "value"));
	}

	/** Setter: Property value */
	void value(int value) {
		PyObject_SetAttrString(pyobjref, "value", Py_BuildValue("i", value));
	}

};

/**************** Game Float Property ****************/

/**
 * Game engine user defined floating point number property
 */
class GameFloatProperty : public GameProperty {
public:
	GameFloatProperty(PyObject* pyobj) : GameProperty(pyobj) {}

	GameFloatProperty() : GameProperty(0)
	{
		// not implemented
	}

	/** Getter: Property value */
	float value() { /* not implemented */ throw NULL; }
	/** Setter: Property value */
	void value(float value) {
		PyObject_SetAttrString(pyobjref, "value", Py_BuildValue("f", value));
	}

};

/**************** Game Timer Property ****************/

/**
 * Game engine user defined timer property
 */
class GameTimerProperty : public GameProperty {
public:
	GameTimerProperty(PyObject* pyobj) : GameProperty(pyobj) {}

	GameTimerProperty() : GameProperty(0)
	{
		// not implemented
	}

	/** Getter: Property value */
	float value() { /* not implemented */ throw NULL; }
	/** Setter: Property value */
	void value(float value) {
		PyObject_SetAttrString(pyobjref, "value", Py_BuildValue("f", value));
	}

};

/**************** Game String Property ****************/

/**
 * Game engine user defined text string property
 */
class GameStringProperty : public GameProperty {
public:
	GameStringProperty(PyObject* pyobj) : GameProperty(pyobj) {}

	GameStringProperty() : GameProperty(0)
	{
		// not implemented
	}

	/** Getter: Property value */
	std::string value() { /* not implemented */ throw NULL; }
	/** Setter: Property value */
	void value(const std::string& value) { /* not implemented */ }

};

/**************** Render Engine ****************/

/**
 * Render engine
 */
class RenderEngine : public pyUniplug {
public:
	RenderEngine(PyObject* pyobj) : pyUniplug(pyobj) {}

	RenderEngine() : pyUniplug(0)
	{
		// not implemented
	}

	/** Getter:  */
	bool is_animation() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "is_animation")) == 1;
	}

	/** Setter:  */
	void is_animation(bool value) {
		PyObject_SetAttrString(pyobjref, "is_animation", Py_BuildValue("i", value));
	}

	/** Getter:  */
	bool is_preview() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "is_preview")) == 1;
	}

	/** Setter:  */
	void is_preview(bool value) {
		PyObject_SetAttrString(pyobjref, "is_preview", Py_BuildValue("i", value));
	}

	/** Getter:  */
	Object camera_override() {
		/* not implemented */ throw NULL;
	}

	/** Getter:  */
	std::array<bool, 20> layer_override() {
		// TODO: MISSING DEREF! USE #DEFINE!
		PyObject *seqval = PyObject_GetAttrString(pyobjref, "layer_override");
		std::array<bool, 20> resarr;
		for (int i = 0; i < 20; i++)
			resarr[i] = PyLong_AsLong(PySequence_GetItem(seqval, i)) == 1;
		return resarr;
	}

	/** Setter:  */
	void layer_override(bool values[20]) { /* not implemented */ }

	/** Getter:  */
	int tile_x() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "tile_x"));
	}

	/** Setter:  */
	void tile_x(int value) {
		PyObject_SetAttrString(pyobjref, "tile_x", Py_BuildValue("i", value));
	}

	/** Getter:  */
	int tile_y() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "tile_y"));
	}

	/** Setter:  */
	void tile_y(int value) {
		PyObject_SetAttrString(pyobjref, "tile_y", Py_BuildValue("i", value));
	}

	/** Getter:  */
	int resolution_x() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "resolution_x"));
	}

	/** Setter:  */
	void resolution_x(int value) {
		PyObject_SetAttrString(pyobjref, "resolution_x", Py_BuildValue("i", value));
	}

	/** Getter:  */
	int resolution_y() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "resolution_y"));
	}

	/** Setter:  */
	void resolution_y(int value) {
		PyObject_SetAttrString(pyobjref, "resolution_y", Py_BuildValue("i", value));
	}

	/** Getter:  */
	RenderSettings render();

	/** Getter:  */
	bool use_highlight_tiles() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_highlight_tiles")) == 1;
	}

	/** Setter:  */
	void use_highlight_tiles(bool value) {
		PyObject_SetAttrString(pyobjref, "use_highlight_tiles", Py_BuildValue("i", value));
	}

	/** Getter:  */
	std::string bl_idname() { /* not implemented */ throw NULL; }
	/** Setter:  */
	void bl_idname(const std::string& value) { /* not implemented */ }

	/** Getter:  */
	std::string bl_label() { /* not implemented */ throw NULL; }
	/** Setter:  */
	void bl_label(const std::string& value) { /* not implemented */ }

	/** Getter:  */
	bool bl_use_preview() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "bl_use_preview")) == 1;
	}

	/** Setter:  */
	void bl_use_preview(bool value) {
		PyObject_SetAttrString(pyobjref, "bl_use_preview", Py_BuildValue("i", value));
	}

	/** Getter:  */
	bool bl_use_texture_preview() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "bl_use_texture_preview")) == 1;
	}

	/** Setter:  */
	void bl_use_texture_preview(bool value) {
		PyObject_SetAttrString(pyobjref, "bl_use_texture_preview", Py_BuildValue("i", value));
	}

	/** Getter:  */
	bool bl_use_postprocess() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "bl_use_postprocess")) == 1;
	}

	/** Setter:  */
	void bl_use_postprocess(bool value) {
		PyObject_SetAttrString(pyobjref, "bl_use_postprocess", Py_BuildValue("i", value));
	}

	/** Getter:  */
	bool bl_use_shading_nodes() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "bl_use_shading_nodes")) == 1;
	}

	/** Setter:  */
	void bl_use_shading_nodes(bool value) {
		PyObject_SetAttrString(pyobjref, "bl_use_shading_nodes", Py_BuildValue("i", value));
	}

	/** Getter:  */
	bool bl_use_shading_nodes_custom() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "bl_use_shading_nodes_custom")) == 1;
	}

	/** Setter:  */
	void bl_use_shading_nodes_custom(bool value) {
		PyObject_SetAttrString(pyobjref, "bl_use_shading_nodes_custom", Py_BuildValue("i", value));
	}

	/** Getter:  */
	bool bl_use_exclude_layers() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "bl_use_exclude_layers")) == 1;
	}

	/** Setter:  */
	void bl_use_exclude_layers(bool value) {
		PyObject_SetAttrString(pyobjref, "bl_use_exclude_layers", Py_BuildValue("i", value));
	}

	/** Getter:  */
	bool bl_use_save_buffers() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "bl_use_save_buffers")) == 1;
	}

	/** Setter:  */
	void bl_use_save_buffers(bool value) {
		PyObject_SetAttrString(pyobjref, "bl_use_save_buffers", Py_BuildValue("i", value));
	}

	/**
	 * Request redraw for viewport rendering
	 */
	void tag_redraw()
	{
		// not implemented
	}

	/**
	 * Request update call for viewport rendering
	 */
	void tag_update()
	{
		// not implemented
	}

	/**
	 * Create render result to write linear floating point render layers and passes
	 * @param Param 'x'
	 * @param Param 'y'
	 * @param Param 'w'
	 * @param Param 'h'
	 * @param Single layer to get render result for
	 * @param Single view to get render result for
	 * @return 
	 */
	RenderResult begin_result(int x, int y, int w, int h, const std::string layer = NULL, const std::string view = NULL);

	/**
	 * Signal that pixels have been updated and can be redrawn in the user interface
	 * @param Param 'result'
	 */
	void update_result(RenderResult result);

	/**
	 * All pixels in the render result have been set and are final
	 * @param Param 'result'
	 * @param Don't mark tile as done, don't merge results unless forced
	 * @param Merge results even if cancel=true
	 */
	void end_result(RenderResult result, bool cancel = false, bool do_merge_results = false);

	/**
	 * Test if the render operation should been canceled, this is a fast call that should be used regularly for responsiveness
	 * @return 
	 */
	bool test_break()
	{
		// not implemented
		return true;
	}

	/**
	 * Function: active_view_set
	 * @param Single view to set as active
	 */
	void active_view_set(const std::string view = NULL)
	{
		// not implemented
	}

	/**
	 * Function: camera_shift_x
	 * @param Param 'camera'
	 * @return 
	 */
	float camera_shift_x(Object camera)
	{
		// not implemented
		throw NULL;
	}

	/**
	 * Function: camera_model_matrix
	 * @param Param 'camera'
	 * @param Normalized camera model matrix
	 */
	void camera_model_matrix(Object camera, float r_model_matrix[16])
	{
		// not implemented
	}

	/**
	 * Update and signal to redraw render status text
	 * @param Param 'stats'
	 * @param Param 'info'
	 */
	void update_stats(const std::string stats, const std::string info)
	{
		// not implemented
	}

	/**
	 * Evaluate scene at a different frame (for motion blur)
	 * @param Param 'frame'
	 * @param Param 'subframe'
	 */
	void frame_set(int frame, float subframe)
	{
		// not implemented
	}

	/**
	 * Update progress percentage of render
	 * @param Percentage of render that's done
	 */
	void update_progress(float progress)
	{
		// not implemented
	}

	/**
	 * Update memory usage statistics
	 * @param Current memory usage in megabytes
	 * @param Peak memory usage in megabytes
	 */
	void update_memory_stats(float memory_used = 0.000000f, float memory_peak = 0.000000f)
	{
		// not implemented
	}

	/**
	 * Enum: items
	 */
	enum items {
		items_DEBUG = 1,	
		items_INFO = 2,	
		items_OPERATOR = 4,	
		items_PROPERTY = 8,	
		items_WARNING = 16,	
		items_ERROR = 32,	
		items_ERROR_INVALID_INPUT = 64,	
		items_ERROR_INVALID_CONTEXT = 128,	
		items_ERROR_OUT_OF_MEMORY = 256	
	};

	/**
	 * Report info, warning or error messages
	 * @param Param 'type'
	 * @param Param 'message'
	 */
	void report(items type, const std::string message)
	{
		// not implemented
	}

	/**
	 * Set error message displaying after the render is finished
	 * @param Param 'message'
	 */
	void error_set(const std::string message)
	{
		// not implemented
	}

	/**
	 * Bind GLSL fragment shader that converts linear colors to display space colors using scene color management settings
	 * @param Param 'scene'
	 */
	void bind_display_space_shader(Scene scene);

	/**
	 * Unbind GLSL display space shader, must always be called after binding the shader
	 */
	void unbind_display_space_shader()
	{
		// not implemented
	}

	/**
	 * Test if GLSL display space shader is supported for the combination of graphics card and scene settings
	 * @param Param 'scene'
	 * @return 
	 */
	bool support_display_space_shader(Scene scene);

};

/**************** Render Result ****************/

/**
 * Result of rendering, including all layers and passes
 */
class RenderResult : public pyUniplug {
public:
	RenderResult(PyObject* pyobj) : pyUniplug(pyobj) {}

	RenderResult() : pyUniplug(0)
	{
		// not implemented
	}

	/** Getter:  */
	int resolution_x() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "resolution_x"));
	}

	/** Setter:  */
	void resolution_x(int value) {
		PyObject_SetAttrString(pyobjref, "resolution_x", Py_BuildValue("i", value));
	}

	/** Getter:  */
	int resolution_y() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "resolution_y"));
	}

	/** Setter:  */
	void resolution_y(int value) {
		PyObject_SetAttrString(pyobjref, "resolution_y", Py_BuildValue("i", value));
	}

	/** Getter:  */
	std::map<std::string, RenderLayer> layers();
	/** Setter:  */
	void layers(std::map<std::string, RenderLayer> value);

	/** Getter:  */
	std::map<std::string, RenderView> views();
	/** Setter:  */
	void views(std::map<std::string, RenderView> value);

	/**
	 * Copies the pixels of this render result from an image file
	 * @param Filename to load into this render tile, must be no smaller than the render result
	 */
	void load_from_file(const std::string filename)
	{
		// not implemented
	}

};

/**************** Render View ****************/

/**
 * 
 */
class RenderView : public pyUniplug {
public:
	RenderView(PyObject* pyobj) : pyUniplug(pyobj) {}

	RenderView() : pyUniplug(0)
	{
		// not implemented
	}

	/** Getter:  */
	std::string name() { /* not implemented */ throw NULL; }
	/** Setter:  */
	void name(const std::string& value) { /* not implemented */ }

};

/**************** Render Layer ****************/

/**
 * 
 */
class RenderLayer : public pyUniplug {
public:
	RenderLayer(PyObject* pyobj) : pyUniplug(pyobj) {}

	RenderLayer() : pyUniplug(0)
	{
		// not implemented
	}

	/** Getter: Render layer name */
	std::string name() { /* not implemented */ throw NULL; }
	/** Setter: Render layer name */
	void name(const std::string& value) { /* not implemented */ }

	/** Getter: Material to override all other materials in this render layer */
	Material material_override() {
		/* not implemented */ throw NULL;
	}

	/** Getter: Group to override all other lights in this render layer */
	Group light_override() {
		/* not implemented */ throw NULL;
	}

	/** Getter: Scene layers included in this render layer */
	std::array<bool, 20> layers() {
		// TODO: MISSING DEREF! USE #DEFINE!
		PyObject *seqval = PyObject_GetAttrString(pyobjref, "layers");
		std::array<bool, 20> resarr;
		for (int i = 0; i < 20; i++)
			resarr[i] = PyLong_AsLong(PySequence_GetItem(seqval, i)) == 1;
		return resarr;
	}

	/** Setter: Scene layers included in this render layer */
	void layers(bool values[20]) { /* not implemented */ }

	/** Getter: Zmask scene layers for solid faces */
	std::array<bool, 20> layers_zmask() {
		// TODO: MISSING DEREF! USE #DEFINE!
		PyObject *seqval = PyObject_GetAttrString(pyobjref, "layers_zmask");
		std::array<bool, 20> resarr;
		for (int i = 0; i < 20; i++)
			resarr[i] = PyLong_AsLong(PySequence_GetItem(seqval, i)) == 1;
		return resarr;
	}

	/** Setter: Zmask scene layers for solid faces */
	void layers_zmask(bool values[20]) { /* not implemented */ }

	/** Getter: Exclude scene layers from having any influence */
	std::array<bool, 20> layers_exclude() {
		// TODO: MISSING DEREF! USE #DEFINE!
		PyObject *seqval = PyObject_GetAttrString(pyobjref, "layers_exclude");
		std::array<bool, 20> resarr;
		for (int i = 0; i < 20; i++)
			resarr[i] = PyLong_AsLong(PySequence_GetItem(seqval, i)) == 1;
		return resarr;
	}

	/** Setter: Exclude scene layers from having any influence */
	void layers_exclude(bool values[20]) { /* not implemented */ }

	/** Getter: Disable or enable the render layer */
	bool use() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use")) == 1;
	}

	/** Setter: Disable or enable the render layer */
	void use(bool value) {
		PyObject_SetAttrString(pyobjref, "use", Py_BuildValue("i", value));
	}

	/** Getter: Only render what's in front of the solid z values */
	bool use_zmask() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_zmask")) == 1;
	}

	/** Setter: Only render what's in front of the solid z values */
	void use_zmask(bool value) {
		PyObject_SetAttrString(pyobjref, "use_zmask", Py_BuildValue("i", value));
	}

	/** Getter: For Zmask, only render what is behind solid z values instead of in front */
	bool invert_zmask() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "invert_zmask")) == 1;
	}

	/** Setter: For Zmask, only render what is behind solid z values instead of in front */
	void invert_zmask(bool value) {
		PyObject_SetAttrString(pyobjref, "invert_zmask", Py_BuildValue("i", value));
	}

	/** Getter: Fill in Z values for solid faces in invisible layers, for masking */
	bool use_all_z() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_all_z")) == 1;
	}

	/** Setter: Fill in Z values for solid faces in invisible layers, for masking */
	void use_all_z(bool value) {
		PyObject_SetAttrString(pyobjref, "use_all_z", Py_BuildValue("i", value));
	}

	/** Getter: Render Solid faces in this Layer */
	bool use_solid() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_solid")) == 1;
	}

	/** Setter: Render Solid faces in this Layer */
	void use_solid(bool value) {
		PyObject_SetAttrString(pyobjref, "use_solid", Py_BuildValue("i", value));
	}

	/** Getter: Render Halos in this Layer (on top of Solid) */
	bool use_halo() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_halo")) == 1;
	}

	/** Setter: Render Halos in this Layer (on top of Solid) */
	void use_halo(bool value) {
		PyObject_SetAttrString(pyobjref, "use_halo", Py_BuildValue("i", value));
	}

	/** Getter: Render Z-Transparent faces in this Layer (on top of Solid and Halos) */
	bool use_ztransp() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_ztransp")) == 1;
	}

	/** Setter: Render Z-Transparent faces in this Layer (on top of Solid and Halos) */
	void use_ztransp(bool value) {
		PyObject_SetAttrString(pyobjref, "use_ztransp", Py_BuildValue("i", value));
	}

	/** Getter: Render Sky in this Layer */
	bool use_sky() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_sky")) == 1;
	}

	/** Setter: Render Sky in this Layer */
	void use_sky(bool value) {
		PyObject_SetAttrString(pyobjref, "use_sky", Py_BuildValue("i", value));
	}

	/** Getter: Render Edge-enhance in this Layer (only works for Solid faces) */
	bool use_edge_enhance() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_edge_enhance")) == 1;
	}

	/** Setter: Render Edge-enhance in this Layer (only works for Solid faces) */
	void use_edge_enhance(bool value) {
		PyObject_SetAttrString(pyobjref, "use_edge_enhance", Py_BuildValue("i", value));
	}

	/** Getter: Render Strands in this Layer */
	bool use_strand() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_strand")) == 1;
	}

	/** Setter: Render Strands in this Layer */
	void use_strand(bool value) {
		PyObject_SetAttrString(pyobjref, "use_strand", Py_BuildValue("i", value));
	}

	/** Getter: Render stylized strokes in this Layer */
	bool use_freestyle() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_freestyle")) == 1;
	}

	/** Setter: Render stylized strokes in this Layer */
	void use_freestyle(bool value) {
		PyObject_SetAttrString(pyobjref, "use_freestyle", Py_BuildValue("i", value));
	}

	/** Getter: Deliver full combined RGBA buffer */
	bool use_pass_combined() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_pass_combined")) == 1;
	}

	/** Setter: Deliver full combined RGBA buffer */
	void use_pass_combined(bool value) {
		PyObject_SetAttrString(pyobjref, "use_pass_combined", Py_BuildValue("i", value));
	}

	/** Getter: Deliver Z values pass */
	bool use_pass_z() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_pass_z")) == 1;
	}

	/** Setter: Deliver Z values pass */
	void use_pass_z(bool value) {
		PyObject_SetAttrString(pyobjref, "use_pass_z", Py_BuildValue("i", value));
	}

	/** Getter: Deliver speed vector pass */
	bool use_pass_vector() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_pass_vector")) == 1;
	}

	/** Setter: Deliver speed vector pass */
	void use_pass_vector(bool value) {
		PyObject_SetAttrString(pyobjref, "use_pass_vector", Py_BuildValue("i", value));
	}

	/** Getter: Deliver normal pass */
	bool use_pass_normal() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_pass_normal")) == 1;
	}

	/** Setter: Deliver normal pass */
	void use_pass_normal(bool value) {
		PyObject_SetAttrString(pyobjref, "use_pass_normal", Py_BuildValue("i", value));
	}

	/** Getter: Deliver texture UV pass */
	bool use_pass_uv() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_pass_uv")) == 1;
	}

	/** Setter: Deliver texture UV pass */
	void use_pass_uv(bool value) {
		PyObject_SetAttrString(pyobjref, "use_pass_uv", Py_BuildValue("i", value));
	}

	/** Getter: Deliver mist factor pass (0.0-1.0) */
	bool use_pass_mist() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_pass_mist")) == 1;
	}

	/** Setter: Deliver mist factor pass (0.0-1.0) */
	void use_pass_mist(bool value) {
		PyObject_SetAttrString(pyobjref, "use_pass_mist", Py_BuildValue("i", value));
	}

	/** Getter: Deliver object index pass */
	bool use_pass_object_index() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_pass_object_index")) == 1;
	}

	/** Setter: Deliver object index pass */
	void use_pass_object_index(bool value) {
		PyObject_SetAttrString(pyobjref, "use_pass_object_index", Py_BuildValue("i", value));
	}

	/** Getter: Deliver material index pass */
	bool use_pass_material_index() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_pass_material_index")) == 1;
	}

	/** Setter: Deliver material index pass */
	void use_pass_material_index(bool value) {
		PyObject_SetAttrString(pyobjref, "use_pass_material_index", Py_BuildValue("i", value));
	}

	/** Getter: Deliver shade-less color pass */
	bool use_pass_color() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_pass_color")) == 1;
	}

	/** Setter: Deliver shade-less color pass */
	void use_pass_color(bool value) {
		PyObject_SetAttrString(pyobjref, "use_pass_color", Py_BuildValue("i", value));
	}

	/** Getter: Deliver diffuse pass */
	bool use_pass_diffuse() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_pass_diffuse")) == 1;
	}

	/** Setter: Deliver diffuse pass */
	void use_pass_diffuse(bool value) {
		PyObject_SetAttrString(pyobjref, "use_pass_diffuse", Py_BuildValue("i", value));
	}

	/** Getter: Deliver specular pass */
	bool use_pass_specular() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_pass_specular")) == 1;
	}

	/** Setter: Deliver specular pass */
	void use_pass_specular(bool value) {
		PyObject_SetAttrString(pyobjref, "use_pass_specular", Py_BuildValue("i", value));
	}

	/** Getter: Deliver shadow pass */
	bool use_pass_shadow() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_pass_shadow")) == 1;
	}

	/** Setter: Deliver shadow pass */
	void use_pass_shadow(bool value) {
		PyObject_SetAttrString(pyobjref, "use_pass_shadow", Py_BuildValue("i", value));
	}

	/** Getter: Deliver AO pass */
	bool use_pass_ambient_occlusion() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_pass_ambient_occlusion")) == 1;
	}

	/** Setter: Deliver AO pass */
	void use_pass_ambient_occlusion(bool value) {
		PyObject_SetAttrString(pyobjref, "use_pass_ambient_occlusion", Py_BuildValue("i", value));
	}

	/** Getter: Deliver raytraced reflection pass */
	bool use_pass_reflection() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_pass_reflection")) == 1;
	}

	/** Setter: Deliver raytraced reflection pass */
	void use_pass_reflection(bool value) {
		PyObject_SetAttrString(pyobjref, "use_pass_reflection", Py_BuildValue("i", value));
	}

	/** Getter: Deliver raytraced refraction pass */
	bool use_pass_refraction() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_pass_refraction")) == 1;
	}

	/** Setter: Deliver raytraced refraction pass */
	void use_pass_refraction(bool value) {
		PyObject_SetAttrString(pyobjref, "use_pass_refraction", Py_BuildValue("i", value));
	}

	/** Getter: Deliver emission pass */
	bool use_pass_emit() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_pass_emit")) == 1;
	}

	/** Setter: Deliver emission pass */
	void use_pass_emit(bool value) {
		PyObject_SetAttrString(pyobjref, "use_pass_emit", Py_BuildValue("i", value));
	}

	/** Getter: Deliver environment lighting pass */
	bool use_pass_environment() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_pass_environment")) == 1;
	}

	/** Setter: Deliver environment lighting pass */
	void use_pass_environment(bool value) {
		PyObject_SetAttrString(pyobjref, "use_pass_environment", Py_BuildValue("i", value));
	}

	/** Getter: Deliver indirect lighting pass */
	bool use_pass_indirect() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_pass_indirect")) == 1;
	}

	/** Setter: Deliver indirect lighting pass */
	void use_pass_indirect(bool value) {
		PyObject_SetAttrString(pyobjref, "use_pass_indirect", Py_BuildValue("i", value));
	}

	/** Getter: Exclude specular pass from combined */
	bool exclude_specular() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "exclude_specular")) == 1;
	}

	/** Setter: Exclude specular pass from combined */
	void exclude_specular(bool value) {
		PyObject_SetAttrString(pyobjref, "exclude_specular", Py_BuildValue("i", value));
	}

	/** Getter: Exclude shadow pass from combined */
	bool exclude_shadow() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "exclude_shadow")) == 1;
	}

	/** Setter: Exclude shadow pass from combined */
	void exclude_shadow(bool value) {
		PyObject_SetAttrString(pyobjref, "exclude_shadow", Py_BuildValue("i", value));
	}

	/** Getter: Exclude AO pass from combined */
	bool exclude_ambient_occlusion() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "exclude_ambient_occlusion")) == 1;
	}

	/** Setter: Exclude AO pass from combined */
	void exclude_ambient_occlusion(bool value) {
		PyObject_SetAttrString(pyobjref, "exclude_ambient_occlusion", Py_BuildValue("i", value));
	}

	/** Getter: Exclude raytraced reflection pass from combined */
	bool exclude_reflection() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "exclude_reflection")) == 1;
	}

	/** Setter: Exclude raytraced reflection pass from combined */
	void exclude_reflection(bool value) {
		PyObject_SetAttrString(pyobjref, "exclude_reflection", Py_BuildValue("i", value));
	}

	/** Getter: Exclude raytraced refraction pass from combined */
	bool exclude_refraction() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "exclude_refraction")) == 1;
	}

	/** Setter: Exclude raytraced refraction pass from combined */
	void exclude_refraction(bool value) {
		PyObject_SetAttrString(pyobjref, "exclude_refraction", Py_BuildValue("i", value));
	}

	/** Getter: Exclude emission pass from combined */
	bool exclude_emit() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "exclude_emit")) == 1;
	}

	/** Setter: Exclude emission pass from combined */
	void exclude_emit(bool value) {
		PyObject_SetAttrString(pyobjref, "exclude_emit", Py_BuildValue("i", value));
	}

	/** Getter: Exclude environment pass from combined */
	bool exclude_environment() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "exclude_environment")) == 1;
	}

	/** Setter: Exclude environment pass from combined */
	void exclude_environment(bool value) {
		PyObject_SetAttrString(pyobjref, "exclude_environment", Py_BuildValue("i", value));
	}

	/** Getter: Exclude indirect pass from combined */
	bool exclude_indirect() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "exclude_indirect")) == 1;
	}

	/** Setter: Exclude indirect pass from combined */
	void exclude_indirect(bool value) {
		PyObject_SetAttrString(pyobjref, "exclude_indirect", Py_BuildValue("i", value));
	}

	/** Getter: Deliver diffuse direct pass */
	bool use_pass_diffuse_direct() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_pass_diffuse_direct")) == 1;
	}

	/** Setter: Deliver diffuse direct pass */
	void use_pass_diffuse_direct(bool value) {
		PyObject_SetAttrString(pyobjref, "use_pass_diffuse_direct", Py_BuildValue("i", value));
	}

	/** Getter: Deliver diffuse indirect pass */
	bool use_pass_diffuse_indirect() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_pass_diffuse_indirect")) == 1;
	}

	/** Setter: Deliver diffuse indirect pass */
	void use_pass_diffuse_indirect(bool value) {
		PyObject_SetAttrString(pyobjref, "use_pass_diffuse_indirect", Py_BuildValue("i", value));
	}

	/** Getter: Deliver diffuse color pass */
	bool use_pass_diffuse_color() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_pass_diffuse_color")) == 1;
	}

	/** Setter: Deliver diffuse color pass */
	void use_pass_diffuse_color(bool value) {
		PyObject_SetAttrString(pyobjref, "use_pass_diffuse_color", Py_BuildValue("i", value));
	}

	/** Getter: Deliver glossy direct pass */
	bool use_pass_glossy_direct() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_pass_glossy_direct")) == 1;
	}

	/** Setter: Deliver glossy direct pass */
	void use_pass_glossy_direct(bool value) {
		PyObject_SetAttrString(pyobjref, "use_pass_glossy_direct", Py_BuildValue("i", value));
	}

	/** Getter: Deliver glossy indirect pass */
	bool use_pass_glossy_indirect() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_pass_glossy_indirect")) == 1;
	}

	/** Setter: Deliver glossy indirect pass */
	void use_pass_glossy_indirect(bool value) {
		PyObject_SetAttrString(pyobjref, "use_pass_glossy_indirect", Py_BuildValue("i", value));
	}

	/** Getter: Deliver glossy color pass */
	bool use_pass_glossy_color() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_pass_glossy_color")) == 1;
	}

	/** Setter: Deliver glossy color pass */
	void use_pass_glossy_color(bool value) {
		PyObject_SetAttrString(pyobjref, "use_pass_glossy_color", Py_BuildValue("i", value));
	}

	/** Getter: Deliver transmission direct pass */
	bool use_pass_transmission_direct() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_pass_transmission_direct")) == 1;
	}

	/** Setter: Deliver transmission direct pass */
	void use_pass_transmission_direct(bool value) {
		PyObject_SetAttrString(pyobjref, "use_pass_transmission_direct", Py_BuildValue("i", value));
	}

	/** Getter: Deliver transmission indirect pass */
	bool use_pass_transmission_indirect() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_pass_transmission_indirect")) == 1;
	}

	/** Setter: Deliver transmission indirect pass */
	void use_pass_transmission_indirect(bool value) {
		PyObject_SetAttrString(pyobjref, "use_pass_transmission_indirect", Py_BuildValue("i", value));
	}

	/** Getter: Deliver transmission color pass */
	bool use_pass_transmission_color() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_pass_transmission_color")) == 1;
	}

	/** Setter: Deliver transmission color pass */
	void use_pass_transmission_color(bool value) {
		PyObject_SetAttrString(pyobjref, "use_pass_transmission_color", Py_BuildValue("i", value));
	}

	/** Getter: Deliver subsurface direct pass */
	bool use_pass_subsurface_direct() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_pass_subsurface_direct")) == 1;
	}

	/** Setter: Deliver subsurface direct pass */
	void use_pass_subsurface_direct(bool value) {
		PyObject_SetAttrString(pyobjref, "use_pass_subsurface_direct", Py_BuildValue("i", value));
	}

	/** Getter: Deliver subsurface indirect pass */
	bool use_pass_subsurface_indirect() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_pass_subsurface_indirect")) == 1;
	}

	/** Setter: Deliver subsurface indirect pass */
	void use_pass_subsurface_indirect(bool value) {
		PyObject_SetAttrString(pyobjref, "use_pass_subsurface_indirect", Py_BuildValue("i", value));
	}

	/** Getter: Deliver subsurface color pass */
	bool use_pass_subsurface_color() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_pass_subsurface_color")) == 1;
	}

	/** Setter: Deliver subsurface color pass */
	void use_pass_subsurface_color(bool value) {
		PyObject_SetAttrString(pyobjref, "use_pass_subsurface_color", Py_BuildValue("i", value));
	}

	/** Getter:  */
	std::map<std::string, RenderPass> passes();
	/** Setter:  */
	void passes(std::map<std::string, RenderPass> value);

	/**
	 * Copies the pixels of this renderlayer from an image file
	 * @param Filename to load into this render tile, must be no smaller than the renderlayer
	 * @param Offset the position to copy from if the image is larger than the render layer
	 * @param Offset the position to copy from if the image is larger than the render layer
	 */
	void load_from_file(const std::string filename, int x = 0, int y = 0)
	{
		// not implemented
	}

};

/**************** Render Pass ****************/

/**
 * 
 */
class RenderPass : public pyUniplug {
public:
	RenderPass(PyObject* pyobj) : pyUniplug(pyobj) {}

	RenderPass() : pyUniplug(0)
	{
		// not implemented
	}

	/** Getter:  */
	std::string name() { /* not implemented */ throw NULL; }
	/** Setter:  */
	void name(const std::string& value) { /* not implemented */ }

	/** Getter:  */
	std::string channel_id() { /* not implemented */ throw NULL; }
	/** Setter:  */
	void channel_id(const std::string& value) { /* not implemented */ }

	/** Getter:  */
	int channels() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "channels"));
	}

	/** Setter:  */
	void channels(int value) {
		PyObject_SetAttrString(pyobjref, "channels", Py_BuildValue("i", value));
	}

	enum type_enum {
		type_COMBINED = 1,
		type_Z = 2,
		type_COLOR = 4,
		type_DIFFUSE = 8,
		type_SPECULAR = 16,
		type_SHADOW = 32,
		type_AO = 64,
		type_REFLECTION = 128,
		type_NORMAL = 256,
		type_VECTOR = 512,
		type_REFRACTION = 1024,
		type_OBJECT_INDEX = 2048,
		type_UV = 4096,
		type_MIST = 16384,
		type_EMIT = 65536,
		type_ENVIRONMENT = 131072,
		type_MATERIAL_INDEX = 262144,
		type_DIFFUSE_DIRECT = 524288,
		type_DIFFUSE_INDIRECT = 1048576,
		type_DIFFUSE_COLOR = 2097152,
		type_GLOSSY_DIRECT = 4194304,
		type_GLOSSY_INDIRECT = 8388608,
		type_GLOSSY_COLOR = 16777216,
		type_TRANSMISSION_DIRECT = 33554432,
		type_TRANSMISSION_INDIRECT = 67108864,
		type_TRANSMISSION_COLOR = 134217728,
		type_SUBSURFACE_DIRECT = 268435456,
		type_SUBSURFACE_INDIRECT = 536870912,
		type_SUBSURFACE_COLOR = 1073741824,
	};

	/** Getter:  */
	type_enum type() { /* not implemented */ throw NULL; }
	/** Setter:  */
	void type(type_enum value) { /* not implemented */ }

	/** Getter:  */
	std::vector<float> rect() {
		// TODO: MISSING DEREF! USE #DEFINE!
		PyObject *seqval = PyObject_GetAttrString(pyobjref, "rect");
		std::vector<float> resvec;
		for (int i = 0; i < PySequence_Length(seqval); i++)
			resvec.push_back((float)PyFloat_AsDouble(PySequence_GetItem(seqval, i)));
		return resvec;
	}

	/** Setter:  */
	void rect(float values[]) { /* not implemented */ }

	/** Getter:  */
	int view_id() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "view_id"));
	}

	/** Setter:  */
	void view_id(int value) {
		PyObject_SetAttrString(pyobjref, "view_id", Py_BuildValue("i", value));
	}

	enum debug_type_enum {
		debug_type_BVH_TRAVERSAL_STEPS = 0,
	};

	/** Getter:  */
	debug_type_enum debug_type() { /* not implemented */ throw NULL; }
	/** Setter:  */
	void debug_type(debug_type_enum value) { /* not implemented */ }

};

/**************** Bake Pixel ****************/

/**
 * 
 */
class BakePixel : public pyUniplug {
public:
	BakePixel(PyObject* pyobj) : pyUniplug(pyobj) {}

	BakePixel() : pyUniplug(0)
	{
		// not implemented
	}

	/** Getter:  */
	int primitive_id() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "primitive_id"));
	}

	/** Setter:  */
	void primitive_id(int value) {
		PyObject_SetAttrString(pyobjref, "primitive_id", Py_BuildValue("i", value));
	}

	/** Getter:  */
	int object_id() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "object_id"));
	}

	/** Setter:  */
	void object_id(int value) {
		PyObject_SetAttrString(pyobjref, "object_id", Py_BuildValue("i", value));
	}

	/** Getter:  */
	std::array<float, 2> uv() {
		// TODO: MISSING DEREF! USE #DEFINE!
		PyObject *seqval = PyObject_GetAttrString(pyobjref, "uv");
		std::array<float, 2> resarr;
		for (int i = 0; i < 2; i++)
			resarr[i] = (float)PyFloat_AsDouble(PySequence_GetItem(seqval, i));
		return resarr;
	}

	/** Setter:  */
	void uv(float values[2]) { /* not implemented */ }

	/** Getter:  */
	float du_dx() { /* not implemented */ throw NULL; }
	/** Setter:  */
	void du_dx(float value) {
		PyObject_SetAttrString(pyobjref, "du_dx", Py_BuildValue("f", value));
	}

	/** Getter:  */
	float du_dy() { /* not implemented */ throw NULL; }
	/** Setter:  */
	void du_dy(float value) {
		PyObject_SetAttrString(pyobjref, "du_dy", Py_BuildValue("f", value));
	}

	/** Getter:  */
	float dv_dx() { /* not implemented */ throw NULL; }
	/** Setter:  */
	void dv_dx(float value) {
		PyObject_SetAttrString(pyobjref, "dv_dx", Py_BuildValue("f", value));
	}

	/** Getter:  */
	float dv_dy() { /* not implemented */ throw NULL; }
	/** Setter:  */
	void dv_dy(float value) {
		PyObject_SetAttrString(pyobjref, "dv_dy", Py_BuildValue("f", value));
	}

	/** Getter:  */
	BakePixel next() {
		/* not implemented */ throw NULL;
	}

};

/**************** Rigid Body World ****************/

/**
 * Self-contained rigid body simulation environment and settings
 */
class RigidBodyWorld : public pyUniplug {
public:
	RigidBodyWorld(PyObject* pyobj) : pyUniplug(pyobj) {}

	RigidBodyWorld() : pyUniplug(0)
	{
		// not implemented
	}

	/** Getter: Group containing objects participating in this simulation */
	Group group() {
		/* not implemented */ throw NULL;
	}

	/** Getter: Group containing rigid body constraint objects */
	Group constraints() {
		/* not implemented */ throw NULL;
	}

	/** Getter: Simulation will be evaluated */
	bool enabled() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "enabled")) == 1;
	}

	/** Setter: Simulation will be evaluated */
	void enabled(bool value) {
		PyObject_SetAttrString(pyobjref, "enabled", Py_BuildValue("i", value));
	}

	/** Getter: Change the speed of the simulation */
	float time_scale() { /* not implemented */ throw NULL; }
	/** Setter: Change the speed of the simulation */
	void time_scale(float value) {
		PyObject_SetAttrString(pyobjref, "time_scale", Py_BuildValue("f", value));
	}

	/** Getter: Number of simulation steps taken per second (higher values are more accurate but slower) */
	int steps_per_second() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "steps_per_second"));
	}

	/** Setter: Number of simulation steps taken per second (higher values are more accurate but slower) */
	void steps_per_second(int value) {
		PyObject_SetAttrString(pyobjref, "steps_per_second", Py_BuildValue("i", value));
	}

	/** Getter: Number of constraint solver iterations made per simulation step (higher values are more accurate but slower) */
	int solver_iterations() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "solver_iterations"));
	}

	/** Setter: Number of constraint solver iterations made per simulation step (higher values are more accurate but slower) */
	void solver_iterations(int value) {
		PyObject_SetAttrString(pyobjref, "solver_iterations", Py_BuildValue("i", value));
	}

	/** Getter: Reduce extra velocity that can build up when objects collide (lowers simulation stability a little so use only when necessary) */
	bool use_split_impulse() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_split_impulse")) == 1;
	}

	/** Setter: Reduce extra velocity that can build up when objects collide (lowers simulation stability a little so use only when necessary) */
	void use_split_impulse(bool value) {
		PyObject_SetAttrString(pyobjref, "use_split_impulse", Py_BuildValue("i", value));
	}

	/** Getter:  */
	PointCache point_cache() {
		/* not implemented */ throw NULL;
	}

	/** Getter:  */
	EffectorWeights effector_weights() {
		/* not implemented */ throw NULL;
	}

	/**
	 * Container for the output of convex_sweep_test()
	 */
	struct convex_sweep_test_result {
		float object_location;	/**< The hit location of this sweep test */
		float hitpoint;	/**< The hit location of this sweep test */
		float normal;	/**< The face normal at the sweep test hit location */
		int has_hit;	/**< If the function has found collision point, value is 1, otherwise 0 */
	};

	/**
	 * Sweep test convex rigidbody against the current rigidbody world
	 * @param Rigidbody object with a convex collision shape
	 * @param Param 'start'
	 * @param Param 'end'
	 * @return A convex_sweep_test_result struct containing the output of this function
	 */
	convex_sweep_test_result convex_sweep_test(Object object_value, float start[3], float end[3])
	{
		// not implemented
		return convex_sweep_test_result();
	}

};

/**************** Rigid Body Object ****************/

/**
 * Settings for object participating in Rigid Body Simulation
 */
class RigidBodyObject : public pyUniplug {
public:
	RigidBodyObject(PyObject* pyobj) : pyUniplug(pyobj) {}

	RigidBodyObject() : pyUniplug(0)
	{
		// not implemented
	}

	enum type_enum {
		type_ACTIVE = 0,
		type_PASSIVE = 1,
	};

	/** Getter: Role of object in Rigid Body Simulations */
	type_enum type() { /* not implemented */ throw NULL; }
	/** Setter: Role of object in Rigid Body Simulations */
	void type(type_enum value) { /* not implemented */ }

	enum mesh_source_enum {
		mesh_source_BASE = 0,
		mesh_source_DEFORM = 1,
		mesh_source_FINAL = 2,
	};

	/** Getter: Source of the mesh used to create collision shape */
	mesh_source_enum mesh_source() { /* not implemented */ throw NULL; }
	/** Setter: Source of the mesh used to create collision shape */
	void mesh_source(mesh_source_enum value) { /* not implemented */ }

	/** Getter: Rigid Body actively participates to the simulation */
	bool enabled() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "enabled")) == 1;
	}

	/** Setter: Rigid Body actively participates to the simulation */
	void enabled(bool value) {
		PyObject_SetAttrString(pyobjref, "enabled", Py_BuildValue("i", value));
	}

	enum collision_shape_enum {
		collision_shape_BOX = 0,
		collision_shape_SPHERE = 1,
		collision_shape_CAPSULE = 2,
		collision_shape_CYLINDER = 3,
		collision_shape_CONE = 4,
		collision_shape_CONVEX_HULL = 5,
		collision_shape_MESH = 6,
	};

	/** Getter: Collision Shape of object in Rigid Body Simulations */
	collision_shape_enum collision_shape() { /* not implemented */ throw NULL; }
	/** Setter: Collision Shape of object in Rigid Body Simulations */
	void collision_shape(collision_shape_enum value) { /* not implemented */ }

	/** Getter: Allow rigid body to be controlled by the animation system */
	bool kinematic() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "kinematic")) == 1;
	}

	/** Setter: Allow rigid body to be controlled by the animation system */
	void kinematic(bool value) {
		PyObject_SetAttrString(pyobjref, "kinematic", Py_BuildValue("i", value));
	}

	/** Getter: Rigid body deforms during simulation */
	bool use_deform() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_deform")) == 1;
	}

	/** Setter: Rigid body deforms during simulation */
	void use_deform(bool value) {
		PyObject_SetAttrString(pyobjref, "use_deform", Py_BuildValue("i", value));
	}

	/** Getter: How much the object 'weighs' irrespective of gravity */
	float mass() { /* not implemented */ throw NULL; }
	/** Setter: How much the object 'weighs' irrespective of gravity */
	void mass(float value) {
		PyObject_SetAttrString(pyobjref, "mass", Py_BuildValue("f", value));
	}

	/** Getter: Enable deactivation of resting rigid bodies (increases performance and stability but can cause glitches) */
	bool use_deactivation() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_deactivation")) == 1;
	}

	/** Setter: Enable deactivation of resting rigid bodies (increases performance and stability but can cause glitches) */
	void use_deactivation(bool value) {
		PyObject_SetAttrString(pyobjref, "use_deactivation", Py_BuildValue("i", value));
	}

	/** Getter: Deactivate rigid body at the start of the simulation */
	bool use_start_deactivated() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_start_deactivated")) == 1;
	}

	/** Setter: Deactivate rigid body at the start of the simulation */
	void use_start_deactivated(bool value) {
		PyObject_SetAttrString(pyobjref, "use_start_deactivated", Py_BuildValue("i", value));
	}

	/** Getter: Linear Velocity below which simulation stops simulating object */
	float deactivate_linear_velocity() { /* not implemented */ throw NULL; }
	/** Setter: Linear Velocity below which simulation stops simulating object */
	void deactivate_linear_velocity(float value) {
		PyObject_SetAttrString(pyobjref, "deactivate_linear_velocity", Py_BuildValue("f", value));
	}

	/** Getter: Angular Velocity below which simulation stops simulating object */
	float deactivate_angular_velocity() { /* not implemented */ throw NULL; }
	/** Setter: Angular Velocity below which simulation stops simulating object */
	void deactivate_angular_velocity(float value) {
		PyObject_SetAttrString(pyobjref, "deactivate_angular_velocity", Py_BuildValue("f", value));
	}

	/** Getter: Amount of linear velocity that is lost over time */
	float linear_damping() { /* not implemented */ throw NULL; }
	/** Setter: Amount of linear velocity that is lost over time */
	void linear_damping(float value) {
		PyObject_SetAttrString(pyobjref, "linear_damping", Py_BuildValue("f", value));
	}

	/** Getter: Amount of angular velocity that is lost over time */
	float angular_damping() { /* not implemented */ throw NULL; }
	/** Setter: Amount of angular velocity that is lost over time */
	void angular_damping(float value) {
		PyObject_SetAttrString(pyobjref, "angular_damping", Py_BuildValue("f", value));
	}

	/** Getter: Resistance of object to movement */
	float friction() { /* not implemented */ throw NULL; }
	/** Setter: Resistance of object to movement */
	void friction(float value) {
		PyObject_SetAttrString(pyobjref, "friction", Py_BuildValue("f", value));
	}

	/** Getter: Tendency of object to bounce after colliding with another (0 = stays still, 1 = perfectly elastic) */
	float restitution() { /* not implemented */ throw NULL; }
	/** Setter: Tendency of object to bounce after colliding with another (0 = stays still, 1 = perfectly elastic) */
	void restitution(float value) {
		PyObject_SetAttrString(pyobjref, "restitution", Py_BuildValue("f", value));
	}

	/** Getter: Use custom collision margin (some shapes will have a visible gap around them) */
	bool use_margin() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_margin")) == 1;
	}

	/** Setter: Use custom collision margin (some shapes will have a visible gap around them) */
	void use_margin(bool value) {
		PyObject_SetAttrString(pyobjref, "use_margin", Py_BuildValue("i", value));
	}

	/** Getter: Threshold of distance near surface where collisions are still considered (best results when non-zero) */
	float collision_margin() { /* not implemented */ throw NULL; }
	/** Setter: Threshold of distance near surface where collisions are still considered (best results when non-zero) */
	void collision_margin(float value) {
		PyObject_SetAttrString(pyobjref, "collision_margin", Py_BuildValue("f", value));
	}

	/** Getter: Collision Groups Rigid Body belongs to */
	std::array<bool, 20> collision_groups() {
		// TODO: MISSING DEREF! USE #DEFINE!
		PyObject *seqval = PyObject_GetAttrString(pyobjref, "collision_groups");
		std::array<bool, 20> resarr;
		for (int i = 0; i < 20; i++)
			resarr[i] = PyLong_AsLong(PySequence_GetItem(seqval, i)) == 1;
		return resarr;
	}

	/** Setter: Collision Groups Rigid Body belongs to */
	void collision_groups(bool values[20]) { /* not implemented */ }

};

/**************** Rigid Body Constraint ****************/

/**
 * Constraint influencing Objects inside Rigid Body Simulation
 */
class RigidBodyConstraint : public pyUniplug {
public:
	RigidBodyConstraint(PyObject* pyobj) : pyUniplug(pyobj) {}

	RigidBodyConstraint() : pyUniplug(0)
	{
		// not implemented
	}

	enum type_enum {
		type_FIXED = 8,
		type_POINT = 0,
		type_HINGE = 1,
		type_SLIDER = 3,
		type_PISTON = 9,
		type_GENERIC = 5,
		type_GENERIC_SPRING = 6,
		type_MOTOR = 11,
	};

	/** Getter: Type of Rigid Body Constraint */
	type_enum type() { /* not implemented */ throw NULL; }
	/** Setter: Type of Rigid Body Constraint */
	void type(type_enum value) { /* not implemented */ }

	/** Getter: Enable this constraint */
	bool enabled() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "enabled")) == 1;
	}

	/** Setter: Enable this constraint */
	void enabled(bool value) {
		PyObject_SetAttrString(pyobjref, "enabled", Py_BuildValue("i", value));
	}

	/** Getter: Disable collisions between constrained rigid bodies */
	bool disable_collisions() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "disable_collisions")) == 1;
	}

	/** Setter: Disable collisions between constrained rigid bodies */
	void disable_collisions(bool value) {
		PyObject_SetAttrString(pyobjref, "disable_collisions", Py_BuildValue("i", value));
	}

	/** Getter: First Rigid Body Object to be constrained */
	Object object1() {
		/* not implemented */ throw NULL;
	}

	/** Getter: Second Rigid Body Object to be constrained */
	Object object2() {
		/* not implemented */ throw NULL;
	}

	/** Getter: Constraint can be broken if it receives an impulse above the threshold */
	bool use_breaking() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_breaking")) == 1;
	}

	/** Setter: Constraint can be broken if it receives an impulse above the threshold */
	void use_breaking(bool value) {
		PyObject_SetAttrString(pyobjref, "use_breaking", Py_BuildValue("i", value));
	}

	/** Getter: Impulse threshold that must be reached for the constraint to break */
	float breaking_threshold() { /* not implemented */ throw NULL; }
	/** Setter: Impulse threshold that must be reached for the constraint to break */
	void breaking_threshold(float value) {
		PyObject_SetAttrString(pyobjref, "breaking_threshold", Py_BuildValue("f", value));
	}

	/** Getter: Override the number of solver iterations for this constraint */
	bool use_override_solver_iterations() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_override_solver_iterations")) == 1;
	}

	/** Setter: Override the number of solver iterations for this constraint */
	void use_override_solver_iterations(bool value) {
		PyObject_SetAttrString(pyobjref, "use_override_solver_iterations", Py_BuildValue("i", value));
	}

	/** Getter: Number of constraint solver iterations made per simulation step (higher values are more accurate but slower) */
	int solver_iterations() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "solver_iterations"));
	}

	/** Setter: Number of constraint solver iterations made per simulation step (higher values are more accurate but slower) */
	void solver_iterations(int value) {
		PyObject_SetAttrString(pyobjref, "solver_iterations", Py_BuildValue("i", value));
	}

	/** Getter: Limit translation on X axis */
	bool use_limit_lin_x() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_limit_lin_x")) == 1;
	}

	/** Setter: Limit translation on X axis */
	void use_limit_lin_x(bool value) {
		PyObject_SetAttrString(pyobjref, "use_limit_lin_x", Py_BuildValue("i", value));
	}

	/** Getter: Limit translation on Y axis */
	bool use_limit_lin_y() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_limit_lin_y")) == 1;
	}

	/** Setter: Limit translation on Y axis */
	void use_limit_lin_y(bool value) {
		PyObject_SetAttrString(pyobjref, "use_limit_lin_y", Py_BuildValue("i", value));
	}

	/** Getter: Limit translation on Z axis */
	bool use_limit_lin_z() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_limit_lin_z")) == 1;
	}

	/** Setter: Limit translation on Z axis */
	void use_limit_lin_z(bool value) {
		PyObject_SetAttrString(pyobjref, "use_limit_lin_z", Py_BuildValue("i", value));
	}

	/** Getter: Limit rotation around X axis */
	bool use_limit_ang_x() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_limit_ang_x")) == 1;
	}

	/** Setter: Limit rotation around X axis */
	void use_limit_ang_x(bool value) {
		PyObject_SetAttrString(pyobjref, "use_limit_ang_x", Py_BuildValue("i", value));
	}

	/** Getter: Limit rotation around Y axis */
	bool use_limit_ang_y() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_limit_ang_y")) == 1;
	}

	/** Setter: Limit rotation around Y axis */
	void use_limit_ang_y(bool value) {
		PyObject_SetAttrString(pyobjref, "use_limit_ang_y", Py_BuildValue("i", value));
	}

	/** Getter: Limit rotation around Z axis */
	bool use_limit_ang_z() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_limit_ang_z")) == 1;
	}

	/** Setter: Limit rotation around Z axis */
	void use_limit_ang_z(bool value) {
		PyObject_SetAttrString(pyobjref, "use_limit_ang_z", Py_BuildValue("i", value));
	}

	/** Getter: Enable spring on X axis */
	bool use_spring_x() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_spring_x")) == 1;
	}

	/** Setter: Enable spring on X axis */
	void use_spring_x(bool value) {
		PyObject_SetAttrString(pyobjref, "use_spring_x", Py_BuildValue("i", value));
	}

	/** Getter: Enable spring on Y axis */
	bool use_spring_y() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_spring_y")) == 1;
	}

	/** Setter: Enable spring on Y axis */
	void use_spring_y(bool value) {
		PyObject_SetAttrString(pyobjref, "use_spring_y", Py_BuildValue("i", value));
	}

	/** Getter: Enable spring on Z axis */
	bool use_spring_z() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_spring_z")) == 1;
	}

	/** Setter: Enable spring on Z axis */
	void use_spring_z(bool value) {
		PyObject_SetAttrString(pyobjref, "use_spring_z", Py_BuildValue("i", value));
	}

	/** Getter: Enable linear motor */
	bool use_motor_lin() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_motor_lin")) == 1;
	}

	/** Setter: Enable linear motor */
	void use_motor_lin(bool value) {
		PyObject_SetAttrString(pyobjref, "use_motor_lin", Py_BuildValue("i", value));
	}

	/** Getter: Enable angular motor */
	bool use_motor_ang() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_motor_ang")) == 1;
	}

	/** Setter: Enable angular motor */
	void use_motor_ang(bool value) {
		PyObject_SetAttrString(pyobjref, "use_motor_ang", Py_BuildValue("i", value));
	}

	/** Getter: Lower limit of X axis translation */
	float limit_lin_x_lower() { /* not implemented */ throw NULL; }
	/** Setter: Lower limit of X axis translation */
	void limit_lin_x_lower(float value) {
		PyObject_SetAttrString(pyobjref, "limit_lin_x_lower", Py_BuildValue("f", value));
	}

	/** Getter: Upper limit of X axis translation */
	float limit_lin_x_upper() { /* not implemented */ throw NULL; }
	/** Setter: Upper limit of X axis translation */
	void limit_lin_x_upper(float value) {
		PyObject_SetAttrString(pyobjref, "limit_lin_x_upper", Py_BuildValue("f", value));
	}

	/** Getter: Lower limit of Y axis translation */
	float limit_lin_y_lower() { /* not implemented */ throw NULL; }
	/** Setter: Lower limit of Y axis translation */
	void limit_lin_y_lower(float value) {
		PyObject_SetAttrString(pyobjref, "limit_lin_y_lower", Py_BuildValue("f", value));
	}

	/** Getter: Upper limit of Y axis translation */
	float limit_lin_y_upper() { /* not implemented */ throw NULL; }
	/** Setter: Upper limit of Y axis translation */
	void limit_lin_y_upper(float value) {
		PyObject_SetAttrString(pyobjref, "limit_lin_y_upper", Py_BuildValue("f", value));
	}

	/** Getter: Lower limit of Z axis translation */
	float limit_lin_z_lower() { /* not implemented */ throw NULL; }
	/** Setter: Lower limit of Z axis translation */
	void limit_lin_z_lower(float value) {
		PyObject_SetAttrString(pyobjref, "limit_lin_z_lower", Py_BuildValue("f", value));
	}

	/** Getter: Upper limit of Z axis translation */
	float limit_lin_z_upper() { /* not implemented */ throw NULL; }
	/** Setter: Upper limit of Z axis translation */
	void limit_lin_z_upper(float value) {
		PyObject_SetAttrString(pyobjref, "limit_lin_z_upper", Py_BuildValue("f", value));
	}

	/** Getter: Lower limit of X axis rotation */
	float limit_ang_x_lower() { /* not implemented */ throw NULL; }
	/** Setter: Lower limit of X axis rotation */
	void limit_ang_x_lower(float value) {
		PyObject_SetAttrString(pyobjref, "limit_ang_x_lower", Py_BuildValue("f", value));
	}

	/** Getter: Upper limit of X axis rotation */
	float limit_ang_x_upper() { /* not implemented */ throw NULL; }
	/** Setter: Upper limit of X axis rotation */
	void limit_ang_x_upper(float value) {
		PyObject_SetAttrString(pyobjref, "limit_ang_x_upper", Py_BuildValue("f", value));
	}

	/** Getter: Lower limit of Y axis rotation */
	float limit_ang_y_lower() { /* not implemented */ throw NULL; }
	/** Setter: Lower limit of Y axis rotation */
	void limit_ang_y_lower(float value) {
		PyObject_SetAttrString(pyobjref, "limit_ang_y_lower", Py_BuildValue("f", value));
	}

	/** Getter: Upper limit of Y axis rotation */
	float limit_ang_y_upper() { /* not implemented */ throw NULL; }
	/** Setter: Upper limit of Y axis rotation */
	void limit_ang_y_upper(float value) {
		PyObject_SetAttrString(pyobjref, "limit_ang_y_upper", Py_BuildValue("f", value));
	}

	/** Getter: Lower limit of Z axis rotation */
	float limit_ang_z_lower() { /* not implemented */ throw NULL; }
	/** Setter: Lower limit of Z axis rotation */
	void limit_ang_z_lower(float value) {
		PyObject_SetAttrString(pyobjref, "limit_ang_z_lower", Py_BuildValue("f", value));
	}

	/** Getter: Upper limit of Z axis rotation */
	float limit_ang_z_upper() { /* not implemented */ throw NULL; }
	/** Setter: Upper limit of Z axis rotation */
	void limit_ang_z_upper(float value) {
		PyObject_SetAttrString(pyobjref, "limit_ang_z_upper", Py_BuildValue("f", value));
	}

	/** Getter: Stiffness on the X axis */
	float spring_stiffness_x() { /* not implemented */ throw NULL; }
	/** Setter: Stiffness on the X axis */
	void spring_stiffness_x(float value) {
		PyObject_SetAttrString(pyobjref, "spring_stiffness_x", Py_BuildValue("f", value));
	}

	/** Getter: Stiffness on the Y axis */
	float spring_stiffness_y() { /* not implemented */ throw NULL; }
	/** Setter: Stiffness on the Y axis */
	void spring_stiffness_y(float value) {
		PyObject_SetAttrString(pyobjref, "spring_stiffness_y", Py_BuildValue("f", value));
	}

	/** Getter: Stiffness on the Z axis */
	float spring_stiffness_z() { /* not implemented */ throw NULL; }
	/** Setter: Stiffness on the Z axis */
	void spring_stiffness_z(float value) {
		PyObject_SetAttrString(pyobjref, "spring_stiffness_z", Py_BuildValue("f", value));
	}

	/** Getter: Damping on the X axis */
	float spring_damping_x() { /* not implemented */ throw NULL; }
	/** Setter: Damping on the X axis */
	void spring_damping_x(float value) {
		PyObject_SetAttrString(pyobjref, "spring_damping_x", Py_BuildValue("f", value));
	}

	/** Getter: Damping on the Y axis */
	float spring_damping_y() { /* not implemented */ throw NULL; }
	/** Setter: Damping on the Y axis */
	void spring_damping_y(float value) {
		PyObject_SetAttrString(pyobjref, "spring_damping_y", Py_BuildValue("f", value));
	}

	/** Getter: Damping on the Z axis */
	float spring_damping_z() { /* not implemented */ throw NULL; }
	/** Setter: Damping on the Z axis */
	void spring_damping_z(float value) {
		PyObject_SetAttrString(pyobjref, "spring_damping_z", Py_BuildValue("f", value));
	}

	/** Getter: Target linear motor velocity */
	float motor_lin_target_velocity() { /* not implemented */ throw NULL; }
	/** Setter: Target linear motor velocity */
	void motor_lin_target_velocity(float value) {
		PyObject_SetAttrString(pyobjref, "motor_lin_target_velocity", Py_BuildValue("f", value));
	}

	/** Getter: Maximum linear motor impulse */
	float motor_lin_max_impulse() { /* not implemented */ throw NULL; }
	/** Setter: Maximum linear motor impulse */
	void motor_lin_max_impulse(float value) {
		PyObject_SetAttrString(pyobjref, "motor_lin_max_impulse", Py_BuildValue("f", value));
	}

	/** Getter: Target angular motor velocity */
	float motor_ang_target_velocity() { /* not implemented */ throw NULL; }
	/** Setter: Target angular motor velocity */
	void motor_ang_target_velocity(float value) {
		PyObject_SetAttrString(pyobjref, "motor_ang_target_velocity", Py_BuildValue("f", value));
	}

	/** Getter: Maximum angular motor impulse */
	float motor_ang_max_impulse() { /* not implemented */ throw NULL; }
	/** Setter: Maximum angular motor impulse */
	void motor_ang_max_impulse(float value) {
		PyObject_SetAttrString(pyobjref, "motor_ang_max_impulse", Py_BuildValue("f", value));
	}

};

/**************** Scene ****************/

/**
 * Scene data block, consisting in objects and defining time and render related settings
 */
class Scene : public ID {
public:
	Scene(PyObject* pyobj) : ID(pyobj) {}

	Scene() : ID(0)
	{
		// not implemented
	}

	/** Getter: Active camera, used for rendering the scene */
	Object camera() {
		/* not implemented */ throw NULL;
	}

	/** Getter: Background set scene */
	Scene background_set() {
		/* not implemented */ throw NULL;
	}

	/** Getter: World used for rendering the scene */
	World world();

	/** Getter: 3D cursor location */
	std::array<float, 3> cursor_location() {
		// TODO: MISSING DEREF! USE #DEFINE!
		PyObject *seqval = PyObject_GetAttrString(pyobjref, "cursor_location");
		std::array<float, 3> resarr;
		for (int i = 0; i < 3; i++)
			resarr[i] = (float)PyFloat_AsDouble(PySequence_GetItem(seqval, i));
		return resarr;
	}

	/** Setter: 3D cursor location */
	void cursor_location(float values[3]) { /* not implemented */ }

	/** Getter:  */
	std::map<std::string, ObjectBase> object_bases() {
		// TODO: MISSING DEREF! USE #DEFINE!
		PyObject *seqval = PyObject_GetAttrString(pyobjref, "object_bases");
		PyObject *seqkeys = PyObject_CallMethod(seqval, "keys", NULL);
		std::map<std::string, ObjectBase> resmap;
		for (int i = 0; i < PySequence_Length(seqval); i++) {
			PyObject *keyobj = PySequence_GetItem(seqkeys, i);
			std::string key = PyBytes_AsString(PyUnicode_AsASCIIString(keyobj));
			ObjectBase value = ObjectBase(PySequence_GetItem(seqval, i));
			resmap.insert(std::pair<std::string,ObjectBase>(key, value));
		}
		return resmap;
	}

	/** Setter:  */
	void object_bases(std::map<std::string, ObjectBase> value) { /* not implemented */ }

	/** Getter:  */
	std::map<std::string, Object> objects() {
		// TODO: MISSING DEREF! USE #DEFINE!
		PyObject *seqval = PyObject_GetAttrString(pyobjref, "objects");
		PyObject *seqkeys = PyObject_CallMethod(seqval, "keys", NULL);
		std::map<std::string, Object> resmap;
		for (int i = 0; i < PySequence_Length(seqval); i++) {
			PyObject *keyobj = PySequence_GetItem(seqkeys, i);
			std::string key = PyBytes_AsString(PyUnicode_AsASCIIString(keyobj));
			Object value = Object(PySequence_GetItem(seqval, i));
			resmap.insert(std::pair<std::string,Object>(key, value));
		}
		return resmap;
	}

	/** Setter:  */
	void objects(std::map<std::string, Object> value) { /* not implemented */ }

	/** Getter: Visible layers - Shift-Click/Drag to select multiple layers */
	std::array<bool, 20> layers() {
		// TODO: MISSING DEREF! USE #DEFINE!
		PyObject *seqval = PyObject_GetAttrString(pyobjref, "layers");
		std::array<bool, 20> resarr;
		for (int i = 0; i < 20; i++)
			resarr[i] = PyLong_AsLong(PySequence_GetItem(seqval, i)) == 1;
		return resarr;
	}

	/** Setter: Visible layers - Shift-Click/Drag to select multiple layers */
	void layers(bool values[20]) { /* not implemented */ }

	/** Getter: Active scene layer index */
	int active_layer() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "active_layer"));
	}

	/** Setter: Active scene layer index */
	void active_layer(int value) {
		PyObject_SetAttrString(pyobjref, "active_layer", Py_BuildValue("i", value));
	}

	/** Getter: Current Frame, to update animation data from python frame_set() instead */
	int frame_current() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "frame_current"));
	}

	/** Setter: Current Frame, to update animation data from python frame_set() instead */
	void frame_current(int value) {
		PyObject_SetAttrString(pyobjref, "frame_current", Py_BuildValue("i", value));
	}

	/** Getter:  */
	float frame_subframe() { /* not implemented */ throw NULL; }
	/** Setter:  */
	void frame_subframe(float value) {
		PyObject_SetAttrString(pyobjref, "frame_subframe", Py_BuildValue("f", value));
	}

	/** Getter: First frame of the playback/rendering range */
	int frame_start() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "frame_start"));
	}

	/** Setter: First frame of the playback/rendering range */
	void frame_start(int value) {
		PyObject_SetAttrString(pyobjref, "frame_start", Py_BuildValue("i", value));
	}

	/** Getter: Final frame of the playback/rendering range */
	int frame_end() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "frame_end"));
	}

	/** Setter: Final frame of the playback/rendering range */
	void frame_end(int value) {
		PyObject_SetAttrString(pyobjref, "frame_end", Py_BuildValue("i", value));
	}

	/** Getter: Number of frames to skip forward while rendering/playing back each frame */
	int frame_step() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "frame_step"));
	}

	/** Setter: Number of frames to skip forward while rendering/playing back each frame */
	void frame_step(int value) {
		PyObject_SetAttrString(pyobjref, "frame_step", Py_BuildValue("i", value));
	}

	/** Getter: Current frame with subframe and time remapping applied */
	float frame_current_final() { /* not implemented */ throw NULL; }
	/** Setter: Current frame with subframe and time remapping applied */
	void frame_current_final(float value) {
		PyObject_SetAttrString(pyobjref, "frame_current_final", Py_BuildValue("f", value));
	}

	/** Getter: Don't allow frame to be selected with mouse outside of frame range */
	bool lock_frame_selection_to_range() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "lock_frame_selection_to_range")) == 1;
	}

	/** Setter: Don't allow frame to be selected with mouse outside of frame range */
	void lock_frame_selection_to_range(bool value) {
		PyObject_SetAttrString(pyobjref, "lock_frame_selection_to_range", Py_BuildValue("i", value));
	}

	/** Getter: Use an alternative start/end frame range for animation playback and OpenGL renders instead of the Render properties start/end frame range */
	bool use_preview_range() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_preview_range")) == 1;
	}

	/** Setter: Use an alternative start/end frame range for animation playback and OpenGL renders instead of the Render properties start/end frame range */
	void use_preview_range(bool value) {
		PyObject_SetAttrString(pyobjref, "use_preview_range", Py_BuildValue("i", value));
	}

	/** Getter: Alternative start frame for UI playback */
	int frame_preview_start() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "frame_preview_start"));
	}

	/** Setter: Alternative start frame for UI playback */
	void frame_preview_start(int value) {
		PyObject_SetAttrString(pyobjref, "frame_preview_start", Py_BuildValue("i", value));
	}

	/** Getter: Alternative end frame for UI playback */
	int frame_preview_end() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "frame_preview_end"));
	}

	/** Setter: Alternative end frame for UI playback */
	void frame_preview_end(int value) {
		PyObject_SetAttrString(pyobjref, "frame_preview_end", Py_BuildValue("i", value));
	}

	/** Getter: Consider keyframes for active Object and/or its selected bones only (in timeline and when jumping between keyframes) */
	bool show_keys_from_selected_only() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "show_keys_from_selected_only")) == 1;
	}

	/** Setter: Consider keyframes for active Object and/or its selected bones only (in timeline and when jumping between keyframes) */
	void show_keys_from_selected_only(bool value) {
		PyObject_SetAttrString(pyobjref, "show_keys_from_selected_only", Py_BuildValue("i", value));
	}

	/** Getter: User defined note for the render stamping */
	std::string use_stamp_note() { /* not implemented */ throw NULL; }
	/** Setter: User defined note for the render stamping */
	void use_stamp_note(const std::string& value) { /* not implemented */ }

	/** Getter: Animation data for this datablock */
	AnimData animation_data() {
		/* not implemented */ throw NULL;
	}

	/** Getter: Whether there is any action referenced by NLA being edited (strictly read-only) */
	bool is_nla_tweakmode() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "is_nla_tweakmode")) == 1;
	}

	/** Setter: Whether there is any action referenced by NLA being edited (strictly read-only) */
	void is_nla_tweakmode(bool value) {
		PyObject_SetAttrString(pyobjref, "is_nla_tweakmode", Py_BuildValue("i", value));
	}

	/** Getter: Play back dropping frames if frame display is too slow */
	bool use_frame_drop() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_frame_drop")) == 1;
	}

	/** Setter: Play back dropping frames if frame display is too slow */
	void use_frame_drop(bool value) {
		PyObject_SetAttrString(pyobjref, "use_frame_drop", Py_BuildValue("i", value));
	}

	enum sync_mode_enum {
		sync_mode_NONE = 0,
		sync_mode_FRAME_DROP = 8,
		sync_mode_AUDIO_SYNC = 2,
	};

	/** Getter: How to sync playback */
	sync_mode_enum sync_mode() { /* not implemented */ throw NULL; }
	/** Setter: How to sync playback */
	void sync_mode(sync_mode_enum value) { /* not implemented */ }

	/** Getter: Compositing node tree */
	NodeTree node_tree() {
		/* not implemented */ throw NULL;
	}

	/** Getter: Enable the compositing node tree */
	bool use_nodes() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_nodes")) == 1;
	}

	/** Setter: Enable the compositing node tree */
	void use_nodes(bool value) {
		PyObject_SetAttrString(pyobjref, "use_nodes", Py_BuildValue("i", value));
	}

	/** Getter:  */
	SequenceEditor sequence_editor();

	/** Getter: Absolute Keying Sets for this Scene */
	std::map<std::string, KeyingSet> keying_sets() {
		// TODO: MISSING DEREF! USE #DEFINE!
		PyObject *seqval = PyObject_GetAttrString(pyobjref, "keying_sets");
		PyObject *seqkeys = PyObject_CallMethod(seqval, "keys", NULL);
		std::map<std::string, KeyingSet> resmap;
		for (int i = 0; i < PySequence_Length(seqval); i++) {
			PyObject *keyobj = PySequence_GetItem(seqkeys, i);
			std::string key = PyBytes_AsString(PyUnicode_AsASCIIString(keyobj));
			KeyingSet value = KeyingSet(PySequence_GetItem(seqval, i));
			resmap.insert(std::pair<std::string,KeyingSet>(key, value));
		}
		return resmap;
	}

	/** Setter: Absolute Keying Sets for this Scene */
	void keying_sets(std::map<std::string, KeyingSet> value) { /* not implemented */ }

	/** Getter: All Keying Sets available for use (Builtins and Absolute Keying Sets for this Scene) */
	std::map<std::string, KeyingSet> keying_sets_all() {
		// TODO: MISSING DEREF! USE #DEFINE!
		PyObject *seqval = PyObject_GetAttrString(pyobjref, "keying_sets_all");
		PyObject *seqkeys = PyObject_CallMethod(seqval, "keys", NULL);
		std::map<std::string, KeyingSet> resmap;
		for (int i = 0; i < PySequence_Length(seqval); i++) {
			PyObject *keyobj = PySequence_GetItem(seqkeys, i);
			std::string key = PyBytes_AsString(PyUnicode_AsASCIIString(keyobj));
			KeyingSet value = KeyingSet(PySequence_GetItem(seqval, i));
			resmap.insert(std::pair<std::string,KeyingSet>(key, value));
		}
		return resmap;
	}

	/** Setter: All Keying Sets available for use (Builtins and Absolute Keying Sets for this Scene) */
	void keying_sets_all(std::map<std::string, KeyingSet> value) { /* not implemented */ }

	/** Getter:  */
	RigidBodyWorld rigidbody_world() {
		/* not implemented */ throw NULL;
	}

	/** Getter:  */
	ToolSettings tool_settings();

	/** Getter: Unit editing settings */
	UnitSettings unit_settings();

	/** Getter: Constant acceleration in a given direction */
	std::array<float, 3> gravity() {
		// TODO: MISSING DEREF! USE #DEFINE!
		PyObject *seqval = PyObject_GetAttrString(pyobjref, "gravity");
		std::array<float, 3> resarr;
		for (int i = 0; i < 3; i++)
			resarr[i] = (float)PyFloat_AsDouble(PySequence_GetItem(seqval, i));
		return resarr;
	}

	/** Setter: Constant acceleration in a given direction */
	void gravity(float values[3]) { /* not implemented */ }

	/** Getter: Use global gravity for all dynamics */
	bool use_gravity() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_gravity")) == 1;
	}

	/** Setter: Use global gravity for all dynamics */
	void use_gravity(bool value) {
		PyObject_SetAttrString(pyobjref, "use_gravity", Py_BuildValue("i", value));
	}

	/** Getter:  */
	RenderSettings render();

	/** Getter:  */
	DisplaySafeAreas safe_areas();

	/** Getter: Markers used in all timelines for the current scene */
	std::map<std::string, TimelineMarker> timeline_markers();
	/** Setter: Markers used in all timelines for the current scene */
	void timeline_markers(std::map<std::string, TimelineMarker> value);

	/** Getter: Play back of audio from Sequence Editor will be muted */
	bool use_audio() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_audio")) == 1;
	}

	/** Setter: Play back of audio from Sequence Editor will be muted */
	void use_audio(bool value) {
		PyObject_SetAttrString(pyobjref, "use_audio", Py_BuildValue("i", value));
	}

	/** Getter: Play back and sync with audio clock, dropping frames if frame display is too slow */
	bool use_audio_sync() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_audio_sync")) == 1;
	}

	/** Setter: Play back and sync with audio clock, dropping frames if frame display is too slow */
	void use_audio_sync(bool value) {
		PyObject_SetAttrString(pyobjref, "use_audio_sync", Py_BuildValue("i", value));
	}

	/** Getter: Play audio from Sequence Editor while scrubbing */
	bool use_audio_scrub() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_audio_scrub")) == 1;
	}

	/** Setter: Play audio from Sequence Editor while scrubbing */
	void use_audio_scrub(bool value) {
		PyObject_SetAttrString(pyobjref, "use_audio_scrub", Py_BuildValue("i", value));
	}

	/** Getter: Speed of sound for Doppler effect calculation */
	float audio_doppler_speed() { /* not implemented */ throw NULL; }
	/** Setter: Speed of sound for Doppler effect calculation */
	void audio_doppler_speed(float value) {
		PyObject_SetAttrString(pyobjref, "audio_doppler_speed", Py_BuildValue("f", value));
	}

	/** Getter: Pitch factor for Doppler effect calculation */
	float audio_doppler_factor() { /* not implemented */ throw NULL; }
	/** Setter: Pitch factor for Doppler effect calculation */
	void audio_doppler_factor(float value) {
		PyObject_SetAttrString(pyobjref, "audio_doppler_factor", Py_BuildValue("f", value));
	}

	enum audio_distance_model_enum {
		audio_distance_model_NONE = 0,
		audio_distance_model_INVERSE = 1,
		audio_distance_model_INVERSE_CLAMPED = 2,
		audio_distance_model_LINEAR = 3,
		audio_distance_model_LINEAR_CLAMPED = 4,
		audio_distance_model_EXPONENT = 5,
		audio_distance_model_EXPONENT_CLAMPED = 6,
	};

	/** Getter: Distance model for distance attenuation calculation */
	audio_distance_model_enum audio_distance_model() { /* not implemented */ throw NULL; }
	/** Setter: Distance model for distance attenuation calculation */
	void audio_distance_model(audio_distance_model_enum value) { /* not implemented */ }

	/** Getter: Audio volume */
	float audio_volume() { /* not implemented */ throw NULL; }
	/** Setter: Audio volume */
	void audio_volume(float value) {
		PyObject_SetAttrString(pyobjref, "audio_volume", Py_BuildValue("f", value));
	}

	/** Getter:  */
	SceneGameData game_settings();

	/** Getter: Grease Pencil datablock */
	GreasePencil grease_pencil() {
		/* not implemented */ throw NULL;
	}

	/** Getter:  */
	std::map<std::string, TransformOrientation> orientations();
	/** Setter:  */
	void orientations(std::map<std::string, TransformOrientation> value);

	/** Getter: Active movie clip used for constraints and viewport drawing */
	MovieClip active_clip();

	/** Getter: Color management settings applied on image before saving */
	ColorManagedViewSettings view_settings() {
		/* not implemented */ throw NULL;
	}

	/** Getter: Settings of device saved image would be displayed on */
	ColorManagedDisplaySettings display_settings() {
		/* not implemented */ throw NULL;
	}

	/** Getter: Settings of color space sequencer is working in */
	ColorManagedSequencerColorspaceSettings sequencer_colorspace_settings() {
		/* not implemented */ throw NULL;
	}

	/** Getter: Dependencies in the scene data */
	Depsgraph depsgraph() {
		/* not implemented */ throw NULL;
	}

	/**
	 * Ensure sequence editor is valid in this scene
	 * @return New sequence editor data or NULL
	 */
	SequenceEditor sequence_editor_create();

	/**
	 * Clear sequence editor in this scene
	 */
	void sequence_editor_clear()
	{
		// not implemented
	}

	/**
	 * Function: statistics
	 * @return 
	 */
	const std::string statistics()
	{
		// not implemented
		throw NULL;
	}

	/**
	 * Set scene frame updating all objects immediately
	 * @param Frame number to set
	 * @param Sub-frame time, between 0.0 and 1.0
	 */
	void frame_set(int frame, float subframe = 0.000000f)
	{
		// not implemented
	}

	/**
	 * Update data tagged to be updated from previous access to data or operators
	 */
	void update()
	{
		// not implemented
	}

	/**
	 * Get uv aspect for current object
	 * @param Object
	 * @return aspect
	 */
	std::array<float, 2> uvedit_aspect(Object object_value)
	{
		// not implemented
		throw NULL;
	}

	/**
	 * Container for the output of ray_cast()
	 */
	struct ray_cast_result {
		bool result;
		Object object_value;	/**< Ray cast object */
		float matrix;	/**< Matrix */
		float location;	/**< The hit location of this ray cast */
		float normal;	/**< The face normal at the ray cast hit location */
	};

	/**
	 * Cast a ray onto in object space
	 * @param Param 'start'
	 * @param Param 'end'
	 * @return A ray_cast_result struct containing the output of this function
	 */
	ray_cast_result ray_cast(float start[3], float end[3])
	{
		// not implemented
		return ray_cast_result();
	}

	/**
	 * Export to collada file
	 * @param File path to write Collada file
	 * @param Apply modifiers
	 * @param Modifier resolution for export
	 * @param Export only selected elements
	 * @param Export all children of selected objects (even if not selected)
	 * @param Export related armatures (even if not selected)
	 * @param Export all Shape Keys from Mesh Objects
	 * @param Only export deforming bones with armatures
	 * @param Export only the active UV Layer
	 * @param Export textures assigned to the object UV maps
	 * @param Export textures assigned to the object Materials
	 * @param Copy textures to same folder where the .dae file is exported
	 * @param Keep NGons in Export
	 * @param Instantiate multiple Objects from same Data
	 * @param Sort exported data by Object name
	 * @param Compatibility mode for SL, OpenSim and similar online worlds
	 * @param Transformation type for translation, scale and rotation
	 */
	void collada_export(const std::string filepath, bool apply_modifiers = false, int export_mesh_type = 0, bool selected = false, bool include_children = false, bool include_armatures = false, bool include_shapekeys = false, bool deform_bones_only = false, bool active_uv_only = false, bool include_uv_textures = false, bool include_material_textures = false, bool use_texture_copies = false, bool use_ngons = true, bool use_object_instantiation = true, bool sort_by_name = false, bool open_sim = false, int export_transformation_type = 0)
	{
		// not implemented
	}

};

/**************** Tool Settings ****************/

/**
 * 
 */
class ToolSettings : public pyUniplug {
public:
	ToolSettings(PyObject* pyobj) : pyUniplug(pyobj) {}

	ToolSettings() : pyUniplug(0)
	{
		// not implemented
	}

	/** Getter:  */
	Sculpt sculpt();

	/** Getter: Ensure all bone-deforming vertex groups add up to 1.0 while weight painting */
	bool use_auto_normalize() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_auto_normalize")) == 1;
	}

	/** Setter: Ensure all bone-deforming vertex groups add up to 1.0 while weight painting */
	void use_auto_normalize(bool value) {
		PyObject_SetAttrString(pyobjref, "use_auto_normalize", Py_BuildValue("i", value));
	}

	/** Getter: Paint across all selected bones while weight painting */
	bool use_multipaint() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_multipaint")) == 1;
	}

	/** Setter: Paint across all selected bones while weight painting */
	void use_multipaint(bool value) {
		PyObject_SetAttrString(pyobjref, "use_multipaint", Py_BuildValue("i", value));
	}

	enum vertex_group_user_enum {
		vertex_group_user_NONE = 0,
		vertex_group_user_ACTIVE = 1,
		vertex_group_user_ALL = 2,
	};

	/** Getter: Display unweighted vertices (multi-paint overrides) */
	vertex_group_user_enum vertex_group_user() { /* not implemented */ throw NULL; }
	/** Setter: Display unweighted vertices (multi-paint overrides) */
	void vertex_group_user(vertex_group_user_enum value) { /* not implemented */ }

	enum vertex_group_subset_enum {
		vertex_group_subset_ALL = 0,
		vertex_group_subset_BONE_DEFORM = 3,
		vertex_group_subset_OTHER_DEFORM = 4,
	};

	/** Getter: Filter Vertex groups for Display */
	vertex_group_subset_enum vertex_group_subset() { /* not implemented */ throw NULL; }
	/** Setter: Filter Vertex groups for Display */
	void vertex_group_subset(vertex_group_subset_enum value) { /* not implemented */ }

	/** Getter:  */
	VertexPaint vertex_paint();

	/** Getter:  */
	VertexPaint weight_paint();

	/** Getter:  */
	ImagePaint image_paint();

	/** Getter:  */
	UvSculpt uv_sculpt();

	/** Getter:  */
	ParticleEdit particle_edit();

	/** Getter: Enable brush for UV sculpting */
	bool use_uv_sculpt() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_uv_sculpt")) == 1;
	}

	/** Setter: Enable brush for UV sculpting */
	void use_uv_sculpt(bool value) {
		PyObject_SetAttrString(pyobjref, "use_uv_sculpt", Py_BuildValue("i", value));
	}

	/** Getter: Disable editing of boundary edges */
	bool uv_sculpt_lock_borders() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "uv_sculpt_lock_borders")) == 1;
	}

	/** Setter: Disable editing of boundary edges */
	void uv_sculpt_lock_borders(bool value) {
		PyObject_SetAttrString(pyobjref, "uv_sculpt_lock_borders", Py_BuildValue("i", value));
	}

	/** Getter: Brush operates on all islands */
	bool uv_sculpt_all_islands() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "uv_sculpt_all_islands")) == 1;
	}

	/** Setter: Brush operates on all islands */
	void uv_sculpt_all_islands(bool value) {
		PyObject_SetAttrString(pyobjref, "uv_sculpt_all_islands", Py_BuildValue("i", value));
	}

	enum uv_sculpt_tool_enum {
		uv_sculpt_tool_PINCH = 1,
		uv_sculpt_tool_RELAX = 2,
		uv_sculpt_tool_GRAB = 3,
	};

	/** Getter: Select Tools for the UV sculpt brushes */
	uv_sculpt_tool_enum uv_sculpt_tool() { /* not implemented */ throw NULL; }
	/** Setter: Select Tools for the UV sculpt brushes */
	void uv_sculpt_tool(uv_sculpt_tool_enum value) { /* not implemented */ }

	enum uv_relax_method_enum {
		uv_relax_method_LAPLACIAN = 1,
		uv_relax_method_HC = 2,
	};

	/** Getter: Algorithm used for UV relaxation */
	uv_relax_method_enum uv_relax_method() { /* not implemented */ throw NULL; }
	/** Setter: Algorithm used for UV relaxation */
	void uv_relax_method(uv_relax_method_enum value) { /* not implemented */ }

	enum proportional_edit_enum {
		proportional_edit_DISABLED = 0,
		proportional_edit_ENABLED = 1,
		proportional_edit_PROJECTED = 3,
		proportional_edit_CONNECTED = 2,
	};

	/** Getter: Proportional Editing mode, allows transforms with distance fall-off */
	proportional_edit_enum proportional_edit() { /* not implemented */ throw NULL; }
	/** Setter: Proportional Editing mode, allows transforms with distance fall-off */
	void proportional_edit(proportional_edit_enum value) { /* not implemented */ }

	/** Getter: Proportional editing object mode */
	bool use_proportional_edit_objects() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_proportional_edit_objects")) == 1;
	}

	/** Setter: Proportional editing object mode */
	void use_proportional_edit_objects(bool value) {
		PyObject_SetAttrString(pyobjref, "use_proportional_edit_objects", Py_BuildValue("i", value));
	}

	/** Getter: Proportional editing mask mode */
	bool use_proportional_edit_mask() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_proportional_edit_mask")) == 1;
	}

	/** Setter: Proportional editing mask mode */
	void use_proportional_edit_mask(bool value) {
		PyObject_SetAttrString(pyobjref, "use_proportional_edit_mask", Py_BuildValue("i", value));
	}

	/** Getter: Proportional editing in action editor */
	bool use_proportional_action() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_proportional_action")) == 1;
	}

	/** Setter: Proportional editing in action editor */
	void use_proportional_action(bool value) {
		PyObject_SetAttrString(pyobjref, "use_proportional_action", Py_BuildValue("i", value));
	}

	/** Getter: Proportional editing in FCurve editor */
	bool use_proportional_fcurve() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_proportional_fcurve")) == 1;
	}

	/** Setter: Proportional editing in FCurve editor */
	void use_proportional_fcurve(bool value) {
		PyObject_SetAttrString(pyobjref, "use_proportional_fcurve", Py_BuildValue("i", value));
	}

	/** Getter: Prevent marker editing */
	bool lock_markers() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "lock_markers")) == 1;
	}

	/** Setter: Prevent marker editing */
	void lock_markers(bool value) {
		PyObject_SetAttrString(pyobjref, "lock_markers", Py_BuildValue("i", value));
	}

	enum proportional_edit_falloff_enum {
		proportional_edit_falloff_SMOOTH = 0,
		proportional_edit_falloff_SPHERE = 1,
		proportional_edit_falloff_ROOT = 2,
		proportional_edit_falloff_INVERSE_SQUARE = 7,
		proportional_edit_falloff_SHARP = 3,
		proportional_edit_falloff_LINEAR = 4,
		proportional_edit_falloff_CONSTANT = 5,
		proportional_edit_falloff_RANDOM = 6,
	};

	/** Getter: Falloff type for proportional editing mode */
	proportional_edit_falloff_enum proportional_edit_falloff() { /* not implemented */ throw NULL; }
	/** Setter: Falloff type for proportional editing mode */
	void proportional_edit_falloff(proportional_edit_falloff_enum value) { /* not implemented */ }

	/** Getter: Display size for proportional editing circle */
	float proportional_size() { /* not implemented */ throw NULL; }
	/** Setter: Display size for proportional editing circle */
	void proportional_size(float value) {
		PyObject_SetAttrString(pyobjref, "proportional_size", Py_BuildValue("f", value));
	}

	/** Getter: Display size for normals in the 3D view */
	float normal_size() { /* not implemented */ throw NULL; }
	/** Setter: Display size for normals in the 3D view */
	void normal_size(float value) {
		PyObject_SetAttrString(pyobjref, "normal_size", Py_BuildValue("f", value));
	}

	/** Getter: Limit for removing duplicates and 'Auto Merge' */
	float double_threshold() { /* not implemented */ throw NULL; }
	/** Setter: Limit for removing duplicates and 'Auto Merge' */
	void double_threshold(float value) {
		PyObject_SetAttrString(pyobjref, "double_threshold", Py_BuildValue("f", value));
	}

	/** Getter: Automatically merge vertices moved to the same location */
	bool use_mesh_automerge() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_mesh_automerge")) == 1;
	}

	/** Setter: Automatically merge vertices moved to the same location */
	void use_mesh_automerge(bool value) {
		PyObject_SetAttrString(pyobjref, "use_mesh_automerge", Py_BuildValue("i", value));
	}

	/** Getter: Snap during transform */
	bool use_snap() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_snap")) == 1;
	}

	/** Setter: Snap during transform */
	void use_snap(bool value) {
		PyObject_SetAttrString(pyobjref, "use_snap", Py_BuildValue("i", value));
	}

	/** Getter: Align rotation with the snapping target */
	bool use_snap_align_rotation() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_snap_align_rotation")) == 1;
	}

	/** Setter: Align rotation with the snapping target */
	void use_snap_align_rotation(bool value) {
		PyObject_SetAttrString(pyobjref, "use_snap_align_rotation", Py_BuildValue("i", value));
	}

	enum snap_element_enum {
		snap_element_INCREMENT = 0,
		snap_element_VERTEX = 1,
		snap_element_EDGE = 2,
		snap_element_FACE = 3,
		snap_element_VOLUME = 4,
	};

	/** Getter: Type of element to snap to */
	snap_element_enum snap_element() { /* not implemented */ throw NULL; }
	/** Setter: Type of element to snap to */
	void snap_element(snap_element_enum value) { /* not implemented */ }

	enum snap_node_element_enum {
		snap_node_element_GRID = 8,
		snap_node_element_NODE_X = 5,
		snap_node_element_NODE_Y = 6,
		snap_node_element_NODE_XY = 7,
	};

	/** Getter: Type of element to snap to */
	snap_node_element_enum snap_node_element() { /* not implemented */ throw NULL; }
	/** Setter: Type of element to snap to */
	void snap_node_element(snap_node_element_enum value) { /* not implemented */ }

	enum snap_uv_element_enum {
		snap_uv_element_INCREMENT = 0,
		snap_uv_element_VERTEX = 1,
	};

	/** Getter: Type of element to snap to */
	snap_uv_element_enum snap_uv_element() { /* not implemented */ throw NULL; }
	/** Setter: Type of element to snap to */
	void snap_uv_element(snap_uv_element_enum value) { /* not implemented */ }

	enum snap_target_enum {
		snap_target_CLOSEST = 0,
		snap_target_CENTER = 1,
		snap_target_MEDIAN = 2,
		snap_target_ACTIVE = 3,
	};

	/** Getter: Which part to snap onto the target */
	snap_target_enum snap_target() { /* not implemented */ throw NULL; }
	/** Setter: Which part to snap onto the target */
	void snap_target(snap_target_enum value) { /* not implemented */ }

	/** Getter: Consider objects as whole when finding volume center */
	bool use_snap_peel_object() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_snap_peel_object")) == 1;
	}

	/** Setter: Consider objects as whole when finding volume center */
	void use_snap_peel_object(bool value) {
		PyObject_SetAttrString(pyobjref, "use_snap_peel_object", Py_BuildValue("i", value));
	}

	/** Getter: Project individual elements on the surface of other objects */
	bool use_snap_project() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_snap_project")) == 1;
	}

	/** Setter: Project individual elements on the surface of other objects */
	void use_snap_project(bool value) {
		PyObject_SetAttrString(pyobjref, "use_snap_project", Py_BuildValue("i", value));
	}

	/** Getter: Snap onto itself (editmode) */
	bool use_snap_self() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_snap_self")) == 1;
	}

	/** Setter: Snap onto itself (editmode) */
	void use_snap_self(bool value) {
		PyObject_SetAttrString(pyobjref, "use_snap_self", Py_BuildValue("i", value));
	}

	/** Getter: Allow drawing multiple strokes at a time with Grease Pencil */
	bool use_grease_pencil_sessions() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_grease_pencil_sessions")) == 1;
	}

	/** Setter: Allow drawing multiple strokes at a time with Grease Pencil */
	void use_grease_pencil_sessions(bool value) {
		PyObject_SetAttrString(pyobjref, "use_grease_pencil_sessions", Py_BuildValue("i", value));
	}

	enum grease_pencil_source_enum {
		grease_pencil_source_SCENE = 0,
		grease_pencil_source_OBJECT = 1,
	};

	/** Getter: Datablock where active Grease Pencil data is found from */
	grease_pencil_source_enum grease_pencil_source() { /* not implemented */ throw NULL; }
	/** Setter: Datablock where active Grease Pencil data is found from */
	void grease_pencil_source(grease_pencil_source_enum value) { /* not implemented */ }

	/** Getter: Automatic keyframe insertion for Objects and Bones */
	bool use_keyframe_insert_auto() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_keyframe_insert_auto")) == 1;
	}

	/** Setter: Automatic keyframe insertion for Objects and Bones */
	void use_keyframe_insert_auto(bool value) {
		PyObject_SetAttrString(pyobjref, "use_keyframe_insert_auto", Py_BuildValue("i", value));
	}

	enum auto_keying_mode_enum {
		auto_keying_mode_ADD_REPLACE_KEYS = 2,
		auto_keying_mode_REPLACE_KEYS = 4,
	};

	/** Getter: Mode of automatic keyframe insertion for Objects and Bones */
	auto_keying_mode_enum auto_keying_mode() { /* not implemented */ throw NULL; }
	/** Setter: Mode of automatic keyframe insertion for Objects and Bones */
	void auto_keying_mode(auto_keying_mode_enum value) { /* not implemented */ }

	/** Getter: Add a new NLA Track + Strip for every loop/pass made over the animation to allow non-destructive tweaking */
	bool use_record_with_nla() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_record_with_nla")) == 1;
	}

	/** Setter: Add a new NLA Track + Strip for every loop/pass made over the animation to allow non-destructive tweaking */
	void use_record_with_nla(bool value) {
		PyObject_SetAttrString(pyobjref, "use_record_with_nla", Py_BuildValue("i", value));
	}

	/** Getter: Automatic keyframe insertion using active Keying Set only */
	bool use_keyframe_insert_keyingset() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_keyframe_insert_keyingset")) == 1;
	}

	/** Setter: Automatic keyframe insertion using active Keying Set only */
	void use_keyframe_insert_keyingset(bool value) {
		PyObject_SetAttrString(pyobjref, "use_keyframe_insert_keyingset", Py_BuildValue("i", value));
	}

	enum uv_select_mode_enum {
		uv_select_mode_VERTEX = 1,
		uv_select_mode_EDGE = 2,
		uv_select_mode_FACE = 4,
		uv_select_mode_ISLAND = 8,
	};

	/** Getter: UV selection and display mode */
	uv_select_mode_enum uv_select_mode() { /* not implemented */ throw NULL; }
	/** Setter: UV selection and display mode */
	void uv_select_mode(uv_select_mode_enum value) { /* not implemented */ }

	/** Getter: Keep UV and edit mode mesh selection in sync */
	bool use_uv_select_sync() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_uv_select_sync")) == 1;
	}

	/** Setter: Keep UV and edit mode mesh selection in sync */
	void use_uv_select_sync(bool value) {
		PyObject_SetAttrString(pyobjref, "use_uv_select_sync", Py_BuildValue("i", value));
	}

	/** Getter: Draw only faces with the currently displayed image assigned */
	bool show_uv_local_view() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "show_uv_local_view")) == 1;
	}

	/** Setter: Draw only faces with the currently displayed image assigned */
	void show_uv_local_view(bool value) {
		PyObject_SetAttrString(pyobjref, "show_uv_local_view", Py_BuildValue("i", value));
	}

	/** Getter: Which mesh elements selection works on */
	std::array<bool, 3> mesh_select_mode() {
		// TODO: MISSING DEREF! USE #DEFINE!
		PyObject *seqval = PyObject_GetAttrString(pyobjref, "mesh_select_mode");
		std::array<bool, 3> resarr;
		for (int i = 0; i < 3; i++)
			resarr[i] = PyLong_AsLong(PySequence_GetItem(seqval, i)) == 1;
		return resarr;
	}

	/** Setter: Which mesh elements selection works on */
	void mesh_select_mode(bool values[3]) { /* not implemented */ }

	/** Getter: Weight to assign in vertex groups */
	float vertex_group_weight() { /* not implemented */ throw NULL; }
	/** Setter: Weight to assign in vertex groups */
	void vertex_group_weight(float value) {
		PyObject_SetAttrString(pyobjref, "vertex_group_weight", Py_BuildValue("f", value));
	}

	enum edge_path_mode_enum {
		edge_path_mode_SELECT = 0,
		edge_path_mode_SEAM = 1,
		edge_path_mode_SHARP = 2,
		edge_path_mode_CREASE = 3,
		edge_path_mode_BEVEL = 4,
		edge_path_mode_FREESTYLE = 5,
	};

	/** Getter: The edge flag to tag when selecting the shortest path */
	edge_path_mode_enum edge_path_mode() { /* not implemented */ throw NULL; }
	/** Setter: The edge flag to tag when selecting the shortest path */
	void edge_path_mode(edge_path_mode_enum value) { /* not implemented */ }

	/** Getter: Changing edges seam re-calculates UV unwrap */
	bool edge_path_live_unwrap() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "edge_path_live_unwrap")) == 1;
	}

	/** Setter: Changing edges seam re-calculates UV unwrap */
	void edge_path_live_unwrap(bool value) {
		PyObject_SetAttrString(pyobjref, "edge_path_live_unwrap", Py_BuildValue("i", value));
	}

	/** Getter: Use sketching to create and edit bones */
	bool use_bone_sketching() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_bone_sketching")) == 1;
	}

	/** Setter: Use sketching to create and edit bones */
	void use_bone_sketching(bool value) {
		PyObject_SetAttrString(pyobjref, "use_bone_sketching", Py_BuildValue("i", value));
	}

	/** Getter: Automatically convert and delete on stroke end */
	bool use_etch_quick() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_etch_quick")) == 1;
	}

	/** Setter: Automatically convert and delete on stroke end */
	void use_etch_quick(bool value) {
		PyObject_SetAttrString(pyobjref, "use_etch_quick", Py_BuildValue("i", value));
	}

	/** Getter: Adjust strokes by drawing near them */
	bool use_etch_overdraw() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_etch_overdraw")) == 1;
	}

	/** Setter: Adjust strokes by drawing near them */
	void use_etch_overdraw(bool value) {
		PyObject_SetAttrString(pyobjref, "use_etch_overdraw", Py_BuildValue("i", value));
	}

	/** Getter: Automatically generate values to replace &N and &S suffix placeholders in template names */
	bool use_etch_autoname() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_etch_autoname")) == 1;
	}

	/** Setter: Automatically generate values to replace &N and &S suffix placeholders in template names */
	void use_etch_autoname(bool value) {
		PyObject_SetAttrString(pyobjref, "use_etch_autoname", Py_BuildValue("i", value));
	}

	/** Getter: Text to replace &N with (e.g. 'Finger.&N' -> 'Finger.1' or 'Finger.One') */
	std::string etch_number() { /* not implemented */ throw NULL; }
	/** Setter: Text to replace &N with (e.g. 'Finger.&N' -> 'Finger.1' or 'Finger.One') */
	void etch_number(const std::string& value) { /* not implemented */ }

	/** Getter: Text to replace &S with (e.g. 'Arm.&S' -> 'Arm.R' or 'Arm.Right') */
	std::string etch_side() { /* not implemented */ throw NULL; }
	/** Setter: Text to replace &S with (e.g. 'Arm.&S' -> 'Arm.R' or 'Arm.Right') */
	void etch_side(const std::string& value) { /* not implemented */ }

	/** Getter: Template armature that will be retargeted to the stroke */
	Object etch_template() {
		/* not implemented */ throw NULL;
	}

	/** Getter: Number of bones in the subdivided stroke */
	int etch_subdivision_number() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "etch_subdivision_number"));
	}

	/** Setter: Number of bones in the subdivided stroke */
	void etch_subdivision_number(int value) {
		PyObject_SetAttrString(pyobjref, "etch_subdivision_number", Py_BuildValue("i", value));
	}

	/** Getter: Correlation threshold for number of bones in the subdivided stroke */
	float etch_adaptive_limit() { /* not implemented */ throw NULL; }
	/** Setter: Correlation threshold for number of bones in the subdivided stroke */
	void etch_adaptive_limit(float value) {
		PyObject_SetAttrString(pyobjref, "etch_adaptive_limit", Py_BuildValue("f", value));
	}

	/** Getter: Maximum length of the subdivided bones */
	float etch_length_limit() { /* not implemented */ throw NULL; }
	/** Setter: Maximum length of the subdivided bones */
	void etch_length_limit(float value) {
		PyObject_SetAttrString(pyobjref, "etch_length_limit", Py_BuildValue("f", value));
	}

	enum etch_roll_mode_enum {
		etch_roll_mode_NONE = 0,
		etch_roll_mode_VIEW = 1,
		etch_roll_mode_JOINT = 2,
	};

	/** Getter: Method used to adjust the roll of bones when retargeting */
	etch_roll_mode_enum etch_roll_mode() { /* not implemented */ throw NULL; }
	/** Setter: Method used to adjust the roll of bones when retargeting */
	void etch_roll_mode(etch_roll_mode_enum value) { /* not implemented */ }

	enum etch_convert_mode_enum {
		etch_convert_mode_FIXED = 0,
		etch_convert_mode_LENGTH = 1,
		etch_convert_mode_ADAPTIVE = 2,
		etch_convert_mode_RETARGET = 3,
	};

	/** Getter: Method used to convert stroke to bones */
	etch_convert_mode_enum etch_convert_mode() { /* not implemented */ throw NULL; }
	/** Setter: Method used to convert stroke to bones */
	void etch_convert_mode(etch_convert_mode_enum value) { /* not implemented */ }

	/** Getter: (null) */
	UnifiedPaintSettings unified_paint_settings();

	/** Getter: (null) */
	MeshStatVis statvis();

};

/**************** Unified Paint Settings ****************/

/**
 * Overrides for some of the active brush's settings
 */
class UnifiedPaintSettings : public pyUniplug {
public:
	UnifiedPaintSettings(PyObject* pyobj) : pyUniplug(pyobj) {}

	UnifiedPaintSettings() : pyUniplug(0)
	{
		// not implemented
	}

	/** Getter: Instead of per-brush radius, the radius is shared across brushes */
	bool use_unified_size() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_unified_size")) == 1;
	}

	/** Setter: Instead of per-brush radius, the radius is shared across brushes */
	void use_unified_size(bool value) {
		PyObject_SetAttrString(pyobjref, "use_unified_size", Py_BuildValue("i", value));
	}

	/** Getter: Instead of per-brush strength, the strength is shared across brushes */
	bool use_unified_strength() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_unified_strength")) == 1;
	}

	/** Setter: Instead of per-brush strength, the strength is shared across brushes */
	void use_unified_strength(bool value) {
		PyObject_SetAttrString(pyobjref, "use_unified_strength", Py_BuildValue("i", value));
	}

	/** Getter: Instead of per-brush weight, the weight is shared across brushes */
	bool use_unified_weight() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_unified_weight")) == 1;
	}

	/** Setter: Instead of per-brush weight, the weight is shared across brushes */
	void use_unified_weight(bool value) {
		PyObject_SetAttrString(pyobjref, "use_unified_weight", Py_BuildValue("i", value));
	}

	/** Getter: Instead of per-brush color, the color is shared across brushes */
	bool use_unified_color() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_unified_color")) == 1;
	}

	/** Setter: Instead of per-brush color, the color is shared across brushes */
	void use_unified_color(bool value) {
		PyObject_SetAttrString(pyobjref, "use_unified_color", Py_BuildValue("i", value));
	}

	/** Getter: Radius of the brush */
	int size() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "size"));
	}

	/** Setter: Radius of the brush */
	void size(int value) {
		PyObject_SetAttrString(pyobjref, "size", Py_BuildValue("i", value));
	}

	/** Getter: Radius of brush in Blender units */
	float unprojected_radius() { /* not implemented */ throw NULL; }
	/** Setter: Radius of brush in Blender units */
	void unprojected_radius(float value) {
		PyObject_SetAttrString(pyobjref, "unprojected_radius", Py_BuildValue("f", value));
	}

	/** Getter: How powerful the effect of the brush is when applied */
	float strength() { /* not implemented */ throw NULL; }
	/** Setter: How powerful the effect of the brush is when applied */
	void strength(float value) {
		PyObject_SetAttrString(pyobjref, "strength", Py_BuildValue("f", value));
	}

	/** Getter: Weight to assign in vertex groups */
	float weight() { /* not implemented */ throw NULL; }
	/** Setter: Weight to assign in vertex groups */
	void weight(float value) {
		PyObject_SetAttrString(pyobjref, "weight", Py_BuildValue("f", value));
	}

	/** Getter:  */
	std::array<float, 3> color() {
		// TODO: MISSING DEREF! USE #DEFINE!
		PyObject *seqval = PyObject_GetAttrString(pyobjref, "color");
		std::array<float, 3> resarr;
		for (int i = 0; i < 3; i++)
			resarr[i] = (float)PyFloat_AsDouble(PySequence_GetItem(seqval, i));
		return resarr;
	}

	/** Setter:  */
	void color(float values[3]) { /* not implemented */ }

	/** Getter:  */
	std::array<float, 3> secondary_color() {
		// TODO: MISSING DEREF! USE #DEFINE!
		PyObject *seqval = PyObject_GetAttrString(pyobjref, "secondary_color");
		std::array<float, 3> resarr;
		for (int i = 0; i < 3; i++)
			resarr[i] = (float)PyFloat_AsDouble(PySequence_GetItem(seqval, i));
		return resarr;
	}

	/** Setter:  */
	void secondary_color(float values[3]) { /* not implemented */ }

	/** Getter: Enable tablet pressure sensitivity for size */
	bool use_pressure_size() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_pressure_size")) == 1;
	}

	/** Setter: Enable tablet pressure sensitivity for size */
	void use_pressure_size(bool value) {
		PyObject_SetAttrString(pyobjref, "use_pressure_size", Py_BuildValue("i", value));
	}

	/** Getter: Enable tablet pressure sensitivity for strength */
	bool use_pressure_strength() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_pressure_strength")) == 1;
	}

	/** Setter: Enable tablet pressure sensitivity for strength */
	void use_pressure_strength(bool value) {
		PyObject_SetAttrString(pyobjref, "use_pressure_strength", Py_BuildValue("i", value));
	}

	/** Getter: When locked brush stays same size relative to object; when unlocked brush size is given in pixels */
	bool use_locked_size() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_locked_size")) == 1;
	}

	/** Setter: When locked brush stays same size relative to object; when unlocked brush size is given in pixels */
	void use_locked_size(bool value) {
		PyObject_SetAttrString(pyobjref, "use_locked_size", Py_BuildValue("i", value));
	}

};

/**************** Mesh Visualize Statistics ****************/

/**
 * 
 */
class MeshStatVis : public pyUniplug {
public:
	MeshStatVis(PyObject* pyobj) : pyUniplug(pyobj) {}

	MeshStatVis() : pyUniplug(0)
	{
		// not implemented
	}

	enum type_enum {
		type_OVERHANG = 0,
		type_THICKNESS = 1,
		type_INTERSECT = 2,
		type_DISTORT = 3,
		type_SHARP = 4,
	};

	/** Getter: Type of data to visualize/check */
	type_enum type() { /* not implemented */ throw NULL; }
	/** Setter: Type of data to visualize/check */
	void type(type_enum value) { /* not implemented */ }

	/** Getter: Minimum angle to display */
	float overhang_min() { /* not implemented */ throw NULL; }
	/** Setter: Minimum angle to display */
	void overhang_min(float value) {
		PyObject_SetAttrString(pyobjref, "overhang_min", Py_BuildValue("f", value));
	}

	/** Getter: Maximum angle to display */
	float overhang_max() { /* not implemented */ throw NULL; }
	/** Setter: Maximum angle to display */
	void overhang_max(float value) {
		PyObject_SetAttrString(pyobjref, "overhang_max", Py_BuildValue("f", value));
	}

	enum overhang_axis_enum {
		overhang_axis_POS_X = 0,
		overhang_axis_POS_Y = 1,
		overhang_axis_POS_Z = 2,
		overhang_axis_NEG_X = 3,
		overhang_axis_NEG_Y = 4,
		overhang_axis_NEG_Z = 5,
	};

	/** Getter:  */
	overhang_axis_enum overhang_axis() { /* not implemented */ throw NULL; }
	/** Setter:  */
	void overhang_axis(overhang_axis_enum value) { /* not implemented */ }

	/** Getter: Minimum for measuring thickness */
	float thickness_min() { /* not implemented */ throw NULL; }
	/** Setter: Minimum for measuring thickness */
	void thickness_min(float value) {
		PyObject_SetAttrString(pyobjref, "thickness_min", Py_BuildValue("f", value));
	}

	/** Getter: Maximum for measuring thickness */
	float thickness_max() { /* not implemented */ throw NULL; }
	/** Setter: Maximum for measuring thickness */
	void thickness_max(float value) {
		PyObject_SetAttrString(pyobjref, "thickness_max", Py_BuildValue("f", value));
	}

	/** Getter: Number of samples to test per face */
	int thickness_samples() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "thickness_samples"));
	}

	/** Setter: Number of samples to test per face */
	void thickness_samples(int value) {
		PyObject_SetAttrString(pyobjref, "thickness_samples", Py_BuildValue("i", value));
	}

	/** Getter: Minimum angle to display */
	float distort_min() { /* not implemented */ throw NULL; }
	/** Setter: Minimum angle to display */
	void distort_min(float value) {
		PyObject_SetAttrString(pyobjref, "distort_min", Py_BuildValue("f", value));
	}

	/** Getter: Maximum angle to display */
	float distort_max() { /* not implemented */ throw NULL; }
	/** Setter: Maximum angle to display */
	void distort_max(float value) {
		PyObject_SetAttrString(pyobjref, "distort_max", Py_BuildValue("f", value));
	}

	/** Getter: Minimum angle to display */
	float sharp_min() { /* not implemented */ throw NULL; }
	/** Setter: Minimum angle to display */
	void sharp_min(float value) {
		PyObject_SetAttrString(pyobjref, "sharp_min", Py_BuildValue("f", value));
	}

	/** Getter: Maximum angle to display */
	float sharp_max() { /* not implemented */ throw NULL; }
	/** Setter: Maximum angle to display */
	void sharp_max(float value) {
		PyObject_SetAttrString(pyobjref, "sharp_max", Py_BuildValue("f", value));
	}

};

/**************** Unit Settings ****************/

/**
 * 
 */
class UnitSettings : public pyUniplug {
public:
	UnitSettings(PyObject* pyobj) : pyUniplug(pyobj) {}

	UnitSettings() : pyUniplug(0)
	{
		// not implemented
	}

	enum system_enum {
		system_NONE = 0,
		system_METRIC = 1,
		system_IMPERIAL = 2,
	};

	/** Getter: The unit system to use for button display */
	system_enum system() { /* not implemented */ throw NULL; }
	/** Setter: The unit system to use for button display */
	void system(system_enum value) { /* not implemented */ }

	enum system_rotation_enum {
		system_rotation_DEGREES = 0,
		system_rotation_RADIANS = 2,
	};

	/** Getter: Unit to use for displaying/editing rotation values */
	system_rotation_enum system_rotation() { /* not implemented */ throw NULL; }
	/** Setter: Unit to use for displaying/editing rotation values */
	void system_rotation(system_rotation_enum value) { /* not implemented */ }

	/** Getter: Scale to use when converting between blender units and dimensions */
	float scale_length() { /* not implemented */ throw NULL; }
	/** Setter: Scale to use when converting between blender units and dimensions */
	void scale_length(float value) {
		PyObject_SetAttrString(pyobjref, "scale_length", Py_BuildValue("f", value));
	}

	/** Getter: Display units in pairs (e.g. 1m 0cm) */
	bool use_separate() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_separate")) == 1;
	}

	/** Setter: Display units in pairs (e.g. 1m 0cm) */
	void use_separate(bool value) {
		PyObject_SetAttrString(pyobjref, "use_separate", Py_BuildValue("i", value));
	}

};

/**************** Stereo Output ****************/

/**
 * Settings for stereo output
 */
class Stereo3dFormat : public pyUniplug {
public:
	Stereo3dFormat(PyObject* pyobj) : pyUniplug(pyobj) {}

	Stereo3dFormat() : pyUniplug(0)
	{
		// not implemented
	}

	enum display_mode_enum {
		display_mode_ANAGLYPH = 0,
		display_mode_INTERLACE = 1,
		display_mode_SIDEBYSIDE = 3,
		display_mode_TOPBOTTOM = 4,
	};

	/** Getter:  */
	display_mode_enum display_mode() { /* not implemented */ throw NULL; }
	/** Setter:  */
	void display_mode(display_mode_enum value) { /* not implemented */ }

	enum anaglyph_type_enum {
		anaglyph_type_RED_CYAN = 0,
		anaglyph_type_GREEN_MAGENTA = 1,
		anaglyph_type_YELLOW_BLUE = 2,
	};

	/** Getter:  */
	anaglyph_type_enum anaglyph_type() { /* not implemented */ throw NULL; }
	/** Setter:  */
	void anaglyph_type(anaglyph_type_enum value) { /* not implemented */ }

	enum interlace_type_enum {
		interlace_type_ROW_INTERLEAVED = 0,
		interlace_type_COLUMN_INTERLEAVED = 1,
		interlace_type_CHECKERBOARD_INTERLEAVED = 2,
	};

	/** Getter:  */
	interlace_type_enum interlace_type() { /* not implemented */ throw NULL; }
	/** Setter:  */
	void interlace_type(interlace_type_enum value) { /* not implemented */ }

	/** Getter: Swap left and right stereo channels */
	bool use_interlace_swap() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_interlace_swap")) == 1;
	}

	/** Setter: Swap left and right stereo channels */
	void use_interlace_swap(bool value) {
		PyObject_SetAttrString(pyobjref, "use_interlace_swap", Py_BuildValue("i", value));
	}

	/** Getter: Right eye should see left image and vice-versa */
	bool use_sidebyside_crosseyed() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_sidebyside_crosseyed")) == 1;
	}

	/** Setter: Right eye should see left image and vice-versa */
	void use_sidebyside_crosseyed(bool value) {
		PyObject_SetAttrString(pyobjref, "use_sidebyside_crosseyed", Py_BuildValue("i", value));
	}

	/** Getter: Combine both views in a squeezed image */
	bool use_squeezed_frame() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_squeezed_frame")) == 1;
	}

	/** Setter: Combine both views in a squeezed image */
	void use_squeezed_frame(bool value) {
		PyObject_SetAttrString(pyobjref, "use_squeezed_frame", Py_BuildValue("i", value));
	}

};

/**************** Image Format ****************/

/**
 * Settings for image formats
 */
class ImageFormatSettings : public pyUniplug {
public:
	ImageFormatSettings(PyObject* pyobj) : pyUniplug(pyobj) {}

	ImageFormatSettings() : pyUniplug(0)
	{
		// not implemented
	}

	enum file_format_enum {
		file_format_BMP = 20,
		file_format_IRIS = 1,
		file_format_PNG = 17,
		file_format_JPEG = 4,
		file_format_JPEG2000 = 30,
		file_format_TARGA = 0,
		file_format_TARGA_RAW = 14,
		file_format_CINEON = 26,
		file_format_DPX = 27,
		file_format_OPEN_EXR_MULTILAYER = 28,
		file_format_OPEN_EXR = 23,
		file_format_HDR = 21,
		file_format_TIFF = 22,
		file_format_AVI_JPEG = 16,
		file_format_AVI_RAW = 15,
		file_format_FRAMESERVER = 25,
		file_format_H264 = 31,
		file_format_FFMPEG = 24,
		file_format_THEORA = 33,
		file_format_XVID = 32,
	};

	/** Getter: File format to save the rendered images as */
	file_format_enum file_format() { /* not implemented */ throw NULL; }
	/** Setter: File format to save the rendered images as */
	void file_format(file_format_enum value) { /* not implemented */ }

	enum color_mode_enum {
		color_mode_BW = 8,
		color_mode_RGB = 24,
		color_mode_RGBA = 32,
	};

	/** Getter: Choose BW for saving grayscale images, RGB for saving red, green and blue channels, and RGBA for saving red, green, blue and alpha channels */
	color_mode_enum color_mode() { /* not implemented */ throw NULL; }
	/** Setter: Choose BW for saving grayscale images, RGB for saving red, green and blue channels, and RGBA for saving red, green, blue and alpha channels */
	void color_mode(color_mode_enum value) { /* not implemented */ }

	enum color_depth_enum {
		color_depth_8 = 2,
		color_depth_10 = 4,
		color_depth_12 = 8,
		color_depth_16 = 16,
		color_depth_32 = 64,
	};

	/** Getter: Bit depth per channel */
	color_depth_enum color_depth() { /* not implemented */ throw NULL; }
	/** Setter: Bit depth per channel */
	void color_depth(color_depth_enum value) { /* not implemented */ }

	/** Getter: Quality for image formats that support lossy compression */
	int quality() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "quality"));
	}

	/** Setter: Quality for image formats that support lossy compression */
	void quality(int value) {
		PyObject_SetAttrString(pyobjref, "quality", Py_BuildValue("i", value));
	}

	/** Getter: Amount of time to determine best compression: 0 = no compression with fast file output, 100 = maximum lossless compression with slow file output */
	int compression() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "compression"));
	}

	/** Setter: Amount of time to determine best compression: 0 = no compression with fast file output, 100 = maximum lossless compression with slow file output */
	void compression(int value) {
		PyObject_SetAttrString(pyobjref, "compression", Py_BuildValue("i", value));
	}

	/** Getter: Save the z-depth per pixel (32 bit unsigned int z-buffer) */
	bool use_zbuffer() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_zbuffer")) == 1;
	}

	/** Setter: Save the z-depth per pixel (32 bit unsigned int z-buffer) */
	void use_zbuffer(bool value) {
		PyObject_SetAttrString(pyobjref, "use_zbuffer", Py_BuildValue("i", value));
	}

	/** Getter: When rendering animations, save JPG preview images in same directory */
	bool use_preview() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_preview")) == 1;
	}

	/** Setter: When rendering animations, save JPG preview images in same directory */
	void use_preview(bool value) {
		PyObject_SetAttrString(pyobjref, "use_preview", Py_BuildValue("i", value));
	}

	enum exr_codec_enum {
		exr_codec_NONE = 0,
		exr_codec_PXR24 = 1,
		exr_codec_ZIP = 2,
		exr_codec_PIZ = 3,
		exr_codec_RLE = 4,
		exr_codec_ZIPS = 5,
		exr_codec_B44 = 6,
		exr_codec_B44A = 7,
		exr_codec_DWAA = 8,
		exr_codec_DWAB = 9,
	};

	/** Getter: Codec settings for OpenEXR */
	exr_codec_enum exr_codec() { /* not implemented */ throw NULL; }
	/** Setter: Codec settings for OpenEXR */
	void exr_codec(exr_codec_enum value) { /* not implemented */ }

	/** Getter: Save luminance-chrominance-chrominance channels instead of RGB colors */
	bool use_jpeg2k_ycc() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_jpeg2k_ycc")) == 1;
	}

	/** Setter: Save luminance-chrominance-chrominance channels instead of RGB colors */
	void use_jpeg2k_ycc(bool value) {
		PyObject_SetAttrString(pyobjref, "use_jpeg2k_ycc", Py_BuildValue("i", value));
	}

	/** Getter: Use Openjpeg Cinema Preset */
	bool use_jpeg2k_cinema_preset() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_jpeg2k_cinema_preset")) == 1;
	}

	/** Setter: Use Openjpeg Cinema Preset */
	void use_jpeg2k_cinema_preset(bool value) {
		PyObject_SetAttrString(pyobjref, "use_jpeg2k_cinema_preset", Py_BuildValue("i", value));
	}

	/** Getter: Use Openjpeg Cinema Preset (48fps) */
	bool use_jpeg2k_cinema_48() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_jpeg2k_cinema_48")) == 1;
	}

	/** Setter: Use Openjpeg Cinema Preset (48fps) */
	void use_jpeg2k_cinema_48(bool value) {
		PyObject_SetAttrString(pyobjref, "use_jpeg2k_cinema_48", Py_BuildValue("i", value));
	}

	enum jpeg2k_codec_enum {
		jpeg2k_codec_JP2 = 0,
		jpeg2k_codec_J2K = 1,
	};

	/** Getter: Codec settings for Jpek2000 */
	jpeg2k_codec_enum jpeg2k_codec() { /* not implemented */ throw NULL; }
	/** Setter: Codec settings for Jpek2000 */
	void jpeg2k_codec(jpeg2k_codec_enum value) { /* not implemented */ }

	/** Getter: Convert to logarithmic color space */
	bool use_cineon_log() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_cineon_log")) == 1;
	}

	/** Setter: Convert to logarithmic color space */
	void use_cineon_log(bool value) {
		PyObject_SetAttrString(pyobjref, "use_cineon_log", Py_BuildValue("i", value));
	}

	/** Getter: Log conversion reference blackpoint */
	int cineon_black() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "cineon_black"));
	}

	/** Setter: Log conversion reference blackpoint */
	void cineon_black(int value) {
		PyObject_SetAttrString(pyobjref, "cineon_black", Py_BuildValue("i", value));
	}

	/** Getter: Log conversion reference whitepoint */
	int cineon_white() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "cineon_white"));
	}

	/** Setter: Log conversion reference whitepoint */
	void cineon_white(int value) {
		PyObject_SetAttrString(pyobjref, "cineon_white", Py_BuildValue("i", value));
	}

	/** Getter: Log conversion gamma */
	float cineon_gamma() { /* not implemented */ throw NULL; }
	/** Setter: Log conversion gamma */
	void cineon_gamma(float value) {
		PyObject_SetAttrString(pyobjref, "cineon_gamma", Py_BuildValue("f", value));
	}

	enum views_format_enum {
		views_format_INDIVIDUAL = 0,
		views_format_STEREO_3D = 1,
	};

	/** Getter: Format of multiview media */
	views_format_enum views_format() { /* not implemented */ throw NULL; }
	/** Setter: Format of multiview media */
	void views_format(views_format_enum value) { /* not implemented */ }

	/** Getter: Settings for stereo 3d */
	Stereo3dFormat stereo_3d_format() {
		/* not implemented */ throw NULL;
	}

	/** Getter: Color management settings applied on image before saving */
	ColorManagedViewSettings view_settings() {
		/* not implemented */ throw NULL;
	}

	/** Getter: Settings of device saved image would be displayed on */
	ColorManagedDisplaySettings display_settings() {
		/* not implemented */ throw NULL;
	}

};

/**************** Game Data ****************/

/**
 * Game data for a Scene datablock
 */
class SceneGameData : public pyUniplug {
public:
	SceneGameData(PyObject* pyobj) : pyUniplug(pyobj) {}

	SceneGameData() : pyUniplug(0)
	{
		// not implemented
	}

	/** Getter: Number of horizontal pixels in the screen */
	int resolution_x() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "resolution_x"));
	}

	/** Setter: Number of horizontal pixels in the screen */
	void resolution_x(int value) {
		PyObject_SetAttrString(pyobjref, "resolution_x", Py_BuildValue("i", value));
	}

	/** Getter: Number of vertical pixels in the screen */
	int resolution_y() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "resolution_y"));
	}

	/** Setter: Number of vertical pixels in the screen */
	void resolution_y(int value) {
		PyObject_SetAttrString(pyobjref, "resolution_y", Py_BuildValue("i", value));
	}

	enum vsync_enum {
		vsync_OFF = 1,
		vsync_ON = 0,
		vsync_ADAPTIVE = 2,
	};

	/** Getter: Change vsync settings */
	vsync_enum vsync() { /* not implemented */ throw NULL; }
	/** Setter: Change vsync settings */
	void vsync(vsync_enum value) { /* not implemented */ }

	enum samples_enum {
		samples_SAMPLES_0 = 0,
		samples_SAMPLES_2 = 2,
		samples_SAMPLES_4 = 4,
		samples_SAMPLES_8 = 8,
		samples_SAMPLES_16 = 16,
	};

	/** Getter: The number of AA Samples to use for MSAA */
	samples_enum samples() { /* not implemented */ throw NULL; }
	/** Setter: The number of AA Samples to use for MSAA */
	void samples(samples_enum value) { /* not implemented */ }

	/** Getter: Display bit depth of full screen display */
	int depth() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "depth"));
	}

	/** Setter: Display bit depth of full screen display */
	void depth(int value) {
		PyObject_SetAttrString(pyobjref, "depth", Py_BuildValue("i", value));
	}

	enum exit_key_enum {
		exit_key_NONE = 0,
		exit_key_LEFTMOUSE = 1,
		exit_key_MIDDLEMOUSE = 2,
		exit_key_RIGHTMOUSE = 3,
		exit_key_BUTTON4MOUSE = 7,
		exit_key_BUTTON5MOUSE = 8,
		exit_key_BUTTON6MOUSE = 18,
		exit_key_BUTTON7MOUSE = 19,
		exit_key_ACTIONMOUSE = 5,
		exit_key_SELECTMOUSE = 6,
		exit_key_MOUSEMOVE = 4,
		exit_key_INBETWEEN_MOUSEMOVE = 17,
		exit_key_TRACKPADPAN = 14,
		exit_key_TRACKPADZOOM = 15,
		exit_key_MOUSEROTATE = 16,
		exit_key_WHEELUPMOUSE = 10,
		exit_key_WHEELDOWNMOUSE = 11,
		exit_key_WHEELINMOUSE = 12,
		exit_key_WHEELOUTMOUSE = 13,
		exit_key_EVT_TWEAK_L = 20482,
		exit_key_EVT_TWEAK_M = 20483,
		exit_key_EVT_TWEAK_R = 20484,
		exit_key_EVT_TWEAK_A = 20485,
		exit_key_EVT_TWEAK_S = 20486,
		exit_key_A = 97,
		exit_key_B = 98,
		exit_key_C = 99,
		exit_key_D = 100,
		exit_key_E = 101,
		exit_key_F = 102,
		exit_key_G = 103,
		exit_key_H = 104,
		exit_key_I = 105,
		exit_key_J = 106,
		exit_key_K = 107,
		exit_key_L = 108,
		exit_key_M = 109,
		exit_key_N = 110,
		exit_key_O = 111,
		exit_key_P = 112,
		exit_key_Q = 113,
		exit_key_R = 114,
		exit_key_S = 115,
		exit_key_T = 116,
		exit_key_U = 117,
		exit_key_V = 118,
		exit_key_W = 119,
		exit_key_X = 120,
		exit_key_Y = 121,
		exit_key_Z = 122,
		exit_key_ZERO = 48,
		exit_key_ONE = 49,
		exit_key_TWO = 50,
		exit_key_THREE = 51,
		exit_key_FOUR = 52,
		exit_key_FIVE = 53,
		exit_key_SIX = 54,
		exit_key_SEVEN = 55,
		exit_key_EIGHT = 56,
		exit_key_NINE = 57,
		exit_key_LEFT_CTRL = 212,
		exit_key_LEFT_ALT = 213,
		exit_key_LEFT_SHIFT = 217,
		exit_key_RIGHT_ALT = 214,
		exit_key_RIGHT_CTRL = 215,
		exit_key_RIGHT_SHIFT = 216,
		exit_key_OSKEY = 172,
		exit_key_GRLESS = 173,
		exit_key_ESC = 218,
		exit_key_TAB = 219,
		exit_key_RET = 220,
		exit_key_SPACE = 221,
		exit_key_LINE_FEED = 222,
		exit_key_BACK_SPACE = 223,
		exit_key_DEL = 224,
		exit_key_SEMI_COLON = 225,
		exit_key_PERIOD = 226,
		exit_key_COMMA = 227,
		exit_key_QUOTE = 228,
		exit_key_ACCENT_GRAVE = 229,
		exit_key_MINUS = 230,
		exit_key_SLASH = 232,
		exit_key_BACK_SLASH = 233,
		exit_key_EQUAL = 234,
		exit_key_LEFT_BRACKET = 235,
		exit_key_RIGHT_BRACKET = 236,
		exit_key_LEFT_ARROW = 137,
		exit_key_DOWN_ARROW = 138,
		exit_key_RIGHT_ARROW = 139,
		exit_key_UP_ARROW = 140,
		exit_key_NUMPAD_2 = 152,
		exit_key_NUMPAD_4 = 154,
		exit_key_NUMPAD_6 = 156,
		exit_key_NUMPAD_8 = 158,
		exit_key_NUMPAD_1 = 151,
		exit_key_NUMPAD_3 = 153,
		exit_key_NUMPAD_5 = 155,
		exit_key_NUMPAD_7 = 157,
		exit_key_NUMPAD_9 = 159,
		exit_key_NUMPAD_PERIOD = 199,
		exit_key_NUMPAD_SLASH = 161,
		exit_key_NUMPAD_ASTERIX = 160,
		exit_key_NUMPAD_0 = 150,
		exit_key_NUMPAD_MINUS = 162,
		exit_key_NUMPAD_ENTER = 163,
		exit_key_NUMPAD_PLUS = 164,
		exit_key_F1 = 300,
		exit_key_F2 = 301,
		exit_key_F3 = 302,
		exit_key_F4 = 303,
		exit_key_F5 = 304,
		exit_key_F6 = 305,
		exit_key_F7 = 306,
		exit_key_F8 = 307,
		exit_key_F9 = 308,
		exit_key_F10 = 309,
		exit_key_F11 = 310,
		exit_key_F12 = 311,
		exit_key_F13 = 312,
		exit_key_F14 = 313,
		exit_key_F15 = 314,
		exit_key_F16 = 315,
		exit_key_F17 = 316,
		exit_key_F18 = 317,
		exit_key_F19 = 318,
		exit_key_PAUSE = 165,
		exit_key_INSERT = 166,
		exit_key_HOME = 167,
		exit_key_PAGE_UP = 168,
		exit_key_PAGE_DOWN = 169,
		exit_key_END = 170,
		exit_key_MEDIA_PLAY = 174,
		exit_key_MEDIA_STOP = 175,
		exit_key_MEDIA_FIRST = 176,
		exit_key_MEDIA_LAST = 177,
		exit_key_TEXTINPUT = -2,
		exit_key_WINDOW_DEACTIVATE = 260,
		exit_key_TIMER = 272,
		exit_key_TIMER0 = 273,
		exit_key_TIMER1 = 274,
		exit_key_TIMER2 = 275,
		exit_key_TIMER_JOBS = 276,
		exit_key_TIMER_AUTOSAVE = 277,
		exit_key_TIMER_REPORT = 278,
		exit_key_TIMERREGION = 279,
		exit_key_NDOF_MOTION = 400,
		exit_key_NDOF_BUTTON_MENU = 401,
		exit_key_NDOF_BUTTON_FIT = 402,
		exit_key_NDOF_BUTTON_TOP = 403,
		exit_key_NDOF_BUTTON_BOTTOM = 404,
		exit_key_NDOF_BUTTON_LEFT = 405,
		exit_key_NDOF_BUTTON_RIGHT = 406,
		exit_key_NDOF_BUTTON_FRONT = 407,
		exit_key_NDOF_BUTTON_BACK = 408,
		exit_key_NDOF_BUTTON_ISO1 = 409,
		exit_key_NDOF_BUTTON_ISO2 = 410,
		exit_key_NDOF_BUTTON_ROLL_CW = 411,
		exit_key_NDOF_BUTTON_ROLL_CCW = 412,
		exit_key_NDOF_BUTTON_SPIN_CW = 413,
		exit_key_NDOF_BUTTON_SPIN_CCW = 414,
		exit_key_NDOF_BUTTON_TILT_CW = 415,
		exit_key_NDOF_BUTTON_TILT_CCW = 416,
		exit_key_NDOF_BUTTON_ROTATE = 417,
		exit_key_NDOF_BUTTON_PANZOOM = 418,
		exit_key_NDOF_BUTTON_DOMINANT = 419,
		exit_key_NDOF_BUTTON_PLUS = 420,
		exit_key_NDOF_BUTTON_MINUS = 421,
		exit_key_NDOF_BUTTON_ESC = 422,
		exit_key_NDOF_BUTTON_ALT = 423,
		exit_key_NDOF_BUTTON_SHIFT = 424,
		exit_key_NDOF_BUTTON_CTRL = 425,
		exit_key_NDOF_BUTTON_1 = 426,
		exit_key_NDOF_BUTTON_2 = 427,
		exit_key_NDOF_BUTTON_3 = 428,
		exit_key_NDOF_BUTTON_4 = 429,
		exit_key_NDOF_BUTTON_5 = 430,
		exit_key_NDOF_BUTTON_6 = 431,
		exit_key_NDOF_BUTTON_7 = 432,
		exit_key_NDOF_BUTTON_8 = 433,
		exit_key_NDOF_BUTTON_9 = 434,
		exit_key_NDOF_BUTTON_10 = 435,
		exit_key_NDOF_BUTTON_A = 436,
		exit_key_NDOF_BUTTON_B = 437,
		exit_key_NDOF_BUTTON_C = 438,
	};

	/** Getter: The key that exits the Game Engine */
	exit_key_enum exit_key() { /* not implemented */ throw NULL; }
	/** Setter: The key that exits the Game Engine */
	void exit_key(exit_key_enum value) { /* not implemented */ }

	enum raster_storage_enum {
		raster_storage_AUTO = 0,
		raster_storage_IMMEDIATE = 1,
		raster_storage_VERTEX_ARRAY = 2,
	};

	/** Getter: Set the storage mode used by the rasterizer */
	raster_storage_enum raster_storage() { /* not implemented */ throw NULL; }
	/** Setter: Set the storage mode used by the rasterizer */
	void raster_storage(raster_storage_enum value) { /* not implemented */ }

	/** Getter: Display clock frequency of fullscreen display */
	int frequency() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "frequency"));
	}

	/** Setter: Display clock frequency of fullscreen display */
	void frequency(int value) {
		PyObject_SetAttrString(pyobjref, "frequency", Py_BuildValue("i", value));
	}

	/** Getter: Start player in a new fullscreen display */
	bool show_fullscreen() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "show_fullscreen")) == 1;
	}

	/** Setter: Start player in a new fullscreen display */
	void show_fullscreen(bool value) {
		PyObject_SetAttrString(pyobjref, "show_fullscreen", Py_BuildValue("i", value));
	}

	/** Getter: Use the current desktop resolution in fullscreen mode */
	bool use_desktop() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_desktop")) == 1;
	}

	/** Setter: Use the current desktop resolution in fullscreen mode */
	void use_desktop(bool value) {
		PyObject_SetAttrString(pyobjref, "use_desktop", Py_BuildValue("i", value));
	}

	enum frame_type_enum {
		frame_type_LETTERBOX = 0,
		frame_type_EXTEND = 1,
		frame_type_SCALE = 2,
	};

	/** Getter: Select the type of Framing you want */
	frame_type_enum frame_type() { /* not implemented */ throw NULL; }
	/** Setter: Select the type of Framing you want */
	void frame_type(frame_type_enum value) { /* not implemented */ }

	/** Getter: Set color of the bars */
	std::array<float, 3> frame_color() {
		// TODO: MISSING DEREF! USE #DEFINE!
		PyObject *seqval = PyObject_GetAttrString(pyobjref, "frame_color");
		std::array<float, 3> resarr;
		for (int i = 0; i < 3; i++)
			resarr[i] = (float)PyFloat_AsDouble(PySequence_GetItem(seqval, i));
		return resarr;
	}

	/** Setter: Set color of the bars */
	void frame_color(float values[3]) { /* not implemented */ }

	enum stereo_enum {
		stereo_NONE = 1,
		stereo_STEREO = 2,
		stereo_DOME = 3,
	};

	/** Getter:  */
	stereo_enum stereo() { /* not implemented */ throw NULL; }
	/** Setter:  */
	void stereo(stereo_enum value) { /* not implemented */ }

	enum stereo_mode_enum {
		stereo_mode_QUADBUFFERED = 2,
		stereo_mode_ABOVEBELOW = 3,
		stereo_mode_INTERLACED = 4,
		stereo_mode_ANAGLYPH = 5,
		stereo_mode_SIDEBYSIDE = 6,
		stereo_mode_VINTERLACE = 7,
		stereo_mode_3DTVTOPBOTTOM = 9,
	};

	/** Getter: Stereographic techniques */
	stereo_mode_enum stereo_mode() { /* not implemented */ throw NULL; }
	/** Setter: Stereographic techniques */
	void stereo_mode(stereo_mode_enum value) { /* not implemented */ }

	/** Getter: Set the distance between the eyes - the camera focal distance/30 should be fine */
	float stereo_eye_separation() { /* not implemented */ throw NULL; }
	/** Setter: Set the distance between the eyes - the camera focal distance/30 should be fine */
	void stereo_eye_separation(float value) {
		PyObject_SetAttrString(pyobjref, "stereo_eye_separation", Py_BuildValue("f", value));
	}

	enum dome_mode_enum {
		dome_mode_FISHEYE = 1,
		dome_mode_TRUNCATED_FRONT = 2,
		dome_mode_TRUNCATED_REAR = 3,
		dome_mode_ENVMAP = 4,
		dome_mode_PANORAM_SPH = 5,
	};

	/** Getter: Dome physical configurations */
	dome_mode_enum dome_mode() { /* not implemented */ throw NULL; }
	/** Setter: Dome physical configurations */
	void dome_mode(dome_mode_enum value) { /* not implemented */ }

	/** Getter: Tessellation level - check the generated mesh in wireframe mode */
	int dome_tessellation() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "dome_tessellation"));
	}

	/** Setter: Tessellation level - check the generated mesh in wireframe mode */
	void dome_tessellation(int value) {
		PyObject_SetAttrString(pyobjref, "dome_tessellation", Py_BuildValue("i", value));
	}

	/** Getter: Buffer Resolution - decrease it to increase speed */
	float dome_buffer_resolution() { /* not implemented */ throw NULL; }
	/** Setter: Buffer Resolution - decrease it to increase speed */
	void dome_buffer_resolution(float value) {
		PyObject_SetAttrString(pyobjref, "dome_buffer_resolution", Py_BuildValue("f", value));
	}

	/** Getter: Field of View of the Dome - it only works in mode Fisheye and Truncated */
	int dome_angle() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "dome_angle"));
	}

	/** Setter: Field of View of the Dome - it only works in mode Fisheye and Truncated */
	void dome_angle(int value) {
		PyObject_SetAttrString(pyobjref, "dome_angle", Py_BuildValue("i", value));
	}

	/** Getter: Camera rotation in horizontal axis */
	int dome_tilt() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "dome_tilt"));
	}

	/** Setter: Camera rotation in horizontal axis */
	void dome_tilt(int value) {
		PyObject_SetAttrString(pyobjref, "dome_tilt", Py_BuildValue("i", value));
	}

	/** Getter: Custom Warp Mesh data file */
	Text dome_text();

	enum physics_engine_enum {
		physics_engine_NONE = 0,
		physics_engine_BULLET = 5,
	};

	/** Getter: Physics engine used for physics simulation in the game engine */
	physics_engine_enum physics_engine() { /* not implemented */ throw NULL; }
	/** Setter: Physics engine used for physics simulation in the game engine */
	void physics_engine(physics_engine_enum value) { /* not implemented */ }

	/** Getter: Gravitational constant used for physics simulation in the game engine */
	float physics_gravity() { /* not implemented */ throw NULL; }
	/** Setter: Gravitational constant used for physics simulation in the game engine */
	void physics_gravity(float value) {
		PyObject_SetAttrString(pyobjref, "physics_gravity", Py_BuildValue("f", value));
	}

	/** Getter: Size of the occlusion buffer, use higher value for better precision (slower) */
	int occlusion_culling_resolution() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "occlusion_culling_resolution"));
	}

	/** Setter: Size of the occlusion buffer, use higher value for better precision (slower) */
	void occlusion_culling_resolution(int value) {
		PyObject_SetAttrString(pyobjref, "occlusion_culling_resolution", Py_BuildValue("i", value));
	}

	/** Getter: Nominal number of game frames per second (physics fixed timestep = 1/fps, independently of actual frame rate) */
	int fps() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "fps"));
	}

	/** Setter: Nominal number of game frames per second (physics fixed timestep = 1/fps, independently of actual frame rate) */
	void fps(int value) {
		PyObject_SetAttrString(pyobjref, "fps", Py_BuildValue("i", value));
	}

	/** Getter: Maximum number of logic frame per game frame if graphics slows down the game, higher value allows better synchronization with physics */
	int logic_step_max() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "logic_step_max"));
	}

	/** Setter: Maximum number of logic frame per game frame if graphics slows down the game, higher value allows better synchronization with physics */
	void logic_step_max(int value) {
		PyObject_SetAttrString(pyobjref, "logic_step_max", Py_BuildValue("i", value));
	}

	/** Getter: Maximum number of physics step per game frame if graphics slows down the game, higher value allows physics to keep up with realtime */
	int physics_step_max() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "physics_step_max"));
	}

	/** Setter: Maximum number of physics step per game frame if graphics slows down the game, higher value allows physics to keep up with realtime */
	void physics_step_max(int value) {
		PyObject_SetAttrString(pyobjref, "physics_step_max", Py_BuildValue("i", value));
	}

	/** Getter: Number of simulation substep per physic timestep, higher value give better physics precision */
	int physics_step_sub() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "physics_step_sub"));
	}

	/** Setter: Number of simulation substep per physic timestep, higher value give better physics precision */
	void physics_step_sub(int value) {
		PyObject_SetAttrString(pyobjref, "physics_step_sub", Py_BuildValue("i", value));
	}

	/** Getter: Linear velocity that an object must be below before the deactivation timer can start */
	float deactivation_linear_threshold() { /* not implemented */ throw NULL; }
	/** Setter: Linear velocity that an object must be below before the deactivation timer can start */
	void deactivation_linear_threshold(float value) {
		PyObject_SetAttrString(pyobjref, "deactivation_linear_threshold", Py_BuildValue("f", value));
	}

	/** Getter: Angular velocity that an object must be below before the deactivation timer can start */
	float deactivation_angular_threshold() { /* not implemented */ throw NULL; }
	/** Setter: Angular velocity that an object must be below before the deactivation timer can start */
	void deactivation_angular_threshold(float value) {
		PyObject_SetAttrString(pyobjref, "deactivation_angular_threshold", Py_BuildValue("f", value));
	}

	/** Getter: Amount of time (in seconds) after which objects with a velocity less than the given threshold will deactivate (0.0 means no deactivation) */
	float deactivation_time() { /* not implemented */ throw NULL; }
	/** Setter: Amount of time (in seconds) after which objects with a velocity less than the given threshold will deactivate (0.0 means no deactivation) */
	void deactivation_time(float value) {
		PyObject_SetAttrString(pyobjref, "deactivation_time", Py_BuildValue("f", value));
	}

	/** Getter: Use optimized Bullet DBVT tree for view frustum and occlusion culling (more efficient, but it can waste unnecessary CPU if the scene doesn't have occluder objects) */
	bool use_occlusion_culling() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_occlusion_culling")) == 1;
	}

	/** Setter: Use optimized Bullet DBVT tree for view frustum and occlusion culling (more efficient, but it can waste unnecessary CPU if the scene doesn't have occluder objects) */
	void use_occlusion_culling(bool value) {
		PyObject_SetAttrString(pyobjref, "use_occlusion_culling", Py_BuildValue("i", value));
	}

	/** Getter: Activity culling is enabled */
	bool use_activity_culling() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_activity_culling")) == 1;
	}

	/** Setter: Activity culling is enabled */
	void use_activity_culling(bool value) {
		PyObject_SetAttrString(pyobjref, "use_activity_culling", Py_BuildValue("i", value));
	}

	/** Getter: Radius of the activity bubble, in Manhattan length (objects outside the box are activity-culled) */
	float activity_culling_box_radius() { /* not implemented */ throw NULL; }
	/** Setter: Radius of the activity bubble, in Manhattan length (objects outside the box are activity-culled) */
	void activity_culling_box_radius(float value) {
		PyObject_SetAttrString(pyobjref, "activity_culling_box_radius", Py_BuildValue("f", value));
	}

	/** Getter: Show properties marked for debugging while the game runs */
	bool show_debug_properties() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "show_debug_properties")) == 1;
	}

	/** Setter: Show properties marked for debugging while the game runs */
	void show_debug_properties(bool value) {
		PyObject_SetAttrString(pyobjref, "show_debug_properties", Py_BuildValue("i", value));
	}

	/** Getter: Show framerate and profiling information while the game runs */
	bool show_framerate_profile() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "show_framerate_profile")) == 1;
	}

	/** Setter: Show framerate and profiling information while the game runs */
	void show_framerate_profile(bool value) {
		PyObject_SetAttrString(pyobjref, "show_framerate_profile", Py_BuildValue("i", value));
	}

	/** Getter: Show a visualization of physics bounds and interactions */
	bool show_physics_visualization() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "show_physics_visualization")) == 1;
	}

	/** Setter: Show a visualization of physics bounds and interactions */
	void show_physics_visualization(bool value) {
		PyObject_SetAttrString(pyobjref, "show_physics_visualization", Py_BuildValue("i", value));
	}

	/** Getter: Start player with a visible mouse cursor */
	bool show_mouse() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "show_mouse")) == 1;
	}

	/** Setter: Start player with a visible mouse cursor */
	void show_mouse(bool value) {
		PyObject_SetAttrString(pyobjref, "show_mouse", Py_BuildValue("i", value));
	}

	/** Getter: Respect the frame rate from the Physics panel in the world properties rather than rendering as many frames as possible */
	bool use_frame_rate() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_frame_rate")) == 1;
	}

	/** Setter: Respect the frame rate from the Physics panel in the world properties rather than rendering as many frames as possible */
	void use_frame_rate(bool value) {
		PyObject_SetAttrString(pyobjref, "use_frame_rate", Py_BuildValue("i", value));
	}

	/** Getter: Use display lists to speed up rendering by keeping geometry on the GPU */
	bool use_display_lists() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_display_lists")) == 1;
	}

	/** Setter: Use display lists to speed up rendering by keeping geometry on the GPU */
	void use_display_lists(bool value) {
		PyObject_SetAttrString(pyobjref, "use_display_lists", Py_BuildValue("i", value));
	}

	/** Getter: Print warnings when using deprecated features in the python API */
	bool use_deprecation_warnings() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_deprecation_warnings")) == 1;
	}

	/** Setter: Print warnings when using deprecated features in the python API */
	void use_deprecation_warnings(bool value) {
		PyObject_SetAttrString(pyobjref, "use_deprecation_warnings", Py_BuildValue("i", value));
	}

	/** Getter: Record animation to F-Curves */
	bool use_animation_record() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_animation_record")) == 1;
	}

	/** Setter: Record animation to F-Curves */
	void use_animation_record(bool value) {
		PyObject_SetAttrString(pyobjref, "use_animation_record", Py_BuildValue("i", value));
	}

	/** Getter: Automatically start game at load time */
	bool use_auto_start() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_auto_start")) == 1;
	}

	/** Setter: Automatically start game at load time */
	void use_auto_start(bool value) {
		PyObject_SetAttrString(pyobjref, "use_auto_start", Py_BuildValue("i", value));
	}

	/** Getter: Restrict the number of animation updates to the animation FPS (this is better for performance, but can cause issues with smooth playback) */
	bool use_restrict_animation_updates() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_restrict_animation_updates")) == 1;
	}

	/** Setter: Restrict the number of animation updates to the animation FPS (this is better for performance, but can cause issues with smooth playback) */
	void use_restrict_animation_updates(bool value) {
		PyObject_SetAttrString(pyobjref, "use_restrict_animation_updates", Py_BuildValue("i", value));
	}

	enum material_mode_enum {
		material_mode_MULTITEXTURE = 1,
		material_mode_GLSL = 2,
	};

	/** Getter: Material mode to use for rendering */
	material_mode_enum material_mode() { /* not implemented */ throw NULL; }
	/** Setter: Material mode to use for rendering */
	void material_mode(material_mode_enum value) { /* not implemented */ }

	/** Getter: Use lights for GLSL rendering */
	bool use_glsl_lights() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_glsl_lights")) == 1;
	}

	/** Setter: Use lights for GLSL rendering */
	void use_glsl_lights(bool value) {
		PyObject_SetAttrString(pyobjref, "use_glsl_lights", Py_BuildValue("i", value));
	}

	/** Getter: Use shaders for GLSL rendering */
	bool use_glsl_shaders() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_glsl_shaders")) == 1;
	}

	/** Setter: Use shaders for GLSL rendering */
	void use_glsl_shaders(bool value) {
		PyObject_SetAttrString(pyobjref, "use_glsl_shaders", Py_BuildValue("i", value));
	}

	/** Getter: Use shadows for GLSL rendering */
	bool use_glsl_shadows() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_glsl_shadows")) == 1;
	}

	/** Setter: Use shadows for GLSL rendering */
	void use_glsl_shadows(bool value) {
		PyObject_SetAttrString(pyobjref, "use_glsl_shadows", Py_BuildValue("i", value));
	}

	/** Getter: Use ramps for GLSL rendering */
	bool use_glsl_ramps() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_glsl_ramps")) == 1;
	}

	/** Setter: Use ramps for GLSL rendering */
	void use_glsl_ramps(bool value) {
		PyObject_SetAttrString(pyobjref, "use_glsl_ramps", Py_BuildValue("i", value));
	}

	/** Getter: Use nodes for GLSL rendering */
	bool use_glsl_nodes() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_glsl_nodes")) == 1;
	}

	/** Setter: Use nodes for GLSL rendering */
	void use_glsl_nodes(bool value) {
		PyObject_SetAttrString(pyobjref, "use_glsl_nodes", Py_BuildValue("i", value));
	}

	/** Getter: Use color management for GLSL rendering */
	bool use_glsl_color_management() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_glsl_color_management")) == 1;
	}

	/** Setter: Use color management for GLSL rendering */
	void use_glsl_color_management(bool value) {
		PyObject_SetAttrString(pyobjref, "use_glsl_color_management", Py_BuildValue("i", value));
	}

	/** Getter: Use extra textures like normal or specular maps for GLSL rendering */
	bool use_glsl_extra_textures() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_glsl_extra_textures")) == 1;
	}

	/** Setter: Use extra textures like normal or specular maps for GLSL rendering */
	void use_glsl_extra_textures(bool value) {
		PyObject_SetAttrString(pyobjref, "use_glsl_extra_textures", Py_BuildValue("i", value));
	}

	/** Getter: Cache materials in the converter (this is faster, but can cause problems with older Singletexture and Multitexture games) */
	bool use_material_caching() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_material_caching")) == 1;
	}

	/** Setter: Cache materials in the converter (this is faster, but can cause problems with older Singletexture and Multitexture games) */
	void use_material_caching(bool value) {
		PyObject_SetAttrString(pyobjref, "use_material_caching", Py_BuildValue("i", value));
	}

	enum obstacle_simulation_enum {
		obstacle_simulation_NONE = 0,
		obstacle_simulation_RVO_RAYS = 1,
		obstacle_simulation_RVO_CELLS = 2,
	};

	/** Getter: Simulation used for obstacle avoidance in the game engine */
	obstacle_simulation_enum obstacle_simulation() { /* not implemented */ throw NULL; }
	/** Setter: Simulation used for obstacle avoidance in the game engine */
	void obstacle_simulation(obstacle_simulation_enum value) { /* not implemented */ }

	/** Getter: Max difference in heights of obstacles to enable their interaction */
	float level_height() { /* not implemented */ throw NULL; }
	/** Setter: Max difference in heights of obstacles to enable their interaction */
	void level_height(float value) {
		PyObject_SetAttrString(pyobjref, "level_height", Py_BuildValue("f", value));
	}

	/** Getter: Enable debug visualization for obstacle simulation */
	bool show_obstacle_simulation() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "show_obstacle_simulation")) == 1;
	}

	/** Setter: Enable debug visualization for obstacle simulation */
	void show_obstacle_simulation(bool value) {
		PyObject_SetAttrString(pyobjref, "show_obstacle_simulation", Py_BuildValue("i", value));
	}

	/** Getter:  */
	SceneGameRecastData recast_data();

	/** Getter: Use LoD Hysteresis setting for the scene */
	bool use_scene_hysteresis() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_scene_hysteresis")) == 1;
	}

	/** Setter: Use LoD Hysteresis setting for the scene */
	void use_scene_hysteresis(bool value) {
		PyObject_SetAttrString(pyobjref, "use_scene_hysteresis", Py_BuildValue("i", value));
	}

	/** Getter: Minimum distance change required to transition to the previous level of detail */
	int scene_hysteresis_percentage() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "scene_hysteresis_percentage"));
	}

	/** Setter: Minimum distance change required to transition to the previous level of detail */
	void scene_hysteresis_percentage(int value) {
		PyObject_SetAttrString(pyobjref, "scene_hysteresis_percentage", Py_BuildValue("i", value));
	}

};

/**************** Recast Data ****************/

/**
 * Recast data for a Game datablock
 */
class SceneGameRecastData : public pyUniplug {
public:
	SceneGameRecastData(PyObject* pyobj) : pyUniplug(pyobj) {}

	SceneGameRecastData() : pyUniplug(0)
	{
		// not implemented
	}

	/** Getter: Rasterized cell size */
	float cell_size() { /* not implemented */ throw NULL; }
	/** Setter: Rasterized cell size */
	void cell_size(float value) {
		PyObject_SetAttrString(pyobjref, "cell_size", Py_BuildValue("f", value));
	}

	/** Getter: Rasterized cell height */
	float cell_height() { /* not implemented */ throw NULL; }
	/** Setter: Rasterized cell height */
	void cell_height(float value) {
		PyObject_SetAttrString(pyobjref, "cell_height", Py_BuildValue("f", value));
	}

	/** Getter: Minimum height where the agent can still walk */
	float agent_height() { /* not implemented */ throw NULL; }
	/** Setter: Minimum height where the agent can still walk */
	void agent_height(float value) {
		PyObject_SetAttrString(pyobjref, "agent_height", Py_BuildValue("f", value));
	}

	/** Getter: Radius of the agent */
	float agent_radius() { /* not implemented */ throw NULL; }
	/** Setter: Radius of the agent */
	void agent_radius(float value) {
		PyObject_SetAttrString(pyobjref, "agent_radius", Py_BuildValue("f", value));
	}

	/** Getter: Maximum height between grid cells the agent can climb */
	float climb_max() { /* not implemented */ throw NULL; }
	/** Setter: Maximum height between grid cells the agent can climb */
	void climb_max(float value) {
		PyObject_SetAttrString(pyobjref, "climb_max", Py_BuildValue("f", value));
	}

	/** Getter: Maximum walkable slope angle */
	float slope_max() { /* not implemented */ throw NULL; }
	/** Setter: Maximum walkable slope angle */
	void slope_max(float value) {
		PyObject_SetAttrString(pyobjref, "slope_max", Py_BuildValue("f", value));
	}

	/** Getter: Minimum regions size (smaller regions will be deleted) */
	float region_min_size() { /* not implemented */ throw NULL; }
	/** Setter: Minimum regions size (smaller regions will be deleted) */
	void region_min_size(float value) {
		PyObject_SetAttrString(pyobjref, "region_min_size", Py_BuildValue("f", value));
	}

	/** Getter: Minimum regions size (smaller regions will be merged) */
	float region_merge_size() { /* not implemented */ throw NULL; }
	/** Setter: Minimum regions size (smaller regions will be merged) */
	void region_merge_size(float value) {
		PyObject_SetAttrString(pyobjref, "region_merge_size", Py_BuildValue("f", value));
	}

	/** Getter: Maximum contour edge length */
	float edge_max_len() { /* not implemented */ throw NULL; }
	/** Setter: Maximum contour edge length */
	void edge_max_len(float value) {
		PyObject_SetAttrString(pyobjref, "edge_max_len", Py_BuildValue("f", value));
	}

	/** Getter: Maximum distance error from contour to cells */
	float edge_max_error() { /* not implemented */ throw NULL; }
	/** Setter: Maximum distance error from contour to cells */
	void edge_max_error(float value) {
		PyObject_SetAttrString(pyobjref, "edge_max_error", Py_BuildValue("f", value));
	}

	/** Getter: Max number of vertices per polygon */
	int verts_per_poly() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "verts_per_poly"));
	}

	/** Setter: Max number of vertices per polygon */
	void verts_per_poly(int value) {
		PyObject_SetAttrString(pyobjref, "verts_per_poly", Py_BuildValue("i", value));
	}

	/** Getter: Detail mesh sample spacing */
	float sample_dist() { /* not implemented */ throw NULL; }
	/** Setter: Detail mesh sample spacing */
	void sample_dist(float value) {
		PyObject_SetAttrString(pyobjref, "sample_dist", Py_BuildValue("f", value));
	}

	/** Getter: Detail mesh simplification max sample error */
	float sample_max_error() { /* not implemented */ throw NULL; }
	/** Setter: Detail mesh simplification max sample error */
	void sample_max_error(float value) {
		PyObject_SetAttrString(pyobjref, "sample_max_error", Py_BuildValue("f", value));
	}

};

/**************** TransformOrientation ****************/

/**
 * 
 */
class TransformOrientation : public pyUniplug {
public:
	TransformOrientation(PyObject* pyobj) : pyUniplug(pyobj) {}

	TransformOrientation() : pyUniplug(0)
	{
		// not implemented
	}

	/** Getter:  */
	std::array<float, 9> matrix() {
		// TODO: MISSING DEREF! USE #DEFINE!
		PyObject *seqval = PyObject_GetAttrString(pyobjref, "matrix");
		std::array<float, 9> resarr;
		for (int i = 0; i < 9; i++)
			resarr[i] = (float)PyFloat_AsDouble(PySequence_GetItem(seqval, i));
		return resarr;
	}

	/** Setter:  */
	void matrix(float values[9]) { /* not implemented */ }

	/** Getter: Name of the custom transform orientation */
	std::string name() { /* not implemented */ throw NULL; }
	/** Setter: Name of the custom transform orientation */
	void name(const std::string& value) { /* not implemented */ }

};

/**************** Selected UV Element ****************/

/**
 * 
 */
class SelectedUvElement : public PropertyGroup {
public:
	SelectedUvElement(PyObject* pyobj) : PropertyGroup(pyobj) {}

	SelectedUvElement() : PropertyGroup(0)
	{
		// not implemented
	}

	/** Getter:  */
	int element_index() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "element_index"));
	}

	/** Setter:  */
	void element_index(int value) {
		PyObject_SetAttrString(pyobjref, "element_index", Py_BuildValue("i", value));
	}

	/** Getter:  */
	int face_index() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "face_index"));
	}

	/** Setter:  */
	void face_index(int value) {
		PyObject_SetAttrString(pyobjref, "face_index", Py_BuildValue("i", value));
	}

};

/**************** Safe Areas ****************/

/**
 * Safe Areas used in 3D view and the VSE
 */
class DisplaySafeAreas : public pyUniplug {
public:
	DisplaySafeAreas(PyObject* pyobj) : pyUniplug(pyobj) {}

	DisplaySafeAreas() : pyUniplug(0)
	{
		// not implemented
	}

	/** Getter: Safe area for text and graphics */
	std::array<float, 2> title() {
		// TODO: MISSING DEREF! USE #DEFINE!
		PyObject *seqval = PyObject_GetAttrString(pyobjref, "title");
		std::array<float, 2> resarr;
		for (int i = 0; i < 2; i++)
			resarr[i] = (float)PyFloat_AsDouble(PySequence_GetItem(seqval, i));
		return resarr;
	}

	/** Setter: Safe area for text and graphics */
	void title(float values[2]) { /* not implemented */ }

	/** Getter: Safe area for general elements */
	std::array<float, 2> action() {
		// TODO: MISSING DEREF! USE #DEFINE!
		PyObject *seqval = PyObject_GetAttrString(pyobjref, "action");
		std::array<float, 2> resarr;
		for (int i = 0; i < 2; i++)
			resarr[i] = (float)PyFloat_AsDouble(PySequence_GetItem(seqval, i));
		return resarr;
	}

	/** Setter: Safe area for general elements */
	void action(float values[2]) { /* not implemented */ }

	/** Getter: Safe area for text and graphics in a different aspect ratio */
	std::array<float, 2> title_center() {
		// TODO: MISSING DEREF! USE #DEFINE!
		PyObject *seqval = PyObject_GetAttrString(pyobjref, "title_center");
		std::array<float, 2> resarr;
		for (int i = 0; i < 2; i++)
			resarr[i] = (float)PyFloat_AsDouble(PySequence_GetItem(seqval, i));
		return resarr;
	}

	/** Setter: Safe area for text and graphics in a different aspect ratio */
	void title_center(float values[2]) { /* not implemented */ }

	/** Getter: Safe area for general elements in a different aspect ratio */
	std::array<float, 2> action_center() {
		// TODO: MISSING DEREF! USE #DEFINE!
		PyObject *seqval = PyObject_GetAttrString(pyobjref, "action_center");
		std::array<float, 2> resarr;
		for (int i = 0; i < 2; i++)
			resarr[i] = (float)PyFloat_AsDouble(PySequence_GetItem(seqval, i));
		return resarr;
	}

	/** Setter: Safe area for general elements in a different aspect ratio */
	void action_center(float values[2]) { /* not implemented */ }

};

/**************** FFmpeg Settings ****************/

/**
 * FFmpeg related settings for the scene
 */
class FFmpegSettings : public pyUniplug {
public:
	FFmpegSettings(PyObject* pyobj) : pyUniplug(pyobj) {}

	FFmpegSettings() : pyUniplug(0)
	{
		// not implemented
	}

	enum format_enum {
		format_MPEG1 = 0,
		format_MPEG2 = 1,
		format_MPEG4 = 2,
		format_AVI = 3,
		format_QUICKTIME = 4,
		format_DV = 5,
		format_H264 = 6,
		format_XVID = 7,
		format_OGG = 10,
		format_MKV = 9,
		format_FLASH = 8,
	};

	/** Getter: Output file format */
	format_enum format() { /* not implemented */ throw NULL; }
	/** Setter: Output file format */
	void format(format_enum value) { /* not implemented */ }

	enum codec_enum {
		codec_NONE = 0,
		codec_MPEG1 = 1,
		codec_MPEG2 = 2,
		codec_MPEG4 = 13,
		codec_HUFFYUV = 26,
		codec_DV = 25,
		codec_H264 = 28,
		codec_THEORA = 31,
		codec_FLASH = 22,
		codec_FFV1 = 34,
		codec_QTRLE = 56,
		codec_DNXHD = 100,
		codec_PNG = 62,
	};

	/** Getter: FFmpeg codec to use */
	codec_enum codec() { /* not implemented */ throw NULL; }
	/** Setter: FFmpeg codec to use */
	void codec(codec_enum value) { /* not implemented */ }

	/** Getter: Video bitrate (kb/s) */
	int video_bitrate() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "video_bitrate"));
	}

	/** Setter: Video bitrate (kb/s) */
	void video_bitrate(int value) {
		PyObject_SetAttrString(pyobjref, "video_bitrate", Py_BuildValue("i", value));
	}

	/** Getter: Rate control: min rate (kb/s) */
	int minrate() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "minrate"));
	}

	/** Setter: Rate control: min rate (kb/s) */
	void minrate(int value) {
		PyObject_SetAttrString(pyobjref, "minrate", Py_BuildValue("i", value));
	}

	/** Getter: Rate control: max rate (kb/s) */
	int maxrate() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "maxrate"));
	}

	/** Setter: Rate control: max rate (kb/s) */
	void maxrate(int value) {
		PyObject_SetAttrString(pyobjref, "maxrate", Py_BuildValue("i", value));
	}

	/** Getter: Mux rate (bits/s(!)) */
	int muxrate() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "muxrate"));
	}

	/** Setter: Mux rate (bits/s(!)) */
	void muxrate(int value) {
		PyObject_SetAttrString(pyobjref, "muxrate", Py_BuildValue("i", value));
	}

	/** Getter: Distance between key frames */
	int gopsize() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "gopsize"));
	}

	/** Setter: Distance between key frames */
	void gopsize(int value) {
		PyObject_SetAttrString(pyobjref, "gopsize", Py_BuildValue("i", value));
	}

	/** Getter: Rate control: buffer size (kb) */
	int buffersize() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "buffersize"));
	}

	/** Setter: Rate control: buffer size (kb) */
	void buffersize(int value) {
		PyObject_SetAttrString(pyobjref, "buffersize", Py_BuildValue("i", value));
	}

	/** Getter: Mux packet size (byte) */
	int packetsize() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "packetsize"));
	}

	/** Setter: Mux packet size (byte) */
	void packetsize(int value) {
		PyObject_SetAttrString(pyobjref, "packetsize", Py_BuildValue("i", value));
	}

	/** Getter: Autosplit output at 2GB boundary */
	bool use_autosplit() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_autosplit")) == 1;
	}

	/** Setter: Autosplit output at 2GB boundary */
	void use_autosplit(bool value) {
		PyObject_SetAttrString(pyobjref, "use_autosplit", Py_BuildValue("i", value));
	}

	/** Getter: Use lossless output for video streams */
	bool use_lossless_output() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_lossless_output")) == 1;
	}

	/** Setter: Use lossless output for video streams */
	void use_lossless_output(bool value) {
		PyObject_SetAttrString(pyobjref, "use_lossless_output", Py_BuildValue("i", value));
	}

	enum audio_codec_enum {
		audio_codec_NONE = 0,
		audio_codec_MP2 = 86016,
		audio_codec_MP3 = 86017,
		audio_codec_AC3 = 86019,
		audio_codec_AAC = 86018,
		audio_codec_VORBIS = 86021,
		audio_codec_FLAC = 86028,
		audio_codec_PCM = 65536,
	};

	/** Getter: FFmpeg audio codec to use */
	audio_codec_enum audio_codec() { /* not implemented */ throw NULL; }
	/** Setter: FFmpeg audio codec to use */
	void audio_codec(audio_codec_enum value) { /* not implemented */ }

	/** Getter: Audio bitrate (kb/s) */
	int audio_bitrate() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "audio_bitrate"));
	}

	/** Setter: Audio bitrate (kb/s) */
	void audio_bitrate(int value) {
		PyObject_SetAttrString(pyobjref, "audio_bitrate", Py_BuildValue("i", value));
	}

	/** Getter: Audio volume */
	float audio_volume() { /* not implemented */ throw NULL; }
	/** Setter: Audio volume */
	void audio_volume(float value) {
		PyObject_SetAttrString(pyobjref, "audio_volume", Py_BuildValue("f", value));
	}

	/** Getter: Audio samplerate(samples/s) */
	int audio_mixrate() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "audio_mixrate"));
	}

	/** Setter: Audio samplerate(samples/s) */
	void audio_mixrate(int value) {
		PyObject_SetAttrString(pyobjref, "audio_mixrate", Py_BuildValue("i", value));
	}

	enum audio_channels_enum {
		audio_channels_MONO = 1,
		audio_channels_STEREO = 2,
		audio_channels_SURROUND4 = 4,
		audio_channels_SURROUND51 = 6,
		audio_channels_SURROUND71 = 8,
	};

	/** Getter: Audio channel count */
	audio_channels_enum audio_channels() { /* not implemented */ throw NULL; }
	/** Setter: Audio channel count */
	void audio_channels(audio_channels_enum value) { /* not implemented */ }

};

/**************** Render Data ****************/

/**
 * Rendering settings for a Scene datablock
 */
class RenderSettings : public pyUniplug {
public:
	RenderSettings(PyObject* pyobj) : pyUniplug(pyobj) {}

	RenderSettings() : pyUniplug(0)
	{
		// not implemented
	}

	/** Getter:  */
	ImageFormatSettings image_settings() {
		/* not implemented */ throw NULL;
	}

	/** Getter: Number of horizontal pixels in the rendered image */
	int resolution_x() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "resolution_x"));
	}

	/** Setter: Number of horizontal pixels in the rendered image */
	void resolution_x(int value) {
		PyObject_SetAttrString(pyobjref, "resolution_x", Py_BuildValue("i", value));
	}

	/** Getter: Number of vertical pixels in the rendered image */
	int resolution_y() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "resolution_y"));
	}

	/** Setter: Number of vertical pixels in the rendered image */
	void resolution_y(int value) {
		PyObject_SetAttrString(pyobjref, "resolution_y", Py_BuildValue("i", value));
	}

	/** Getter: Percentage scale for render resolution */
	int resolution_percentage() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "resolution_percentage"));
	}

	/** Setter: Percentage scale for render resolution */
	void resolution_percentage(int value) {
		PyObject_SetAttrString(pyobjref, "resolution_percentage", Py_BuildValue("i", value));
	}

	/** Getter: Horizontal tile size to use while rendering */
	int tile_x() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "tile_x"));
	}

	/** Setter: Horizontal tile size to use while rendering */
	void tile_x(int value) {
		PyObject_SetAttrString(pyobjref, "tile_x", Py_BuildValue("i", value));
	}

	/** Getter: Vertical tile size to use while rendering */
	int tile_y() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "tile_y"));
	}

	/** Setter: Vertical tile size to use while rendering */
	void tile_y(int value) {
		PyObject_SetAttrString(pyobjref, "tile_y", Py_BuildValue("i", value));
	}

	/** Getter: Resolution to start rendering preview at, progressively increasing it to the full viewport size */
	int preview_start_resolution() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "preview_start_resolution"));
	}

	/** Setter: Resolution to start rendering preview at, progressively increasing it to the full viewport size */
	void preview_start_resolution(int value) {
		PyObject_SetAttrString(pyobjref, "preview_start_resolution", Py_BuildValue("i", value));
	}

	/** Getter: Horizontal aspect ratio - for anamorphic or non-square pixel output */
	float pixel_aspect_x() { /* not implemented */ throw NULL; }
	/** Setter: Horizontal aspect ratio - for anamorphic or non-square pixel output */
	void pixel_aspect_x(float value) {
		PyObject_SetAttrString(pyobjref, "pixel_aspect_x", Py_BuildValue("f", value));
	}

	/** Getter: Vertical aspect ratio - for anamorphic or non-square pixel output */
	float pixel_aspect_y() { /* not implemented */ throw NULL; }
	/** Setter: Vertical aspect ratio - for anamorphic or non-square pixel output */
	void pixel_aspect_y(float value) {
		PyObject_SetAttrString(pyobjref, "pixel_aspect_y", Py_BuildValue("f", value));
	}

	/** Getter: FFmpeg related settings for the scene */
	FFmpegSettings ffmpeg() {
		/* not implemented */ throw NULL;
	}

	/** Getter: Framerate, expressed in frames per second */
	int fps() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "fps"));
	}

	/** Setter: Framerate, expressed in frames per second */
	void fps(int value) {
		PyObject_SetAttrString(pyobjref, "fps", Py_BuildValue("i", value));
	}

	/** Getter: Framerate base */
	float fps_base() { /* not implemented */ throw NULL; }
	/** Setter: Framerate base */
	void fps_base(float value) {
		PyObject_SetAttrString(pyobjref, "fps_base", Py_BuildValue("f", value));
	}

	/** Getter: Old mapping value in frames */
	int frame_map_old() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "frame_map_old"));
	}

	/** Setter: Old mapping value in frames */
	void frame_map_old(int value) {
		PyObject_SetAttrString(pyobjref, "frame_map_old", Py_BuildValue("i", value));
	}

	/** Getter: How many frames the Map Old will last */
	int frame_map_new() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "frame_map_new"));
	}

	/** Setter: How many frames the Map Old will last */
	void frame_map_new(int value) {
		PyObject_SetAttrString(pyobjref, "frame_map_new", Py_BuildValue("i", value));
	}

	/** Getter: Amount of dithering noise added to the rendered image to break up banding */
	float dither_intensity() { /* not implemented */ throw NULL; }
	/** Setter: Amount of dithering noise added to the rendered image to break up banding */
	void dither_intensity(float value) {
		PyObject_SetAttrString(pyobjref, "dither_intensity", Py_BuildValue("f", value));
	}

	enum pixel_filter_type_enum {
		pixel_filter_type_BOX = 0,
		pixel_filter_type_TENT = 1,
		pixel_filter_type_QUADRATIC = 2,
		pixel_filter_type_CUBIC = 3,
		pixel_filter_type_CATMULLROM = 4,
		pixel_filter_type_GAUSSIAN = 5,
		pixel_filter_type_MITCHELL = 6,
	};

	/** Getter: Reconstruction filter used for combining anti-aliasing samples */
	pixel_filter_type_enum pixel_filter_type() { /* not implemented */ throw NULL; }
	/** Setter: Reconstruction filter used for combining anti-aliasing samples */
	void pixel_filter_type(pixel_filter_type_enum value) { /* not implemented */ }

	/** Getter: Width over which the reconstruction filter combines samples */
	float filter_size() { /* not implemented */ throw NULL; }
	/** Setter: Width over which the reconstruction filter combines samples */
	void filter_size(float value) {
		PyObject_SetAttrString(pyobjref, "filter_size", Py_BuildValue("f", value));
	}

	enum alpha_mode_enum {
		alpha_mode_SKY = 0,
		alpha_mode_TRANSPARENT = 1,
	};

	/** Getter: Representation of alpha information in the RGBA pixels */
	alpha_mode_enum alpha_mode() { /* not implemented */ throw NULL; }
	/** Setter: Representation of alpha information in the RGBA pixels */
	void alpha_mode(alpha_mode_enum value) { /* not implemented */ }

	enum octree_resolution_enum {
		octree_resolution_64 = 64,
		octree_resolution_128 = 128,
		octree_resolution_256 = 256,
		octree_resolution_512 = 512,
	};

	/** Getter: Resolution of raytrace accelerator, use higher resolutions for larger scenes */
	octree_resolution_enum octree_resolution() { /* not implemented */ throw NULL; }
	/** Setter: Resolution of raytrace accelerator, use higher resolutions for larger scenes */
	void octree_resolution(octree_resolution_enum value) { /* not implemented */ }

	enum raytrace_method_enum {
		raytrace_method_AUTO = 0,
		raytrace_method_OCTREE = 1,
		raytrace_method_VBVH = 3,
		raytrace_method_SIMD_SVBVH = 4,
		raytrace_method_SIMD_QBVH = 5,
	};

	/** Getter: Type of raytrace accelerator structure */
	raytrace_method_enum raytrace_method() { /* not implemented */ throw NULL; }
	/** Setter: Type of raytrace accelerator structure */
	void raytrace_method(raytrace_method_enum value) { /* not implemented */ }

	/** Getter: Instance support leads to effective memory reduction when using duplicates */
	bool use_instances() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_instances")) == 1;
	}

	/** Setter: Instance support leads to effective memory reduction when using duplicates */
	void use_instances(bool value) {
		PyObject_SetAttrString(pyobjref, "use_instances", Py_BuildValue("i", value));
	}

	/** Getter: Vertex coordinates are stored locally on each primitive (increases memory usage, but may have impact on speed) */
	bool use_local_coords() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_local_coords")) == 1;
	}

	/** Setter: Vertex coordinates are stored locally on each primitive (increases memory usage, but may have impact on speed) */
	void use_local_coords(bool value) {
		PyObject_SetAttrString(pyobjref, "use_local_coords", Py_BuildValue("i", value));
	}

	/** Getter: Render and combine multiple samples per pixel to prevent jagged edges */
	bool use_antialiasing() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_antialiasing")) == 1;
	}

	/** Setter: Render and combine multiple samples per pixel to prevent jagged edges */
	void use_antialiasing(bool value) {
		PyObject_SetAttrString(pyobjref, "use_antialiasing", Py_BuildValue("i", value));
	}

	enum antialiasing_samples_enum {
		antialiasing_samples_5 = 5,
		antialiasing_samples_8 = 8,
		antialiasing_samples_11 = 11,
		antialiasing_samples_16 = 16,
	};

	/** Getter: Amount of anti-aliasing samples per pixel */
	antialiasing_samples_enum antialiasing_samples() { /* not implemented */ throw NULL; }
	/** Setter: Amount of anti-aliasing samples per pixel */
	void antialiasing_samples(antialiasing_samples_enum value) { /* not implemented */ }

	/** Getter: Render image to two fields per frame, for interlaced TV output */
	bool use_fields() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_fields")) == 1;
	}

	/** Setter: Render image to two fields per frame, for interlaced TV output */
	void use_fields(bool value) {
		PyObject_SetAttrString(pyobjref, "use_fields", Py_BuildValue("i", value));
	}

	enum field_order_enum {
		field_order_EVEN_FIRST = 0,
		field_order_ODD_FIRST = 8192,
	};

	/** Getter: Order of video fields (select which lines get rendered first, to create smooth motion for TV output) */
	field_order_enum field_order() { /* not implemented */ throw NULL; }
	/** Setter: Order of video fields (select which lines get rendered first, to create smooth motion for TV output) */
	void field_order(field_order_enum value) { /* not implemented */ }

	/** Getter: Disable the time difference between fields */
	bool use_fields_still() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_fields_still")) == 1;
	}

	/** Setter: Disable the time difference between fields */
	void use_fields_still(bool value) {
		PyObject_SetAttrString(pyobjref, "use_fields_still", Py_BuildValue("i", value));
	}

	/** Getter: Calculate shadows while rendering */
	bool use_shadows() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_shadows")) == 1;
	}

	/** Setter: Calculate shadows while rendering */
	void use_shadows(bool value) {
		PyObject_SetAttrString(pyobjref, "use_shadows", Py_BuildValue("i", value));
	}

	/** Getter: Calculate environment maps while rendering */
	bool use_envmaps() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_envmaps")) == 1;
	}

	/** Setter: Calculate environment maps while rendering */
	void use_envmaps(bool value) {
		PyObject_SetAttrString(pyobjref, "use_envmaps", Py_BuildValue("i", value));
	}

	/** Getter: Calculate sub-surface scattering in materials rendering */
	bool use_sss() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_sss")) == 1;
	}

	/** Setter: Calculate sub-surface scattering in materials rendering */
	void use_sss(bool value) {
		PyObject_SetAttrString(pyobjref, "use_sss", Py_BuildValue("i", value));
	}

	/** Getter: Pre-calculate the raytrace accelerator and render raytracing effects */
	bool use_raytrace() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_raytrace")) == 1;
	}

	/** Setter: Pre-calculate the raytrace accelerator and render raytracing effects */
	void use_raytrace(bool value) {
		PyObject_SetAttrString(pyobjref, "use_raytrace", Py_BuildValue("i", value));
	}

	/** Getter: Use textures to affect material properties */
	bool use_textures() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_textures")) == 1;
	}

	/** Setter: Use textures to affect material properties */
	void use_textures(bool value) {
		PyObject_SetAttrString(pyobjref, "use_textures", Py_BuildValue("i", value));
	}

	/** Getter: Create a toon outline around the edges of geometry */
	bool use_edge_enhance() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_edge_enhance")) == 1;
	}

	/** Setter: Create a toon outline around the edges of geometry */
	void use_edge_enhance(bool value) {
		PyObject_SetAttrString(pyobjref, "use_edge_enhance", Py_BuildValue("i", value));
	}

	/** Getter: Threshold for drawing outlines on geometry edges */
	int edge_threshold() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "edge_threshold"));
	}

	/** Setter: Threshold for drawing outlines on geometry edges */
	void edge_threshold(int value) {
		PyObject_SetAttrString(pyobjref, "edge_threshold", Py_BuildValue("i", value));
	}

	/** Getter: Edge color */
	std::array<float, 3> edge_color() {
		// TODO: MISSING DEREF! USE #DEFINE!
		PyObject *seqval = PyObject_GetAttrString(pyobjref, "edge_color");
		std::array<float, 3> resarr;
		for (int i = 0; i < 3; i++)
			resarr[i] = (float)PyFloat_AsDouble(PySequence_GetItem(seqval, i));
		return resarr;
	}

	/** Setter: Edge color */
	void edge_color(float values[3]) { /* not implemented */ }

	/** Getter: Draw stylized strokes using Freestyle */
	bool use_freestyle() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_freestyle")) == 1;
	}

	/** Setter: Draw stylized strokes using Freestyle */
	void use_freestyle(bool value) {
		PyObject_SetAttrString(pyobjref, "use_freestyle", Py_BuildValue("i", value));
	}

	/** Getter: Number of CPU threads to use simultaneously while rendering (for multi-core/CPU systems) */
	int threads() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "threads"));
	}

	/** Setter: Number of CPU threads to use simultaneously while rendering (for multi-core/CPU systems) */
	void threads(int value) {
		PyObject_SetAttrString(pyobjref, "threads", Py_BuildValue("i", value));
	}

	enum threads_mode_enum {
		threads_mode_AUTO = 0,
		threads_mode_FIXED = 524288,
	};

	/** Getter: Determine the amount of render threads used */
	threads_mode_enum threads_mode() { /* not implemented */ throw NULL; }
	/** Setter: Determine the amount of render threads used */
	void threads_mode(threads_mode_enum value) { /* not implemented */ }

	/** Getter: Use multi-sampled 3D scene motion blur */
	bool use_motion_blur() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_motion_blur")) == 1;
	}

	/** Setter: Use multi-sampled 3D scene motion blur */
	void use_motion_blur(bool value) {
		PyObject_SetAttrString(pyobjref, "use_motion_blur", Py_BuildValue("i", value));
	}

	/** Getter: Number of scene samples to take with motion blur */
	int motion_blur_samples() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "motion_blur_samples"));
	}

	/** Setter: Number of scene samples to take with motion blur */
	void motion_blur_samples(int value) {
		PyObject_SetAttrString(pyobjref, "motion_blur_samples", Py_BuildValue("i", value));
	}

	/** Getter: Time taken in frames between shutter open and close */
	float motion_blur_shutter() { /* not implemented */ throw NULL; }
	/** Setter: Time taken in frames between shutter open and close */
	void motion_blur_shutter(float value) {
		PyObject_SetAttrString(pyobjref, "motion_blur_shutter", Py_BuildValue("f", value));
	}

	/** Getter: Render a user-defined border region, within the frame size (note that this disables save_buffers and full_sample) */
	bool use_border() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_border")) == 1;
	}

	/** Setter: Render a user-defined border region, within the frame size (note that this disables save_buffers and full_sample) */
	void use_border(bool value) {
		PyObject_SetAttrString(pyobjref, "use_border", Py_BuildValue("i", value));
	}

	/** Getter: Minimum X value to for the render border */
	float border_min_x() { /* not implemented */ throw NULL; }
	/** Setter: Minimum X value to for the render border */
	void border_min_x(float value) {
		PyObject_SetAttrString(pyobjref, "border_min_x", Py_BuildValue("f", value));
	}

	/** Getter: Minimum Y value for the render border */
	float border_min_y() { /* not implemented */ throw NULL; }
	/** Setter: Minimum Y value for the render border */
	void border_min_y(float value) {
		PyObject_SetAttrString(pyobjref, "border_min_y", Py_BuildValue("f", value));
	}

	/** Getter: Maximum X value for the render border */
	float border_max_x() { /* not implemented */ throw NULL; }
	/** Setter: Maximum X value for the render border */
	void border_max_x(float value) {
		PyObject_SetAttrString(pyobjref, "border_max_x", Py_BuildValue("f", value));
	}

	/** Getter: Maximum Y value for the render border */
	float border_max_y() { /* not implemented */ throw NULL; }
	/** Setter: Maximum Y value for the render border */
	void border_max_y(float value) {
		PyObject_SetAttrString(pyobjref, "border_max_y", Py_BuildValue("f", value));
	}

	/** Getter: Crop the rendered frame to the defined border size */
	bool use_crop_to_border() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_crop_to_border")) == 1;
	}

	/** Setter: Crop the rendered frame to the defined border size */
	void use_crop_to_border(bool value) {
		PyObject_SetAttrString(pyobjref, "use_crop_to_border", Py_BuildValue("i", value));
	}

	/** Getter: Create empty placeholder files while rendering frames (similar to Unix 'touch') */
	bool use_placeholder() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_placeholder")) == 1;
	}

	/** Setter: Create empty placeholder files while rendering frames (similar to Unix 'touch') */
	void use_placeholder(bool value) {
		PyObject_SetAttrString(pyobjref, "use_placeholder", Py_BuildValue("i", value));
	}

	/** Getter: Overwrite existing files while rendering */
	bool use_overwrite() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_overwrite")) == 1;
	}

	/** Setter: Overwrite existing files while rendering */
	void use_overwrite(bool value) {
		PyObject_SetAttrString(pyobjref, "use_overwrite", Py_BuildValue("i", value));
	}

	/** Getter: Process the render result through the compositing pipeline, if compositing nodes are enabled */
	bool use_compositing() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_compositing")) == 1;
	}

	/** Setter: Process the render result through the compositing pipeline, if compositing nodes are enabled */
	void use_compositing(bool value) {
		PyObject_SetAttrString(pyobjref, "use_compositing", Py_BuildValue("i", value));
	}

	/** Getter: Process the render (and composited) result through the video sequence editor pipeline, if sequencer strips exist */
	bool use_sequencer() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_sequencer")) == 1;
	}

	/** Setter: Process the render (and composited) result through the video sequence editor pipeline, if sequencer strips exist */
	void use_sequencer(bool value) {
		PyObject_SetAttrString(pyobjref, "use_sequencer", Py_BuildValue("i", value));
	}

	/** Getter: Add the file format extensions to the rendered file name (eg: filename + .jpg) */
	bool use_file_extension() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_file_extension")) == 1;
	}

	/** Setter: Add the file format extensions to the rendered file name (eg: filename + .jpg) */
	void use_file_extension(bool value) {
		PyObject_SetAttrString(pyobjref, "use_file_extension", Py_BuildValue("i", value));
	}

	/** Getter: The file extension used for saving renders */
	std::string file_extension() { /* not implemented */ throw NULL; }
	/** Setter: The file extension used for saving renders */
	void file_extension(const std::string& value) { /* not implemented */ }

	/** Getter: When true the format is a movie */
	bool is_movie_format() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "is_movie_format")) == 1;
	}

	/** Setter: When true the format is a movie */
	void is_movie_format(bool value) {
		PyObject_SetAttrString(pyobjref, "is_movie_format", Py_BuildValue("i", value));
	}

	/** Getter: Free all image textures from memory after render, to save memory before compositing */
	bool use_free_image_textures() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_free_image_textures")) == 1;
	}

	/** Setter: Free all image textures from memory after render, to save memory before compositing */
	void use_free_image_textures(bool value) {
		PyObject_SetAttrString(pyobjref, "use_free_image_textures", Py_BuildValue("i", value));
	}

	/** Getter: Free Nodes that are not used while compositing, to save memory */
	bool use_free_unused_nodes() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_free_unused_nodes")) == 1;
	}

	/** Setter: Free Nodes that are not used while compositing, to save memory */
	void use_free_unused_nodes(bool value) {
		PyObject_SetAttrString(pyobjref, "use_free_unused_nodes", Py_BuildValue("i", value));
	}

	/** Getter: Save tiles for all RenderLayers and SceneNodes to files in the temp directory (saves memory, required for Full Sample) */
	bool use_save_buffers() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_save_buffers")) == 1;
	}

	/** Setter: Save tiles for all RenderLayers and SceneNodes to files in the temp directory (saves memory, required for Full Sample) */
	void use_save_buffers(bool value) {
		PyObject_SetAttrString(pyobjref, "use_save_buffers", Py_BuildValue("i", value));
	}

	/** Getter: Save for every anti-aliasing sample the entire RenderLayer results (this solves anti-aliasing issues with compositing) */
	bool use_full_sample() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_full_sample")) == 1;
	}

	/** Setter: Save for every anti-aliasing sample the entire RenderLayer results (this solves anti-aliasing issues with compositing) */
	void use_full_sample(bool value) {
		PyObject_SetAttrString(pyobjref, "use_full_sample", Py_BuildValue("i", value));
	}

	enum display_mode_enum {
		display_mode_SCREEN = 0,
		display_mode_AREA = 1,
		display_mode_WINDOW = 2,
		display_mode_NONE = 3,
	};

	/** Getter: Select where rendered images will be displayed */
	display_mode_enum display_mode() { /* not implemented */ throw NULL; }
	/** Setter: Select where rendered images will be displayed */
	void display_mode(display_mode_enum value) { /* not implemented */ }

	/** Getter: Lock interface during rendering in favor of giving more memory to the renderer */
	bool use_lock_interface() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_lock_interface")) == 1;
	}

	/** Setter: Lock interface during rendering in favor of giving more memory to the renderer */
	void use_lock_interface(bool value) {
		PyObject_SetAttrString(pyobjref, "use_lock_interface", Py_BuildValue("i", value));
	}

	/** Getter: Directory/name to save animations, # characters defines the position and length of frame numbers */
	std::string filepath() { /* not implemented */ throw NULL; }
	/** Setter: Directory/name to save animations, # characters defines the position and length of frame numbers */
	void filepath(const std::string& value) { /* not implemented */ }

	/** Getter: Save render cache to EXR files (useful for heavy compositing, Note: affects indirectly rendered scenes) */
	bool use_render_cache() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_render_cache")) == 1;
	}

	/** Setter: Save render cache to EXR files (useful for heavy compositing, Note: affects indirectly rendered scenes) */
	void use_render_cache(bool value) {
		PyObject_SetAttrString(pyobjref, "use_render_cache", Py_BuildValue("i", value));
	}

	enum bake_type_enum {
		bake_type_FULL = 1,
		bake_type_AO = 2,
		bake_type_SHADOW = 6,
		bake_type_NORMALS = 3,
		bake_type_TEXTURE = 4,
		bake_type_DISPLACEMENT = 5,
		bake_type_DERIVATIVE = 13,
		bake_type_VERTEX_COLORS = 14,
		bake_type_EMIT = 12,
		bake_type_ALPHA = 11,
		bake_type_MIRROR_INTENSITY = 10,
		bake_type_MIRROR_COLOR = 9,
		bake_type_SPEC_INTENSITY = 8,
		bake_type_SPEC_COLOR = 7,
	};

	/** Getter: Choose shading information to bake into the image */
	bake_type_enum bake_type() { /* not implemented */ throw NULL; }
	/** Setter: Choose shading information to bake into the image */
	void bake_type(bake_type_enum value) { /* not implemented */ }

	enum bake_normal_space_enum {
		bake_normal_space_CAMERA = 0,
		bake_normal_space_WORLD = 1,
		bake_normal_space_OBJECT = 2,
		bake_normal_space_TANGENT = 3,
	};

	/** Getter: Choose normal space for baking */
	bake_normal_space_enum bake_normal_space() { /* not implemented */ throw NULL; }
	/** Setter: Choose normal space for baking */
	void bake_normal_space(bake_normal_space_enum value) { /* not implemented */ }

	enum bake_quad_split_enum {
		bake_quad_split_AUTO = 0,
		bake_quad_split_FIXED = 1,
		bake_quad_split_FIXED_ALT = 2,
	};

	/** Getter: Choose the method used to split a quad into 2 triangles for baking */
	bake_quad_split_enum bake_quad_split() { /* not implemented */ throw NULL; }
	/** Setter: Choose the method used to split a quad into 2 triangles for baking */
	void bake_quad_split(bake_quad_split_enum value) { /* not implemented */ }

	enum bake_aa_mode_enum {
		bake_aa_mode_5 = 5,
		bake_aa_mode_8 = 8,
		bake_aa_mode_11 = 11,
		bake_aa_mode_16 = 16,
	};

	/** Getter:  */
	bake_aa_mode_enum bake_aa_mode() { /* not implemented */ throw NULL; }
	/** Setter:  */
	void bake_aa_mode(bake_aa_mode_enum value) { /* not implemented */ }

	/** Getter: Bake shading on the surface of selected objects to the active object */
	bool use_bake_selected_to_active() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_bake_selected_to_active")) == 1;
	}

	/** Setter: Bake shading on the surface of selected objects to the active object */
	void use_bake_selected_to_active(bool value) {
		PyObject_SetAttrString(pyobjref, "use_bake_selected_to_active", Py_BuildValue("i", value));
	}

	/** Getter: With displacement normalize to the distance, with ambient occlusion normalize without using material settings */
	bool use_bake_normalize() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_bake_normalize")) == 1;
	}

	/** Setter: With displacement normalize to the distance, with ambient occlusion normalize without using material settings */
	void use_bake_normalize(bool value) {
		PyObject_SetAttrString(pyobjref, "use_bake_normalize", Py_BuildValue("i", value));
	}

	/** Getter: Clear Images before baking */
	bool use_bake_clear() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_bake_clear")) == 1;
	}

	/** Setter: Clear Images before baking */
	void use_bake_clear(bool value) {
		PyObject_SetAttrString(pyobjref, "use_bake_clear", Py_BuildValue("i", value));
	}

	/** Getter: Enables Anti-aliasing */
	bool use_bake_antialiasing() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_bake_antialiasing")) == 1;
	}

	/** Setter: Enables Anti-aliasing */
	void use_bake_antialiasing(bool value) {
		PyObject_SetAttrString(pyobjref, "use_bake_antialiasing", Py_BuildValue("i", value));
	}

	/** Getter: Extends the baked result as a post process filter */
	int bake_margin() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "bake_margin"));
	}

	/** Setter: Extends the baked result as a post process filter */
	void bake_margin(int value) {
		PyObject_SetAttrString(pyobjref, "bake_margin", Py_BuildValue("i", value));
	}

	/** Getter: Maximum distance from active object to other object (in blender units) */
	float bake_distance() { /* not implemented */ throw NULL; }
	/** Setter: Maximum distance from active object to other object (in blender units) */
	void bake_distance(float value) {
		PyObject_SetAttrString(pyobjref, "bake_distance", Py_BuildValue("f", value));
	}

	/** Getter: Bias towards faces further away from the object (in blender units) */
	float bake_bias() { /* not implemented */ throw NULL; }
	/** Setter: Bias towards faces further away from the object (in blender units) */
	void bake_bias(float value) {
		PyObject_SetAttrString(pyobjref, "bake_bias", Py_BuildValue("f", value));
	}

	/** Getter: Bake directly from multires object */
	bool use_bake_multires() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_bake_multires")) == 1;
	}

	/** Setter: Bake directly from multires object */
	void use_bake_multires(bool value) {
		PyObject_SetAttrString(pyobjref, "use_bake_multires", Py_BuildValue("i", value));
	}

	/** Getter: Calculate heights against unsubdivided low resolution mesh */
	bool use_bake_lores_mesh() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_bake_lores_mesh")) == 1;
	}

	/** Setter: Calculate heights against unsubdivided low resolution mesh */
	void use_bake_lores_mesh(bool value) {
		PyObject_SetAttrString(pyobjref, "use_bake_lores_mesh", Py_BuildValue("i", value));
	}

	/** Getter: Number of samples used for ambient occlusion baking from multires */
	int bake_samples() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "bake_samples"));
	}

	/** Setter: Number of samples used for ambient occlusion baking from multires */
	void bake_samples(int value) {
		PyObject_SetAttrString(pyobjref, "bake_samples", Py_BuildValue("i", value));
	}

	/** Getter: Bake to vertex colors instead of to a UV-mapped image */
	bool use_bake_to_vertex_color() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_bake_to_vertex_color")) == 1;
	}

	/** Setter: Bake to vertex colors instead of to a UV-mapped image */
	void use_bake_to_vertex_color(bool value) {
		PyObject_SetAttrString(pyobjref, "use_bake_to_vertex_color", Py_BuildValue("i", value));
	}

	/** Getter: Use a user scale for the derivative map */
	bool use_bake_user_scale() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_bake_user_scale")) == 1;
	}

	/** Setter: Use a user scale for the derivative map */
	void use_bake_user_scale(bool value) {
		PyObject_SetAttrString(pyobjref, "use_bake_user_scale", Py_BuildValue("i", value));
	}

	/** Getter: Instead of automatically normalizing to 0..1, apply a user scale to the derivative map */
	float bake_user_scale() { /* not implemented */ throw NULL; }
	/** Setter: Instead of automatically normalizing to 0..1, apply a user scale to the derivative map */
	void bake_user_scale(float value) {
		PyObject_SetAttrString(pyobjref, "bake_user_scale", Py_BuildValue("f", value));
	}

	/** Getter: Include the rendered frame timecode as HH:MM:SS.FF in image metadata */
	bool use_stamp_time() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_stamp_time")) == 1;
	}

	/** Setter: Include the rendered frame timecode as HH:MM:SS.FF in image metadata */
	void use_stamp_time(bool value) {
		PyObject_SetAttrString(pyobjref, "use_stamp_time", Py_BuildValue("i", value));
	}

	/** Getter: Include the current date in image metadata */
	bool use_stamp_date() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_stamp_date")) == 1;
	}

	/** Setter: Include the current date in image metadata */
	void use_stamp_date(bool value) {
		PyObject_SetAttrString(pyobjref, "use_stamp_date", Py_BuildValue("i", value));
	}

	/** Getter: Include the frame number in image metadata */
	bool use_stamp_frame() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_stamp_frame")) == 1;
	}

	/** Setter: Include the frame number in image metadata */
	void use_stamp_frame(bool value) {
		PyObject_SetAttrString(pyobjref, "use_stamp_frame", Py_BuildValue("i", value));
	}

	/** Getter: Include the name of the active camera in image metadata */
	bool use_stamp_camera() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_stamp_camera")) == 1;
	}

	/** Setter: Include the name of the active camera in image metadata */
	void use_stamp_camera(bool value) {
		PyObject_SetAttrString(pyobjref, "use_stamp_camera", Py_BuildValue("i", value));
	}

	/** Getter: Include the active camera's lens in image metadata */
	bool use_stamp_lens() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_stamp_lens")) == 1;
	}

	/** Setter: Include the active camera's lens in image metadata */
	void use_stamp_lens(bool value) {
		PyObject_SetAttrString(pyobjref, "use_stamp_lens", Py_BuildValue("i", value));
	}

	/** Getter: Include the name of the active scene in image metadata */
	bool use_stamp_scene() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_stamp_scene")) == 1;
	}

	/** Setter: Include the name of the active scene in image metadata */
	void use_stamp_scene(bool value) {
		PyObject_SetAttrString(pyobjref, "use_stamp_scene", Py_BuildValue("i", value));
	}

	/** Getter: Include a custom note in image metadata */
	bool use_stamp_note() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_stamp_note")) == 1;
	}

	/** Setter: Include a custom note in image metadata */
	void use_stamp_note(bool value) {
		PyObject_SetAttrString(pyobjref, "use_stamp_note", Py_BuildValue("i", value));
	}

	/** Getter: Include the name of the last marker in image metadata */
	bool use_stamp_marker() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_stamp_marker")) == 1;
	}

	/** Setter: Include the name of the last marker in image metadata */
	void use_stamp_marker(bool value) {
		PyObject_SetAttrString(pyobjref, "use_stamp_marker", Py_BuildValue("i", value));
	}

	/** Getter: Include the .blend filename in image metadata */
	bool use_stamp_filename() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_stamp_filename")) == 1;
	}

	/** Setter: Include the .blend filename in image metadata */
	void use_stamp_filename(bool value) {
		PyObject_SetAttrString(pyobjref, "use_stamp_filename", Py_BuildValue("i", value));
	}

	/** Getter: Include the name of the foreground sequence strip in image metadata */
	bool use_stamp_sequencer_strip() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_stamp_sequencer_strip")) == 1;
	}

	/** Setter: Include the name of the foreground sequence strip in image metadata */
	void use_stamp_sequencer_strip(bool value) {
		PyObject_SetAttrString(pyobjref, "use_stamp_sequencer_strip", Py_BuildValue("i", value));
	}

	/** Getter: Include the render time in image metadata */
	bool use_stamp_render_time() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_stamp_render_time")) == 1;
	}

	/** Setter: Include the render time in image metadata */
	void use_stamp_render_time(bool value) {
		PyObject_SetAttrString(pyobjref, "use_stamp_render_time", Py_BuildValue("i", value));
	}

	/** Getter: Custom text to appear in the stamp note */
	std::string stamp_note_text() { /* not implemented */ throw NULL; }
	/** Setter: Custom text to appear in the stamp note */
	void stamp_note_text(const std::string& value) { /* not implemented */ }

	/** Getter: Render the stamp info text in the rendered image */
	bool use_stamp() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_stamp")) == 1;
	}

	/** Setter: Render the stamp info text in the rendered image */
	void use_stamp(bool value) {
		PyObject_SetAttrString(pyobjref, "use_stamp", Py_BuildValue("i", value));
	}

	/** Getter: Size of the font used when rendering stamp text */
	int stamp_font_size() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "stamp_font_size"));
	}

	/** Setter: Size of the font used when rendering stamp text */
	void stamp_font_size(int value) {
		PyObject_SetAttrString(pyobjref, "stamp_font_size", Py_BuildValue("i", value));
	}

	/** Getter: Color to use for stamp text */
	std::array<float, 4> stamp_foreground() {
		// TODO: MISSING DEREF! USE #DEFINE!
		PyObject *seqval = PyObject_GetAttrString(pyobjref, "stamp_foreground");
		std::array<float, 4> resarr;
		for (int i = 0; i < 4; i++)
			resarr[i] = (float)PyFloat_AsDouble(PySequence_GetItem(seqval, i));
		return resarr;
	}

	/** Setter: Color to use for stamp text */
	void stamp_foreground(float values[4]) { /* not implemented */ }

	/** Getter: Color to use behind stamp text */
	std::array<float, 4> stamp_background() {
		// TODO: MISSING DEREF! USE #DEFINE!
		PyObject *seqval = PyObject_GetAttrString(pyobjref, "stamp_background");
		std::array<float, 4> resarr;
		for (int i = 0; i < 4; i++)
			resarr[i] = (float)PyFloat_AsDouble(PySequence_GetItem(seqval, i));
		return resarr;
	}

	/** Setter: Color to use behind stamp text */
	void stamp_background(float values[4]) { /* not implemented */ }

	/** Getter:  */
	bool use_sequencer_gl_preview() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_sequencer_gl_preview")) == 1;
	}

	/** Setter:  */
	void use_sequencer_gl_preview(bool value) {
		PyObject_SetAttrString(pyobjref, "use_sequencer_gl_preview", Py_BuildValue("i", value));
	}

	enum sequencer_gl_preview_enum {
		sequencer_gl_preview_BOUNDBOX = 1,
		sequencer_gl_preview_WIREFRAME = 2,
		sequencer_gl_preview_SOLID = 3,
		sequencer_gl_preview_TEXTURED = 5,
		sequencer_gl_preview_MATERIAL = 4,
		sequencer_gl_preview_RENDERED = 6,
	};

	/** Getter: Method to draw in the sequencer view */
	sequencer_gl_preview_enum sequencer_gl_preview() { /* not implemented */ throw NULL; }
	/** Setter: Method to draw in the sequencer view */
	void sequencer_gl_preview(sequencer_gl_preview_enum value) { /* not implemented */ }

	enum sequencer_gl_render_enum {
		sequencer_gl_render_BOUNDBOX = 1,
		sequencer_gl_render_WIREFRAME = 2,
		sequencer_gl_render_SOLID = 3,
		sequencer_gl_render_TEXTURED = 5,
		sequencer_gl_render_MATERIAL = 4,
		sequencer_gl_render_RENDERED = 6,
	};

	/** Getter: Method to draw in the sequencer view */
	sequencer_gl_render_enum sequencer_gl_render() { /* not implemented */ throw NULL; }
	/** Setter: Method to draw in the sequencer view */
	void sequencer_gl_render(sequencer_gl_render_enum value) { /* not implemented */ }

	/** Getter: Draw face-assigned textures in solid draw method */
	bool use_sequencer_gl_textured_solid() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_sequencer_gl_textured_solid")) == 1;
	}

	/** Setter: Draw face-assigned textures in solid draw method */
	void use_sequencer_gl_textured_solid(bool value) {
		PyObject_SetAttrString(pyobjref, "use_sequencer_gl_textured_solid", Py_BuildValue("i", value));
	}

	/** Getter:  */
	std::map<std::string, SceneRenderLayer> layers();
	/** Setter:  */
	void layers(std::map<std::string, SceneRenderLayer> value);

	/** Getter: Only render the active layer */
	bool use_single_layer() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_single_layer")) == 1;
	}

	/** Setter: Only render the active layer */
	void use_single_layer(bool value) {
		PyObject_SetAttrString(pyobjref, "use_single_layer", Py_BuildValue("i", value));
	}

	/** Getter:  */
	std::map<std::string, SceneRenderView> views();
	/** Setter:  */
	void views(std::map<std::string, SceneRenderView> value);

	/** Getter:  */
	std::map<std::string, SceneRenderView> stereo_views();
	/** Setter:  */
	void stereo_views(std::map<std::string, SceneRenderView> value);

	/** Getter: Use multiple views in the scene */
	bool use_multiview() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_multiview")) == 1;
	}

	/** Setter: Use multiple views in the scene */
	void use_multiview(bool value) {
		PyObject_SetAttrString(pyobjref, "use_multiview", Py_BuildValue("i", value));
	}

	enum views_format_enum {
		views_format_STEREO_3D = 0,
		views_format_MULTIVIEW = 1,
	};

	/** Getter:  */
	views_format_enum views_format() { /* not implemented */ throw NULL; }
	/** Setter:  */
	void views_format(views_format_enum value) { /* not implemented */ }

	enum engine_enum {
		engine_BLENDER_RENDER = 0,
	};

	/** Getter: Engine to use for rendering */
	engine_enum engine() { /* not implemented */ throw NULL; }
	/** Setter: Engine to use for rendering */
	void engine(engine_enum value) { /* not implemented */ }

	/** Getter: More than one rendering engine is available */
	bool has_multiple_engines() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "has_multiple_engines")) == 1;
	}

	/** Setter: More than one rendering engine is available */
	void has_multiple_engines(bool value) {
		PyObject_SetAttrString(pyobjref, "has_multiple_engines", Py_BuildValue("i", value));
	}

	/** Getter: Active render engine uses new shading nodes system */
	bool use_shading_nodes() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_shading_nodes")) == 1;
	}

	/** Setter: Active render engine uses new shading nodes system */
	void use_shading_nodes(bool value) {
		PyObject_SetAttrString(pyobjref, "use_shading_nodes", Py_BuildValue("i", value));
	}

	/** Getter: Current rendering engine is a game engine */
	bool use_game_engine() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_game_engine")) == 1;
	}

	/** Setter: Current rendering engine is a game engine */
	void use_game_engine(bool value) {
		PyObject_SetAttrString(pyobjref, "use_game_engine", Py_BuildValue("i", value));
	}

	/** Getter: Enable simplification of scene for quicker preview renders */
	bool use_simplify() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_simplify")) == 1;
	}

	/** Setter: Enable simplification of scene for quicker preview renders */
	void use_simplify(bool value) {
		PyObject_SetAttrString(pyobjref, "use_simplify", Py_BuildValue("i", value));
	}

	/** Getter: Global maximum subdivision level */
	int simplify_subdivision() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "simplify_subdivision"));
	}

	/** Setter: Global maximum subdivision level */
	void simplify_subdivision(int value) {
		PyObject_SetAttrString(pyobjref, "simplify_subdivision", Py_BuildValue("i", value));
	}

	/** Getter: Global child particles percentage */
	float simplify_child_particles() { /* not implemented */ throw NULL; }
	/** Setter: Global child particles percentage */
	void simplify_child_particles(float value) {
		PyObject_SetAttrString(pyobjref, "simplify_child_particles", Py_BuildValue("f", value));
	}

	/** Getter: Global maximum subdivision level during rendering */
	int simplify_subdivision_render() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "simplify_subdivision_render"));
	}

	/** Setter: Global maximum subdivision level during rendering */
	void simplify_subdivision_render(int value) {
		PyObject_SetAttrString(pyobjref, "simplify_subdivision_render", Py_BuildValue("i", value));
	}

	/** Getter: Global child particles percentage during rendering */
	float simplify_child_particles_render() { /* not implemented */ throw NULL; }
	/** Setter: Global child particles percentage during rendering */
	void simplify_child_particles_render(float value) {
		PyObject_SetAttrString(pyobjref, "simplify_child_particles_render", Py_BuildValue("f", value));
	}

	/** Getter: Global maximum shadow samples */
	int simplify_shadow_samples() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "simplify_shadow_samples"));
	}

	/** Setter: Global maximum shadow samples */
	void simplify_shadow_samples(int value) {
		PyObject_SetAttrString(pyobjref, "simplify_shadow_samples", Py_BuildValue("i", value));
	}

	/** Getter: Global approximate AO and SSS quality factor */
	float simplify_ao_sss() { /* not implemented */ throw NULL; }
	/** Setter: Global approximate AO and SSS quality factor */
	void simplify_ao_sss(float value) {
		PyObject_SetAttrString(pyobjref, "simplify_ao_sss", Py_BuildValue("f", value));
	}

	/** Getter: Disable non-planar quads being triangulated */
	bool use_simplify_triangulate() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_simplify_triangulate")) == 1;
	}

	/** Setter: Disable non-planar quads being triangulated */
	void use_simplify_triangulate(bool value) {
		PyObject_SetAttrString(pyobjref, "use_simplify_triangulate", Py_BuildValue("i", value));
	}

	/** Getter: Keep render data around for faster re-renders */
	bool use_persistent_data() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_persistent_data")) == 1;
	}

	/** Setter: Keep render data around for faster re-renders */
	void use_persistent_data(bool value) {
		PyObject_SetAttrString(pyobjref, "use_persistent_data", Py_BuildValue("i", value));
	}

	enum line_thickness_mode_enum {
		line_thickness_mode_ABSOLUTE = 1,
		line_thickness_mode_RELATIVE = 2,
	};

	/** Getter: Line thickness mode for Freestyle line drawing */
	line_thickness_mode_enum line_thickness_mode() { /* not implemented */ throw NULL; }
	/** Setter: Line thickness mode for Freestyle line drawing */
	void line_thickness_mode(line_thickness_mode_enum value) { /* not implemented */ }

	/** Getter: Line thickness in pixels */
	float line_thickness() { /* not implemented */ throw NULL; }
	/** Setter: Line thickness in pixels */
	void line_thickness(float value) {
		PyObject_SetAttrString(pyobjref, "line_thickness", Py_BuildValue("f", value));
	}

	/** Getter:  */
	BakeSettings bake();

	/**
	 * Return the absolute path to the filename to be written for a given frame
	 * @param Frame number to use, if unset the current frame will be used
	 * @param Use preview range
	 * @param The name of the view to use to replace the "%" chars
	 * @return The resulting filepath from the scenes render settings
	 */
	std::string frame_path(int frame = -2147483648, bool preview = false, const std::string view = NULL)
	{
		// not implemented
		throw NULL;
	}

};

/**************** Bake Data ****************/

/**
 * Bake data for a Scene datablock
 */
class BakeSettings : public pyUniplug {
public:
	BakeSettings(PyObject* pyobj) : pyUniplug(pyobj) {}

	BakeSettings() : pyUniplug(0)
	{
		// not implemented
	}

	/** Getter: Object to use as cage instead of calculating the cage from the active object with cage extrusion */
	std::string cage_object() { /* not implemented */ throw NULL; }
	/** Setter: Object to use as cage instead of calculating the cage from the active object with cage extrusion */
	void cage_object(const std::string& value) { /* not implemented */ }

	/** Getter: Image filepath to use when saving externally */
	std::string filepath() { /* not implemented */ throw NULL; }
	/** Setter: Image filepath to use when saving externally */
	void filepath(const std::string& value) { /* not implemented */ }

	/** Getter: Horizontal dimension of the baking map */
	int width() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "width"));
	}

	/** Setter: Horizontal dimension of the baking map */
	void width(int value) {
		PyObject_SetAttrString(pyobjref, "width", Py_BuildValue("i", value));
	}

	/** Getter: Vertical dimension of the baking map */
	int height() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "height"));
	}

	/** Setter: Vertical dimension of the baking map */
	void height(int value) {
		PyObject_SetAttrString(pyobjref, "height", Py_BuildValue("i", value));
	}

	/** Getter: Extends the baked result as a post process filter */
	int margin() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "margin"));
	}

	/** Setter: Extends the baked result as a post process filter */
	void margin(int value) {
		PyObject_SetAttrString(pyobjref, "margin", Py_BuildValue("i", value));
	}

	/** Getter: Distance to use for the inward ray cast when using selected to active */
	float cage_extrusion() { /* not implemented */ throw NULL; }
	/** Setter: Distance to use for the inward ray cast when using selected to active */
	void cage_extrusion(float value) {
		PyObject_SetAttrString(pyobjref, "cage_extrusion", Py_BuildValue("f", value));
	}

	enum normal_space_enum {
		normal_space_OBJECT = 2,
		normal_space_TANGENT = 3,
	};

	/** Getter: Choose normal space for baking */
	normal_space_enum normal_space() { /* not implemented */ throw NULL; }
	/** Setter: Choose normal space for baking */
	void normal_space(normal_space_enum value) { /* not implemented */ }

	enum normal_r_enum {
		normal_r_POS_X = 0,
		normal_r_POS_Y = 1,
		normal_r_POS_Z = 2,
		normal_r_NEG_X = 3,
		normal_r_NEG_Y = 4,
		normal_r_NEG_Z = 5,
	};

	/** Getter: Axis to bake in red channel */
	normal_r_enum normal_r() { /* not implemented */ throw NULL; }
	/** Setter: Axis to bake in red channel */
	void normal_r(normal_r_enum value) { /* not implemented */ }

	enum normal_g_enum {
		normal_g_POS_X = 0,
		normal_g_POS_Y = 1,
		normal_g_POS_Z = 2,
		normal_g_NEG_X = 3,
		normal_g_NEG_Y = 4,
		normal_g_NEG_Z = 5,
	};

	/** Getter: Axis to bake in green channel */
	normal_g_enum normal_g() { /* not implemented */ throw NULL; }
	/** Setter: Axis to bake in green channel */
	void normal_g(normal_g_enum value) { /* not implemented */ }

	enum normal_b_enum {
		normal_b_POS_X = 0,
		normal_b_POS_Y = 1,
		normal_b_POS_Z = 2,
		normal_b_NEG_X = 3,
		normal_b_NEG_Y = 4,
		normal_b_NEG_Z = 5,
	};

	/** Getter: Axis to bake in blue channel */
	normal_b_enum normal_b() { /* not implemented */ throw NULL; }
	/** Setter: Axis to bake in blue channel */
	void normal_b(normal_b_enum value) { /* not implemented */ }

	/** Getter:  */
	ImageFormatSettings image_settings() {
		/* not implemented */ throw NULL;
	}

	enum save_mode_enum {
		save_mode_INTERNAL = 0,
		save_mode_EXTERNAL = 1,
	};

	/** Getter: Choose how to save the baking map */
	save_mode_enum save_mode() { /* not implemented */ throw NULL; }
	/** Setter: Choose how to save the baking map */
	void save_mode(save_mode_enum value) { /* not implemented */ }

	/** Getter: Bake shading on the surface of selected objects to the active object */
	bool use_selected_to_active() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_selected_to_active")) == 1;
	}

	/** Setter: Bake shading on the surface of selected objects to the active object */
	void use_selected_to_active(bool value) {
		PyObject_SetAttrString(pyobjref, "use_selected_to_active", Py_BuildValue("i", value));
	}

	/** Getter: Clear Images before baking (internal only) */
	bool use_clear() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_clear")) == 1;
	}

	/** Setter: Clear Images before baking (internal only) */
	void use_clear(bool value) {
		PyObject_SetAttrString(pyobjref, "use_clear", Py_BuildValue("i", value));
	}

	/** Getter: Split external images per material (external only) */
	bool use_split_materials() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_split_materials")) == 1;
	}

	/** Setter: Split external images per material (external only) */
	void use_split_materials(bool value) {
		PyObject_SetAttrString(pyobjref, "use_split_materials", Py_BuildValue("i", value));
	}

	/** Getter: Automatically name the output file with the pass type (external only) */
	bool use_automatic_name() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_automatic_name")) == 1;
	}

	/** Setter: Automatically name the output file with the pass type (external only) */
	void use_automatic_name(bool value) {
		PyObject_SetAttrString(pyobjref, "use_automatic_name", Py_BuildValue("i", value));
	}

	/** Getter: Cast rays to active object from a cage */
	bool use_cage() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_cage")) == 1;
	}

	/** Setter: Cast rays to active object from a cage */
	void use_cage(bool value) {
		PyObject_SetAttrString(pyobjref, "use_cage", Py_BuildValue("i", value));
	}

};

/**************** Scene Render Layer ****************/

/**
 * Render layer
 */
class SceneRenderLayer : public pyUniplug {
public:
	SceneRenderLayer(PyObject* pyobj) : pyUniplug(pyobj) {}

	SceneRenderLayer() : pyUniplug(0)
	{
		// not implemented
	}

	/** Getter: Render layer name */
	std::string name() { /* not implemented */ throw NULL; }
	/** Setter: Render layer name */
	void name(const std::string& value) { /* not implemented */ }

	/** Getter: Material to override all other materials in this render layer */
	Material material_override() {
		/* not implemented */ throw NULL;
	}

	/** Getter: Group to override all other lights in this render layer */
	Group light_override() {
		/* not implemented */ throw NULL;
	}

	/** Getter: Scene layers included in this render layer */
	std::array<bool, 20> layers() {
		// TODO: MISSING DEREF! USE #DEFINE!
		PyObject *seqval = PyObject_GetAttrString(pyobjref, "layers");
		std::array<bool, 20> resarr;
		for (int i = 0; i < 20; i++)
			resarr[i] = PyLong_AsLong(PySequence_GetItem(seqval, i)) == 1;
		return resarr;
	}

	/** Setter: Scene layers included in this render layer */
	void layers(bool values[20]) { /* not implemented */ }

	/** Getter: Zmask scene layers for solid faces */
	std::array<bool, 20> layers_zmask() {
		// TODO: MISSING DEREF! USE #DEFINE!
		PyObject *seqval = PyObject_GetAttrString(pyobjref, "layers_zmask");
		std::array<bool, 20> resarr;
		for (int i = 0; i < 20; i++)
			resarr[i] = PyLong_AsLong(PySequence_GetItem(seqval, i)) == 1;
		return resarr;
	}

	/** Setter: Zmask scene layers for solid faces */
	void layers_zmask(bool values[20]) { /* not implemented */ }

	/** Getter: Exclude scene layers from having any influence */
	std::array<bool, 20> layers_exclude() {
		// TODO: MISSING DEREF! USE #DEFINE!
		PyObject *seqval = PyObject_GetAttrString(pyobjref, "layers_exclude");
		std::array<bool, 20> resarr;
		for (int i = 0; i < 20; i++)
			resarr[i] = PyLong_AsLong(PySequence_GetItem(seqval, i)) == 1;
		return resarr;
	}

	/** Setter: Exclude scene layers from having any influence */
	void layers_exclude(bool values[20]) { /* not implemented */ }

	/** Getter: Override number of render samples for this render layer, 0 will use the scene setting */
	int samples() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "samples"));
	}

	/** Setter: Override number of render samples for this render layer, 0 will use the scene setting */
	void samples(int value) {
		PyObject_SetAttrString(pyobjref, "samples", Py_BuildValue("i", value));
	}

	/** Getter: Z, Index, normal, UV and vector passes are only affected by surfaces with alpha transparency equal to or higher than this threshold */
	float pass_alpha_threshold() { /* not implemented */ throw NULL; }
	/** Setter: Z, Index, normal, UV and vector passes are only affected by surfaces with alpha transparency equal to or higher than this threshold */
	void pass_alpha_threshold(float value) {
		PyObject_SetAttrString(pyobjref, "pass_alpha_threshold", Py_BuildValue("f", value));
	}

	/** Getter: Disable or enable the render layer */
	bool use() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use")) == 1;
	}

	/** Setter: Disable or enable the render layer */
	void use(bool value) {
		PyObject_SetAttrString(pyobjref, "use", Py_BuildValue("i", value));
	}

	/** Getter: Only render what's in front of the solid z values */
	bool use_zmask() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_zmask")) == 1;
	}

	/** Setter: Only render what's in front of the solid z values */
	void use_zmask(bool value) {
		PyObject_SetAttrString(pyobjref, "use_zmask", Py_BuildValue("i", value));
	}

	/** Getter: For Zmask, only render what is behind solid z values instead of in front */
	bool invert_zmask() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "invert_zmask")) == 1;
	}

	/** Setter: For Zmask, only render what is behind solid z values instead of in front */
	void invert_zmask(bool value) {
		PyObject_SetAttrString(pyobjref, "invert_zmask", Py_BuildValue("i", value));
	}

	/** Getter: Fill in Z values for solid faces in invisible layers, for masking */
	bool use_all_z() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_all_z")) == 1;
	}

	/** Setter: Fill in Z values for solid faces in invisible layers, for masking */
	void use_all_z(bool value) {
		PyObject_SetAttrString(pyobjref, "use_all_z", Py_BuildValue("i", value));
	}

	/** Getter: Render Solid faces in this Layer */
	bool use_solid() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_solid")) == 1;
	}

	/** Setter: Render Solid faces in this Layer */
	void use_solid(bool value) {
		PyObject_SetAttrString(pyobjref, "use_solid", Py_BuildValue("i", value));
	}

	/** Getter: Render Halos in this Layer (on top of Solid) */
	bool use_halo() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_halo")) == 1;
	}

	/** Setter: Render Halos in this Layer (on top of Solid) */
	void use_halo(bool value) {
		PyObject_SetAttrString(pyobjref, "use_halo", Py_BuildValue("i", value));
	}

	/** Getter: Render Z-Transparent faces in this Layer (on top of Solid and Halos) */
	bool use_ztransp() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_ztransp")) == 1;
	}

	/** Setter: Render Z-Transparent faces in this Layer (on top of Solid and Halos) */
	void use_ztransp(bool value) {
		PyObject_SetAttrString(pyobjref, "use_ztransp", Py_BuildValue("i", value));
	}

	/** Getter: Render Sky in this Layer */
	bool use_sky() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_sky")) == 1;
	}

	/** Setter: Render Sky in this Layer */
	void use_sky(bool value) {
		PyObject_SetAttrString(pyobjref, "use_sky", Py_BuildValue("i", value));
	}

	/** Getter: Render Edge-enhance in this Layer (only works for Solid faces) */
	bool use_edge_enhance() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_edge_enhance")) == 1;
	}

	/** Setter: Render Edge-enhance in this Layer (only works for Solid faces) */
	void use_edge_enhance(bool value) {
		PyObject_SetAttrString(pyobjref, "use_edge_enhance", Py_BuildValue("i", value));
	}

	/** Getter: Render Strands in this Layer */
	bool use_strand() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_strand")) == 1;
	}

	/** Setter: Render Strands in this Layer */
	void use_strand(bool value) {
		PyObject_SetAttrString(pyobjref, "use_strand", Py_BuildValue("i", value));
	}

	/** Getter: Render stylized strokes in this Layer */
	bool use_freestyle() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_freestyle")) == 1;
	}

	/** Setter: Render stylized strokes in this Layer */
	void use_freestyle(bool value) {
		PyObject_SetAttrString(pyobjref, "use_freestyle", Py_BuildValue("i", value));
	}

	/** Getter: Deliver full combined RGBA buffer */
	bool use_pass_combined() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_pass_combined")) == 1;
	}

	/** Setter: Deliver full combined RGBA buffer */
	void use_pass_combined(bool value) {
		PyObject_SetAttrString(pyobjref, "use_pass_combined", Py_BuildValue("i", value));
	}

	/** Getter: Deliver Z values pass */
	bool use_pass_z() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_pass_z")) == 1;
	}

	/** Setter: Deliver Z values pass */
	void use_pass_z(bool value) {
		PyObject_SetAttrString(pyobjref, "use_pass_z", Py_BuildValue("i", value));
	}

	/** Getter: Deliver speed vector pass */
	bool use_pass_vector() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_pass_vector")) == 1;
	}

	/** Setter: Deliver speed vector pass */
	void use_pass_vector(bool value) {
		PyObject_SetAttrString(pyobjref, "use_pass_vector", Py_BuildValue("i", value));
	}

	/** Getter: Deliver normal pass */
	bool use_pass_normal() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_pass_normal")) == 1;
	}

	/** Setter: Deliver normal pass */
	void use_pass_normal(bool value) {
		PyObject_SetAttrString(pyobjref, "use_pass_normal", Py_BuildValue("i", value));
	}

	/** Getter: Deliver texture UV pass */
	bool use_pass_uv() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_pass_uv")) == 1;
	}

	/** Setter: Deliver texture UV pass */
	void use_pass_uv(bool value) {
		PyObject_SetAttrString(pyobjref, "use_pass_uv", Py_BuildValue("i", value));
	}

	/** Getter: Deliver mist factor pass (0.0-1.0) */
	bool use_pass_mist() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_pass_mist")) == 1;
	}

	/** Setter: Deliver mist factor pass (0.0-1.0) */
	void use_pass_mist(bool value) {
		PyObject_SetAttrString(pyobjref, "use_pass_mist", Py_BuildValue("i", value));
	}

	/** Getter: Deliver object index pass */
	bool use_pass_object_index() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_pass_object_index")) == 1;
	}

	/** Setter: Deliver object index pass */
	void use_pass_object_index(bool value) {
		PyObject_SetAttrString(pyobjref, "use_pass_object_index", Py_BuildValue("i", value));
	}

	/** Getter: Deliver material index pass */
	bool use_pass_material_index() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_pass_material_index")) == 1;
	}

	/** Setter: Deliver material index pass */
	void use_pass_material_index(bool value) {
		PyObject_SetAttrString(pyobjref, "use_pass_material_index", Py_BuildValue("i", value));
	}

	/** Getter: Deliver shade-less color pass */
	bool use_pass_color() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_pass_color")) == 1;
	}

	/** Setter: Deliver shade-less color pass */
	void use_pass_color(bool value) {
		PyObject_SetAttrString(pyobjref, "use_pass_color", Py_BuildValue("i", value));
	}

	/** Getter: Deliver diffuse pass */
	bool use_pass_diffuse() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_pass_diffuse")) == 1;
	}

	/** Setter: Deliver diffuse pass */
	void use_pass_diffuse(bool value) {
		PyObject_SetAttrString(pyobjref, "use_pass_diffuse", Py_BuildValue("i", value));
	}

	/** Getter: Deliver specular pass */
	bool use_pass_specular() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_pass_specular")) == 1;
	}

	/** Setter: Deliver specular pass */
	void use_pass_specular(bool value) {
		PyObject_SetAttrString(pyobjref, "use_pass_specular", Py_BuildValue("i", value));
	}

	/** Getter: Deliver shadow pass */
	bool use_pass_shadow() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_pass_shadow")) == 1;
	}

	/** Setter: Deliver shadow pass */
	void use_pass_shadow(bool value) {
		PyObject_SetAttrString(pyobjref, "use_pass_shadow", Py_BuildValue("i", value));
	}

	/** Getter: Deliver AO pass */
	bool use_pass_ambient_occlusion() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_pass_ambient_occlusion")) == 1;
	}

	/** Setter: Deliver AO pass */
	void use_pass_ambient_occlusion(bool value) {
		PyObject_SetAttrString(pyobjref, "use_pass_ambient_occlusion", Py_BuildValue("i", value));
	}

	/** Getter: Deliver raytraced reflection pass */
	bool use_pass_reflection() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_pass_reflection")) == 1;
	}

	/** Setter: Deliver raytraced reflection pass */
	void use_pass_reflection(bool value) {
		PyObject_SetAttrString(pyobjref, "use_pass_reflection", Py_BuildValue("i", value));
	}

	/** Getter: Deliver raytraced refraction pass */
	bool use_pass_refraction() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_pass_refraction")) == 1;
	}

	/** Setter: Deliver raytraced refraction pass */
	void use_pass_refraction(bool value) {
		PyObject_SetAttrString(pyobjref, "use_pass_refraction", Py_BuildValue("i", value));
	}

	/** Getter: Deliver emission pass */
	bool use_pass_emit() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_pass_emit")) == 1;
	}

	/** Setter: Deliver emission pass */
	void use_pass_emit(bool value) {
		PyObject_SetAttrString(pyobjref, "use_pass_emit", Py_BuildValue("i", value));
	}

	/** Getter: Deliver environment lighting pass */
	bool use_pass_environment() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_pass_environment")) == 1;
	}

	/** Setter: Deliver environment lighting pass */
	void use_pass_environment(bool value) {
		PyObject_SetAttrString(pyobjref, "use_pass_environment", Py_BuildValue("i", value));
	}

	/** Getter: Deliver indirect lighting pass */
	bool use_pass_indirect() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_pass_indirect")) == 1;
	}

	/** Setter: Deliver indirect lighting pass */
	void use_pass_indirect(bool value) {
		PyObject_SetAttrString(pyobjref, "use_pass_indirect", Py_BuildValue("i", value));
	}

	/** Getter: Exclude specular pass from combined */
	bool exclude_specular() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "exclude_specular")) == 1;
	}

	/** Setter: Exclude specular pass from combined */
	void exclude_specular(bool value) {
		PyObject_SetAttrString(pyobjref, "exclude_specular", Py_BuildValue("i", value));
	}

	/** Getter: Exclude shadow pass from combined */
	bool exclude_shadow() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "exclude_shadow")) == 1;
	}

	/** Setter: Exclude shadow pass from combined */
	void exclude_shadow(bool value) {
		PyObject_SetAttrString(pyobjref, "exclude_shadow", Py_BuildValue("i", value));
	}

	/** Getter: Exclude AO pass from combined */
	bool exclude_ambient_occlusion() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "exclude_ambient_occlusion")) == 1;
	}

	/** Setter: Exclude AO pass from combined */
	void exclude_ambient_occlusion(bool value) {
		PyObject_SetAttrString(pyobjref, "exclude_ambient_occlusion", Py_BuildValue("i", value));
	}

	/** Getter: Exclude raytraced reflection pass from combined */
	bool exclude_reflection() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "exclude_reflection")) == 1;
	}

	/** Setter: Exclude raytraced reflection pass from combined */
	void exclude_reflection(bool value) {
		PyObject_SetAttrString(pyobjref, "exclude_reflection", Py_BuildValue("i", value));
	}

	/** Getter: Exclude raytraced refraction pass from combined */
	bool exclude_refraction() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "exclude_refraction")) == 1;
	}

	/** Setter: Exclude raytraced refraction pass from combined */
	void exclude_refraction(bool value) {
		PyObject_SetAttrString(pyobjref, "exclude_refraction", Py_BuildValue("i", value));
	}

	/** Getter: Exclude emission pass from combined */
	bool exclude_emit() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "exclude_emit")) == 1;
	}

	/** Setter: Exclude emission pass from combined */
	void exclude_emit(bool value) {
		PyObject_SetAttrString(pyobjref, "exclude_emit", Py_BuildValue("i", value));
	}

	/** Getter: Exclude environment pass from combined */
	bool exclude_environment() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "exclude_environment")) == 1;
	}

	/** Setter: Exclude environment pass from combined */
	void exclude_environment(bool value) {
		PyObject_SetAttrString(pyobjref, "exclude_environment", Py_BuildValue("i", value));
	}

	/** Getter: Exclude indirect pass from combined */
	bool exclude_indirect() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "exclude_indirect")) == 1;
	}

	/** Setter: Exclude indirect pass from combined */
	void exclude_indirect(bool value) {
		PyObject_SetAttrString(pyobjref, "exclude_indirect", Py_BuildValue("i", value));
	}

	/** Getter: Deliver diffuse direct pass */
	bool use_pass_diffuse_direct() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_pass_diffuse_direct")) == 1;
	}

	/** Setter: Deliver diffuse direct pass */
	void use_pass_diffuse_direct(bool value) {
		PyObject_SetAttrString(pyobjref, "use_pass_diffuse_direct", Py_BuildValue("i", value));
	}

	/** Getter: Deliver diffuse indirect pass */
	bool use_pass_diffuse_indirect() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_pass_diffuse_indirect")) == 1;
	}

	/** Setter: Deliver diffuse indirect pass */
	void use_pass_diffuse_indirect(bool value) {
		PyObject_SetAttrString(pyobjref, "use_pass_diffuse_indirect", Py_BuildValue("i", value));
	}

	/** Getter: Deliver diffuse color pass */
	bool use_pass_diffuse_color() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_pass_diffuse_color")) == 1;
	}

	/** Setter: Deliver diffuse color pass */
	void use_pass_diffuse_color(bool value) {
		PyObject_SetAttrString(pyobjref, "use_pass_diffuse_color", Py_BuildValue("i", value));
	}

	/** Getter: Deliver glossy direct pass */
	bool use_pass_glossy_direct() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_pass_glossy_direct")) == 1;
	}

	/** Setter: Deliver glossy direct pass */
	void use_pass_glossy_direct(bool value) {
		PyObject_SetAttrString(pyobjref, "use_pass_glossy_direct", Py_BuildValue("i", value));
	}

	/** Getter: Deliver glossy indirect pass */
	bool use_pass_glossy_indirect() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_pass_glossy_indirect")) == 1;
	}

	/** Setter: Deliver glossy indirect pass */
	void use_pass_glossy_indirect(bool value) {
		PyObject_SetAttrString(pyobjref, "use_pass_glossy_indirect", Py_BuildValue("i", value));
	}

	/** Getter: Deliver glossy color pass */
	bool use_pass_glossy_color() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_pass_glossy_color")) == 1;
	}

	/** Setter: Deliver glossy color pass */
	void use_pass_glossy_color(bool value) {
		PyObject_SetAttrString(pyobjref, "use_pass_glossy_color", Py_BuildValue("i", value));
	}

	/** Getter: Deliver transmission direct pass */
	bool use_pass_transmission_direct() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_pass_transmission_direct")) == 1;
	}

	/** Setter: Deliver transmission direct pass */
	void use_pass_transmission_direct(bool value) {
		PyObject_SetAttrString(pyobjref, "use_pass_transmission_direct", Py_BuildValue("i", value));
	}

	/** Getter: Deliver transmission indirect pass */
	bool use_pass_transmission_indirect() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_pass_transmission_indirect")) == 1;
	}

	/** Setter: Deliver transmission indirect pass */
	void use_pass_transmission_indirect(bool value) {
		PyObject_SetAttrString(pyobjref, "use_pass_transmission_indirect", Py_BuildValue("i", value));
	}

	/** Getter: Deliver transmission color pass */
	bool use_pass_transmission_color() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_pass_transmission_color")) == 1;
	}

	/** Setter: Deliver transmission color pass */
	void use_pass_transmission_color(bool value) {
		PyObject_SetAttrString(pyobjref, "use_pass_transmission_color", Py_BuildValue("i", value));
	}

	/** Getter: Deliver subsurface direct pass */
	bool use_pass_subsurface_direct() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_pass_subsurface_direct")) == 1;
	}

	/** Setter: Deliver subsurface direct pass */
	void use_pass_subsurface_direct(bool value) {
		PyObject_SetAttrString(pyobjref, "use_pass_subsurface_direct", Py_BuildValue("i", value));
	}

	/** Getter: Deliver subsurface indirect pass */
	bool use_pass_subsurface_indirect() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_pass_subsurface_indirect")) == 1;
	}

	/** Setter: Deliver subsurface indirect pass */
	void use_pass_subsurface_indirect(bool value) {
		PyObject_SetAttrString(pyobjref, "use_pass_subsurface_indirect", Py_BuildValue("i", value));
	}

	/** Getter: Deliver subsurface color pass */
	bool use_pass_subsurface_color() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_pass_subsurface_color")) == 1;
	}

	/** Setter: Deliver subsurface color pass */
	void use_pass_subsurface_color(bool value) {
		PyObject_SetAttrString(pyobjref, "use_pass_subsurface_color", Py_BuildValue("i", value));
	}

	/** Getter:  */
	FreestyleSettings freestyle_settings();

};

/**************** Freestyle Line Set ****************/

/**
 * Line set for associating lines and style parameters
 */
class FreestyleLineSet : public pyUniplug {
public:
	FreestyleLineSet(PyObject* pyobj) : pyUniplug(pyobj) {}

	FreestyleLineSet() : pyUniplug(0)
	{
		// not implemented
	}

	/** Getter: Line style settings */
	FreestyleLineStyle linestyle() {
		/* not implemented */ throw NULL;
	}

	/** Getter: Line set name */
	std::string name() { /* not implemented */ throw NULL; }
	/** Setter: Line set name */
	void name(const std::string& value) { /* not implemented */ }

	/** Getter: Enable or disable this line set during stroke rendering */
	bool show_render() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "show_render")) == 1;
	}

	/** Setter: Enable or disable this line set during stroke rendering */
	void show_render(bool value) {
		PyObject_SetAttrString(pyobjref, "show_render", Py_BuildValue("i", value));
	}

	/** Getter: Select feature edges based on visibility */
	bool select_by_visibility() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "select_by_visibility")) == 1;
	}

	/** Setter: Select feature edges based on visibility */
	void select_by_visibility(bool value) {
		PyObject_SetAttrString(pyobjref, "select_by_visibility", Py_BuildValue("i", value));
	}

	/** Getter: Select feature edges based on edge types */
	bool select_by_edge_types() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "select_by_edge_types")) == 1;
	}

	/** Setter: Select feature edges based on edge types */
	void select_by_edge_types(bool value) {
		PyObject_SetAttrString(pyobjref, "select_by_edge_types", Py_BuildValue("i", value));
	}

	/** Getter: Select feature edges based on a group of objects */
	bool select_by_group() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "select_by_group")) == 1;
	}

	/** Setter: Select feature edges based on a group of objects */
	void select_by_group(bool value) {
		PyObject_SetAttrString(pyobjref, "select_by_group", Py_BuildValue("i", value));
	}

	/** Getter: Select feature edges by image border (less memory consumption) */
	bool select_by_image_border() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "select_by_image_border")) == 1;
	}

	/** Setter: Select feature edges by image border (less memory consumption) */
	void select_by_image_border(bool value) {
		PyObject_SetAttrString(pyobjref, "select_by_image_border", Py_BuildValue("i", value));
	}

	/** Getter: Select feature edges by face marks */
	bool select_by_face_marks() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "select_by_face_marks")) == 1;
	}

	/** Setter: Select feature edges by face marks */
	void select_by_face_marks(bool value) {
		PyObject_SetAttrString(pyobjref, "select_by_face_marks", Py_BuildValue("i", value));
	}

	enum edge_type_negation_enum {
		edge_type_negation_INCLUSIVE = 0,
		edge_type_negation_EXCLUSIVE = 4,
	};

	/** Getter: Specify either inclusion or exclusion of feature edges selected by edge types */
	edge_type_negation_enum edge_type_negation() { /* not implemented */ throw NULL; }
	/** Setter: Specify either inclusion or exclusion of feature edges selected by edge types */
	void edge_type_negation(edge_type_negation_enum value) { /* not implemented */ }

	enum edge_type_combination_enum {
		edge_type_combination_OR = 0,
		edge_type_combination_AND = 8,
	};

	/** Getter: Specify a logical combination of selection conditions on feature edge types */
	edge_type_combination_enum edge_type_combination() { /* not implemented */ throw NULL; }
	/** Setter: Specify a logical combination of selection conditions on feature edge types */
	void edge_type_combination(edge_type_combination_enum value) { /* not implemented */ }

	/** Getter: A group of objects based on which feature edges are selected */
	Group group() {
		/* not implemented */ throw NULL;
	}

	enum group_negation_enum {
		group_negation_INCLUSIVE = 0,
		group_negation_EXCLUSIVE = 16,
	};

	/** Getter: Specify either inclusion or exclusion of feature edges belonging to a group of objects */
	group_negation_enum group_negation() { /* not implemented */ throw NULL; }
	/** Setter: Specify either inclusion or exclusion of feature edges belonging to a group of objects */
	void group_negation(group_negation_enum value) { /* not implemented */ }

	enum face_mark_negation_enum {
		face_mark_negation_INCLUSIVE = 0,
		face_mark_negation_EXCLUSIVE = 32,
	};

	/** Getter: Specify either inclusion or exclusion of feature edges selected by face marks */
	face_mark_negation_enum face_mark_negation() { /* not implemented */ throw NULL; }
	/** Setter: Specify either inclusion or exclusion of feature edges selected by face marks */
	void face_mark_negation(face_mark_negation_enum value) { /* not implemented */ }

	enum face_mark_condition_enum {
		face_mark_condition_ONE = 0,
		face_mark_condition_BOTH = 64,
	};

	/** Getter: Specify a feature edge selection condition based on face marks */
	face_mark_condition_enum face_mark_condition() { /* not implemented */ throw NULL; }
	/** Setter: Specify a feature edge selection condition based on face marks */
	void face_mark_condition(face_mark_condition_enum value) { /* not implemented */ }

	/** Getter: Select silhouettes (edges at the boundary of visible and hidden faces) */
	bool select_silhouette() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "select_silhouette")) == 1;
	}

	/** Setter: Select silhouettes (edges at the boundary of visible and hidden faces) */
	void select_silhouette(bool value) {
		PyObject_SetAttrString(pyobjref, "select_silhouette", Py_BuildValue("i", value));
	}

	/** Getter: Select border edges (open mesh edges) */
	bool select_border() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "select_border")) == 1;
	}

	/** Setter: Select border edges (open mesh edges) */
	void select_border(bool value) {
		PyObject_SetAttrString(pyobjref, "select_border", Py_BuildValue("i", value));
	}

	/** Getter: Select crease edges (those between two faces making an angle smaller than the Crease Angle) */
	bool select_crease() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "select_crease")) == 1;
	}

	/** Setter: Select crease edges (those between two faces making an angle smaller than the Crease Angle) */
	void select_crease(bool value) {
		PyObject_SetAttrString(pyobjref, "select_crease", Py_BuildValue("i", value));
	}

	/** Getter: Select ridges and valleys (boundary lines between convex and concave areas of surface) */
	bool select_ridge_valley() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "select_ridge_valley")) == 1;
	}

	/** Setter: Select ridges and valleys (boundary lines between convex and concave areas of surface) */
	void select_ridge_valley(bool value) {
		PyObject_SetAttrString(pyobjref, "select_ridge_valley", Py_BuildValue("i", value));
	}

	/** Getter: Select suggestive contours (almost silhouette/contour edges) */
	bool select_suggestive_contour() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "select_suggestive_contour")) == 1;
	}

	/** Setter: Select suggestive contours (almost silhouette/contour edges) */
	void select_suggestive_contour(bool value) {
		PyObject_SetAttrString(pyobjref, "select_suggestive_contour", Py_BuildValue("i", value));
	}

	/** Getter: Select edges at material boundaries */
	bool select_material_boundary() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "select_material_boundary")) == 1;
	}

	/** Setter: Select edges at material boundaries */
	void select_material_boundary(bool value) {
		PyObject_SetAttrString(pyobjref, "select_material_boundary", Py_BuildValue("i", value));
	}

	/** Getter: Select contours (outer silhouettes of each object) */
	bool select_contour() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "select_contour")) == 1;
	}

	/** Setter: Select contours (outer silhouettes of each object) */
	void select_contour(bool value) {
		PyObject_SetAttrString(pyobjref, "select_contour", Py_BuildValue("i", value));
	}

	/** Getter: Select external contours (outer silhouettes of occluding and occluded objects) */
	bool select_external_contour() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "select_external_contour")) == 1;
	}

	/** Setter: Select external contours (outer silhouettes of occluding and occluded objects) */
	void select_external_contour(bool value) {
		PyObject_SetAttrString(pyobjref, "select_external_contour", Py_BuildValue("i", value));
	}

	/** Getter: Select edge marks (edges annotated by Freestyle edge marks) */
	bool select_edge_mark() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "select_edge_mark")) == 1;
	}

	/** Setter: Select edge marks (edges annotated by Freestyle edge marks) */
	void select_edge_mark(bool value) {
		PyObject_SetAttrString(pyobjref, "select_edge_mark", Py_BuildValue("i", value));
	}

	/** Getter: Exclude silhouette edges */
	bool exclude_silhouette() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "exclude_silhouette")) == 1;
	}

	/** Setter: Exclude silhouette edges */
	void exclude_silhouette(bool value) {
		PyObject_SetAttrString(pyobjref, "exclude_silhouette", Py_BuildValue("i", value));
	}

	/** Getter: Exclude border edges */
	bool exclude_border() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "exclude_border")) == 1;
	}

	/** Setter: Exclude border edges */
	void exclude_border(bool value) {
		PyObject_SetAttrString(pyobjref, "exclude_border", Py_BuildValue("i", value));
	}

	/** Getter: Exclude crease edges */
	bool exclude_crease() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "exclude_crease")) == 1;
	}

	/** Setter: Exclude crease edges */
	void exclude_crease(bool value) {
		PyObject_SetAttrString(pyobjref, "exclude_crease", Py_BuildValue("i", value));
	}

	/** Getter: Exclude ridges and valleys */
	bool exclude_ridge_valley() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "exclude_ridge_valley")) == 1;
	}

	/** Setter: Exclude ridges and valleys */
	void exclude_ridge_valley(bool value) {
		PyObject_SetAttrString(pyobjref, "exclude_ridge_valley", Py_BuildValue("i", value));
	}

	/** Getter: Exclude suggestive contours */
	bool exclude_suggestive_contour() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "exclude_suggestive_contour")) == 1;
	}

	/** Setter: Exclude suggestive contours */
	void exclude_suggestive_contour(bool value) {
		PyObject_SetAttrString(pyobjref, "exclude_suggestive_contour", Py_BuildValue("i", value));
	}

	/** Getter: Exclude edges at material boundaries */
	bool exclude_material_boundary() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "exclude_material_boundary")) == 1;
	}

	/** Setter: Exclude edges at material boundaries */
	void exclude_material_boundary(bool value) {
		PyObject_SetAttrString(pyobjref, "exclude_material_boundary", Py_BuildValue("i", value));
	}

	/** Getter: Exclude contours */
	bool exclude_contour() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "exclude_contour")) == 1;
	}

	/** Setter: Exclude contours */
	void exclude_contour(bool value) {
		PyObject_SetAttrString(pyobjref, "exclude_contour", Py_BuildValue("i", value));
	}

	/** Getter: Exclude external contours */
	bool exclude_external_contour() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "exclude_external_contour")) == 1;
	}

	/** Setter: Exclude external contours */
	void exclude_external_contour(bool value) {
		PyObject_SetAttrString(pyobjref, "exclude_external_contour", Py_BuildValue("i", value));
	}

	/** Getter: Exclude edge marks */
	bool exclude_edge_mark() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "exclude_edge_mark")) == 1;
	}

	/** Setter: Exclude edge marks */
	void exclude_edge_mark(bool value) {
		PyObject_SetAttrString(pyobjref, "exclude_edge_mark", Py_BuildValue("i", value));
	}

	enum visibility_enum {
		visibility_VISIBLE = 1,
		visibility_HIDDEN = 2,
		visibility_RANGE = 3,
	};

	/** Getter: Determine how to use visibility for feature edge selection */
	visibility_enum visibility() { /* not implemented */ throw NULL; }
	/** Setter: Determine how to use visibility for feature edge selection */
	void visibility(visibility_enum value) { /* not implemented */ }

	/** Getter: First QI value of the QI range */
	int qi_start() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "qi_start"));
	}

	/** Setter: First QI value of the QI range */
	void qi_start(int value) {
		PyObject_SetAttrString(pyobjref, "qi_start", Py_BuildValue("i", value));
	}

	/** Getter: Last QI value of the QI range */
	int qi_end() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "qi_end"));
	}

	/** Setter: Last QI value of the QI range */
	void qi_end(int value) {
		PyObject_SetAttrString(pyobjref, "qi_end", Py_BuildValue("i", value));
	}

};

/**************** Freestyle Module ****************/

/**
 * Style module configuration for specifying a style module
 */
class FreestyleModuleSettings : public pyUniplug {
public:
	FreestyleModuleSettings(PyObject* pyobj) : pyUniplug(pyobj) {}

	FreestyleModuleSettings() : pyUniplug(0)
	{
		// not implemented
	}

	/** Getter: Python script to define a style module */
	Text script();

	/** Getter: Enable or disable this style module during stroke rendering */
	bool use() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use")) == 1;
	}

	/** Setter: Enable or disable this style module during stroke rendering */
	void use(bool value) {
		PyObject_SetAttrString(pyobjref, "use", Py_BuildValue("i", value));
	}

};

/**************** Freestyle Settings ****************/

/**
 * Freestyle settings for a SceneRenderLayer datablock
 */
class FreestyleSettings : public pyUniplug {
public:
	FreestyleSettings(PyObject* pyobj) : pyUniplug(pyobj) {}

	FreestyleSettings() : pyUniplug(0)
	{
		// not implemented
	}

	/** Getter: A list of style modules (to be applied from top to bottom) */
	std::map<std::string, FreestyleModuleSettings> modules() {
		// TODO: MISSING DEREF! USE #DEFINE!
		PyObject *seqval = PyObject_GetAttrString(pyobjref, "modules");
		PyObject *seqkeys = PyObject_CallMethod(seqval, "keys", NULL);
		std::map<std::string, FreestyleModuleSettings> resmap;
		for (int i = 0; i < PySequence_Length(seqval); i++) {
			PyObject *keyobj = PySequence_GetItem(seqkeys, i);
			std::string key = PyBytes_AsString(PyUnicode_AsASCIIString(keyobj));
			FreestyleModuleSettings value = FreestyleModuleSettings(PySequence_GetItem(seqval, i));
			resmap.insert(std::pair<std::string,FreestyleModuleSettings>(key, value));
		}
		return resmap;
	}

	/** Setter: A list of style modules (to be applied from top to bottom) */
	void modules(std::map<std::string, FreestyleModuleSettings> value) { /* not implemented */ }

	enum mode_enum {
		mode_SCRIPT = 1,
		mode_EDITOR = 2,
	};

	/** Getter: Select the Freestyle control mode */
	mode_enum mode() { /* not implemented */ throw NULL; }
	/** Setter: Select the Freestyle control mode */
	void mode(mode_enum value) { /* not implemented */ }

	/** Getter: If enabled, out-of-view edges are ignored */
	bool use_culling() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_culling")) == 1;
	}

	/** Setter: If enabled, out-of-view edges are ignored */
	void use_culling(bool value) {
		PyObject_SetAttrString(pyobjref, "use_culling", Py_BuildValue("i", value));
	}

	/** Getter: Enable suggestive contours */
	bool use_suggestive_contours() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_suggestive_contours")) == 1;
	}

	/** Setter: Enable suggestive contours */
	void use_suggestive_contours(bool value) {
		PyObject_SetAttrString(pyobjref, "use_suggestive_contours", Py_BuildValue("i", value));
	}

	/** Getter: Enable ridges and valleys */
	bool use_ridges_and_valleys() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_ridges_and_valleys")) == 1;
	}

	/** Setter: Enable ridges and valleys */
	void use_ridges_and_valleys(bool value) {
		PyObject_SetAttrString(pyobjref, "use_ridges_and_valleys", Py_BuildValue("i", value));
	}

	/** Getter: Enable material boundaries */
	bool use_material_boundaries() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_material_boundaries")) == 1;
	}

	/** Setter: Enable material boundaries */
	void use_material_boundaries(bool value) {
		PyObject_SetAttrString(pyobjref, "use_material_boundaries", Py_BuildValue("i", value));
	}

	/** Getter: Take face smoothness into account in view map calculation */
	bool use_smoothness() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_smoothness")) == 1;
	}

	/** Setter: Take face smoothness into account in view map calculation */
	void use_smoothness(bool value) {
		PyObject_SetAttrString(pyobjref, "use_smoothness", Py_BuildValue("i", value));
	}

	/** Getter: Enable advanced edge detection options (sphere radius and Kr derivative epsilon) */
	bool use_advanced_options() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_advanced_options")) == 1;
	}

	/** Setter: Enable advanced edge detection options (sphere radius and Kr derivative epsilon) */
	void use_advanced_options(bool value) {
		PyObject_SetAttrString(pyobjref, "use_advanced_options", Py_BuildValue("i", value));
	}

	/** Getter: Keep the computed view map and avoid re-calculating it if mesh geometry is unchanged */
	bool use_view_map_cache() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_view_map_cache")) == 1;
	}

	/** Setter: Keep the computed view map and avoid re-calculating it if mesh geometry is unchanged */
	void use_view_map_cache(bool value) {
		PyObject_SetAttrString(pyobjref, "use_view_map_cache", Py_BuildValue("i", value));
	}

	/** Getter: Sphere radius for computing curvatures */
	float sphere_radius() { /* not implemented */ throw NULL; }
	/** Setter: Sphere radius for computing curvatures */
	void sphere_radius(float value) {
		PyObject_SetAttrString(pyobjref, "sphere_radius", Py_BuildValue("f", value));
	}

	/** Getter: Kr derivative epsilon for computing suggestive contours */
	float kr_derivative_epsilon() { /* not implemented */ throw NULL; }
	/** Setter: Kr derivative epsilon for computing suggestive contours */
	void kr_derivative_epsilon(float value) {
		PyObject_SetAttrString(pyobjref, "kr_derivative_epsilon", Py_BuildValue("f", value));
	}

	/** Getter: Angular threshold for detecting crease edges */
	float crease_angle() { /* not implemented */ throw NULL; }
	/** Setter: Angular threshold for detecting crease edges */
	void crease_angle(float value) {
		PyObject_SetAttrString(pyobjref, "crease_angle", Py_BuildValue("f", value));
	}

	/** Getter:  */
	std::map<std::string, FreestyleLineSet> linesets() {
		// TODO: MISSING DEREF! USE #DEFINE!
		PyObject *seqval = PyObject_GetAttrString(pyobjref, "linesets");
		PyObject *seqkeys = PyObject_CallMethod(seqval, "keys", NULL);
		std::map<std::string, FreestyleLineSet> resmap;
		for (int i = 0; i < PySequence_Length(seqval); i++) {
			PyObject *keyobj = PySequence_GetItem(seqkeys, i);
			std::string key = PyBytes_AsString(PyUnicode_AsASCIIString(keyobj));
			FreestyleLineSet value = FreestyleLineSet(PySequence_GetItem(seqval, i));
			resmap.insert(std::pair<std::string,FreestyleLineSet>(key, value));
		}
		return resmap;
	}

	/** Setter:  */
	void linesets(std::map<std::string, FreestyleLineSet> value) { /* not implemented */ }

};

/**************** GPU SSAO ****************/

/**
 * Settings for GPU based screen space ambient occlusion
 */
class GPUSSAOSettings : public pyUniplug {
public:
	GPUSSAOSettings(PyObject* pyobj) : pyUniplug(pyobj) {}

	GPUSSAOSettings() : pyUniplug(0)
	{
		// not implemented
	}

	/** Getter: Strength of the SSAO effect */
	float factor() { /* not implemented */ throw NULL; }
	/** Setter: Strength of the SSAO effect */
	void factor(float value) {
		PyObject_SetAttrString(pyobjref, "factor", Py_BuildValue("f", value));
	}

	/** Getter: Distance of object that contribute to the SSAO effect */
	float distance_max() { /* not implemented */ throw NULL; }
	/** Setter: Distance of object that contribute to the SSAO effect */
	void distance_max(float value) {
		PyObject_SetAttrString(pyobjref, "distance_max", Py_BuildValue("f", value));
	}

	/** Getter: Attenuation constant */
	float attenuation() { /* not implemented */ throw NULL; }
	/** Setter: Attenuation constant */
	void attenuation(float value) {
		PyObject_SetAttrString(pyobjref, "attenuation", Py_BuildValue("f", value));
	}

	/** Getter: Number of samples */
	int samples() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "samples"));
	}

	/** Setter: Number of samples */
	void samples(int value) {
		PyObject_SetAttrString(pyobjref, "samples", Py_BuildValue("i", value));
	}

	/** Getter: Color for screen space ambient occlusion effect */
	std::array<float, 3> color() {
		// TODO: MISSING DEREF! USE #DEFINE!
		PyObject *seqval = PyObject_GetAttrString(pyobjref, "color");
		std::array<float, 3> resarr;
		for (int i = 0; i < 3; i++)
			resarr[i] = (float)PyFloat_AsDouble(PySequence_GetItem(seqval, i));
		return resarr;
	}

	/** Setter: Color for screen space ambient occlusion effect */
	void color(float values[3]) { /* not implemented */ }

};

/**************** GPU DOF ****************/

/**
 * Settings for GPU based depth of field
 */
class GPUDOFSettings : public pyUniplug {
public:
	GPUDOFSettings(PyObject* pyobj) : pyUniplug(pyobj) {}

	GPUDOFSettings() : pyUniplug(0)
	{
		// not implemented
	}

	/** Getter: Viewport depth of field focus distance */
	float focus_distance() { /* not implemented */ throw NULL; }
	/** Setter: Viewport depth of field focus distance */
	void focus_distance(float value) {
		PyObject_SetAttrString(pyobjref, "focus_distance", Py_BuildValue("f", value));
	}

	/** Getter: Focal length for dof effect */
	float focal_length() { /* not implemented */ throw NULL; }
	/** Setter: Focal length for dof effect */
	void focal_length(float value) {
		PyObject_SetAttrString(pyobjref, "focal_length", Py_BuildValue("f", value));
	}

	/** Getter: Size of sensor */
	float sensor() { /* not implemented */ throw NULL; }
	/** Setter: Size of sensor */
	void sensor(float value) {
		PyObject_SetAttrString(pyobjref, "sensor", Py_BuildValue("f", value));
	}

	/** Getter: F-stop for dof effect */
	float fstop() { /* not implemented */ throw NULL; }
	/** Setter: F-stop for dof effect */
	void fstop(float value) {
		PyObject_SetAttrString(pyobjref, "fstop", Py_BuildValue("f", value));
	}

	/** Getter: Blades for dof effect */
	int blades() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "blades"));
	}

	/** Setter: Blades for dof effect */
	void blades(int value) {
		PyObject_SetAttrString(pyobjref, "blades", Py_BuildValue("i", value));
	}

	/** Getter: Use high quality depth of field */
	bool use_high_quality() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_high_quality")) == 1;
	}

	/** Setter: Use high quality depth of field */
	void use_high_quality(bool value) {
		PyObject_SetAttrString(pyobjref, "use_high_quality", Py_BuildValue("i", value));
	}

	/** Getter: Use high quality depth of field */
	bool is_hq_supported() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "is_hq_supported")) == 1;
	}

	/** Setter: Use high quality depth of field */
	void is_hq_supported(bool value) {
		PyObject_SetAttrString(pyobjref, "is_hq_supported", Py_BuildValue("i", value));
	}

};

/**************** GPU FX Settings ****************/

/**
 * Settings for GPU based compositing
 */
class GPUFXSettings : public pyUniplug {
public:
	GPUFXSettings(PyObject* pyobj) : pyUniplug(pyobj) {}

	GPUFXSettings() : pyUniplug(0)
	{
		// not implemented
	}

	/** Getter:  */
	GPUDOFSettings dof() {
		/* not implemented */ throw NULL;
	}

	/** Getter: Use depth of field on viewport using the values from active camera */
	bool use_dof() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_dof")) == 1;
	}

	/** Setter: Use depth of field on viewport using the values from active camera */
	void use_dof(bool value) {
		PyObject_SetAttrString(pyobjref, "use_dof", Py_BuildValue("i", value));
	}

	/** Getter:  */
	GPUSSAOSettings ssao() {
		/* not implemented */ throw NULL;
	}

	/** Getter: Use screen space ambient occlusion of field on viewport */
	bool use_ssao() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_ssao")) == 1;
	}

	/** Setter: Use screen space ambient occlusion of field on viewport */
	void use_ssao(bool value) {
		PyObject_SetAttrString(pyobjref, "use_ssao", Py_BuildValue("i", value));
	}

};

/**************** Scene Render View ****************/

/**
 * Render viewpoint for 3D stereo and multiview rendering
 */
class SceneRenderView : public pyUniplug {
public:
	SceneRenderView(PyObject* pyobj) : pyUniplug(pyobj) {}

	SceneRenderView() : pyUniplug(0)
	{
		// not implemented
	}

	/** Getter: Render view name */
	std::string name() { /* not implemented */ throw NULL; }
	/** Setter: Render view name */
	void name(const std::string& value) { /* not implemented */ }

	/** Getter: Suffix added to the render images for this view */
	std::string file_suffix() { /* not implemented */ throw NULL; }
	/** Setter: Suffix added to the render images for this view */
	void file_suffix(const std::string& value) { /* not implemented */ }

	/** Getter: Suffix to identify the cameras to use, and added to the render images for this view */
	std::string camera_suffix() { /* not implemented */ throw NULL; }
	/** Setter: Suffix to identify the cameras to use, and added to the render images for this view */
	void camera_suffix(const std::string& value) { /* not implemented */ }

	/** Getter: Disable or enable the render view */
	bool use() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use")) == 1;
	}

	/** Setter: Disable or enable the render view */
	void use(bool value) {
		PyObject_SetAttrString(pyobjref, "use", Py_BuildValue("i", value));
	}

};

/**************** Screen ****************/

/**
 * Screen datablock, defining the layout of areas in a window
 */
class Screen : public ID {
public:
	Screen(PyObject* pyobj) : ID(pyobj) {}

	Screen() : ID(0)
	{
		// not implemented
	}

	/** Getter: Active scene to be edited in the screen */
	Scene scene() {
		/* not implemented */ throw NULL;
	}

	/** Getter: Areas the screen is subdivided into */
	std::map<std::string, Area> areas();
	/** Setter: Areas the screen is subdivided into */
	void areas(std::map<std::string, Area> value);

	/** Getter: Animation playback is active */
	bool is_animation_playing() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "is_animation_playing")) == 1;
	}

	/** Setter: Animation playback is active */
	void is_animation_playing(bool value) {
		PyObject_SetAttrString(pyobjref, "is_animation_playing", Py_BuildValue("i", value));
	}

	/** Getter: An area is maximized, filling this screen */
	bool show_fullscreen() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "show_fullscreen")) == 1;
	}

	/** Setter: An area is maximized, filling this screen */
	void show_fullscreen(bool value) {
		PyObject_SetAttrString(pyobjref, "show_fullscreen", Py_BuildValue("i", value));
	}

	/** Getter:  */
	bool use_play_top_left_3d_editor() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_play_top_left_3d_editor")) == 1;
	}

	/** Setter:  */
	void use_play_top_left_3d_editor(bool value) {
		PyObject_SetAttrString(pyobjref, "use_play_top_left_3d_editor", Py_BuildValue("i", value));
	}

	/** Getter:  */
	bool use_play_3d_editors() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_play_3d_editors")) == 1;
	}

	/** Setter:  */
	void use_play_3d_editors(bool value) {
		PyObject_SetAttrString(pyobjref, "use_play_3d_editors", Py_BuildValue("i", value));
	}

	/** Getter: Follow current frame in editors */
	bool use_follow() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_follow")) == 1;
	}

	/** Setter: Follow current frame in editors */
	void use_follow(bool value) {
		PyObject_SetAttrString(pyobjref, "use_follow", Py_BuildValue("i", value));
	}

	/** Getter:  */
	bool use_play_animation_editors() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_play_animation_editors")) == 1;
	}

	/** Setter:  */
	void use_play_animation_editors(bool value) {
		PyObject_SetAttrString(pyobjref, "use_play_animation_editors", Py_BuildValue("i", value));
	}

	/** Getter:  */
	bool use_play_properties_editors() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_play_properties_editors")) == 1;
	}

	/** Setter:  */
	void use_play_properties_editors(bool value) {
		PyObject_SetAttrString(pyobjref, "use_play_properties_editors", Py_BuildValue("i", value));
	}

	/** Getter:  */
	bool use_play_image_editors() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_play_image_editors")) == 1;
	}

	/** Setter:  */
	void use_play_image_editors(bool value) {
		PyObject_SetAttrString(pyobjref, "use_play_image_editors", Py_BuildValue("i", value));
	}

	/** Getter:  */
	bool use_play_sequence_editors() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_play_sequence_editors")) == 1;
	}

	/** Setter:  */
	void use_play_sequence_editors(bool value) {
		PyObject_SetAttrString(pyobjref, "use_play_sequence_editors", Py_BuildValue("i", value));
	}

	/** Getter:  */
	bool use_play_node_editors() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_play_node_editors")) == 1;
	}

	/** Setter:  */
	void use_play_node_editors(bool value) {
		PyObject_SetAttrString(pyobjref, "use_play_node_editors", Py_BuildValue("i", value));
	}

	/** Getter:  */
	bool use_play_clip_editors() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_play_clip_editors")) == 1;
	}

	/** Setter:  */
	void use_play_clip_editors(bool value) {
		PyObject_SetAttrString(pyobjref, "use_play_clip_editors", Py_BuildValue("i", value));
	}

};

/**************** Area ****************/

/**
 * Area in a subdivided screen, containing an editor
 */
class Area : public pyUniplug {
public:
	Area(PyObject* pyobj) : pyUniplug(pyobj) {}

	Area() : pyUniplug(0)
	{
		// not implemented
	}

	/** Getter: Spaces contained in this area, the first being the active space (NOTE: Useful for example to restore a previously used 3D view space in a certain area to get the old view orientation) */
	std::map<std::string, Space> spaces();
	/** Setter: Spaces contained in this area, the first being the active space (NOTE: Useful for example to restore a previously used 3D view space in a certain area to get the old view orientation) */
	void spaces(std::map<std::string, Space> value);

	/** Getter: Regions this area is subdivided in */
	std::map<std::string, Region> regions();
	/** Setter: Regions this area is subdivided in */
	void regions(std::map<std::string, Region> value);

	/** Getter: Show menus in the header */
	bool show_menus() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "show_menus")) == 1;
	}

	/** Setter: Show menus in the header */
	void show_menus(bool value) {
		PyObject_SetAttrString(pyobjref, "show_menus", Py_BuildValue("i", value));
	}

	enum type_enum {
		type_EMPTY = 0,
		type_VIEW_3D = 1,
		type_TIMELINE = 15,
		type_GRAPH_EDITOR = 2,
		type_DOPESHEET_EDITOR = 12,
		type_NLA_EDITOR = 13,
		type_IMAGE_EDITOR = 6,
		type_SEQUENCE_EDITOR = 8,
		type_CLIP_EDITOR = 20,
		type_TEXT_EDITOR = 9,
		type_NODE_EDITOR = 16,
		type_LOGIC_EDITOR = 17,
		type_PROPERTIES = 4,
		type_OUTLINER = 3,
		type_USER_PREFERENCES = 19,
		type_INFO = 7,
		type_FILE_BROWSER = 5,
		type_CONSOLE = 18,
	};

	/** Getter: Current editor type for this area */
	type_enum type() { /* not implemented */ throw NULL; }
	/** Setter: Current editor type for this area */
	void type(type_enum value) { /* not implemented */ }

	/** Getter: The window relative vertical location of the area */
	int x() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "x"));
	}

	/** Setter: The window relative vertical location of the area */
	void x(int value) {
		PyObject_SetAttrString(pyobjref, "x", Py_BuildValue("i", value));
	}

	/** Getter: The window relative horizontal location of the area */
	int y() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "y"));
	}

	/** Setter: The window relative horizontal location of the area */
	void y(int value) {
		PyObject_SetAttrString(pyobjref, "y", Py_BuildValue("i", value));
	}

	/** Getter: Area width */
	int width() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "width"));
	}

	/** Setter: Area width */
	void width(int value) {
		PyObject_SetAttrString(pyobjref, "width", Py_BuildValue("i", value));
	}

	/** Getter: Area height */
	int height() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "height"));
	}

	/** Setter: Area height */
	void height(int value) {
		PyObject_SetAttrString(pyobjref, "height", Py_BuildValue("i", value));
	}

	/**
	 * Function: tag_redraw
	 */
	void tag_redraw()
	{
		// not implemented
	}

	/**
	 * Set the header text
	 * @param New string for the header, no argument clears the text
	 */
	void header_text_set(const std::string text = NULL)
	{
		// not implemented
	}

};

/**************** Region ****************/

/**
 * Region in a subdivided screen area
 */
class Region : public pyUniplug {
public:
	Region(PyObject* pyobj) : pyUniplug(pyobj) {}

	Region() : pyUniplug(0)
	{
		// not implemented
	}

	/** Getter: Unique ID for this region */
	int id() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "id"));
	}

	/** Setter: Unique ID for this region */
	void id(int value) {
		PyObject_SetAttrString(pyobjref, "id", Py_BuildValue("i", value));
	}

	enum type_enum {
		type_WINDOW = 0,
		type_HEADER = 1,
		type_CHANNELS = 2,
		type_TEMPORARY = 3,
		type_UI = 4,
		type_TOOLS = 5,
		type_TOOL_PROPS = 6,
		type_PREVIEW = 7,
	};

	/** Getter: Type of this region */
	type_enum type() { /* not implemented */ throw NULL; }
	/** Setter: Type of this region */
	void type(type_enum value) { /* not implemented */ }

	/** Getter: The window relative vertical location of the region */
	int x() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "x"));
	}

	/** Setter: The window relative vertical location of the region */
	void x(int value) {
		PyObject_SetAttrString(pyobjref, "x", Py_BuildValue("i", value));
	}

	/** Getter: The window relative horizontal location of the region */
	int y() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "y"));
	}

	/** Setter: The window relative horizontal location of the region */
	void y(int value) {
		PyObject_SetAttrString(pyobjref, "y", Py_BuildValue("i", value));
	}

	/** Getter: Region width */
	int width() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "width"));
	}

	/** Setter: Region width */
	void width(int value) {
		PyObject_SetAttrString(pyobjref, "width", Py_BuildValue("i", value));
	}

	/** Getter: Region height */
	int height() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "height"));
	}

	/** Setter: Region height */
	void height(int value) {
		PyObject_SetAttrString(pyobjref, "height", Py_BuildValue("i", value));
	}

	/** Getter: 2D view of the region */
	View2D view2d();

	/**
	 * Function: tag_redraw
	 */
	void tag_redraw()
	{
		// not implemented
	}

};

/**************** View2D ****************/

/**
 * Scroll and zoom for a 2D region
 */
class View2D : public pyUniplug {
public:
	View2D(PyObject* pyobj) : pyUniplug(pyobj) {}

	View2D() : pyUniplug(0)
	{
		// not implemented
	}

	/**
	 * Transform region coordinates to 2D view
	 * @param Region x coordinate
	 * @param Region y coordinate
	 * @return View coordinates
	 */
	std::array<float, 2> region_to_view(int x, int y)
	{
		// not implemented
		throw NULL;
	}

	/**
	 * Transform 2D view coordinates to region
	 * @param 2D View x coordinate
	 * @param 2D View y coordinate
	 * @param Clip coordinates to the visible region
	 * @return Region coordinates
	 */
	std::array<int, 2> view_to_region(float x, float y, bool clip = true)
	{
		// not implemented
		throw NULL;
	}

};

/**************** Paint Curve ****************/

/**
 * 
 */
class PaintCurve : public ID {
public:
	PaintCurve(PyObject* pyobj) : ID(pyobj) {}

	PaintCurve() : ID(0)
	{
		// not implemented
	}

};

/**************** Paint ****************/

/**
 * 
 */
class Paint : public pyUniplug {
public:
	Paint(PyObject* pyobj) : pyUniplug(pyobj) {}

	Paint() : pyUniplug(0)
	{
		// not implemented
	}

	/** Getter: Active Brush */
	Brush brush() {
		/* not implemented */ throw NULL;
	}

	/** Getter: Active Palette */
	Palette palette() {
		/* not implemented */ throw NULL;
	}

	/** Getter:  */
	bool show_brush() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "show_brush")) == 1;
	}

	/** Setter:  */
	void show_brush(bool value) {
		PyObject_SetAttrString(pyobjref, "show_brush", Py_BuildValue("i", value));
	}

	/** Getter:  */
	bool show_brush_on_surface() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "show_brush_on_surface")) == 1;
	}

	/** Setter:  */
	void show_brush_on_surface(bool value) {
		PyObject_SetAttrString(pyobjref, "show_brush_on_surface", Py_BuildValue("i", value));
	}

	/** Getter: For multires, show low resolution while navigating the view */
	bool show_low_resolution() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "show_low_resolution")) == 1;
	}

	/** Setter: For multires, show low resolution while navigating the view */
	void show_low_resolution(bool value) {
		PyObject_SetAttrString(pyobjref, "show_low_resolution", Py_BuildValue("i", value));
	}

	/** Getter: Average multiple input samples together to smooth the brush stroke */
	int input_samples() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "input_samples"));
	}

	/** Setter: Average multiple input samples together to smooth the brush stroke */
	void input_samples(int value) {
		PyObject_SetAttrString(pyobjref, "input_samples", Py_BuildValue("i", value));
	}

	/** Getter: Mirror brush across the X axis */
	bool use_symmetry_x() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_symmetry_x")) == 1;
	}

	/** Setter: Mirror brush across the X axis */
	void use_symmetry_x(bool value) {
		PyObject_SetAttrString(pyobjref, "use_symmetry_x", Py_BuildValue("i", value));
	}

	/** Getter: Mirror brush across the Y axis */
	bool use_symmetry_y() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_symmetry_y")) == 1;
	}

	/** Setter: Mirror brush across the Y axis */
	void use_symmetry_y(bool value) {
		PyObject_SetAttrString(pyobjref, "use_symmetry_y", Py_BuildValue("i", value));
	}

	/** Getter: Mirror brush across the Z axis */
	bool use_symmetry_z() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_symmetry_z")) == 1;
	}

	/** Setter: Mirror brush across the Z axis */
	void use_symmetry_z(bool value) {
		PyObject_SetAttrString(pyobjref, "use_symmetry_z", Py_BuildValue("i", value));
	}

	/** Getter: Reduce the strength of the brush where it overlaps symmetrical daubs */
	bool use_symmetry_feather() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_symmetry_feather")) == 1;
	}

	/** Setter: Reduce the strength of the brush where it overlaps symmetrical daubs */
	void use_symmetry_feather(bool value) {
		PyObject_SetAttrString(pyobjref, "use_symmetry_feather", Py_BuildValue("i", value));
	}

	/** Getter: Editable cavity curve */
	CurveMapping cavity_curve() {
		/* not implemented */ throw NULL;
	}

	/** Getter: Mask painting according to mesh geometry cavity */
	bool use_cavity() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_cavity")) == 1;
	}

	/** Setter: Mask painting according to mesh geometry cavity */
	void use_cavity(bool value) {
		PyObject_SetAttrString(pyobjref, "use_cavity", Py_BuildValue("i", value));
	}

};

/**************** Sculpt ****************/

/**
 * 
 */
class Sculpt : public Paint {
public:
	Sculpt(PyObject* pyobj) : Paint(pyobj) {}

	Sculpt() : Paint(0)
	{
		// not implemented
	}

	/** Getter: Number of times to copy strokes across the surface */
	std::array<int, 3> radial_symmetry() {
		// TODO: MISSING DEREF! USE #DEFINE!
		PyObject *seqval = PyObject_GetAttrString(pyobjref, "radial_symmetry");
		std::array<int, 3> resarr;
		for (int i = 0; i < 3; i++)
			resarr[i] = PyLong_AsLong(PySequence_GetItem(seqval, i));
		return resarr;
	}

	/** Setter: Number of times to copy strokes across the surface */
	void radial_symmetry(int values[3]) { /* not implemented */ }

	/** Getter: Disallow changes to the X axis of vertices */
	bool lock_x() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "lock_x")) == 1;
	}

	/** Setter: Disallow changes to the X axis of vertices */
	void lock_x(bool value) {
		PyObject_SetAttrString(pyobjref, "lock_x", Py_BuildValue("i", value));
	}

	/** Getter: Disallow changes to the Y axis of vertices */
	bool lock_y() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "lock_y")) == 1;
	}

	/** Setter: Disallow changes to the Y axis of vertices */
	void lock_y(bool value) {
		PyObject_SetAttrString(pyobjref, "lock_y", Py_BuildValue("i", value));
	}

	/** Getter: Disallow changes to the Z axis of vertices */
	bool lock_z() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "lock_z")) == 1;
	}

	/** Setter: Disallow changes to the Z axis of vertices */
	void lock_z(bool value) {
		PyObject_SetAttrString(pyobjref, "lock_z", Py_BuildValue("i", value));
	}

	/** Getter: Take advantage of multiple CPU cores to improve sculpting performance */
	bool use_threaded() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_threaded")) == 1;
	}

	/** Setter: Take advantage of multiple CPU cores to improve sculpting performance */
	void use_threaded(bool value) {
		PyObject_SetAttrString(pyobjref, "use_threaded", Py_BuildValue("i", value));
	}

	/** Getter: Use only deformation modifiers (temporary disable all constructive modifiers except multi-resolution) */
	bool use_deform_only() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_deform_only")) == 1;
	}

	/** Setter: Use only deformation modifiers (temporary disable all constructive modifiers except multi-resolution) */
	void use_deform_only(bool value) {
		PyObject_SetAttrString(pyobjref, "use_deform_only", Py_BuildValue("i", value));
	}

	/** Getter: Show diffuse color of object and overlay sculpt mask on top of it */
	bool show_diffuse_color() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "show_diffuse_color")) == 1;
	}

	/** Setter: Show diffuse color of object and overlay sculpt mask on top of it */
	void show_diffuse_color(bool value) {
		PyObject_SetAttrString(pyobjref, "show_diffuse_color", Py_BuildValue("i", value));
	}

	/** Getter: Maximum edge length for dynamic topology sculpting (in pixels) */
	float detail_size() { /* not implemented */ throw NULL; }
	/** Setter: Maximum edge length for dynamic topology sculpting (in pixels) */
	void detail_size(float value) {
		PyObject_SetAttrString(pyobjref, "detail_size", Py_BuildValue("f", value));
	}

	/** Getter: Maximum edge length for dynamic topology sculpting (in brush percenage) */
	float detail_percent() { /* not implemented */ throw NULL; }
	/** Setter: Maximum edge length for dynamic topology sculpting (in brush percenage) */
	void detail_percent(float value) {
		PyObject_SetAttrString(pyobjref, "detail_percent", Py_BuildValue("f", value));
	}

	/** Getter: Maximum edge length for dynamic topology sculpting (as percentage of blender unit) */
	float constant_detail() { /* not implemented */ throw NULL; }
	/** Setter: Maximum edge length for dynamic topology sculpting (as percentage of blender unit) */
	void constant_detail(float value) {
		PyObject_SetAttrString(pyobjref, "constant_detail", Py_BuildValue("f", value));
	}

	/** Getter: Show faces in dynamic-topology mode with smooth shading rather than flat shaded */
	bool use_smooth_shading() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_smooth_shading")) == 1;
	}

	/** Setter: Show faces in dynamic-topology mode with smooth shading rather than flat shaded */
	void use_smooth_shading(bool value) {
		PyObject_SetAttrString(pyobjref, "use_smooth_shading", Py_BuildValue("i", value));
	}

	enum symmetrize_direction_enum {
		symmetrize_direction_NEGATIVE_X = 0,
		symmetrize_direction_POSITIVE_X = 3,
		symmetrize_direction_NEGATIVE_Y = 1,
		symmetrize_direction_POSITIVE_Y = 4,
		symmetrize_direction_NEGATIVE_Z = 2,
		symmetrize_direction_POSITIVE_Z = 5,
	};

	/** Getter: Source and destination for symmetrize operator */
	symmetrize_direction_enum symmetrize_direction() { /* not implemented */ throw NULL; }
	/** Setter: Source and destination for symmetrize operator */
	void symmetrize_direction(symmetrize_direction_enum value) { /* not implemented */ }

	enum detail_refine_method_enum {
		detail_refine_method_SUBDIVIDE = 4096,
		detail_refine_method_COLLAPSE = 2048,
		detail_refine_method_SUBDIVIDE_COLLAPSE = 6144,
	};

	/** Getter: In dynamic-topology mode, how to add or remove mesh detail */
	detail_refine_method_enum detail_refine_method() { /* not implemented */ throw NULL; }
	/** Setter: In dynamic-topology mode, how to add or remove mesh detail */
	void detail_refine_method(detail_refine_method_enum value) { /* not implemented */ }

	enum detail_type_method_enum {
		detail_type_method_RELATIVE = 0,
		detail_type_method_CONSTANT = 8192,
		detail_type_method_BRUSH = 16384,
	};

	/** Getter: In dynamic-topology mode, how mesh detail size is calculated */
	detail_type_method_enum detail_type_method() { /* not implemented */ throw NULL; }
	/** Setter: In dynamic-topology mode, how mesh detail size is calculated */
	void detail_type_method(detail_type_method_enum value) { /* not implemented */ }

	/** Getter: Amount of gravity after each dab */
	float gravity() { /* not implemented */ throw NULL; }
	/** Setter: Amount of gravity after each dab */
	void gravity(float value) {
		PyObject_SetAttrString(pyobjref, "gravity", Py_BuildValue("f", value));
	}

	/** Getter: Object whose Z axis defines orientation of gravity */
	Object gravity_object() {
		/* not implemented */ throw NULL;
	}

};

/**************** UV Sculpting ****************/

/**
 * 
 */
class UvSculpt : public Paint {
public:
	UvSculpt(PyObject* pyobj) : Paint(pyobj) {}

	UvSculpt() : Paint(0)
	{
		// not implemented
	}

};

/**************** Vertex Paint ****************/

/**
 * Properties of vertex and weight paint mode
 */
class VertexPaint : public Paint {
public:
	VertexPaint(PyObject* pyobj) : Paint(pyobj) {}

	VertexPaint() : Paint(0)
	{
		// not implemented
	}

	/** Getter: Apply the vertex normal before painting */
	bool use_normal() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_normal")) == 1;
	}

	/** Setter: Apply the vertex normal before painting */
	void use_normal(bool value) {
		PyObject_SetAttrString(pyobjref, "use_normal", Py_BuildValue("i", value));
	}

	/** Getter: Keep applying paint effect while holding mouse */
	bool use_spray() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_spray")) == 1;
	}

	/** Setter: Keep applying paint effect while holding mouse */
	void use_spray(bool value) {
		PyObject_SetAttrString(pyobjref, "use_spray", Py_BuildValue("i", value));
	}

	/** Getter: Restrict painting to vertices in the group */
	bool use_group_restrict() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_group_restrict")) == 1;
	}

	/** Setter: Restrict painting to vertices in the group */
	void use_group_restrict(bool value) {
		PyObject_SetAttrString(pyobjref, "use_group_restrict", Py_BuildValue("i", value));
	}

};

/**************** Image Paint ****************/

/**
 * Properties of image and texture painting mode
 */
class ImagePaint : public Paint {
public:
	ImagePaint(PyObject* pyobj) : Paint(pyobj) {}

	ImagePaint() : Paint(0)
	{
		// not implemented
	}

	/** Getter: Only paint onto the faces directly under the brush (slower) */
	bool use_occlude() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_occlude")) == 1;
	}

	/** Setter: Only paint onto the faces directly under the brush (slower) */
	void use_occlude(bool value) {
		PyObject_SetAttrString(pyobjref, "use_occlude", Py_BuildValue("i", value));
	}

	/** Getter: Ignore faces pointing away from the view (faster) */
	bool use_backface_culling() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_backface_culling")) == 1;
	}

	/** Setter: Ignore faces pointing away from the view (faster) */
	void use_backface_culling(bool value) {
		PyObject_SetAttrString(pyobjref, "use_backface_culling", Py_BuildValue("i", value));
	}

	/** Getter: Paint most on faces pointing towards the view */
	bool use_normal_falloff() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_normal_falloff")) == 1;
	}

	/** Setter: Paint most on faces pointing towards the view */
	void use_normal_falloff(bool value) {
		PyObject_SetAttrString(pyobjref, "use_normal_falloff", Py_BuildValue("i", value));
	}

	/** Getter: Set the mask layer from the UV map buttons */
	bool use_stencil_layer() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_stencil_layer")) == 1;
	}

	/** Setter: Set the mask layer from the UV map buttons */
	void use_stencil_layer(bool value) {
		PyObject_SetAttrString(pyobjref, "use_stencil_layer", Py_BuildValue("i", value));
	}

	/** Getter: Invert the stencil layer */
	bool invert_stencil() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "invert_stencil")) == 1;
	}

	/** Setter: Invert the stencil layer */
	void invert_stencil(bool value) {
		PyObject_SetAttrString(pyobjref, "invert_stencil", Py_BuildValue("i", value));
	}

	/** Getter: Image used as stencil */
	Image stencil_image() {
		/* not implemented */ throw NULL;
	}

	/** Getter: Image used as canvas */
	Image canvas() {
		/* not implemented */ throw NULL;
	}

	/** Getter: Image used as clone source */
	Image clone_image() {
		/* not implemented */ throw NULL;
	}

	/** Getter: Stencil color in the viewport */
	std::array<float, 3> stencil_color() {
		// TODO: MISSING DEREF! USE #DEFINE!
		PyObject *seqval = PyObject_GetAttrString(pyobjref, "stencil_color");
		std::array<float, 3> resarr;
		for (int i = 0; i < 3; i++)
			resarr[i] = (float)PyFloat_AsDouble(PySequence_GetItem(seqval, i));
		return resarr;
	}

	/** Setter: Stencil color in the viewport */
	void stencil_color(float values[3]) { /* not implemented */ }

	/** Getter: Amount of dithering when painting on byte images */
	float dither() { /* not implemented */ throw NULL; }
	/** Setter: Amount of dithering when painting on byte images */
	void dither(float value) {
		PyObject_SetAttrString(pyobjref, "dither", Py_BuildValue("f", value));
	}

	/** Getter: Use another UV map as clone source, otherwise use the 3D cursor as the source */
	bool use_clone_layer() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_clone_layer")) == 1;
	}

	/** Setter: Use another UV map as clone source, otherwise use the 3D cursor as the source */
	void use_clone_layer(bool value) {
		PyObject_SetAttrString(pyobjref, "use_clone_layer", Py_BuildValue("i", value));
	}

	/** Getter: Extend paint beyond the faces UVs to reduce seams (in pixels, slower) */
	int seam_bleed() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "seam_bleed"));
	}

	/** Setter: Extend paint beyond the faces UVs to reduce seams (in pixels, slower) */
	void seam_bleed(int value) {
		PyObject_SetAttrString(pyobjref, "seam_bleed", Py_BuildValue("i", value));
	}

	/** Getter: Paint most on faces pointing towards the view according to this angle */
	int normal_angle() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "normal_angle"));
	}

	/** Setter: Paint most on faces pointing towards the view according to this angle */
	void normal_angle(int value) {
		PyObject_SetAttrString(pyobjref, "normal_angle", Py_BuildValue("i", value));
	}

	/** Getter: Size to capture the image for re-projecting */
	std::array<int, 2> screen_grab_size() {
		// TODO: MISSING DEREF! USE #DEFINE!
		PyObject *seqval = PyObject_GetAttrString(pyobjref, "screen_grab_size");
		std::array<int, 2> resarr;
		for (int i = 0; i < 2; i++)
			resarr[i] = PyLong_AsLong(PySequence_GetItem(seqval, i));
		return resarr;
	}

	/** Setter: Size to capture the image for re-projecting */
	void screen_grab_size(int values[2]) { /* not implemented */ }

	enum mode_enum {
		mode_MATERIAL = 0,
		mode_IMAGE = 1,
	};

	/** Getter: Mode of operation for projection painting */
	mode_enum mode() { /* not implemented */ throw NULL; }
	/** Setter: Mode of operation for projection painting */
	void mode(mode_enum value) { /* not implemented */ }

	/** Getter: A UV layer is missing on the mesh */
	bool missing_uvs() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "missing_uvs")) == 1;
	}

	/** Setter: A UV layer is missing on the mesh */
	void missing_uvs(bool value) {
		PyObject_SetAttrString(pyobjref, "missing_uvs", Py_BuildValue("i", value));
	}

	/** Getter: The mesh is missing materials */
	bool missing_materials() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "missing_materials")) == 1;
	}

	/** Setter: The mesh is missing materials */
	void missing_materials(bool value) {
		PyObject_SetAttrString(pyobjref, "missing_materials", Py_BuildValue("i", value));
	}

	/** Getter: Image Painting does not have a stencil */
	bool missing_stencil() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "missing_stencil")) == 1;
	}

	/** Setter: Image Painting does not have a stencil */
	void missing_stencil(bool value) {
		PyObject_SetAttrString(pyobjref, "missing_stencil", Py_BuildValue("i", value));
	}

	/** Getter: Image Painting does not have a texture to paint on */
	bool missing_texture() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "missing_texture")) == 1;
	}

	/** Setter: Image Painting does not have a texture to paint on */
	void missing_texture(bool value) {
		PyObject_SetAttrString(pyobjref, "missing_texture", Py_BuildValue("i", value));
	}

	/**
	 * Check if required texpaint data exist
	 * @return 
	 */
	bool detect_data()
	{
		// not implemented
		return true;
	}

};

/**************** Particle Edit ****************/

/**
 * Properties of particle editing mode
 */
class ParticleEdit : public pyUniplug {
public:
	ParticleEdit(PyObject* pyobj) : pyUniplug(pyobj) {}

	ParticleEdit() : pyUniplug(0)
	{
		// not implemented
	}

	enum tool_enum {
		tool_NONE = -1,
		tool_COMB = 0,
		tool_SMOOTH = 5,
		tool_ADD = 4,
		tool_LENGTH = 2,
		tool_PUFF = 3,
		tool_CUT = 1,
		tool_WEIGHT = 6,
	};

	/** Getter:  */
	tool_enum tool() { /* not implemented */ throw NULL; }
	/** Setter:  */
	void tool(tool_enum value) { /* not implemented */ }

	enum select_mode_enum {
		select_mode_PATH = 1,
		select_mode_POINT = 2,
		select_mode_TIP = 4,
	};

	/** Getter: Particle select and display mode */
	select_mode_enum select_mode() { /* not implemented */ throw NULL; }
	/** Setter: Particle select and display mode */
	void select_mode(select_mode_enum value) { /* not implemented */ }

	/** Getter: Keep path lengths constant */
	bool use_preserve_length() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_preserve_length")) == 1;
	}

	/** Setter: Keep path lengths constant */
	void use_preserve_length(bool value) {
		PyObject_SetAttrString(pyobjref, "use_preserve_length", Py_BuildValue("i", value));
	}

	/** Getter: Keep root keys unmodified */
	bool use_preserve_root() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_preserve_root")) == 1;
	}

	/** Setter: Keep root keys unmodified */
	void use_preserve_root(bool value) {
		PyObject_SetAttrString(pyobjref, "use_preserve_root", Py_BuildValue("i", value));
	}

	/** Getter: Keep paths from intersecting the emitter */
	bool use_emitter_deflect() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_emitter_deflect")) == 1;
	}

	/** Setter: Keep paths from intersecting the emitter */
	void use_emitter_deflect(bool value) {
		PyObject_SetAttrString(pyobjref, "use_emitter_deflect", Py_BuildValue("i", value));
	}

	/** Getter: Distance to keep particles away from the emitter */
	float emitter_distance() { /* not implemented */ throw NULL; }
	/** Setter: Distance to keep particles away from the emitter */
	void emitter_distance(float value) {
		PyObject_SetAttrString(pyobjref, "emitter_distance", Py_BuildValue("f", value));
	}

	/** Getter: Fade paths and keys further away from current frame */
	bool use_fade_time() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_fade_time")) == 1;
	}

	/** Setter: Fade paths and keys further away from current frame */
	void use_fade_time(bool value) {
		PyObject_SetAttrString(pyobjref, "use_fade_time", Py_BuildValue("i", value));
	}

	/** Getter: Calculate point velocities automatically */
	bool use_auto_velocity() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_auto_velocity")) == 1;
	}

	/** Setter: Calculate point velocities automatically */
	void use_auto_velocity(bool value) {
		PyObject_SetAttrString(pyobjref, "use_auto_velocity", Py_BuildValue("i", value));
	}

	/** Getter: Draw actual particles */
	bool show_particles() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "show_particles")) == 1;
	}

	/** Setter: Draw actual particles */
	void show_particles(bool value) {
		PyObject_SetAttrString(pyobjref, "show_particles", Py_BuildValue("i", value));
	}

	/** Getter: Interpolate new particles from the existing ones */
	bool use_default_interpolate() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_default_interpolate")) == 1;
	}

	/** Setter: Interpolate new particles from the existing ones */
	void use_default_interpolate(bool value) {
		PyObject_SetAttrString(pyobjref, "use_default_interpolate", Py_BuildValue("i", value));
	}

	/** Getter: How many keys to make new particles with */
	int default_key_count() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "default_key_count"));
	}

	/** Setter: How many keys to make new particles with */
	void default_key_count(int value) {
		PyObject_SetAttrString(pyobjref, "default_key_count", Py_BuildValue("i", value));
	}

	/** Getter:  */
	ParticleBrush brush();

	/** Getter: How many steps to draw the path with */
	int draw_step() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "draw_step"));
	}

	/** Setter: How many steps to draw the path with */
	void draw_step(int value) {
		PyObject_SetAttrString(pyobjref, "draw_step", Py_BuildValue("i", value));
	}

	/** Getter: How many frames to fade */
	int fade_frames() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "fade_frames"));
	}

	/** Setter: How many frames to fade */
	void fade_frames(int value) {
		PyObject_SetAttrString(pyobjref, "fade_frames", Py_BuildValue("i", value));
	}

	enum type_enum {
		type_PARTICLES = 0,
		type_SOFT_BODY = 1,
		type_CLOTH = 2,
	};

	/** Getter:  */
	type_enum type() { /* not implemented */ throw NULL; }
	/** Setter:  */
	void type(type_enum value) { /* not implemented */ }

	/** Getter: A valid edit mode exists */
	bool is_editable() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "is_editable")) == 1;
	}

	/** Setter: A valid edit mode exists */
	void is_editable(bool value) {
		PyObject_SetAttrString(pyobjref, "is_editable", Py_BuildValue("i", value));
	}

	/** Getter: Editing hair */
	bool is_hair() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "is_hair")) == 1;
	}

	/** Setter: Editing hair */
	void is_hair(bool value) {
		PyObject_SetAttrString(pyobjref, "is_hair", Py_BuildValue("i", value));
	}

	/** Getter: The edited object */
	Object object_value() {
		/* not implemented */ throw NULL;
	}

	/** Getter: Outer shape to use for tools */
	Object shape_object() {
		/* not implemented */ throw NULL;
	}

};

/**************** Particle Brush ****************/

/**
 * Particle editing brush
 */
class ParticleBrush : public pyUniplug {
public:
	ParticleBrush(PyObject* pyobj) : pyUniplug(pyobj) {}

	ParticleBrush() : pyUniplug(0)
	{
		// not implemented
	}

	/** Getter: Radius of the brush in pixels */
	int size() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "size"));
	}

	/** Setter: Radius of the brush in pixels */
	void size(int value) {
		PyObject_SetAttrString(pyobjref, "size", Py_BuildValue("i", value));
	}

	/** Getter: Brush strength */
	float strength() { /* not implemented */ throw NULL; }
	/** Setter: Brush strength */
	void strength(float value) {
		PyObject_SetAttrString(pyobjref, "strength", Py_BuildValue("f", value));
	}

	/** Getter: Particle count */
	int count() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "count"));
	}

	/** Setter: Particle count */
	void count(int value) {
		PyObject_SetAttrString(pyobjref, "count", Py_BuildValue("i", value));
	}

	/** Getter: Brush steps */
	int steps() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "steps"));
	}

	/** Setter: Brush steps */
	void steps(int value) {
		PyObject_SetAttrString(pyobjref, "steps", Py_BuildValue("i", value));
	}

	enum puff_mode_enum {
		puff_mode_ADD = 0,
		puff_mode_SUB = 1,
	};

	/** Getter:  */
	puff_mode_enum puff_mode() { /* not implemented */ throw NULL; }
	/** Setter:  */
	void puff_mode(puff_mode_enum value) { /* not implemented */ }

	/** Getter: Apply puff to unselected end-points (helps maintain hair volume when puffing root) */
	bool use_puff_volume() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_puff_volume")) == 1;
	}

	/** Setter: Apply puff to unselected end-points (helps maintain hair volume when puffing root) */
	void use_puff_volume(bool value) {
		PyObject_SetAttrString(pyobjref, "use_puff_volume", Py_BuildValue("i", value));
	}

	enum length_mode_enum {
		length_mode_GROW = 0,
		length_mode_SHRINK = 1,
	};

	/** Getter:  */
	length_mode_enum length_mode() { /* not implemented */ throw NULL; }
	/** Setter:  */
	void length_mode(length_mode_enum value) { /* not implemented */ }

	/** Getter:  */
	CurveMapping curve() {
		/* not implemented */ throw NULL;
	}

};

/**************** Sensor ****************/

/**
 * Game engine logic brick to detect events
 */
class Sensor : public pyUniplug {
public:
	Sensor(PyObject* pyobj) : pyUniplug(pyobj) {}

	Sensor() : pyUniplug(0)
	{
		// not implemented
	}

	/** Getter: Sensor name */
	std::string name() { /* not implemented */ throw NULL; }
	/** Setter: Sensor name */
	void name(const std::string& value) { /* not implemented */ }

	enum type_enum {
		type_ACTUATOR = 12,
		type_ALWAYS = 0,
		type_ARMATURE = 14,
		type_COLLISION = 6,
		type_DELAY = 13,
		type_JOYSTICK = 11,
		type_KEYBOARD = 3,
		type_MESSAGE = 10,
		type_MOUSE = 5,
		type_NEAR = 2,
		type_PROPERTY = 4,
		type_RADAR = 7,
		type_RANDOM = 8,
		type_RAY = 9,
	};

	/** Getter:  */
	type_enum type() { /* not implemented */ throw NULL; }
	/** Setter:  */
	void type(type_enum value) { /* not implemented */ }

	/** Getter: Display when not linked to a visible states controller */
	bool pin() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "pin")) == 1;
	}

	/** Setter: Display when not linked to a visible states controller */
	void pin(bool value) {
		PyObject_SetAttrString(pyobjref, "pin", Py_BuildValue("i", value));
	}

	/** Getter: Set active state of the sensor */
	bool active() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "active")) == 1;
	}

	/** Setter: Set active state of the sensor */
	void active(bool value) {
		PyObject_SetAttrString(pyobjref, "active", Py_BuildValue("i", value));
	}

	/** Getter: Set sensor expanded in the user interface */
	bool show_expanded() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "show_expanded")) == 1;
	}

	/** Setter: Set sensor expanded in the user interface */
	void show_expanded(bool value) {
		PyObject_SetAttrString(pyobjref, "show_expanded", Py_BuildValue("i", value));
	}

	/** Getter: Invert the level(output) of this sensor */
	bool invert() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "invert")) == 1;
	}

	/** Setter: Invert the level(output) of this sensor */
	void invert(bool value) {
		PyObject_SetAttrString(pyobjref, "invert", Py_BuildValue("i", value));
	}

	/** Getter: Level detector, trigger controllers of new states (only applicable upon logic state transition) */
	bool use_level() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_level")) == 1;
	}

	/** Setter: Level detector, trigger controllers of new states (only applicable upon logic state transition) */
	void use_level(bool value) {
		PyObject_SetAttrString(pyobjref, "use_level", Py_BuildValue("i", value));
	}

	/** Getter: Activate TRUE level triggering (pulse mode) */
	bool use_pulse_true_level() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_pulse_true_level")) == 1;
	}

	/** Setter: Activate TRUE level triggering (pulse mode) */
	void use_pulse_true_level(bool value) {
		PyObject_SetAttrString(pyobjref, "use_pulse_true_level", Py_BuildValue("i", value));
	}

	/** Getter: Activate FALSE level triggering (pulse mode) */
	bool use_pulse_false_level() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_pulse_false_level")) == 1;
	}

	/** Setter: Activate FALSE level triggering (pulse mode) */
	void use_pulse_false_level(bool value) {
		PyObject_SetAttrString(pyobjref, "use_pulse_false_level", Py_BuildValue("i", value));
	}

	/** Getter: Number of logic ticks skipped between 2 active pulses (0 = pulse every logic tick, 1 = skip 1 logic tick between pulses, etc.) */
	int tick_skip() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "tick_skip"));
	}

	/** Setter: Number of logic ticks skipped between 2 active pulses (0 = pulse every logic tick, 1 = skip 1 logic tick between pulses, etc.) */
	void tick_skip(int value) {
		PyObject_SetAttrString(pyobjref, "tick_skip", Py_BuildValue("i", value));
	}

	/** Getter: Trigger controllers only for an instant, even while the sensor remains true */
	bool use_tap() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_tap")) == 1;
	}

	/** Setter: Trigger controllers only for an instant, even while the sensor remains true */
	void use_tap(bool value) {
		PyObject_SetAttrString(pyobjref, "use_tap", Py_BuildValue("i", value));
	}

	/** Getter: The list containing the controllers connected to the sensor */
	std::map<std::string, Controller> controllers() {
		// TODO: MISSING DEREF! USE #DEFINE!
		PyObject *seqval = PyObject_GetAttrString(pyobjref, "controllers");
		PyObject *seqkeys = PyObject_CallMethod(seqval, "keys", NULL);
		std::map<std::string, Controller> resmap;
		for (int i = 0; i < PySequence_Length(seqval); i++) {
			PyObject *keyobj = PySequence_GetItem(seqkeys, i);
			std::string key = PyBytes_AsString(PyUnicode_AsASCIIString(keyobj));
			Controller value = Controller(PySequence_GetItem(seqval, i));
			resmap.insert(std::pair<std::string,Controller>(key, value));
		}
		return resmap;
	}

	/** Setter: The list containing the controllers connected to the sensor */
	void controllers(std::map<std::string, Controller> value) { /* not implemented */ }

	/**
	 * Link the sensor to a controller
	 * @param Controller to link to
	 */
	void link(Controller controller)
	{
		// not implemented
	}

	/**
	 * Unlink the sensor from a controller
	 * @param Controller to unlink from
	 */
	void unlink(Controller controller)
	{
		// not implemented
	}

};

/**************** Always Sensor ****************/

/**
 * Sensor to generate continuous pulses
 */
class AlwaysSensor : public Sensor {
public:
	AlwaysSensor(PyObject* pyobj) : Sensor(pyobj) {}

	AlwaysSensor() : Sensor(0)
	{
		// not implemented
	}

};

/**************** Near Sensor ****************/

/**
 * Sensor to detect nearby objects
 */
class NearSensor : public Sensor {
public:
	NearSensor(PyObject* pyobj) : Sensor(pyobj) {}

	NearSensor() : Sensor(0)
	{
		// not implemented
	}

	/** Getter: Only look for objects with this property (blank = all objects) */
	std::string property() { /* not implemented */ throw NULL; }
	/** Setter: Only look for objects with this property (blank = all objects) */
	void property(const std::string& value) { /* not implemented */ }

	/** Getter: Trigger distance */
	float distance() { /* not implemented */ throw NULL; }
	/** Setter: Trigger distance */
	void distance(float value) {
		PyObject_SetAttrString(pyobjref, "distance", Py_BuildValue("f", value));
	}

	/** Getter: The distance where the sensor forgets the actor */
	float reset_distance() { /* not implemented */ throw NULL; }
	/** Setter: The distance where the sensor forgets the actor */
	void reset_distance(float value) {
		PyObject_SetAttrString(pyobjref, "reset_distance", Py_BuildValue("f", value));
	}

};

/**************** Mouse Sensor ****************/

/**
 * Sensor to detect mouse events
 */
class MouseSensor : public Sensor {
public:
	MouseSensor(PyObject* pyobj) : Sensor(pyobj) {}

	MouseSensor() : Sensor(0)
	{
		// not implemented
	}

	enum mouse_event_enum {
		mouse_event_LEFTCLICK = 1,
		mouse_event_MIDDLECLICK = 2,
		mouse_event_RIGHTCLICK = 4,
		mouse_event_WHEELUP = 5,
		mouse_event_WHEELDOWN = 6,
		mouse_event_MOVEMENT = 8,
		mouse_event_MOUSEOVER = 16,
		mouse_event_MOUSEOVERANY = 32,
	};

	/** Getter: Type of event this mouse sensor should trigger on */
	mouse_event_enum mouse_event() { /* not implemented */ throw NULL; }
	/** Setter: Type of event this mouse sensor should trigger on */
	void mouse_event(mouse_event_enum value) { /* not implemented */ }

	/** Getter: Moving the mouse over a different object generates a pulse */
	bool use_pulse() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_pulse")) == 1;
	}

	/** Setter: Moving the mouse over a different object generates a pulse */
	void use_pulse(bool value) {
		PyObject_SetAttrString(pyobjref, "use_pulse", Py_BuildValue("i", value));
	}

	enum use_material_enum {
		use_material_PROPERTY = 0,
		use_material_MATERIAL = 1,
	};

	/** Getter: Toggle collision on material or property */
	use_material_enum use_material() { /* not implemented */ throw NULL; }
	/** Setter: Toggle collision on material or property */
	void use_material(use_material_enum value) { /* not implemented */ }

	/** Getter: Only look for objects with this property (blank = all objects) */
	std::string property() { /* not implemented */ throw NULL; }
	/** Setter: Only look for objects with this property (blank = all objects) */
	void property(const std::string& value) { /* not implemented */ }

	/** Getter: Only look for objects with this material (blank = all objects) */
	std::string material() { /* not implemented */ throw NULL; }
	/** Setter: Only look for objects with this material (blank = all objects) */
	void material(const std::string& value) { /* not implemented */ }

	/** Getter: Toggle X-Ray option (see through objects that don't have the property) */
	bool use_x_ray() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_x_ray")) == 1;
	}

	/** Setter: Toggle X-Ray option (see through objects that don't have the property) */
	void use_x_ray(bool value) {
		PyObject_SetAttrString(pyobjref, "use_x_ray", Py_BuildValue("i", value));
	}

};

/**************** Keyboard Sensor ****************/

/**
 * Sensor to detect keyboard events
 */
class KeyboardSensor : public Sensor {
public:
	KeyboardSensor(PyObject* pyobj) : Sensor(pyobj) {}

	KeyboardSensor() : Sensor(0)
	{
		// not implemented
	}

	enum key_enum {
		key_NONE = 0,
		key_LEFTMOUSE = 1,
		key_MIDDLEMOUSE = 2,
		key_RIGHTMOUSE = 3,
		key_BUTTON4MOUSE = 7,
		key_BUTTON5MOUSE = 8,
		key_BUTTON6MOUSE = 18,
		key_BUTTON7MOUSE = 19,
		key_ACTIONMOUSE = 5,
		key_SELECTMOUSE = 6,
		key_MOUSEMOVE = 4,
		key_INBETWEEN_MOUSEMOVE = 17,
		key_TRACKPADPAN = 14,
		key_TRACKPADZOOM = 15,
		key_MOUSEROTATE = 16,
		key_WHEELUPMOUSE = 10,
		key_WHEELDOWNMOUSE = 11,
		key_WHEELINMOUSE = 12,
		key_WHEELOUTMOUSE = 13,
		key_EVT_TWEAK_L = 20482,
		key_EVT_TWEAK_M = 20483,
		key_EVT_TWEAK_R = 20484,
		key_EVT_TWEAK_A = 20485,
		key_EVT_TWEAK_S = 20486,
		key_A = 97,
		key_B = 98,
		key_C = 99,
		key_D = 100,
		key_E = 101,
		key_F = 102,
		key_G = 103,
		key_H = 104,
		key_I = 105,
		key_J = 106,
		key_K = 107,
		key_L = 108,
		key_M = 109,
		key_N = 110,
		key_O = 111,
		key_P = 112,
		key_Q = 113,
		key_R = 114,
		key_S = 115,
		key_T = 116,
		key_U = 117,
		key_V = 118,
		key_W = 119,
		key_X = 120,
		key_Y = 121,
		key_Z = 122,
		key_ZERO = 48,
		key_ONE = 49,
		key_TWO = 50,
		key_THREE = 51,
		key_FOUR = 52,
		key_FIVE = 53,
		key_SIX = 54,
		key_SEVEN = 55,
		key_EIGHT = 56,
		key_NINE = 57,
		key_LEFT_CTRL = 212,
		key_LEFT_ALT = 213,
		key_LEFT_SHIFT = 217,
		key_RIGHT_ALT = 214,
		key_RIGHT_CTRL = 215,
		key_RIGHT_SHIFT = 216,
		key_OSKEY = 172,
		key_GRLESS = 173,
		key_ESC = 218,
		key_TAB = 219,
		key_RET = 220,
		key_SPACE = 221,
		key_LINE_FEED = 222,
		key_BACK_SPACE = 223,
		key_DEL = 224,
		key_SEMI_COLON = 225,
		key_PERIOD = 226,
		key_COMMA = 227,
		key_QUOTE = 228,
		key_ACCENT_GRAVE = 229,
		key_MINUS = 230,
		key_SLASH = 232,
		key_BACK_SLASH = 233,
		key_EQUAL = 234,
		key_LEFT_BRACKET = 235,
		key_RIGHT_BRACKET = 236,
		key_LEFT_ARROW = 137,
		key_DOWN_ARROW = 138,
		key_RIGHT_ARROW = 139,
		key_UP_ARROW = 140,
		key_NUMPAD_2 = 152,
		key_NUMPAD_4 = 154,
		key_NUMPAD_6 = 156,
		key_NUMPAD_8 = 158,
		key_NUMPAD_1 = 151,
		key_NUMPAD_3 = 153,
		key_NUMPAD_5 = 155,
		key_NUMPAD_7 = 157,
		key_NUMPAD_9 = 159,
		key_NUMPAD_PERIOD = 199,
		key_NUMPAD_SLASH = 161,
		key_NUMPAD_ASTERIX = 160,
		key_NUMPAD_0 = 150,
		key_NUMPAD_MINUS = 162,
		key_NUMPAD_ENTER = 163,
		key_NUMPAD_PLUS = 164,
		key_F1 = 300,
		key_F2 = 301,
		key_F3 = 302,
		key_F4 = 303,
		key_F5 = 304,
		key_F6 = 305,
		key_F7 = 306,
		key_F8 = 307,
		key_F9 = 308,
		key_F10 = 309,
		key_F11 = 310,
		key_F12 = 311,
		key_F13 = 312,
		key_F14 = 313,
		key_F15 = 314,
		key_F16 = 315,
		key_F17 = 316,
		key_F18 = 317,
		key_F19 = 318,
		key_PAUSE = 165,
		key_INSERT = 166,
		key_HOME = 167,
		key_PAGE_UP = 168,
		key_PAGE_DOWN = 169,
		key_END = 170,
		key_MEDIA_PLAY = 174,
		key_MEDIA_STOP = 175,
		key_MEDIA_FIRST = 176,
		key_MEDIA_LAST = 177,
		key_TEXTINPUT = -2,
		key_WINDOW_DEACTIVATE = 260,
		key_TIMER = 272,
		key_TIMER0 = 273,
		key_TIMER1 = 274,
		key_TIMER2 = 275,
		key_TIMER_JOBS = 276,
		key_TIMER_AUTOSAVE = 277,
		key_TIMER_REPORT = 278,
		key_TIMERREGION = 279,
		key_NDOF_MOTION = 400,
		key_NDOF_BUTTON_MENU = 401,
		key_NDOF_BUTTON_FIT = 402,
		key_NDOF_BUTTON_TOP = 403,
		key_NDOF_BUTTON_BOTTOM = 404,
		key_NDOF_BUTTON_LEFT = 405,
		key_NDOF_BUTTON_RIGHT = 406,
		key_NDOF_BUTTON_FRONT = 407,
		key_NDOF_BUTTON_BACK = 408,
		key_NDOF_BUTTON_ISO1 = 409,
		key_NDOF_BUTTON_ISO2 = 410,
		key_NDOF_BUTTON_ROLL_CW = 411,
		key_NDOF_BUTTON_ROLL_CCW = 412,
		key_NDOF_BUTTON_SPIN_CW = 413,
		key_NDOF_BUTTON_SPIN_CCW = 414,
		key_NDOF_BUTTON_TILT_CW = 415,
		key_NDOF_BUTTON_TILT_CCW = 416,
		key_NDOF_BUTTON_ROTATE = 417,
		key_NDOF_BUTTON_PANZOOM = 418,
		key_NDOF_BUTTON_DOMINANT = 419,
		key_NDOF_BUTTON_PLUS = 420,
		key_NDOF_BUTTON_MINUS = 421,
		key_NDOF_BUTTON_ESC = 422,
		key_NDOF_BUTTON_ALT = 423,
		key_NDOF_BUTTON_SHIFT = 424,
		key_NDOF_BUTTON_CTRL = 425,
		key_NDOF_BUTTON_1 = 426,
		key_NDOF_BUTTON_2 = 427,
		key_NDOF_BUTTON_3 = 428,
		key_NDOF_BUTTON_4 = 429,
		key_NDOF_BUTTON_5 = 430,
		key_NDOF_BUTTON_6 = 431,
		key_NDOF_BUTTON_7 = 432,
		key_NDOF_BUTTON_8 = 433,
		key_NDOF_BUTTON_9 = 434,
		key_NDOF_BUTTON_10 = 435,
		key_NDOF_BUTTON_A = 436,
		key_NDOF_BUTTON_B = 437,
		key_NDOF_BUTTON_C = 438,
	};

	/** Getter:  */
	key_enum key() { /* not implemented */ throw NULL; }
	/** Setter:  */
	void key(key_enum value) { /* not implemented */ }

	enum modifier_key_1_enum {
		modifier_key_1_NONE = 0,
		modifier_key_1_LEFTMOUSE = 1,
		modifier_key_1_MIDDLEMOUSE = 2,
		modifier_key_1_RIGHTMOUSE = 3,
		modifier_key_1_BUTTON4MOUSE = 7,
		modifier_key_1_BUTTON5MOUSE = 8,
		modifier_key_1_BUTTON6MOUSE = 18,
		modifier_key_1_BUTTON7MOUSE = 19,
		modifier_key_1_ACTIONMOUSE = 5,
		modifier_key_1_SELECTMOUSE = 6,
		modifier_key_1_MOUSEMOVE = 4,
		modifier_key_1_INBETWEEN_MOUSEMOVE = 17,
		modifier_key_1_TRACKPADPAN = 14,
		modifier_key_1_TRACKPADZOOM = 15,
		modifier_key_1_MOUSEROTATE = 16,
		modifier_key_1_WHEELUPMOUSE = 10,
		modifier_key_1_WHEELDOWNMOUSE = 11,
		modifier_key_1_WHEELINMOUSE = 12,
		modifier_key_1_WHEELOUTMOUSE = 13,
		modifier_key_1_EVT_TWEAK_L = 20482,
		modifier_key_1_EVT_TWEAK_M = 20483,
		modifier_key_1_EVT_TWEAK_R = 20484,
		modifier_key_1_EVT_TWEAK_A = 20485,
		modifier_key_1_EVT_TWEAK_S = 20486,
		modifier_key_1_A = 97,
		modifier_key_1_B = 98,
		modifier_key_1_C = 99,
		modifier_key_1_D = 100,
		modifier_key_1_E = 101,
		modifier_key_1_F = 102,
		modifier_key_1_G = 103,
		modifier_key_1_H = 104,
		modifier_key_1_I = 105,
		modifier_key_1_J = 106,
		modifier_key_1_K = 107,
		modifier_key_1_L = 108,
		modifier_key_1_M = 109,
		modifier_key_1_N = 110,
		modifier_key_1_O = 111,
		modifier_key_1_P = 112,
		modifier_key_1_Q = 113,
		modifier_key_1_R = 114,
		modifier_key_1_S = 115,
		modifier_key_1_T = 116,
		modifier_key_1_U = 117,
		modifier_key_1_V = 118,
		modifier_key_1_W = 119,
		modifier_key_1_X = 120,
		modifier_key_1_Y = 121,
		modifier_key_1_Z = 122,
		modifier_key_1_ZERO = 48,
		modifier_key_1_ONE = 49,
		modifier_key_1_TWO = 50,
		modifier_key_1_THREE = 51,
		modifier_key_1_FOUR = 52,
		modifier_key_1_FIVE = 53,
		modifier_key_1_SIX = 54,
		modifier_key_1_SEVEN = 55,
		modifier_key_1_EIGHT = 56,
		modifier_key_1_NINE = 57,
		modifier_key_1_LEFT_CTRL = 212,
		modifier_key_1_LEFT_ALT = 213,
		modifier_key_1_LEFT_SHIFT = 217,
		modifier_key_1_RIGHT_ALT = 214,
		modifier_key_1_RIGHT_CTRL = 215,
		modifier_key_1_RIGHT_SHIFT = 216,
		modifier_key_1_OSKEY = 172,
		modifier_key_1_GRLESS = 173,
		modifier_key_1_ESC = 218,
		modifier_key_1_TAB = 219,
		modifier_key_1_RET = 220,
		modifier_key_1_SPACE = 221,
		modifier_key_1_LINE_FEED = 222,
		modifier_key_1_BACK_SPACE = 223,
		modifier_key_1_DEL = 224,
		modifier_key_1_SEMI_COLON = 225,
		modifier_key_1_PERIOD = 226,
		modifier_key_1_COMMA = 227,
		modifier_key_1_QUOTE = 228,
		modifier_key_1_ACCENT_GRAVE = 229,
		modifier_key_1_MINUS = 230,
		modifier_key_1_SLASH = 232,
		modifier_key_1_BACK_SLASH = 233,
		modifier_key_1_EQUAL = 234,
		modifier_key_1_LEFT_BRACKET = 235,
		modifier_key_1_RIGHT_BRACKET = 236,
		modifier_key_1_LEFT_ARROW = 137,
		modifier_key_1_DOWN_ARROW = 138,
		modifier_key_1_RIGHT_ARROW = 139,
		modifier_key_1_UP_ARROW = 140,
		modifier_key_1_NUMPAD_2 = 152,
		modifier_key_1_NUMPAD_4 = 154,
		modifier_key_1_NUMPAD_6 = 156,
		modifier_key_1_NUMPAD_8 = 158,
		modifier_key_1_NUMPAD_1 = 151,
		modifier_key_1_NUMPAD_3 = 153,
		modifier_key_1_NUMPAD_5 = 155,
		modifier_key_1_NUMPAD_7 = 157,
		modifier_key_1_NUMPAD_9 = 159,
		modifier_key_1_NUMPAD_PERIOD = 199,
		modifier_key_1_NUMPAD_SLASH = 161,
		modifier_key_1_NUMPAD_ASTERIX = 160,
		modifier_key_1_NUMPAD_0 = 150,
		modifier_key_1_NUMPAD_MINUS = 162,
		modifier_key_1_NUMPAD_ENTER = 163,
		modifier_key_1_NUMPAD_PLUS = 164,
		modifier_key_1_F1 = 300,
		modifier_key_1_F2 = 301,
		modifier_key_1_F3 = 302,
		modifier_key_1_F4 = 303,
		modifier_key_1_F5 = 304,
		modifier_key_1_F6 = 305,
		modifier_key_1_F7 = 306,
		modifier_key_1_F8 = 307,
		modifier_key_1_F9 = 308,
		modifier_key_1_F10 = 309,
		modifier_key_1_F11 = 310,
		modifier_key_1_F12 = 311,
		modifier_key_1_F13 = 312,
		modifier_key_1_F14 = 313,
		modifier_key_1_F15 = 314,
		modifier_key_1_F16 = 315,
		modifier_key_1_F17 = 316,
		modifier_key_1_F18 = 317,
		modifier_key_1_F19 = 318,
		modifier_key_1_PAUSE = 165,
		modifier_key_1_INSERT = 166,
		modifier_key_1_HOME = 167,
		modifier_key_1_PAGE_UP = 168,
		modifier_key_1_PAGE_DOWN = 169,
		modifier_key_1_END = 170,
		modifier_key_1_MEDIA_PLAY = 174,
		modifier_key_1_MEDIA_STOP = 175,
		modifier_key_1_MEDIA_FIRST = 176,
		modifier_key_1_MEDIA_LAST = 177,
		modifier_key_1_TEXTINPUT = -2,
		modifier_key_1_WINDOW_DEACTIVATE = 260,
		modifier_key_1_TIMER = 272,
		modifier_key_1_TIMER0 = 273,
		modifier_key_1_TIMER1 = 274,
		modifier_key_1_TIMER2 = 275,
		modifier_key_1_TIMER_JOBS = 276,
		modifier_key_1_TIMER_AUTOSAVE = 277,
		modifier_key_1_TIMER_REPORT = 278,
		modifier_key_1_TIMERREGION = 279,
		modifier_key_1_NDOF_MOTION = 400,
		modifier_key_1_NDOF_BUTTON_MENU = 401,
		modifier_key_1_NDOF_BUTTON_FIT = 402,
		modifier_key_1_NDOF_BUTTON_TOP = 403,
		modifier_key_1_NDOF_BUTTON_BOTTOM = 404,
		modifier_key_1_NDOF_BUTTON_LEFT = 405,
		modifier_key_1_NDOF_BUTTON_RIGHT = 406,
		modifier_key_1_NDOF_BUTTON_FRONT = 407,
		modifier_key_1_NDOF_BUTTON_BACK = 408,
		modifier_key_1_NDOF_BUTTON_ISO1 = 409,
		modifier_key_1_NDOF_BUTTON_ISO2 = 410,
		modifier_key_1_NDOF_BUTTON_ROLL_CW = 411,
		modifier_key_1_NDOF_BUTTON_ROLL_CCW = 412,
		modifier_key_1_NDOF_BUTTON_SPIN_CW = 413,
		modifier_key_1_NDOF_BUTTON_SPIN_CCW = 414,
		modifier_key_1_NDOF_BUTTON_TILT_CW = 415,
		modifier_key_1_NDOF_BUTTON_TILT_CCW = 416,
		modifier_key_1_NDOF_BUTTON_ROTATE = 417,
		modifier_key_1_NDOF_BUTTON_PANZOOM = 418,
		modifier_key_1_NDOF_BUTTON_DOMINANT = 419,
		modifier_key_1_NDOF_BUTTON_PLUS = 420,
		modifier_key_1_NDOF_BUTTON_MINUS = 421,
		modifier_key_1_NDOF_BUTTON_ESC = 422,
		modifier_key_1_NDOF_BUTTON_ALT = 423,
		modifier_key_1_NDOF_BUTTON_SHIFT = 424,
		modifier_key_1_NDOF_BUTTON_CTRL = 425,
		modifier_key_1_NDOF_BUTTON_1 = 426,
		modifier_key_1_NDOF_BUTTON_2 = 427,
		modifier_key_1_NDOF_BUTTON_3 = 428,
		modifier_key_1_NDOF_BUTTON_4 = 429,
		modifier_key_1_NDOF_BUTTON_5 = 430,
		modifier_key_1_NDOF_BUTTON_6 = 431,
		modifier_key_1_NDOF_BUTTON_7 = 432,
		modifier_key_1_NDOF_BUTTON_8 = 433,
		modifier_key_1_NDOF_BUTTON_9 = 434,
		modifier_key_1_NDOF_BUTTON_10 = 435,
		modifier_key_1_NDOF_BUTTON_A = 436,
		modifier_key_1_NDOF_BUTTON_B = 437,
		modifier_key_1_NDOF_BUTTON_C = 438,
	};

	/** Getter: Modifier key code */
	modifier_key_1_enum modifier_key_1() { /* not implemented */ throw NULL; }
	/** Setter: Modifier key code */
	void modifier_key_1(modifier_key_1_enum value) { /* not implemented */ }

	enum modifier_key_2_enum {
		modifier_key_2_NONE = 0,
		modifier_key_2_LEFTMOUSE = 1,
		modifier_key_2_MIDDLEMOUSE = 2,
		modifier_key_2_RIGHTMOUSE = 3,
		modifier_key_2_BUTTON4MOUSE = 7,
		modifier_key_2_BUTTON5MOUSE = 8,
		modifier_key_2_BUTTON6MOUSE = 18,
		modifier_key_2_BUTTON7MOUSE = 19,
		modifier_key_2_ACTIONMOUSE = 5,
		modifier_key_2_SELECTMOUSE = 6,
		modifier_key_2_MOUSEMOVE = 4,
		modifier_key_2_INBETWEEN_MOUSEMOVE = 17,
		modifier_key_2_TRACKPADPAN = 14,
		modifier_key_2_TRACKPADZOOM = 15,
		modifier_key_2_MOUSEROTATE = 16,
		modifier_key_2_WHEELUPMOUSE = 10,
		modifier_key_2_WHEELDOWNMOUSE = 11,
		modifier_key_2_WHEELINMOUSE = 12,
		modifier_key_2_WHEELOUTMOUSE = 13,
		modifier_key_2_EVT_TWEAK_L = 20482,
		modifier_key_2_EVT_TWEAK_M = 20483,
		modifier_key_2_EVT_TWEAK_R = 20484,
		modifier_key_2_EVT_TWEAK_A = 20485,
		modifier_key_2_EVT_TWEAK_S = 20486,
		modifier_key_2_A = 97,
		modifier_key_2_B = 98,
		modifier_key_2_C = 99,
		modifier_key_2_D = 100,
		modifier_key_2_E = 101,
		modifier_key_2_F = 102,
		modifier_key_2_G = 103,
		modifier_key_2_H = 104,
		modifier_key_2_I = 105,
		modifier_key_2_J = 106,
		modifier_key_2_K = 107,
		modifier_key_2_L = 108,
		modifier_key_2_M = 109,
		modifier_key_2_N = 110,
		modifier_key_2_O = 111,
		modifier_key_2_P = 112,
		modifier_key_2_Q = 113,
		modifier_key_2_R = 114,
		modifier_key_2_S = 115,
		modifier_key_2_T = 116,
		modifier_key_2_U = 117,
		modifier_key_2_V = 118,
		modifier_key_2_W = 119,
		modifier_key_2_X = 120,
		modifier_key_2_Y = 121,
		modifier_key_2_Z = 122,
		modifier_key_2_ZERO = 48,
		modifier_key_2_ONE = 49,
		modifier_key_2_TWO = 50,
		modifier_key_2_THREE = 51,
		modifier_key_2_FOUR = 52,
		modifier_key_2_FIVE = 53,
		modifier_key_2_SIX = 54,
		modifier_key_2_SEVEN = 55,
		modifier_key_2_EIGHT = 56,
		modifier_key_2_NINE = 57,
		modifier_key_2_LEFT_CTRL = 212,
		modifier_key_2_LEFT_ALT = 213,
		modifier_key_2_LEFT_SHIFT = 217,
		modifier_key_2_RIGHT_ALT = 214,
		modifier_key_2_RIGHT_CTRL = 215,
		modifier_key_2_RIGHT_SHIFT = 216,
		modifier_key_2_OSKEY = 172,
		modifier_key_2_GRLESS = 173,
		modifier_key_2_ESC = 218,
		modifier_key_2_TAB = 219,
		modifier_key_2_RET = 220,
		modifier_key_2_SPACE = 221,
		modifier_key_2_LINE_FEED = 222,
		modifier_key_2_BACK_SPACE = 223,
		modifier_key_2_DEL = 224,
		modifier_key_2_SEMI_COLON = 225,
		modifier_key_2_PERIOD = 226,
		modifier_key_2_COMMA = 227,
		modifier_key_2_QUOTE = 228,
		modifier_key_2_ACCENT_GRAVE = 229,
		modifier_key_2_MINUS = 230,
		modifier_key_2_SLASH = 232,
		modifier_key_2_BACK_SLASH = 233,
		modifier_key_2_EQUAL = 234,
		modifier_key_2_LEFT_BRACKET = 235,
		modifier_key_2_RIGHT_BRACKET = 236,
		modifier_key_2_LEFT_ARROW = 137,
		modifier_key_2_DOWN_ARROW = 138,
		modifier_key_2_RIGHT_ARROW = 139,
		modifier_key_2_UP_ARROW = 140,
		modifier_key_2_NUMPAD_2 = 152,
		modifier_key_2_NUMPAD_4 = 154,
		modifier_key_2_NUMPAD_6 = 156,
		modifier_key_2_NUMPAD_8 = 158,
		modifier_key_2_NUMPAD_1 = 151,
		modifier_key_2_NUMPAD_3 = 153,
		modifier_key_2_NUMPAD_5 = 155,
		modifier_key_2_NUMPAD_7 = 157,
		modifier_key_2_NUMPAD_9 = 159,
		modifier_key_2_NUMPAD_PERIOD = 199,
		modifier_key_2_NUMPAD_SLASH = 161,
		modifier_key_2_NUMPAD_ASTERIX = 160,
		modifier_key_2_NUMPAD_0 = 150,
		modifier_key_2_NUMPAD_MINUS = 162,
		modifier_key_2_NUMPAD_ENTER = 163,
		modifier_key_2_NUMPAD_PLUS = 164,
		modifier_key_2_F1 = 300,
		modifier_key_2_F2 = 301,
		modifier_key_2_F3 = 302,
		modifier_key_2_F4 = 303,
		modifier_key_2_F5 = 304,
		modifier_key_2_F6 = 305,
		modifier_key_2_F7 = 306,
		modifier_key_2_F8 = 307,
		modifier_key_2_F9 = 308,
		modifier_key_2_F10 = 309,
		modifier_key_2_F11 = 310,
		modifier_key_2_F12 = 311,
		modifier_key_2_F13 = 312,
		modifier_key_2_F14 = 313,
		modifier_key_2_F15 = 314,
		modifier_key_2_F16 = 315,
		modifier_key_2_F17 = 316,
		modifier_key_2_F18 = 317,
		modifier_key_2_F19 = 318,
		modifier_key_2_PAUSE = 165,
		modifier_key_2_INSERT = 166,
		modifier_key_2_HOME = 167,
		modifier_key_2_PAGE_UP = 168,
		modifier_key_2_PAGE_DOWN = 169,
		modifier_key_2_END = 170,
		modifier_key_2_MEDIA_PLAY = 174,
		modifier_key_2_MEDIA_STOP = 175,
		modifier_key_2_MEDIA_FIRST = 176,
		modifier_key_2_MEDIA_LAST = 177,
		modifier_key_2_TEXTINPUT = -2,
		modifier_key_2_WINDOW_DEACTIVATE = 260,
		modifier_key_2_TIMER = 272,
		modifier_key_2_TIMER0 = 273,
		modifier_key_2_TIMER1 = 274,
		modifier_key_2_TIMER2 = 275,
		modifier_key_2_TIMER_JOBS = 276,
		modifier_key_2_TIMER_AUTOSAVE = 277,
		modifier_key_2_TIMER_REPORT = 278,
		modifier_key_2_TIMERREGION = 279,
		modifier_key_2_NDOF_MOTION = 400,
		modifier_key_2_NDOF_BUTTON_MENU = 401,
		modifier_key_2_NDOF_BUTTON_FIT = 402,
		modifier_key_2_NDOF_BUTTON_TOP = 403,
		modifier_key_2_NDOF_BUTTON_BOTTOM = 404,
		modifier_key_2_NDOF_BUTTON_LEFT = 405,
		modifier_key_2_NDOF_BUTTON_RIGHT = 406,
		modifier_key_2_NDOF_BUTTON_FRONT = 407,
		modifier_key_2_NDOF_BUTTON_BACK = 408,
		modifier_key_2_NDOF_BUTTON_ISO1 = 409,
		modifier_key_2_NDOF_BUTTON_ISO2 = 410,
		modifier_key_2_NDOF_BUTTON_ROLL_CW = 411,
		modifier_key_2_NDOF_BUTTON_ROLL_CCW = 412,
		modifier_key_2_NDOF_BUTTON_SPIN_CW = 413,
		modifier_key_2_NDOF_BUTTON_SPIN_CCW = 414,
		modifier_key_2_NDOF_BUTTON_TILT_CW = 415,
		modifier_key_2_NDOF_BUTTON_TILT_CCW = 416,
		modifier_key_2_NDOF_BUTTON_ROTATE = 417,
		modifier_key_2_NDOF_BUTTON_PANZOOM = 418,
		modifier_key_2_NDOF_BUTTON_DOMINANT = 419,
		modifier_key_2_NDOF_BUTTON_PLUS = 420,
		modifier_key_2_NDOF_BUTTON_MINUS = 421,
		modifier_key_2_NDOF_BUTTON_ESC = 422,
		modifier_key_2_NDOF_BUTTON_ALT = 423,
		modifier_key_2_NDOF_BUTTON_SHIFT = 424,
		modifier_key_2_NDOF_BUTTON_CTRL = 425,
		modifier_key_2_NDOF_BUTTON_1 = 426,
		modifier_key_2_NDOF_BUTTON_2 = 427,
		modifier_key_2_NDOF_BUTTON_3 = 428,
		modifier_key_2_NDOF_BUTTON_4 = 429,
		modifier_key_2_NDOF_BUTTON_5 = 430,
		modifier_key_2_NDOF_BUTTON_6 = 431,
		modifier_key_2_NDOF_BUTTON_7 = 432,
		modifier_key_2_NDOF_BUTTON_8 = 433,
		modifier_key_2_NDOF_BUTTON_9 = 434,
		modifier_key_2_NDOF_BUTTON_10 = 435,
		modifier_key_2_NDOF_BUTTON_A = 436,
		modifier_key_2_NDOF_BUTTON_B = 437,
		modifier_key_2_NDOF_BUTTON_C = 438,
	};

	/** Getter: Modifier key code */
	modifier_key_2_enum modifier_key_2() { /* not implemented */ throw NULL; }
	/** Setter: Modifier key code */
	void modifier_key_2(modifier_key_2_enum value) { /* not implemented */ }

	/** Getter: Property that receives the keystrokes in case a string is logged */
	std::string target() { /* not implemented */ throw NULL; }
	/** Setter: Property that receives the keystrokes in case a string is logged */
	void target(const std::string& value) { /* not implemented */ }

	/** Getter: Property that indicates whether to log keystrokes as a string */
	std::string log() { /* not implemented */ throw NULL; }
	/** Setter: Property that indicates whether to log keystrokes as a string */
	void log(const std::string& value) { /* not implemented */ }

	/** Getter: Trigger this sensor on any keystroke */
	bool use_all_keys() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_all_keys")) == 1;
	}

	/** Setter: Trigger this sensor on any keystroke */
	void use_all_keys(bool value) {
		PyObject_SetAttrString(pyobjref, "use_all_keys", Py_BuildValue("i", value));
	}

};

/**************** Property Sensor ****************/

/**
 * Sensor to detect values and changes in values of properties
 */
class PropertySensor : public Sensor {
public:
	PropertySensor(PyObject* pyobj) : Sensor(pyobj) {}

	PropertySensor() : Sensor(0)
	{
		// not implemented
	}

	enum evaluation_type_enum {
		evaluation_type_PROPEQUAL = 0,
		evaluation_type_PROPNEQUAL = 1,
		evaluation_type_PROPINTERVAL = 2,
		evaluation_type_PROPCHANGED = 3,
		evaluation_type_PROPLESSTHAN = 5,
		evaluation_type_PROPGREATERTHAN = 6,
	};

	/** Getter: Type of property evaluation */
	evaluation_type_enum evaluation_type() { /* not implemented */ throw NULL; }
	/** Setter: Type of property evaluation */
	void evaluation_type(evaluation_type_enum value) { /* not implemented */ }

	/** Getter:  */
	std::string property() { /* not implemented */ throw NULL; }
	/** Setter:  */
	void property(const std::string& value) { /* not implemented */ }

	/** Getter: Check for this value in types in Equal, Not Equal, Less Than and Greater Than types */
	std::string value() { /* not implemented */ throw NULL; }
	/** Setter: Check for this value in types in Equal, Not Equal, Less Than and Greater Than types */
	void value(const std::string& value) { /* not implemented */ }

	/** Getter: Minimum value in Interval type */
	std::string value_min() { /* not implemented */ throw NULL; }
	/** Setter: Minimum value in Interval type */
	void value_min(const std::string& value) { /* not implemented */ }

	/** Getter: Maximum value in Interval type */
	std::string value_max() { /* not implemented */ throw NULL; }
	/** Setter: Maximum value in Interval type */
	void value_max(const std::string& value) { /* not implemented */ }

};

/**************** Armature Sensor ****************/

/**
 * Sensor to detect values and changes in values of IK solver
 */
class ArmatureSensor : public Sensor {
public:
	ArmatureSensor(PyObject* pyobj) : Sensor(pyobj) {}

	ArmatureSensor() : Sensor(0)
	{
		// not implemented
	}

	enum test_type_enum {
		test_type_STATECHG = 0,
		test_type_LINERRORBELOW = 1,
		test_type_LINERRORABOVE = 2,
		test_type_ROTERRORBELOW = 3,
		test_type_ROTERRORABOVE = 4,
	};

	/** Getter: Type of value and test */
	test_type_enum test_type() { /* not implemented */ throw NULL; }
	/** Setter: Type of value and test */
	void test_type(test_type_enum value) { /* not implemented */ }

	/** Getter: Identify the bone to check value from */
	std::string bone() { /* not implemented */ throw NULL; }
	/** Setter: Identify the bone to check value from */
	void bone(const std::string& value) { /* not implemented */ }

	/** Getter: Identify the bone constraint to check value from */
	std::string constraint() { /* not implemented */ throw NULL; }
	/** Setter: Identify the bone constraint to check value from */
	void constraint(const std::string& value) { /* not implemented */ }

	/** Getter: Value to be used in comparison */
	float value() { /* not implemented */ throw NULL; }
	/** Setter: Value to be used in comparison */
	void value(float value) {
		PyObject_SetAttrString(pyobjref, "value", Py_BuildValue("f", value));
	}

};

/**************** Actuator Sensor ****************/

/**
 * Sensor to detect state modifications of actuators
 */
class ActuatorSensor : public Sensor {
public:
	ActuatorSensor(PyObject* pyobj) : Sensor(pyobj) {}

	ActuatorSensor() : Sensor(0)
	{
		// not implemented
	}

	/** Getter: Actuator name, actuator active state modifications will be detected */
	std::string actuator() { /* not implemented */ throw NULL; }
	/** Setter: Actuator name, actuator active state modifications will be detected */
	void actuator(const std::string& value) { /* not implemented */ }

};

/**************** Delay Sensor ****************/

/**
 * Sensor to send delayed events
 */
class DelaySensor : public Sensor {
public:
	DelaySensor(PyObject* pyobj) : Sensor(pyobj) {}

	DelaySensor() : Sensor(0)
	{
		// not implemented
	}

	/** Getter: Delay in number of logic tics before the positive trigger (default 60 per second) */
	int delay() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "delay"));
	}

	/** Setter: Delay in number of logic tics before the positive trigger (default 60 per second) */
	void delay(int value) {
		PyObject_SetAttrString(pyobjref, "delay", Py_BuildValue("i", value));
	}

	/** Getter: If >0, delay in number of logic tics before the negative trigger following the positive trigger */
	int duration() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "duration"));
	}

	/** Setter: If >0, delay in number of logic tics before the negative trigger following the positive trigger */
	void duration(int value) {
		PyObject_SetAttrString(pyobjref, "duration", Py_BuildValue("i", value));
	}

	/** Getter: Toggle repeat option (if selected, the sensor restarts after Delay+Duration logic tics) */
	bool use_repeat() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_repeat")) == 1;
	}

	/** Setter: Toggle repeat option (if selected, the sensor restarts after Delay+Duration logic tics) */
	void use_repeat(bool value) {
		PyObject_SetAttrString(pyobjref, "use_repeat", Py_BuildValue("i", value));
	}

};

/**************** Collision Sensor ****************/

/**
 * Sensor to detect objects colliding with the current object, with more settings than the Touch sensor
 */
class CollisionSensor : public Sensor {
public:
	CollisionSensor(PyObject* pyobj) : Sensor(pyobj) {}

	CollisionSensor() : Sensor(0)
	{
		// not implemented
	}

	/** Getter: Change to the set of colliding objects generates pulse */
	bool use_pulse() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_pulse")) == 1;
	}

	/** Setter: Change to the set of colliding objects generates pulse */
	void use_pulse(bool value) {
		PyObject_SetAttrString(pyobjref, "use_pulse", Py_BuildValue("i", value));
	}

	/** Getter: Toggle collision on material or property */
	bool use_material() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_material")) == 1;
	}

	/** Setter: Toggle collision on material or property */
	void use_material(bool value) {
		PyObject_SetAttrString(pyobjref, "use_material", Py_BuildValue("i", value));
	}

	/** Getter: Only look for objects with this property (blank = all objects) */
	std::string property() { /* not implemented */ throw NULL; }
	/** Setter: Only look for objects with this property (blank = all objects) */
	void property(const std::string& value) { /* not implemented */ }

	/** Getter: Only look for objects with this material (blank = all objects) */
	std::string material() { /* not implemented */ throw NULL; }
	/** Setter: Only look for objects with this material (blank = all objects) */
	void material(const std::string& value) { /* not implemented */ }

};

/**************** Radar Sensor ****************/

/**
 * Sensor to detect objects in a cone shaped radar emanating from the current object
 */
class RadarSensor : public Sensor {
public:
	RadarSensor(PyObject* pyobj) : Sensor(pyobj) {}

	RadarSensor() : Sensor(0)
	{
		// not implemented
	}

	/** Getter: Only look for objects with this property (blank = all objects) */
	std::string property() { /* not implemented */ throw NULL; }
	/** Setter: Only look for objects with this property (blank = all objects) */
	void property(const std::string& value) { /* not implemented */ }

	enum axis_enum {
		axis_XAXIS = 0,
		axis_YAXIS = 1,
		axis_ZAXIS = 2,
		axis_NEGXAXIS = 3,
		axis_NEGYAXIS = 4,
		axis_NEGZAXIS = 5,
	};

	/** Getter: Along which axis the radar cone is cast */
	axis_enum axis() { /* not implemented */ throw NULL; }
	/** Setter: Along which axis the radar cone is cast */
	void axis(axis_enum value) { /* not implemented */ }

	/** Getter: Opening angle of the radar cone */
	float angle() { /* not implemented */ throw NULL; }
	/** Setter: Opening angle of the radar cone */
	void angle(float value) {
		PyObject_SetAttrString(pyobjref, "angle", Py_BuildValue("f", value));
	}

	/** Getter: Depth of the radar cone */
	float distance() { /* not implemented */ throw NULL; }
	/** Setter: Depth of the radar cone */
	void distance(float value) {
		PyObject_SetAttrString(pyobjref, "distance", Py_BuildValue("f", value));
	}

};

/**************** Random Sensor ****************/

/**
 * Sensor to send random events
 */
class RandomSensor : public Sensor {
public:
	RandomSensor(PyObject* pyobj) : Sensor(pyobj) {}

	RandomSensor() : Sensor(0)
	{
		// not implemented
	}

	/** Getter: Initial seed of the generator (choose 0 for not random) */
	int seed() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "seed"));
	}

	/** Setter: Initial seed of the generator (choose 0 for not random) */
	void seed(int value) {
		PyObject_SetAttrString(pyobjref, "seed", Py_BuildValue("i", value));
	}

};

/**************** Ray Sensor ****************/

/**
 * Sensor to detect intersections with a ray emanating from the current object
 */
class RaySensor : public Sensor {
public:
	RaySensor(PyObject* pyobj) : Sensor(pyobj) {}

	RaySensor() : Sensor(0)
	{
		// not implemented
	}

	enum ray_type_enum {
		ray_type_PROPERTY = 0,
		ray_type_MATERIAL = 1,
	};

	/** Getter: Toggle collision on material or property */
	ray_type_enum ray_type() { /* not implemented */ throw NULL; }
	/** Setter: Toggle collision on material or property */
	void ray_type(ray_type_enum value) { /* not implemented */ }

	/** Getter: Only look for objects with this property (blank = all objects) */
	std::string property() { /* not implemented */ throw NULL; }
	/** Setter: Only look for objects with this property (blank = all objects) */
	void property(const std::string& value) { /* not implemented */ }

	/** Getter: Only look for objects with this material (blank = all objects) */
	std::string material() { /* not implemented */ throw NULL; }
	/** Setter: Only look for objects with this material (blank = all objects) */
	void material(const std::string& value) { /* not implemented */ }

	/** Getter: Toggle X-Ray option (see through objects that don't have the property) */
	bool use_x_ray() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_x_ray")) == 1;
	}

	/** Setter: Toggle X-Ray option (see through objects that don't have the property) */
	void use_x_ray(bool value) {
		PyObject_SetAttrString(pyobjref, "use_x_ray", Py_BuildValue("i", value));
	}

	/** Getter: Sense objects no farther than this distance */
	float range() { /* not implemented */ throw NULL; }
	/** Setter: Sense objects no farther than this distance */
	void range(float value) {
		PyObject_SetAttrString(pyobjref, "range", Py_BuildValue("f", value));
	}

	enum axis_enum {
		axis_XAXIS = 1,
		axis_YAXIS = 0,
		axis_ZAXIS = 2,
		axis_NEGXAXIS = 3,
		axis_NEGYAXIS = 4,
		axis_NEGZAXIS = 5,
	};

	/** Getter: Along which axis the ray is cast */
	axis_enum axis() { /* not implemented */ throw NULL; }
	/** Setter: Along which axis the ray is cast */
	void axis(axis_enum value) { /* not implemented */ }

};

/**************** Message Sensor ****************/

/**
 * Sensor to detect incoming messages
 */
class MessageSensor : public Sensor {
public:
	MessageSensor(PyObject* pyobj) : Sensor(pyobj) {}

	MessageSensor() : Sensor(0)
	{
		// not implemented
	}

	/** Getter: Optional subject filter: only accept messages with this subject, or empty to accept all */
	std::string subject() { /* not implemented */ throw NULL; }
	/** Setter: Optional subject filter: only accept messages with this subject, or empty to accept all */
	void subject(const std::string& value) { /* not implemented */ }

};

/**************** Joystick Sensor ****************/

/**
 * Sensor to detect joystick events
 */
class JoystickSensor : public Sensor {
public:
	JoystickSensor(PyObject* pyobj) : Sensor(pyobj) {}

	JoystickSensor() : Sensor(0)
	{
		// not implemented
	}

	/** Getter: Which joystick to use */
	int joystick_index() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "joystick_index"));
	}

	/** Setter: Which joystick to use */
	void joystick_index(int value) {
		PyObject_SetAttrString(pyobjref, "joystick_index", Py_BuildValue("i", value));
	}

	enum event_type_enum {
		event_type_BUTTON = 0,
		event_type_AXIS = 1,
		event_type_HAT = 2,
		event_type_AXIS_SINGLE = 3,
	};

	/** Getter: The type of event this joystick sensor is triggered on */
	event_type_enum event_type() { /* not implemented */ throw NULL; }
	/** Setter: The type of event this joystick sensor is triggered on */
	void event_type(event_type_enum value) { /* not implemented */ }

	/** Getter: Triggered by all events on this joystick's current type (axis/button/hat) */
	bool use_all_events() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_all_events")) == 1;
	}

	/** Setter: Triggered by all events on this joystick's current type (axis/button/hat) */
	void use_all_events(bool value) {
		PyObject_SetAttrString(pyobjref, "use_all_events", Py_BuildValue("i", value));
	}

	/** Getter: Which button to use */
	int button_number() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "button_number"));
	}

	/** Setter: Which button to use */
	void button_number(int value) {
		PyObject_SetAttrString(pyobjref, "button_number", Py_BuildValue("i", value));
	}

	/** Getter: Which axis pair to use, 1 is usually the main direction input */
	int axis_number() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "axis_number"));
	}

	/** Setter: Which axis pair to use, 1 is usually the main direction input */
	void axis_number(int value) {
		PyObject_SetAttrString(pyobjref, "axis_number", Py_BuildValue("i", value));
	}

	/** Getter: Precision of the axis */
	int axis_threshold() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "axis_threshold"));
	}

	/** Setter: Precision of the axis */
	void axis_threshold(int value) {
		PyObject_SetAttrString(pyobjref, "axis_threshold", Py_BuildValue("i", value));
	}

	enum axis_direction_enum {
		axis_direction_RIGHTAXIS = 0,
		axis_direction_UPAXIS = 1,
		axis_direction_LEFTAXIS = 2,
		axis_direction_DOWNAXIS = 3,
	};

	/** Getter: The direction of the axis */
	axis_direction_enum axis_direction() { /* not implemented */ throw NULL; }
	/** Setter: The direction of the axis */
	void axis_direction(axis_direction_enum value) { /* not implemented */ }

	/** Getter: Single axis (vertical/horizontal/other) to detect */
	int single_axis_number() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "single_axis_number"));
	}

	/** Setter: Single axis (vertical/horizontal/other) to detect */
	void single_axis_number(int value) {
		PyObject_SetAttrString(pyobjref, "single_axis_number", Py_BuildValue("i", value));
	}

	/** Getter: Which hat to use */
	int hat_number() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "hat_number"));
	}

	/** Setter: Which hat to use */
	void hat_number(int value) {
		PyObject_SetAttrString(pyobjref, "hat_number", Py_BuildValue("i", value));
	}

	enum hat_direction_enum {
		hat_direction_UP = 1,
		hat_direction_DOWN = 4,
		hat_direction_LEFT = 8,
		hat_direction_RIGHT = 2,
		hat_direction_UPRIGHT = 3,
		hat_direction_DOWNLEFT = 12,
		hat_direction_UPLEFT = 9,
		hat_direction_DOWNRIGHT = 6,
	};

	/** Getter: Hat direction */
	hat_direction_enum hat_direction() { /* not implemented */ throw NULL; }
	/** Setter: Hat direction */
	void hat_direction(hat_direction_enum value) { /* not implemented */ }

};

/**************** Sequence Color Balance Data ****************/

/**
 * Color balance parameters for a sequence strip and it's modifiers
 */
class SequenceColorBalanceData : public pyUniplug {
public:
	SequenceColorBalanceData(PyObject* pyobj) : pyUniplug(pyobj) {}

	SequenceColorBalanceData() : pyUniplug(0)
	{
		// not implemented
	}

	/** Getter: Color balance lift (shadows) */
	std::array<float, 3> lift() {
		// TODO: MISSING DEREF! USE #DEFINE!
		PyObject *seqval = PyObject_GetAttrString(pyobjref, "lift");
		std::array<float, 3> resarr;
		for (int i = 0; i < 3; i++)
			resarr[i] = (float)PyFloat_AsDouble(PySequence_GetItem(seqval, i));
		return resarr;
	}

	/** Setter: Color balance lift (shadows) */
	void lift(float values[3]) { /* not implemented */ }

	/** Getter: Color balance gamma (midtones) */
	std::array<float, 3> gamma() {
		// TODO: MISSING DEREF! USE #DEFINE!
		PyObject *seqval = PyObject_GetAttrString(pyobjref, "gamma");
		std::array<float, 3> resarr;
		for (int i = 0; i < 3; i++)
			resarr[i] = (float)PyFloat_AsDouble(PySequence_GetItem(seqval, i));
		return resarr;
	}

	/** Setter: Color balance gamma (midtones) */
	void gamma(float values[3]) { /* not implemented */ }

	/** Getter: Color balance gain (highlights) */
	std::array<float, 3> gain() {
		// TODO: MISSING DEREF! USE #DEFINE!
		PyObject *seqval = PyObject_GetAttrString(pyobjref, "gain");
		std::array<float, 3> resarr;
		for (int i = 0; i < 3; i++)
			resarr[i] = (float)PyFloat_AsDouble(PySequence_GetItem(seqval, i));
		return resarr;
	}

	/** Setter: Color balance gain (highlights) */
	void gain(float values[3]) { /* not implemented */ }

	/** Getter:  */
	bool invert_gain() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "invert_gain")) == 1;
	}

	/** Setter:  */
	void invert_gain(bool value) {
		PyObject_SetAttrString(pyobjref, "invert_gain", Py_BuildValue("i", value));
	}

	/** Getter:  */
	bool invert_gamma() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "invert_gamma")) == 1;
	}

	/** Setter:  */
	void invert_gamma(bool value) {
		PyObject_SetAttrString(pyobjref, "invert_gamma", Py_BuildValue("i", value));
	}

	/** Getter:  */
	bool invert_lift() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "invert_lift")) == 1;
	}

	/** Setter:  */
	void invert_lift(bool value) {
		PyObject_SetAttrString(pyobjref, "invert_lift", Py_BuildValue("i", value));
	}

};

/**************** Sequence Element ****************/

/**
 * Sequence strip data for a single frame
 */
class SequenceElement : public pyUniplug {
public:
	SequenceElement(PyObject* pyobj) : pyUniplug(pyobj) {}

	SequenceElement() : pyUniplug(0)
	{
		// not implemented
	}

	/** Getter:  */
	std::string filename() { /* not implemented */ throw NULL; }
	/** Setter:  */
	void filename(const std::string& value) { /* not implemented */ }

	/** Getter: Original image width */
	int orig_width() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "orig_width"));
	}

	/** Setter: Original image width */
	void orig_width(int value) {
		PyObject_SetAttrString(pyobjref, "orig_width", Py_BuildValue("i", value));
	}

	/** Getter: Original image height */
	int orig_height() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "orig_height"));
	}

	/** Setter: Original image height */
	void orig_height(int value) {
		PyObject_SetAttrString(pyobjref, "orig_height", Py_BuildValue("i", value));
	}

};

/**************** Sequence Proxy ****************/

/**
 * Proxy parameters for a sequence strip
 */
class SequenceProxy : public pyUniplug {
public:
	SequenceProxy(PyObject* pyobj) : pyUniplug(pyobj) {}

	SequenceProxy() : pyUniplug(0)
	{
		// not implemented
	}

	/** Getter: Location to store the proxy files */
	std::string directory() { /* not implemented */ throw NULL; }
	/** Setter: Location to store the proxy files */
	void directory(const std::string& value) { /* not implemented */ }

	/** Getter: Location of custom proxy file */
	std::string filepath() { /* not implemented */ throw NULL; }
	/** Setter: Location of custom proxy file */
	void filepath(const std::string& value) { /* not implemented */ }

	/** Getter: Overwrite existing proxy files when building */
	bool use_overwrite() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_overwrite")) == 1;
	}

	/** Setter: Overwrite existing proxy files when building */
	void use_overwrite(bool value) {
		PyObject_SetAttrString(pyobjref, "use_overwrite", Py_BuildValue("i", value));
	}

	/** Getter: Build 25% proxy resolution */
	bool build_25() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "build_25")) == 1;
	}

	/** Setter: Build 25% proxy resolution */
	void build_25(bool value) {
		PyObject_SetAttrString(pyobjref, "build_25", Py_BuildValue("i", value));
	}

	/** Getter: Build 50% proxy resolution */
	bool build_50() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "build_50")) == 1;
	}

	/** Setter: Build 50% proxy resolution */
	void build_50(bool value) {
		PyObject_SetAttrString(pyobjref, "build_50", Py_BuildValue("i", value));
	}

	/** Getter: Build 75% proxy resolution */
	bool build_75() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "build_75")) == 1;
	}

	/** Setter: Build 75% proxy resolution */
	void build_75(bool value) {
		PyObject_SetAttrString(pyobjref, "build_75", Py_BuildValue("i", value));
	}

	/** Getter: Build 100% proxy resolution */
	bool build_100() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "build_100")) == 1;
	}

	/** Setter: Build 100% proxy resolution */
	void build_100(bool value) {
		PyObject_SetAttrString(pyobjref, "build_100", Py_BuildValue("i", value));
	}

	/** Getter: Build record run time code index */
	bool build_record_run() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "build_record_run")) == 1;
	}

	/** Setter: Build record run time code index */
	void build_record_run(bool value) {
		PyObject_SetAttrString(pyobjref, "build_record_run", Py_BuildValue("i", value));
	}

	/** Getter: Build free run time code index */
	bool build_free_run() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "build_free_run")) == 1;
	}

	/** Setter: Build free run time code index */
	void build_free_run(bool value) {
		PyObject_SetAttrString(pyobjref, "build_free_run", Py_BuildValue("i", value));
	}

	/** Getter: Build free run time code index using Record Date/Time */
	bool build_free_run_rec_date() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "build_free_run_rec_date")) == 1;
	}

	/** Setter: Build free run time code index using Record Date/Time */
	void build_free_run_rec_date(bool value) {
		PyObject_SetAttrString(pyobjref, "build_free_run_rec_date", Py_BuildValue("i", value));
	}

	/** Getter: JPEG Quality of proxies to build */
	int quality() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "quality"));
	}

	/** Setter: JPEG Quality of proxies to build */
	void quality(int value) {
		PyObject_SetAttrString(pyobjref, "quality", Py_BuildValue("i", value));
	}

	enum timecode_enum {
		timecode_NONE = 0,
		timecode_RECORD_RUN = 1,
		timecode_FREE_RUN = 2,
		timecode_FREE_RUN_REC_DATE = 4,
		timecode_RECORD_RUN_NO_GAPS = 8,
	};

	/** Getter:  */
	timecode_enum timecode() { /* not implemented */ throw NULL; }
	/** Setter:  */
	void timecode(timecode_enum value) { /* not implemented */ }

	/** Getter: Use a custom directory to store data */
	bool use_proxy_custom_directory() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_proxy_custom_directory")) == 1;
	}

	/** Setter: Use a custom directory to store data */
	void use_proxy_custom_directory(bool value) {
		PyObject_SetAttrString(pyobjref, "use_proxy_custom_directory", Py_BuildValue("i", value));
	}

	/** Getter: Use a custom file to read proxy data from */
	bool use_proxy_custom_file() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_proxy_custom_file")) == 1;
	}

	/** Setter: Use a custom file to read proxy data from */
	void use_proxy_custom_file(bool value) {
		PyObject_SetAttrString(pyobjref, "use_proxy_custom_file", Py_BuildValue("i", value));
	}

};

/**************** Sequence Color Balance ****************/

/**
 * Color balance parameters for a sequence strip
 */
class SequenceColorBalance : public SequenceColorBalanceData {
public:
	SequenceColorBalance(PyObject* pyobj) : SequenceColorBalanceData(pyobj) {}

	SequenceColorBalance() : SequenceColorBalanceData(0)
	{
		// not implemented
	}

};

/**************** Sequence Crop ****************/

/**
 * Cropping parameters for a sequence strip
 */
class SequenceCrop : public pyUniplug {
public:
	SequenceCrop(PyObject* pyobj) : pyUniplug(pyobj) {}

	SequenceCrop() : pyUniplug(0)
	{
		// not implemented
	}

	/** Getter:  */
	int max_y() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "max_y"));
	}

	/** Setter:  */
	void max_y(int value) {
		PyObject_SetAttrString(pyobjref, "max_y", Py_BuildValue("i", value));
	}

	/** Getter:  */
	int min_y() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "min_y"));
	}

	/** Setter:  */
	void min_y(int value) {
		PyObject_SetAttrString(pyobjref, "min_y", Py_BuildValue("i", value));
	}

	/** Getter:  */
	int min_x() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "min_x"));
	}

	/** Setter:  */
	void min_x(int value) {
		PyObject_SetAttrString(pyobjref, "min_x", Py_BuildValue("i", value));
	}

	/** Getter:  */
	int max_x() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "max_x"));
	}

	/** Setter:  */
	void max_x(int value) {
		PyObject_SetAttrString(pyobjref, "max_x", Py_BuildValue("i", value));
	}

};

/**************** Sequence Transform ****************/

/**
 * Transform parameters for a sequence strip
 */
class SequenceTransform : public pyUniplug {
public:
	SequenceTransform(PyObject* pyobj) : pyUniplug(pyobj) {}

	SequenceTransform() : pyUniplug(0)
	{
		// not implemented
	}

	/** Getter:  */
	int offset_x() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "offset_x"));
	}

	/** Setter:  */
	void offset_x(int value) {
		PyObject_SetAttrString(pyobjref, "offset_x", Py_BuildValue("i", value));
	}

	/** Getter:  */
	int offset_y() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "offset_y"));
	}

	/** Setter:  */
	void offset_y(int value) {
		PyObject_SetAttrString(pyobjref, "offset_y", Py_BuildValue("i", value));
	}

};

/**************** Sequence ****************/

/**
 * Sequence strip in the sequence editor
 */
class Sequence : public pyUniplug {
public:
	Sequence(PyObject* pyobj) : pyUniplug(pyobj) {}

	Sequence() : pyUniplug(0)
	{
		// not implemented
	}

	/** Getter:  */
	std::string name() { /* not implemented */ throw NULL; }
	/** Setter:  */
	void name(const std::string& value) { /* not implemented */ }

	enum type_enum {
		type_IMAGE = 0,
		type_META = 1,
		type_SCENE = 2,
		type_MOVIE = 3,
		type_MOVIECLIP = 6,
		type_MASK = 7,
		type_SOUND = 4,
		type_CROSS = 8,
		type_ADD = 9,
		type_SUBTRACT = 10,
		type_ALPHA_OVER = 11,
		type_ALPHA_UNDER = 12,
		type_GAMMA_CROSS = 13,
		type_MULTIPLY = 14,
		type_OVER_DROP = 15,
		type_WIPE = 25,
		type_GLOW = 26,
		type_TRANSFORM = 27,
		type_COLOR = 28,
		type_SPEED = 29,
		type_MULTICAM = 30,
		type_ADJUSTMENT = 31,
		type_GAUSSIAN_BLUR = 40,
	};

	/** Getter:  */
	type_enum type() { /* not implemented */ throw NULL; }
	/** Setter:  */
	void type(type_enum value) { /* not implemented */ }

	/** Getter:  */
	bool select() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "select")) == 1;
	}

	/** Setter:  */
	void select(bool value) {
		PyObject_SetAttrString(pyobjref, "select", Py_BuildValue("i", value));
	}

	/** Getter:  */
	bool select_left_handle() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "select_left_handle")) == 1;
	}

	/** Setter:  */
	void select_left_handle(bool value) {
		PyObject_SetAttrString(pyobjref, "select_left_handle", Py_BuildValue("i", value));
	}

	/** Getter:  */
	bool select_right_handle() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "select_right_handle")) == 1;
	}

	/** Setter:  */
	void select_right_handle(bool value) {
		PyObject_SetAttrString(pyobjref, "select_right_handle", Py_BuildValue("i", value));
	}

	/** Getter:  */
	bool mute() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "mute")) == 1;
	}

	/** Setter:  */
	void mute(bool value) {
		PyObject_SetAttrString(pyobjref, "mute", Py_BuildValue("i", value));
	}

	/** Getter: Lock strip so that it can't be transformed */
	bool lock_value() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "lock")) == 1;
	}

	/** Setter: Lock strip so that it can't be transformed */
	void lock_value(bool value) {
		PyObject_SetAttrString(pyobjref, "lock", Py_BuildValue("i", value));
	}

	/** Getter: The length of the contents of this strip after the handles are applied */
	int frame_final_duration() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "frame_final_duration"));
	}

	/** Setter: The length of the contents of this strip after the handles are applied */
	void frame_final_duration(int value) {
		PyObject_SetAttrString(pyobjref, "frame_final_duration", Py_BuildValue("i", value));
	}

	/** Getter: The length of the contents of this strip before the handles are applied */
	int frame_duration() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "frame_duration"));
	}

	/** Setter: The length of the contents of this strip before the handles are applied */
	void frame_duration(int value) {
		PyObject_SetAttrString(pyobjref, "frame_duration", Py_BuildValue("i", value));
	}

	/** Getter:  */
	int frame_start() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "frame_start"));
	}

	/** Setter:  */
	void frame_start(int value) {
		PyObject_SetAttrString(pyobjref, "frame_start", Py_BuildValue("i", value));
	}

	/** Getter: Start frame displayed in the sequence editor after offsets are applied, setting this is equivalent to moving the handle, not the actual start frame */
	int frame_final_start() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "frame_final_start"));
	}

	/** Setter: Start frame displayed in the sequence editor after offsets are applied, setting this is equivalent to moving the handle, not the actual start frame */
	void frame_final_start(int value) {
		PyObject_SetAttrString(pyobjref, "frame_final_start", Py_BuildValue("i", value));
	}

	/** Getter: End frame displayed in the sequence editor after offsets are applied */
	int frame_final_end() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "frame_final_end"));
	}

	/** Setter: End frame displayed in the sequence editor after offsets are applied */
	void frame_final_end(int value) {
		PyObject_SetAttrString(pyobjref, "frame_final_end", Py_BuildValue("i", value));
	}

	/** Getter:  */
	int frame_offset_start() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "frame_offset_start"));
	}

	/** Setter:  */
	void frame_offset_start(int value) {
		PyObject_SetAttrString(pyobjref, "frame_offset_start", Py_BuildValue("i", value));
	}

	/** Getter:  */
	int frame_offset_end() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "frame_offset_end"));
	}

	/** Setter:  */
	void frame_offset_end(int value) {
		PyObject_SetAttrString(pyobjref, "frame_offset_end", Py_BuildValue("i", value));
	}

	/** Getter:  */
	int frame_still_start() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "frame_still_start"));
	}

	/** Setter:  */
	void frame_still_start(int value) {
		PyObject_SetAttrString(pyobjref, "frame_still_start", Py_BuildValue("i", value));
	}

	/** Getter:  */
	int frame_still_end() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "frame_still_end"));
	}

	/** Setter:  */
	void frame_still_end(int value) {
		PyObject_SetAttrString(pyobjref, "frame_still_end", Py_BuildValue("i", value));
	}

	/** Getter: Y position of the sequence strip */
	int channel() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "channel"));
	}

	/** Setter: Y position of the sequence strip */
	void channel(int value) {
		PyObject_SetAttrString(pyobjref, "channel", Py_BuildValue("i", value));
	}

	/** Getter: Calculate modifiers in linear space instead of sequencer's space */
	bool use_linear_modifiers() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_linear_modifiers")) == 1;
	}

	/** Setter: Calculate modifiers in linear space instead of sequencer's space */
	void use_linear_modifiers(bool value) {
		PyObject_SetAttrString(pyobjref, "use_linear_modifiers", Py_BuildValue("i", value));
	}

	enum blend_type_enum {
		blend_type_REPLACE = 0,
		blend_type_CROSS = 8,
		blend_type_ADD = 9,
		blend_type_SUBTRACT = 10,
		blend_type_ALPHA_OVER = 11,
		blend_type_ALPHA_UNDER = 12,
		blend_type_GAMMA_CROSS = 13,
		blend_type_MULTIPLY = 14,
		blend_type_OVER_DROP = 15,
	};

	/** Getter:  */
	blend_type_enum blend_type() { /* not implemented */ throw NULL; }
	/** Setter:  */
	void blend_type(blend_type_enum value) { /* not implemented */ }

	/** Getter:  */
	float blend_alpha() { /* not implemented */ throw NULL; }
	/** Setter:  */
	void blend_alpha(float value) {
		PyObject_SetAttrString(pyobjref, "blend_alpha", Py_BuildValue("f", value));
	}

	/** Getter:  */
	float effect_fader() { /* not implemented */ throw NULL; }
	/** Setter:  */
	void effect_fader(float value) {
		PyObject_SetAttrString(pyobjref, "effect_fader", Py_BuildValue("f", value));
	}

	/** Getter: Fade effect using the built-in default (usually make transition as long as effect strip) */
	bool use_default_fade() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_default_fade")) == 1;
	}

	/** Setter: Fade effect using the built-in default (usually make transition as long as effect strip) */
	void use_default_fade(bool value) {
		PyObject_SetAttrString(pyobjref, "use_default_fade", Py_BuildValue("i", value));
	}

	/** Getter: Multiply the current speed of the sequence with this number or remap current frame to this frame */
	float speed_factor() { /* not implemented */ throw NULL; }
	/** Setter: Multiply the current speed of the sequence with this number or remap current frame to this frame */
	void speed_factor(float value) {
		PyObject_SetAttrString(pyobjref, "speed_factor", Py_BuildValue("f", value));
	}

	/** Getter: Modifiers affecting this strip */
	std::map<std::string, SequenceModifier> modifiers();
	/** Setter: Modifiers affecting this strip */
	void modifiers(std::map<std::string, SequenceModifier> value);

	/**
	 * Update the strip dimensions
	 * @param Update strip data
	 */
	void update(bool data = false)
	{
		// not implemented
	}

	/**
	 * Return the strip element from a given frame or None
	 * @param The frame to get the strip element from
	 * @return strip element of the current frame
	 */
	SequenceElement strip_elem_from_frame(int frame)
	{
		// not implemented
		return SequenceElement();
	}

	/**
	 * Function: swap
	 * @param Param 'other'
	 */
	void swap(Sequence other)
	{
		// not implemented
	}

};

/**************** Sequence Editor ****************/

/**
 * Sequence editing data for a Scene datablock
 */
class SequenceEditor : public pyUniplug {
public:
	SequenceEditor(PyObject* pyobj) : pyUniplug(pyobj) {}

	SequenceEditor() : pyUniplug(0)
	{
		// not implemented
	}

	/** Getter: Top-level strips only */
	std::map<std::string, Sequence> sequences() {
		// TODO: MISSING DEREF! USE #DEFINE!
		PyObject *seqval = PyObject_GetAttrString(pyobjref, "sequences");
		PyObject *seqkeys = PyObject_CallMethod(seqval, "keys", NULL);
		std::map<std::string, Sequence> resmap;
		for (int i = 0; i < PySequence_Length(seqval); i++) {
			PyObject *keyobj = PySequence_GetItem(seqkeys, i);
			std::string key = PyBytes_AsString(PyUnicode_AsASCIIString(keyobj));
			Sequence value = Sequence(PySequence_GetItem(seqval, i));
			resmap.insert(std::pair<std::string,Sequence>(key, value));
		}
		return resmap;
	}

	/** Setter: Top-level strips only */
	void sequences(std::map<std::string, Sequence> value) { /* not implemented */ }

	/** Getter: All strips, recursively including those inside metastrips */
	std::map<std::string, Sequence> sequences_all() {
		// TODO: MISSING DEREF! USE #DEFINE!
		PyObject *seqval = PyObject_GetAttrString(pyobjref, "sequences_all");
		PyObject *seqkeys = PyObject_CallMethod(seqval, "keys", NULL);
		std::map<std::string, Sequence> resmap;
		for (int i = 0; i < PySequence_Length(seqval); i++) {
			PyObject *keyobj = PySequence_GetItem(seqkeys, i);
			std::string key = PyBytes_AsString(PyUnicode_AsASCIIString(keyobj));
			Sequence value = Sequence(PySequence_GetItem(seqval, i));
			resmap.insert(std::pair<std::string,Sequence>(key, value));
		}
		return resmap;
	}

	/** Setter: All strips, recursively including those inside metastrips */
	void sequences_all(std::map<std::string, Sequence> value) { /* not implemented */ }

	/** Getter: Meta strip stack, last is currently edited meta strip */
	std::map<std::string, Sequence> meta_stack() {
		// TODO: MISSING DEREF! USE #DEFINE!
		PyObject *seqval = PyObject_GetAttrString(pyobjref, "meta_stack");
		PyObject *seqkeys = PyObject_CallMethod(seqval, "keys", NULL);
		std::map<std::string, Sequence> resmap;
		for (int i = 0; i < PySequence_Length(seqval); i++) {
			PyObject *keyobj = PySequence_GetItem(seqkeys, i);
			std::string key = PyBytes_AsString(PyUnicode_AsASCIIString(keyobj));
			Sequence value = Sequence(PySequence_GetItem(seqval, i));
			resmap.insert(std::pair<std::string,Sequence>(key, value));
		}
		return resmap;
	}

	/** Setter: Meta strip stack, last is currently edited meta strip */
	void meta_stack(std::map<std::string, Sequence> value) { /* not implemented */ }

	/** Getter: Sequencer's active strip */
	Sequence active_strip() {
		/* not implemented */ throw NULL;
	}

	/** Getter: Partial overlay on top of the sequencer */
	bool show_overlay() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "show_overlay")) == 1;
	}

	/** Setter: Partial overlay on top of the sequencer */
	void show_overlay(bool value) {
		PyObject_SetAttrString(pyobjref, "show_overlay", Py_BuildValue("i", value));
	}

	/** Getter:  */
	bool use_overlay_lock() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_overlay_lock")) == 1;
	}

	/** Setter:  */
	void use_overlay_lock(bool value) {
		PyObject_SetAttrString(pyobjref, "use_overlay_lock", Py_BuildValue("i", value));
	}

	/** Getter:  */
	int overlay_frame() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "overlay_frame"));
	}

	/** Setter:  */
	void overlay_frame(int value) {
		PyObject_SetAttrString(pyobjref, "overlay_frame", Py_BuildValue("i", value));
	}

	enum proxy_storage_enum {
		proxy_storage_PER_STRIP = 0,
		proxy_storage_PROJECT = 1,
	};

	/** Getter: How to store proxies for this project */
	proxy_storage_enum proxy_storage() { /* not implemented */ throw NULL; }
	/** Setter: How to store proxies for this project */
	void proxy_storage(proxy_storage_enum value) { /* not implemented */ }

	/** Getter:  */
	std::string proxy_dir() { /* not implemented */ throw NULL; }
	/** Setter:  */
	void proxy_dir(const std::string& value) { /* not implemented */ }

};

/**************** Image Sequence ****************/

/**
 * Sequence strip to load one or more images
 */
class ImageSequence : public Sequence {
public:
	ImageSequence(PyObject* pyobj) : Sequence(pyobj) {}

	ImageSequence() : Sequence(0)
	{
		// not implemented
	}

	/** Getter:  */
	std::string directory() { /* not implemented */ throw NULL; }
	/** Setter:  */
	void directory(const std::string& value) { /* not implemented */ }

	/** Getter:  */
	std::map<std::string, SequenceElement> elements() {
		// TODO: MISSING DEREF! USE #DEFINE!
		PyObject *seqval = PyObject_GetAttrString(pyobjref, "elements");
		PyObject *seqkeys = PyObject_CallMethod(seqval, "keys", NULL);
		std::map<std::string, SequenceElement> resmap;
		for (int i = 0; i < PySequence_Length(seqval); i++) {
			PyObject *keyobj = PySequence_GetItem(seqkeys, i);
			std::string key = PyBytes_AsString(PyUnicode_AsASCIIString(keyobj));
			SequenceElement value = SequenceElement(PySequence_GetItem(seqval, i));
			resmap.insert(std::pair<std::string,SequenceElement>(key, value));
		}
		return resmap;
	}

	/** Setter:  */
	void elements(std::map<std::string, SequenceElement> value) { /* not implemented */ }

	/** Getter: Use Multiple Views (when available) */
	bool use_multiview() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_multiview")) == 1;
	}

	/** Setter: Use Multiple Views (when available) */
	void use_multiview(bool value) {
		PyObject_SetAttrString(pyobjref, "use_multiview", Py_BuildValue("i", value));
	}

	enum views_format_enum {
		views_format_INDIVIDUAL = 0,
		views_format_STEREO_3D = 1,
	};

	/** Getter: Mode to load image views */
	views_format_enum views_format() { /* not implemented */ throw NULL; }
	/** Setter: Mode to load image views */
	void views_format(views_format_enum value) { /* not implemented */ }

	/** Getter: Settings for stereo 3d */
	Stereo3dFormat stereo_3d_format() {
		/* not implemented */ throw NULL;
	}

	/** Getter: For video movies to remove fields */
	bool use_deinterlace() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_deinterlace")) == 1;
	}

	/** Setter: For video movies to remove fields */
	void use_deinterlace(bool value) {
		PyObject_SetAttrString(pyobjref, "use_deinterlace", Py_BuildValue("i", value));
	}

	enum alpha_mode_enum {
		alpha_mode_STRAIGHT = 0,
		alpha_mode_PREMUL = 1,
	};

	/** Getter: Representation of alpha information in the RGBA pixels */
	alpha_mode_enum alpha_mode() { /* not implemented */ throw NULL; }
	/** Setter: Representation of alpha information in the RGBA pixels */
	void alpha_mode(alpha_mode_enum value) { /* not implemented */ }

	/** Getter: Flip on the X axis */
	bool use_flip_x() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_flip_x")) == 1;
	}

	/** Setter: Flip on the X axis */
	void use_flip_x(bool value) {
		PyObject_SetAttrString(pyobjref, "use_flip_x", Py_BuildValue("i", value));
	}

	/** Getter: Flip on the Y axis */
	bool use_flip_y() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_flip_y")) == 1;
	}

	/** Setter: Flip on the Y axis */
	void use_flip_y(bool value) {
		PyObject_SetAttrString(pyobjref, "use_flip_y", Py_BuildValue("i", value));
	}

	/** Getter: Convert input to float data */
	bool use_float() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_float")) == 1;
	}

	/** Setter: Convert input to float data */
	void use_float(bool value) {
		PyObject_SetAttrString(pyobjref, "use_float", Py_BuildValue("i", value));
	}

	/** Getter: Reverse frame order */
	bool use_reverse_frames() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_reverse_frames")) == 1;
	}

	/** Setter: Reverse frame order */
	void use_reverse_frames(bool value) {
		PyObject_SetAttrString(pyobjref, "use_reverse_frames", Py_BuildValue("i", value));
	}

	/** Getter:  */
	float color_multiply() { /* not implemented */ throw NULL; }
	/** Setter:  */
	void color_multiply(float value) {
		PyObject_SetAttrString(pyobjref, "color_multiply", Py_BuildValue("f", value));
	}

	/** Getter:  */
	float color_saturation() { /* not implemented */ throw NULL; }
	/** Setter:  */
	void color_saturation(float value) {
		PyObject_SetAttrString(pyobjref, "color_saturation", Py_BuildValue("f", value));
	}

	/** Getter: Only display every nth frame */
	float strobe() { /* not implemented */ throw NULL; }
	/** Setter: Only display every nth frame */
	void strobe(float value) {
		PyObject_SetAttrString(pyobjref, "strobe", Py_BuildValue("f", value));
	}

	/** Getter: Translate image before processing */
	bool use_translation() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_translation")) == 1;
	}

	/** Setter: Translate image before processing */
	void use_translation(bool value) {
		PyObject_SetAttrString(pyobjref, "use_translation", Py_BuildValue("i", value));
	}

	/** Getter:  */
	SequenceTransform transform() {
		/* not implemented */ throw NULL;
	}

	/** Getter: Crop image before processing */
	bool use_crop() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_crop")) == 1;
	}

	/** Setter: Crop image before processing */
	void use_crop(bool value) {
		PyObject_SetAttrString(pyobjref, "use_crop", Py_BuildValue("i", value));
	}

	/** Getter:  */
	SequenceCrop crop() {
		/* not implemented */ throw NULL;
	}

	/** Getter: Use a preview proxy and/or timecode index for this strip */
	bool use_proxy() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_proxy")) == 1;
	}

	/** Setter: Use a preview proxy and/or timecode index for this strip */
	void use_proxy(bool value) {
		PyObject_SetAttrString(pyobjref, "use_proxy", Py_BuildValue("i", value));
	}

	/** Getter:  */
	SequenceProxy proxy() {
		/* not implemented */ throw NULL;
	}

	/** Getter: Animation start offset (trim start) */
	int animation_offset_start() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "animation_offset_start"));
	}

	/** Setter: Animation start offset (trim start) */
	void animation_offset_start(int value) {
		PyObject_SetAttrString(pyobjref, "animation_offset_start", Py_BuildValue("i", value));
	}

	/** Getter: Animation end offset (trim end) */
	int animation_offset_end() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "animation_offset_end"));
	}

	/** Setter: Animation end offset (trim end) */
	void animation_offset_end(int value) {
		PyObject_SetAttrString(pyobjref, "animation_offset_end", Py_BuildValue("i", value));
	}

	/** Getter: Input color space settings */
	ColorManagedInputColorspaceSettings colorspace_settings() {
		/* not implemented */ throw NULL;
	}

};

/**************** Meta Sequence ****************/

/**
 * Sequence strip to group other strips as a single sequence strip
 */
class MetaSequence : public Sequence {
public:
	MetaSequence(PyObject* pyobj) : Sequence(pyobj) {}

	MetaSequence() : Sequence(0)
	{
		// not implemented
	}

	/** Getter:  */
	std::map<std::string, Sequence> sequences() {
		// TODO: MISSING DEREF! USE #DEFINE!
		PyObject *seqval = PyObject_GetAttrString(pyobjref, "sequences");
		PyObject *seqkeys = PyObject_CallMethod(seqval, "keys", NULL);
		std::map<std::string, Sequence> resmap;
		for (int i = 0; i < PySequence_Length(seqval); i++) {
			PyObject *keyobj = PySequence_GetItem(seqkeys, i);
			std::string key = PyBytes_AsString(PyUnicode_AsASCIIString(keyobj));
			Sequence value = Sequence(PySequence_GetItem(seqval, i));
			resmap.insert(std::pair<std::string,Sequence>(key, value));
		}
		return resmap;
	}

	/** Setter:  */
	void sequences(std::map<std::string, Sequence> value) { /* not implemented */ }

	/** Getter: For video movies to remove fields */
	bool use_deinterlace() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_deinterlace")) == 1;
	}

	/** Setter: For video movies to remove fields */
	void use_deinterlace(bool value) {
		PyObject_SetAttrString(pyobjref, "use_deinterlace", Py_BuildValue("i", value));
	}

	enum alpha_mode_enum {
		alpha_mode_STRAIGHT = 0,
		alpha_mode_PREMUL = 1,
	};

	/** Getter: Representation of alpha information in the RGBA pixels */
	alpha_mode_enum alpha_mode() { /* not implemented */ throw NULL; }
	/** Setter: Representation of alpha information in the RGBA pixels */
	void alpha_mode(alpha_mode_enum value) { /* not implemented */ }

	/** Getter: Flip on the X axis */
	bool use_flip_x() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_flip_x")) == 1;
	}

	/** Setter: Flip on the X axis */
	void use_flip_x(bool value) {
		PyObject_SetAttrString(pyobjref, "use_flip_x", Py_BuildValue("i", value));
	}

	/** Getter: Flip on the Y axis */
	bool use_flip_y() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_flip_y")) == 1;
	}

	/** Setter: Flip on the Y axis */
	void use_flip_y(bool value) {
		PyObject_SetAttrString(pyobjref, "use_flip_y", Py_BuildValue("i", value));
	}

	/** Getter: Convert input to float data */
	bool use_float() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_float")) == 1;
	}

	/** Setter: Convert input to float data */
	void use_float(bool value) {
		PyObject_SetAttrString(pyobjref, "use_float", Py_BuildValue("i", value));
	}

	/** Getter: Reverse frame order */
	bool use_reverse_frames() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_reverse_frames")) == 1;
	}

	/** Setter: Reverse frame order */
	void use_reverse_frames(bool value) {
		PyObject_SetAttrString(pyobjref, "use_reverse_frames", Py_BuildValue("i", value));
	}

	/** Getter:  */
	float color_multiply() { /* not implemented */ throw NULL; }
	/** Setter:  */
	void color_multiply(float value) {
		PyObject_SetAttrString(pyobjref, "color_multiply", Py_BuildValue("f", value));
	}

	/** Getter:  */
	float color_saturation() { /* not implemented */ throw NULL; }
	/** Setter:  */
	void color_saturation(float value) {
		PyObject_SetAttrString(pyobjref, "color_saturation", Py_BuildValue("f", value));
	}

	/** Getter: Only display every nth frame */
	float strobe() { /* not implemented */ throw NULL; }
	/** Setter: Only display every nth frame */
	void strobe(float value) {
		PyObject_SetAttrString(pyobjref, "strobe", Py_BuildValue("f", value));
	}

	/** Getter: Translate image before processing */
	bool use_translation() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_translation")) == 1;
	}

	/** Setter: Translate image before processing */
	void use_translation(bool value) {
		PyObject_SetAttrString(pyobjref, "use_translation", Py_BuildValue("i", value));
	}

	/** Getter:  */
	SequenceTransform transform() {
		/* not implemented */ throw NULL;
	}

	/** Getter: Crop image before processing */
	bool use_crop() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_crop")) == 1;
	}

	/** Setter: Crop image before processing */
	void use_crop(bool value) {
		PyObject_SetAttrString(pyobjref, "use_crop", Py_BuildValue("i", value));
	}

	/** Getter:  */
	SequenceCrop crop() {
		/* not implemented */ throw NULL;
	}

	/** Getter: Use a preview proxy and/or timecode index for this strip */
	bool use_proxy() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_proxy")) == 1;
	}

	/** Setter: Use a preview proxy and/or timecode index for this strip */
	void use_proxy(bool value) {
		PyObject_SetAttrString(pyobjref, "use_proxy", Py_BuildValue("i", value));
	}

	/** Getter:  */
	SequenceProxy proxy() {
		/* not implemented */ throw NULL;
	}

	/** Getter: Animation start offset (trim start) */
	int animation_offset_start() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "animation_offset_start"));
	}

	/** Setter: Animation start offset (trim start) */
	void animation_offset_start(int value) {
		PyObject_SetAttrString(pyobjref, "animation_offset_start", Py_BuildValue("i", value));
	}

	/** Getter: Animation end offset (trim end) */
	int animation_offset_end() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "animation_offset_end"));
	}

	/** Setter: Animation end offset (trim end) */
	void animation_offset_end(int value) {
		PyObject_SetAttrString(pyobjref, "animation_offset_end", Py_BuildValue("i", value));
	}

};

/**************** Scene Sequence ****************/

/**
 * Sequence strip to used the rendered image of a scene
 */
class SceneSequence : public Sequence {
public:
	SceneSequence(PyObject* pyobj) : Sequence(pyobj) {}

	SceneSequence() : Sequence(0)
	{
		// not implemented
	}

	/** Getter: Scene that this sequence uses */
	Scene scene() {
		/* not implemented */ throw NULL;
	}

	/** Getter: Override the scenes active camera */
	Object scene_camera() {
		/* not implemented */ throw NULL;
	}

	/** Getter: Show Grease Pencil strokes in OpenGL previews */
	bool use_grease_pencil() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_grease_pencil")) == 1;
	}

	/** Setter: Show Grease Pencil strokes in OpenGL previews */
	void use_grease_pencil(bool value) {
		PyObject_SetAttrString(pyobjref, "use_grease_pencil", Py_BuildValue("i", value));
	}

	/** Getter: For video movies to remove fields */
	bool use_deinterlace() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_deinterlace")) == 1;
	}

	/** Setter: For video movies to remove fields */
	void use_deinterlace(bool value) {
		PyObject_SetAttrString(pyobjref, "use_deinterlace", Py_BuildValue("i", value));
	}

	enum alpha_mode_enum {
		alpha_mode_STRAIGHT = 0,
		alpha_mode_PREMUL = 1,
	};

	/** Getter: Representation of alpha information in the RGBA pixels */
	alpha_mode_enum alpha_mode() { /* not implemented */ throw NULL; }
	/** Setter: Representation of alpha information in the RGBA pixels */
	void alpha_mode(alpha_mode_enum value) { /* not implemented */ }

	/** Getter: Flip on the X axis */
	bool use_flip_x() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_flip_x")) == 1;
	}

	/** Setter: Flip on the X axis */
	void use_flip_x(bool value) {
		PyObject_SetAttrString(pyobjref, "use_flip_x", Py_BuildValue("i", value));
	}

	/** Getter: Flip on the Y axis */
	bool use_flip_y() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_flip_y")) == 1;
	}

	/** Setter: Flip on the Y axis */
	void use_flip_y(bool value) {
		PyObject_SetAttrString(pyobjref, "use_flip_y", Py_BuildValue("i", value));
	}

	/** Getter: Convert input to float data */
	bool use_float() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_float")) == 1;
	}

	/** Setter: Convert input to float data */
	void use_float(bool value) {
		PyObject_SetAttrString(pyobjref, "use_float", Py_BuildValue("i", value));
	}

	/** Getter: Reverse frame order */
	bool use_reverse_frames() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_reverse_frames")) == 1;
	}

	/** Setter: Reverse frame order */
	void use_reverse_frames(bool value) {
		PyObject_SetAttrString(pyobjref, "use_reverse_frames", Py_BuildValue("i", value));
	}

	/** Getter:  */
	float color_multiply() { /* not implemented */ throw NULL; }
	/** Setter:  */
	void color_multiply(float value) {
		PyObject_SetAttrString(pyobjref, "color_multiply", Py_BuildValue("f", value));
	}

	/** Getter:  */
	float color_saturation() { /* not implemented */ throw NULL; }
	/** Setter:  */
	void color_saturation(float value) {
		PyObject_SetAttrString(pyobjref, "color_saturation", Py_BuildValue("f", value));
	}

	/** Getter: Only display every nth frame */
	float strobe() { /* not implemented */ throw NULL; }
	/** Setter: Only display every nth frame */
	void strobe(float value) {
		PyObject_SetAttrString(pyobjref, "strobe", Py_BuildValue("f", value));
	}

	/** Getter: Translate image before processing */
	bool use_translation() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_translation")) == 1;
	}

	/** Setter: Translate image before processing */
	void use_translation(bool value) {
		PyObject_SetAttrString(pyobjref, "use_translation", Py_BuildValue("i", value));
	}

	/** Getter:  */
	SequenceTransform transform() {
		/* not implemented */ throw NULL;
	}

	/** Getter: Crop image before processing */
	bool use_crop() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_crop")) == 1;
	}

	/** Setter: Crop image before processing */
	void use_crop(bool value) {
		PyObject_SetAttrString(pyobjref, "use_crop", Py_BuildValue("i", value));
	}

	/** Getter:  */
	SequenceCrop crop() {
		/* not implemented */ throw NULL;
	}

	/** Getter: Use a preview proxy and/or timecode index for this strip */
	bool use_proxy() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_proxy")) == 1;
	}

	/** Setter: Use a preview proxy and/or timecode index for this strip */
	void use_proxy(bool value) {
		PyObject_SetAttrString(pyobjref, "use_proxy", Py_BuildValue("i", value));
	}

	/** Getter:  */
	SequenceProxy proxy() {
		/* not implemented */ throw NULL;
	}

	/** Getter: Animation start offset (trim start) */
	int animation_offset_start() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "animation_offset_start"));
	}

	/** Setter: Animation start offset (trim start) */
	void animation_offset_start(int value) {
		PyObject_SetAttrString(pyobjref, "animation_offset_start", Py_BuildValue("i", value));
	}

	/** Getter: Animation end offset (trim end) */
	int animation_offset_end() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "animation_offset_end"));
	}

	/** Setter: Animation end offset (trim end) */
	void animation_offset_end(int value) {
		PyObject_SetAttrString(pyobjref, "animation_offset_end", Py_BuildValue("i", value));
	}

};

/**************** Movie Sequence ****************/

/**
 * Sequence strip to load a video
 */
class MovieSequence : public Sequence {
public:
	MovieSequence(PyObject* pyobj) : Sequence(pyobj) {}

	MovieSequence() : Sequence(0)
	{
		// not implemented
	}

	/** Getter: For MPEG movies, preseek this many frames */
	int mpeg_preseek() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "mpeg_preseek"));
	}

	/** Setter: For MPEG movies, preseek this many frames */
	void mpeg_preseek(int value) {
		PyObject_SetAttrString(pyobjref, "mpeg_preseek", Py_BuildValue("i", value));
	}

	/** Getter: For files with several movie streams, use the stream with the given index */
	int stream_index() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "stream_index"));
	}

	/** Setter: For files with several movie streams, use the stream with the given index */
	void stream_index(int value) {
		PyObject_SetAttrString(pyobjref, "stream_index", Py_BuildValue("i", value));
	}

	/** Getter:  */
	std::map<std::string, SequenceElement> elements() {
		// TODO: MISSING DEREF! USE #DEFINE!
		PyObject *seqval = PyObject_GetAttrString(pyobjref, "elements");
		PyObject *seqkeys = PyObject_CallMethod(seqval, "keys", NULL);
		std::map<std::string, SequenceElement> resmap;
		for (int i = 0; i < PySequence_Length(seqval); i++) {
			PyObject *keyobj = PySequence_GetItem(seqkeys, i);
			std::string key = PyBytes_AsString(PyUnicode_AsASCIIString(keyobj));
			SequenceElement value = SequenceElement(PySequence_GetItem(seqval, i));
			resmap.insert(std::pair<std::string,SequenceElement>(key, value));
		}
		return resmap;
	}

	/** Setter:  */
	void elements(std::map<std::string, SequenceElement> value) { /* not implemented */ }

	/** Getter:  */
	std::string filepath() { /* not implemented */ throw NULL; }
	/** Setter:  */
	void filepath(const std::string& value) { /* not implemented */ }

	/** Getter: Use Multiple Views (when available) */
	bool use_multiview() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_multiview")) == 1;
	}

	/** Setter: Use Multiple Views (when available) */
	void use_multiview(bool value) {
		PyObject_SetAttrString(pyobjref, "use_multiview", Py_BuildValue("i", value));
	}

	enum views_format_enum {
		views_format_INDIVIDUAL = 0,
		views_format_STEREO_3D = 1,
	};

	/** Getter: Mode to load movie views */
	views_format_enum views_format() { /* not implemented */ throw NULL; }
	/** Setter: Mode to load movie views */
	void views_format(views_format_enum value) { /* not implemented */ }

	/** Getter: Settings for stereo 3d */
	Stereo3dFormat stereo_3d_format() {
		/* not implemented */ throw NULL;
	}

	/** Getter: For video movies to remove fields */
	bool use_deinterlace() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_deinterlace")) == 1;
	}

	/** Setter: For video movies to remove fields */
	void use_deinterlace(bool value) {
		PyObject_SetAttrString(pyobjref, "use_deinterlace", Py_BuildValue("i", value));
	}

	enum alpha_mode_enum {
		alpha_mode_STRAIGHT = 0,
		alpha_mode_PREMUL = 1,
	};

	/** Getter: Representation of alpha information in the RGBA pixels */
	alpha_mode_enum alpha_mode() { /* not implemented */ throw NULL; }
	/** Setter: Representation of alpha information in the RGBA pixels */
	void alpha_mode(alpha_mode_enum value) { /* not implemented */ }

	/** Getter: Flip on the X axis */
	bool use_flip_x() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_flip_x")) == 1;
	}

	/** Setter: Flip on the X axis */
	void use_flip_x(bool value) {
		PyObject_SetAttrString(pyobjref, "use_flip_x", Py_BuildValue("i", value));
	}

	/** Getter: Flip on the Y axis */
	bool use_flip_y() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_flip_y")) == 1;
	}

	/** Setter: Flip on the Y axis */
	void use_flip_y(bool value) {
		PyObject_SetAttrString(pyobjref, "use_flip_y", Py_BuildValue("i", value));
	}

	/** Getter: Convert input to float data */
	bool use_float() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_float")) == 1;
	}

	/** Setter: Convert input to float data */
	void use_float(bool value) {
		PyObject_SetAttrString(pyobjref, "use_float", Py_BuildValue("i", value));
	}

	/** Getter: Reverse frame order */
	bool use_reverse_frames() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_reverse_frames")) == 1;
	}

	/** Setter: Reverse frame order */
	void use_reverse_frames(bool value) {
		PyObject_SetAttrString(pyobjref, "use_reverse_frames", Py_BuildValue("i", value));
	}

	/** Getter:  */
	float color_multiply() { /* not implemented */ throw NULL; }
	/** Setter:  */
	void color_multiply(float value) {
		PyObject_SetAttrString(pyobjref, "color_multiply", Py_BuildValue("f", value));
	}

	/** Getter:  */
	float color_saturation() { /* not implemented */ throw NULL; }
	/** Setter:  */
	void color_saturation(float value) {
		PyObject_SetAttrString(pyobjref, "color_saturation", Py_BuildValue("f", value));
	}

	/** Getter: Only display every nth frame */
	float strobe() { /* not implemented */ throw NULL; }
	/** Setter: Only display every nth frame */
	void strobe(float value) {
		PyObject_SetAttrString(pyobjref, "strobe", Py_BuildValue("f", value));
	}

	/** Getter: Translate image before processing */
	bool use_translation() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_translation")) == 1;
	}

	/** Setter: Translate image before processing */
	void use_translation(bool value) {
		PyObject_SetAttrString(pyobjref, "use_translation", Py_BuildValue("i", value));
	}

	/** Getter:  */
	SequenceTransform transform() {
		/* not implemented */ throw NULL;
	}

	/** Getter: Crop image before processing */
	bool use_crop() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_crop")) == 1;
	}

	/** Setter: Crop image before processing */
	void use_crop(bool value) {
		PyObject_SetAttrString(pyobjref, "use_crop", Py_BuildValue("i", value));
	}

	/** Getter:  */
	SequenceCrop crop() {
		/* not implemented */ throw NULL;
	}

	/** Getter: Use a preview proxy and/or timecode index for this strip */
	bool use_proxy() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_proxy")) == 1;
	}

	/** Setter: Use a preview proxy and/or timecode index for this strip */
	void use_proxy(bool value) {
		PyObject_SetAttrString(pyobjref, "use_proxy", Py_BuildValue("i", value));
	}

	/** Getter:  */
	SequenceProxy proxy() {
		/* not implemented */ throw NULL;
	}

	/** Getter: Animation start offset (trim start) */
	int animation_offset_start() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "animation_offset_start"));
	}

	/** Setter: Animation start offset (trim start) */
	void animation_offset_start(int value) {
		PyObject_SetAttrString(pyobjref, "animation_offset_start", Py_BuildValue("i", value));
	}

	/** Getter: Animation end offset (trim end) */
	int animation_offset_end() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "animation_offset_end"));
	}

	/** Setter: Animation end offset (trim end) */
	void animation_offset_end(int value) {
		PyObject_SetAttrString(pyobjref, "animation_offset_end", Py_BuildValue("i", value));
	}

	/** Getter: Input color space settings */
	ColorManagedInputColorspaceSettings colorspace_settings() {
		/* not implemented */ throw NULL;
	}

};

/**************** MovieClip Sequence ****************/

/**
 * Sequence strip to load a video from the clip editor
 */
class MovieClipSequence : public Sequence {
public:
	MovieClipSequence(PyObject* pyobj) : Sequence(pyobj) {}

	MovieClipSequence() : Sequence(0)
	{
		// not implemented
	}

	/** Getter: Use the undistorted version of the clip */
	bool undistort() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "undistort")) == 1;
	}

	/** Setter: Use the undistorted version of the clip */
	void undistort(bool value) {
		PyObject_SetAttrString(pyobjref, "undistort", Py_BuildValue("i", value));
	}

	/** Getter: Use the 2D stabilized version of the clip */
	bool stabilize2d() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "stabilize2d")) == 1;
	}

	/** Setter: Use the 2D stabilized version of the clip */
	void stabilize2d(bool value) {
		PyObject_SetAttrString(pyobjref, "stabilize2d", Py_BuildValue("i", value));
	}

	/** Getter: For video movies to remove fields */
	bool use_deinterlace() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_deinterlace")) == 1;
	}

	/** Setter: For video movies to remove fields */
	void use_deinterlace(bool value) {
		PyObject_SetAttrString(pyobjref, "use_deinterlace", Py_BuildValue("i", value));
	}

	enum alpha_mode_enum {
		alpha_mode_STRAIGHT = 0,
		alpha_mode_PREMUL = 1,
	};

	/** Getter: Representation of alpha information in the RGBA pixels */
	alpha_mode_enum alpha_mode() { /* not implemented */ throw NULL; }
	/** Setter: Representation of alpha information in the RGBA pixels */
	void alpha_mode(alpha_mode_enum value) { /* not implemented */ }

	/** Getter: Flip on the X axis */
	bool use_flip_x() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_flip_x")) == 1;
	}

	/** Setter: Flip on the X axis */
	void use_flip_x(bool value) {
		PyObject_SetAttrString(pyobjref, "use_flip_x", Py_BuildValue("i", value));
	}

	/** Getter: Flip on the Y axis */
	bool use_flip_y() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_flip_y")) == 1;
	}

	/** Setter: Flip on the Y axis */
	void use_flip_y(bool value) {
		PyObject_SetAttrString(pyobjref, "use_flip_y", Py_BuildValue("i", value));
	}

	/** Getter: Convert input to float data */
	bool use_float() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_float")) == 1;
	}

	/** Setter: Convert input to float data */
	void use_float(bool value) {
		PyObject_SetAttrString(pyobjref, "use_float", Py_BuildValue("i", value));
	}

	/** Getter: Reverse frame order */
	bool use_reverse_frames() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_reverse_frames")) == 1;
	}

	/** Setter: Reverse frame order */
	void use_reverse_frames(bool value) {
		PyObject_SetAttrString(pyobjref, "use_reverse_frames", Py_BuildValue("i", value));
	}

	/** Getter:  */
	float color_multiply() { /* not implemented */ throw NULL; }
	/** Setter:  */
	void color_multiply(float value) {
		PyObject_SetAttrString(pyobjref, "color_multiply", Py_BuildValue("f", value));
	}

	/** Getter:  */
	float color_saturation() { /* not implemented */ throw NULL; }
	/** Setter:  */
	void color_saturation(float value) {
		PyObject_SetAttrString(pyobjref, "color_saturation", Py_BuildValue("f", value));
	}

	/** Getter: Only display every nth frame */
	float strobe() { /* not implemented */ throw NULL; }
	/** Setter: Only display every nth frame */
	void strobe(float value) {
		PyObject_SetAttrString(pyobjref, "strobe", Py_BuildValue("f", value));
	}

	/** Getter: Translate image before processing */
	bool use_translation() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_translation")) == 1;
	}

	/** Setter: Translate image before processing */
	void use_translation(bool value) {
		PyObject_SetAttrString(pyobjref, "use_translation", Py_BuildValue("i", value));
	}

	/** Getter:  */
	SequenceTransform transform() {
		/* not implemented */ throw NULL;
	}

	/** Getter: Crop image before processing */
	bool use_crop() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_crop")) == 1;
	}

	/** Setter: Crop image before processing */
	void use_crop(bool value) {
		PyObject_SetAttrString(pyobjref, "use_crop", Py_BuildValue("i", value));
	}

	/** Getter:  */
	SequenceCrop crop() {
		/* not implemented */ throw NULL;
	}

	/** Getter: Animation start offset (trim start) */
	int animation_offset_start() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "animation_offset_start"));
	}

	/** Setter: Animation start offset (trim start) */
	void animation_offset_start(int value) {
		PyObject_SetAttrString(pyobjref, "animation_offset_start", Py_BuildValue("i", value));
	}

	/** Getter: Animation end offset (trim end) */
	int animation_offset_end() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "animation_offset_end"));
	}

	/** Setter: Animation end offset (trim end) */
	void animation_offset_end(int value) {
		PyObject_SetAttrString(pyobjref, "animation_offset_end", Py_BuildValue("i", value));
	}

};

/**************** Mask Sequence ****************/

/**
 * Sequence strip to load a video from a mask
 */
class MaskSequence : public Sequence {
public:
	MaskSequence(PyObject* pyobj) : Sequence(pyobj) {}

	MaskSequence() : Sequence(0)
	{
		// not implemented
	}

	/** Getter: Mask that this sequence uses */
	Mask mask();

	/** Getter: For video movies to remove fields */
	bool use_deinterlace() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_deinterlace")) == 1;
	}

	/** Setter: For video movies to remove fields */
	void use_deinterlace(bool value) {
		PyObject_SetAttrString(pyobjref, "use_deinterlace", Py_BuildValue("i", value));
	}

	enum alpha_mode_enum {
		alpha_mode_STRAIGHT = 0,
		alpha_mode_PREMUL = 1,
	};

	/** Getter: Representation of alpha information in the RGBA pixels */
	alpha_mode_enum alpha_mode() { /* not implemented */ throw NULL; }
	/** Setter: Representation of alpha information in the RGBA pixels */
	void alpha_mode(alpha_mode_enum value) { /* not implemented */ }

	/** Getter: Flip on the X axis */
	bool use_flip_x() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_flip_x")) == 1;
	}

	/** Setter: Flip on the X axis */
	void use_flip_x(bool value) {
		PyObject_SetAttrString(pyobjref, "use_flip_x", Py_BuildValue("i", value));
	}

	/** Getter: Flip on the Y axis */
	bool use_flip_y() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_flip_y")) == 1;
	}

	/** Setter: Flip on the Y axis */
	void use_flip_y(bool value) {
		PyObject_SetAttrString(pyobjref, "use_flip_y", Py_BuildValue("i", value));
	}

	/** Getter: Convert input to float data */
	bool use_float() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_float")) == 1;
	}

	/** Setter: Convert input to float data */
	void use_float(bool value) {
		PyObject_SetAttrString(pyobjref, "use_float", Py_BuildValue("i", value));
	}

	/** Getter: Reverse frame order */
	bool use_reverse_frames() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_reverse_frames")) == 1;
	}

	/** Setter: Reverse frame order */
	void use_reverse_frames(bool value) {
		PyObject_SetAttrString(pyobjref, "use_reverse_frames", Py_BuildValue("i", value));
	}

	/** Getter:  */
	float color_multiply() { /* not implemented */ throw NULL; }
	/** Setter:  */
	void color_multiply(float value) {
		PyObject_SetAttrString(pyobjref, "color_multiply", Py_BuildValue("f", value));
	}

	/** Getter:  */
	float color_saturation() { /* not implemented */ throw NULL; }
	/** Setter:  */
	void color_saturation(float value) {
		PyObject_SetAttrString(pyobjref, "color_saturation", Py_BuildValue("f", value));
	}

	/** Getter: Only display every nth frame */
	float strobe() { /* not implemented */ throw NULL; }
	/** Setter: Only display every nth frame */
	void strobe(float value) {
		PyObject_SetAttrString(pyobjref, "strobe", Py_BuildValue("f", value));
	}

	/** Getter: Translate image before processing */
	bool use_translation() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_translation")) == 1;
	}

	/** Setter: Translate image before processing */
	void use_translation(bool value) {
		PyObject_SetAttrString(pyobjref, "use_translation", Py_BuildValue("i", value));
	}

	/** Getter:  */
	SequenceTransform transform() {
		/* not implemented */ throw NULL;
	}

	/** Getter: Crop image before processing */
	bool use_crop() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_crop")) == 1;
	}

	/** Setter: Crop image before processing */
	void use_crop(bool value) {
		PyObject_SetAttrString(pyobjref, "use_crop", Py_BuildValue("i", value));
	}

	/** Getter:  */
	SequenceCrop crop() {
		/* not implemented */ throw NULL;
	}

	/** Getter: Animation start offset (trim start) */
	int animation_offset_start() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "animation_offset_start"));
	}

	/** Setter: Animation start offset (trim start) */
	void animation_offset_start(int value) {
		PyObject_SetAttrString(pyobjref, "animation_offset_start", Py_BuildValue("i", value));
	}

	/** Getter: Animation end offset (trim end) */
	int animation_offset_end() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "animation_offset_end"));
	}

	/** Setter: Animation end offset (trim end) */
	void animation_offset_end(int value) {
		PyObject_SetAttrString(pyobjref, "animation_offset_end", Py_BuildValue("i", value));
	}

};

/**************** Sound Sequence ****************/

/**
 * Sequence strip defining a sound to be played over a period of time
 */
class SoundSequence : public Sequence {
public:
	SoundSequence(PyObject* pyobj) : Sequence(pyobj) {}

	SoundSequence() : Sequence(0)
	{
		// not implemented
	}

	/** Getter: Sound datablock used by this sequence */
	Sound sound();

	/** Getter: Playback volume of the sound */
	float volume() { /* not implemented */ throw NULL; }
	/** Setter: Playback volume of the sound */
	void volume(float value) {
		PyObject_SetAttrString(pyobjref, "volume", Py_BuildValue("f", value));
	}

	/** Getter: Playback pitch of the sound */
	float pitch() { /* not implemented */ throw NULL; }
	/** Setter: Playback pitch of the sound */
	void pitch(float value) {
		PyObject_SetAttrString(pyobjref, "pitch", Py_BuildValue("f", value));
	}

	/** Getter: Playback panning of the sound (only for Mono sources) */
	float pan() { /* not implemented */ throw NULL; }
	/** Setter: Playback panning of the sound (only for Mono sources) */
	void pan(float value) {
		PyObject_SetAttrString(pyobjref, "pan", Py_BuildValue("f", value));
	}

	/** Getter:  */
	std::string filepath() { /* not implemented */ throw NULL; }
	/** Setter:  */
	void filepath(const std::string& value) { /* not implemented */ }

	/** Getter: Whether to draw the sound's waveform */
	bool show_waveform() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "show_waveform")) == 1;
	}

	/** Setter: Whether to draw the sound's waveform */
	void show_waveform(bool value) {
		PyObject_SetAttrString(pyobjref, "show_waveform", Py_BuildValue("i", value));
	}

	/** Getter: Animation start offset (trim start) */
	int animation_offset_start() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "animation_offset_start"));
	}

	/** Setter: Animation start offset (trim start) */
	void animation_offset_start(int value) {
		PyObject_SetAttrString(pyobjref, "animation_offset_start", Py_BuildValue("i", value));
	}

	/** Getter: Animation end offset (trim end) */
	int animation_offset_end() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "animation_offset_end"));
	}

	/** Setter: Animation end offset (trim end) */
	void animation_offset_end(int value) {
		PyObject_SetAttrString(pyobjref, "animation_offset_end", Py_BuildValue("i", value));
	}

};

/**************** Effect Sequence ****************/

/**
 * Sequence strip applying an effect on the images created by other strips
 */
class EffectSequence : public Sequence {
public:
	EffectSequence(PyObject* pyobj) : Sequence(pyobj) {}

	EffectSequence() : Sequence(0)
	{
		// not implemented
	}

	/** Getter: For video movies to remove fields */
	bool use_deinterlace() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_deinterlace")) == 1;
	}

	/** Setter: For video movies to remove fields */
	void use_deinterlace(bool value) {
		PyObject_SetAttrString(pyobjref, "use_deinterlace", Py_BuildValue("i", value));
	}

	enum alpha_mode_enum {
		alpha_mode_STRAIGHT = 0,
		alpha_mode_PREMUL = 1,
	};

	/** Getter: Representation of alpha information in the RGBA pixels */
	alpha_mode_enum alpha_mode() { /* not implemented */ throw NULL; }
	/** Setter: Representation of alpha information in the RGBA pixels */
	void alpha_mode(alpha_mode_enum value) { /* not implemented */ }

	/** Getter: Flip on the X axis */
	bool use_flip_x() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_flip_x")) == 1;
	}

	/** Setter: Flip on the X axis */
	void use_flip_x(bool value) {
		PyObject_SetAttrString(pyobjref, "use_flip_x", Py_BuildValue("i", value));
	}

	/** Getter: Flip on the Y axis */
	bool use_flip_y() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_flip_y")) == 1;
	}

	/** Setter: Flip on the Y axis */
	void use_flip_y(bool value) {
		PyObject_SetAttrString(pyobjref, "use_flip_y", Py_BuildValue("i", value));
	}

	/** Getter: Convert input to float data */
	bool use_float() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_float")) == 1;
	}

	/** Setter: Convert input to float data */
	void use_float(bool value) {
		PyObject_SetAttrString(pyobjref, "use_float", Py_BuildValue("i", value));
	}

	/** Getter: Reverse frame order */
	bool use_reverse_frames() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_reverse_frames")) == 1;
	}

	/** Setter: Reverse frame order */
	void use_reverse_frames(bool value) {
		PyObject_SetAttrString(pyobjref, "use_reverse_frames", Py_BuildValue("i", value));
	}

	/** Getter:  */
	float color_multiply() { /* not implemented */ throw NULL; }
	/** Setter:  */
	void color_multiply(float value) {
		PyObject_SetAttrString(pyobjref, "color_multiply", Py_BuildValue("f", value));
	}

	/** Getter:  */
	float color_saturation() { /* not implemented */ throw NULL; }
	/** Setter:  */
	void color_saturation(float value) {
		PyObject_SetAttrString(pyobjref, "color_saturation", Py_BuildValue("f", value));
	}

	/** Getter: Only display every nth frame */
	float strobe() { /* not implemented */ throw NULL; }
	/** Setter: Only display every nth frame */
	void strobe(float value) {
		PyObject_SetAttrString(pyobjref, "strobe", Py_BuildValue("f", value));
	}

	/** Getter: Translate image before processing */
	bool use_translation() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_translation")) == 1;
	}

	/** Setter: Translate image before processing */
	void use_translation(bool value) {
		PyObject_SetAttrString(pyobjref, "use_translation", Py_BuildValue("i", value));
	}

	/** Getter:  */
	SequenceTransform transform() {
		/* not implemented */ throw NULL;
	}

	/** Getter: Crop image before processing */
	bool use_crop() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_crop")) == 1;
	}

	/** Setter: Crop image before processing */
	void use_crop(bool value) {
		PyObject_SetAttrString(pyobjref, "use_crop", Py_BuildValue("i", value));
	}

	/** Getter:  */
	SequenceCrop crop() {
		/* not implemented */ throw NULL;
	}

	/** Getter: Use a preview proxy and/or timecode index for this strip */
	bool use_proxy() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_proxy")) == 1;
	}

	/** Setter: Use a preview proxy and/or timecode index for this strip */
	void use_proxy(bool value) {
		PyObject_SetAttrString(pyobjref, "use_proxy", Py_BuildValue("i", value));
	}

	/** Getter:  */
	SequenceProxy proxy() {
		/* not implemented */ throw NULL;
	}

};

/**************** Add Sequence ****************/

/**
 * Add Sequence
 */
class AddSequence : public EffectSequence {
public:
	AddSequence(PyObject* pyobj) : EffectSequence(pyobj) {}

	AddSequence() : EffectSequence(0)
	{
		// not implemented
	}

	/** Getter:  */
	int input_count() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "input_count"));
	}

	/** Setter:  */
	void input_count(int value) {
		PyObject_SetAttrString(pyobjref, "input_count", Py_BuildValue("i", value));
	}

	/** Getter: First input for the effect strip */
	Sequence input_1() {
		/* not implemented */ throw NULL;
	}

	/** Getter: Second input for the effect strip */
	Sequence input_2() {
		/* not implemented */ throw NULL;
	}

};

/**************** Adjustment Layer Sequence ****************/

/**
 * Sequence strip to perform filter adjustments to layers below
 */
class AdjustmentSequence : public EffectSequence {
public:
	AdjustmentSequence(PyObject* pyobj) : EffectSequence(pyobj) {}

	AdjustmentSequence() : EffectSequence(0)
	{
		// not implemented
	}

	/** Getter:  */
	int input_count() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "input_count"));
	}

	/** Setter:  */
	void input_count(int value) {
		PyObject_SetAttrString(pyobjref, "input_count", Py_BuildValue("i", value));
	}

	/** Getter: Animation start offset (trim start) */
	int animation_offset_start() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "animation_offset_start"));
	}

	/** Setter: Animation start offset (trim start) */
	void animation_offset_start(int value) {
		PyObject_SetAttrString(pyobjref, "animation_offset_start", Py_BuildValue("i", value));
	}

	/** Getter: Animation end offset (trim end) */
	int animation_offset_end() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "animation_offset_end"));
	}

	/** Setter: Animation end offset (trim end) */
	void animation_offset_end(int value) {
		PyObject_SetAttrString(pyobjref, "animation_offset_end", Py_BuildValue("i", value));
	}

};

/**************** Alpha Over Sequence ****************/

/**
 * Alpha Over Sequence
 */
class AlphaOverSequence : public EffectSequence {
public:
	AlphaOverSequence(PyObject* pyobj) : EffectSequence(pyobj) {}

	AlphaOverSequence() : EffectSequence(0)
	{
		// not implemented
	}

	/** Getter:  */
	int input_count() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "input_count"));
	}

	/** Setter:  */
	void input_count(int value) {
		PyObject_SetAttrString(pyobjref, "input_count", Py_BuildValue("i", value));
	}

	/** Getter: First input for the effect strip */
	Sequence input_1() {
		/* not implemented */ throw NULL;
	}

	/** Getter: Second input for the effect strip */
	Sequence input_2() {
		/* not implemented */ throw NULL;
	}

};

/**************** Alpha Under Sequence ****************/

/**
 * Alpha Under Sequence
 */
class AlphaUnderSequence : public EffectSequence {
public:
	AlphaUnderSequence(PyObject* pyobj) : EffectSequence(pyobj) {}

	AlphaUnderSequence() : EffectSequence(0)
	{
		// not implemented
	}

	/** Getter:  */
	int input_count() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "input_count"));
	}

	/** Setter:  */
	void input_count(int value) {
		PyObject_SetAttrString(pyobjref, "input_count", Py_BuildValue("i", value));
	}

	/** Getter: First input for the effect strip */
	Sequence input_1() {
		/* not implemented */ throw NULL;
	}

	/** Getter: Second input for the effect strip */
	Sequence input_2() {
		/* not implemented */ throw NULL;
	}

};

/**************** Color Sequence ****************/

/**
 * Sequence strip creating an image filled with a single color
 */
class ColorSequence : public EffectSequence {
public:
	ColorSequence(PyObject* pyobj) : EffectSequence(pyobj) {}

	ColorSequence() : EffectSequence(0)
	{
		// not implemented
	}

	/** Getter:  */
	int input_count() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "input_count"));
	}

	/** Setter:  */
	void input_count(int value) {
		PyObject_SetAttrString(pyobjref, "input_count", Py_BuildValue("i", value));
	}

	/** Getter:  */
	std::array<float, 3> color() {
		// TODO: MISSING DEREF! USE #DEFINE!
		PyObject *seqval = PyObject_GetAttrString(pyobjref, "color");
		std::array<float, 3> resarr;
		for (int i = 0; i < 3; i++)
			resarr[i] = (float)PyFloat_AsDouble(PySequence_GetItem(seqval, i));
		return resarr;
	}

	/** Setter:  */
	void color(float values[3]) { /* not implemented */ }

};

/**************** Cross Sequence ****************/

/**
 * Cross Sequence
 */
class CrossSequence : public EffectSequence {
public:
	CrossSequence(PyObject* pyobj) : EffectSequence(pyobj) {}

	CrossSequence() : EffectSequence(0)
	{
		// not implemented
	}

	/** Getter:  */
	int input_count() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "input_count"));
	}

	/** Setter:  */
	void input_count(int value) {
		PyObject_SetAttrString(pyobjref, "input_count", Py_BuildValue("i", value));
	}

	/** Getter: First input for the effect strip */
	Sequence input_1() {
		/* not implemented */ throw NULL;
	}

	/** Getter: Second input for the effect strip */
	Sequence input_2() {
		/* not implemented */ throw NULL;
	}

};

/**************** Gamma Cross Sequence ****************/

/**
 * Gamma Cross Sequence
 */
class GammaCrossSequence : public EffectSequence {
public:
	GammaCrossSequence(PyObject* pyobj) : EffectSequence(pyobj) {}

	GammaCrossSequence() : EffectSequence(0)
	{
		// not implemented
	}

	/** Getter:  */
	int input_count() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "input_count"));
	}

	/** Setter:  */
	void input_count(int value) {
		PyObject_SetAttrString(pyobjref, "input_count", Py_BuildValue("i", value));
	}

	/** Getter: First input for the effect strip */
	Sequence input_1() {
		/* not implemented */ throw NULL;
	}

	/** Getter: Second input for the effect strip */
	Sequence input_2() {
		/* not implemented */ throw NULL;
	}

};

/**************** Glow Sequence ****************/

/**
 * Sequence strip creating a glow effect
 */
class GlowSequence : public EffectSequence {
public:
	GlowSequence(PyObject* pyobj) : EffectSequence(pyobj) {}

	GlowSequence() : EffectSequence(0)
	{
		// not implemented
	}

	/** Getter:  */
	int input_count() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "input_count"));
	}

	/** Setter:  */
	void input_count(int value) {
		PyObject_SetAttrString(pyobjref, "input_count", Py_BuildValue("i", value));
	}

	/** Getter: First input for the effect strip */
	Sequence input_1() {
		/* not implemented */ throw NULL;
	}

	/** Getter: Minimum intensity to trigger a glow */
	float threshold() { /* not implemented */ throw NULL; }
	/** Setter: Minimum intensity to trigger a glow */
	void threshold(float value) {
		PyObject_SetAttrString(pyobjref, "threshold", Py_BuildValue("f", value));
	}

	/** Getter: Brightness limit of intensity */
	float clamp() { /* not implemented */ throw NULL; }
	/** Setter: Brightness limit of intensity */
	void clamp(float value) {
		PyObject_SetAttrString(pyobjref, "clamp", Py_BuildValue("f", value));
	}

	/** Getter: Brightness multiplier */
	float boost_factor() { /* not implemented */ throw NULL; }
	/** Setter: Brightness multiplier */
	void boost_factor(float value) {
		PyObject_SetAttrString(pyobjref, "boost_factor", Py_BuildValue("f", value));
	}

	/** Getter: Radius of glow effect */
	float blur_radius() { /* not implemented */ throw NULL; }
	/** Setter: Radius of glow effect */
	void blur_radius(float value) {
		PyObject_SetAttrString(pyobjref, "blur_radius", Py_BuildValue("f", value));
	}

	/** Getter: Accuracy of the blur effect */
	int quality() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "quality"));
	}

	/** Setter: Accuracy of the blur effect */
	void quality(int value) {
		PyObject_SetAttrString(pyobjref, "quality", Py_BuildValue("i", value));
	}

	/** Getter: Show the glow buffer only */
	bool use_only_boost() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_only_boost")) == 1;
	}

	/** Setter: Show the glow buffer only */
	void use_only_boost(bool value) {
		PyObject_SetAttrString(pyobjref, "use_only_boost", Py_BuildValue("i", value));
	}

};

/**************** Multicam Select Sequence ****************/

/**
 * Sequence strip to perform multicam editing
 */
class MulticamSequence : public EffectSequence {
public:
	MulticamSequence(PyObject* pyobj) : EffectSequence(pyobj) {}

	MulticamSequence() : EffectSequence(0)
	{
		// not implemented
	}

	/** Getter:  */
	int input_count() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "input_count"));
	}

	/** Setter:  */
	void input_count(int value) {
		PyObject_SetAttrString(pyobjref, "input_count", Py_BuildValue("i", value));
	}

	/** Getter:  */
	int multicam_source() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "multicam_source"));
	}

	/** Setter:  */
	void multicam_source(int value) {
		PyObject_SetAttrString(pyobjref, "multicam_source", Py_BuildValue("i", value));
	}

	/** Getter: Animation start offset (trim start) */
	int animation_offset_start() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "animation_offset_start"));
	}

	/** Setter: Animation start offset (trim start) */
	void animation_offset_start(int value) {
		PyObject_SetAttrString(pyobjref, "animation_offset_start", Py_BuildValue("i", value));
	}

	/** Getter: Animation end offset (trim end) */
	int animation_offset_end() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "animation_offset_end"));
	}

	/** Setter: Animation end offset (trim end) */
	void animation_offset_end(int value) {
		PyObject_SetAttrString(pyobjref, "animation_offset_end", Py_BuildValue("i", value));
	}

};

/**************** Multiply Sequence ****************/

/**
 * Multiply Sequence
 */
class MultiplySequence : public EffectSequence {
public:
	MultiplySequence(PyObject* pyobj) : EffectSequence(pyobj) {}

	MultiplySequence() : EffectSequence(0)
	{
		// not implemented
	}

	/** Getter:  */
	int input_count() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "input_count"));
	}

	/** Setter:  */
	void input_count(int value) {
		PyObject_SetAttrString(pyobjref, "input_count", Py_BuildValue("i", value));
	}

	/** Getter: First input for the effect strip */
	Sequence input_1() {
		/* not implemented */ throw NULL;
	}

	/** Getter: Second input for the effect strip */
	Sequence input_2() {
		/* not implemented */ throw NULL;
	}

};

/**************** Over Drop Sequence ****************/

/**
 * Over Drop Sequence
 */
class OverDropSequence : public EffectSequence {
public:
	OverDropSequence(PyObject* pyobj) : EffectSequence(pyobj) {}

	OverDropSequence() : EffectSequence(0)
	{
		// not implemented
	}

	/** Getter:  */
	int input_count() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "input_count"));
	}

	/** Setter:  */
	void input_count(int value) {
		PyObject_SetAttrString(pyobjref, "input_count", Py_BuildValue("i", value));
	}

	/** Getter: First input for the effect strip */
	Sequence input_1() {
		/* not implemented */ throw NULL;
	}

	/** Getter: Second input for the effect strip */
	Sequence input_2() {
		/* not implemented */ throw NULL;
	}

};

/**************** SpeedControl Sequence ****************/

/**
 * Sequence strip to control the speed of other strips
 */
class SpeedControlSequence : public EffectSequence {
public:
	SpeedControlSequence(PyObject* pyobj) : EffectSequence(pyobj) {}

	SpeedControlSequence() : EffectSequence(0)
	{
		// not implemented
	}

	/** Getter:  */
	int input_count() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "input_count"));
	}

	/** Setter:  */
	void input_count(int value) {
		PyObject_SetAttrString(pyobjref, "input_count", Py_BuildValue("i", value));
	}

	/** Getter: First input for the effect strip */
	Sequence input_1() {
		/* not implemented */ throw NULL;
	}

	/** Getter: Multiply the resulting speed after the speed factor */
	float multiply_speed() { /* not implemented */ throw NULL; }
	/** Setter: Multiply the resulting speed after the speed factor */
	void multiply_speed(float value) {
		PyObject_SetAttrString(pyobjref, "multiply_speed", Py_BuildValue("f", value));
	}

	/** Getter: Interpret the value as speed instead of a frame number */
	bool use_as_speed() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_as_speed")) == 1;
	}

	/** Setter: Interpret the value as speed instead of a frame number */
	void use_as_speed(bool value) {
		PyObject_SetAttrString(pyobjref, "use_as_speed", Py_BuildValue("i", value));
	}

	/** Getter: Scale values from 0.0 to 1.0 to target sequence length */
	bool scale_to_length() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "scale_to_length")) == 1;
	}

	/** Setter: Scale values from 0.0 to 1.0 to target sequence length */
	void scale_to_length(bool value) {
		PyObject_SetAttrString(pyobjref, "scale_to_length", Py_BuildValue("i", value));
	}

};

/**************** Subtract Sequence ****************/

/**
 * Subtract Sequence
 */
class SubtractSequence : public EffectSequence {
public:
	SubtractSequence(PyObject* pyobj) : EffectSequence(pyobj) {}

	SubtractSequence() : EffectSequence(0)
	{
		// not implemented
	}

	/** Getter:  */
	int input_count() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "input_count"));
	}

	/** Setter:  */
	void input_count(int value) {
		PyObject_SetAttrString(pyobjref, "input_count", Py_BuildValue("i", value));
	}

	/** Getter: First input for the effect strip */
	Sequence input_1() {
		/* not implemented */ throw NULL;
	}

	/** Getter: Second input for the effect strip */
	Sequence input_2() {
		/* not implemented */ throw NULL;
	}

};

/**************** Transform Sequence ****************/

/**
 * Sequence strip applying affine transformations to other strips
 */
class TransformSequence : public EffectSequence {
public:
	TransformSequence(PyObject* pyobj) : EffectSequence(pyobj) {}

	TransformSequence() : EffectSequence(0)
	{
		// not implemented
	}

	/** Getter:  */
	int input_count() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "input_count"));
	}

	/** Setter:  */
	void input_count(int value) {
		PyObject_SetAttrString(pyobjref, "input_count", Py_BuildValue("i", value));
	}

	/** Getter: First input for the effect strip */
	Sequence input_1() {
		/* not implemented */ throw NULL;
	}

	/** Getter:  */
	float scale_start_x() { /* not implemented */ throw NULL; }
	/** Setter:  */
	void scale_start_x(float value) {
		PyObject_SetAttrString(pyobjref, "scale_start_x", Py_BuildValue("f", value));
	}

	/** Getter:  */
	float scale_start_y() { /* not implemented */ throw NULL; }
	/** Setter:  */
	void scale_start_y(float value) {
		PyObject_SetAttrString(pyobjref, "scale_start_y", Py_BuildValue("f", value));
	}

	/** Getter: Scale uniformly, preserving aspect ratio */
	bool use_uniform_scale() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_uniform_scale")) == 1;
	}

	/** Setter: Scale uniformly, preserving aspect ratio */
	void use_uniform_scale(bool value) {
		PyObject_SetAttrString(pyobjref, "use_uniform_scale", Py_BuildValue("i", value));
	}

	/** Getter:  */
	float translate_start_x() { /* not implemented */ throw NULL; }
	/** Setter:  */
	void translate_start_x(float value) {
		PyObject_SetAttrString(pyobjref, "translate_start_x", Py_BuildValue("f", value));
	}

	/** Getter:  */
	float translate_start_y() { /* not implemented */ throw NULL; }
	/** Setter:  */
	void translate_start_y(float value) {
		PyObject_SetAttrString(pyobjref, "translate_start_y", Py_BuildValue("f", value));
	}

	/** Getter:  */
	float rotation_start() { /* not implemented */ throw NULL; }
	/** Setter:  */
	void rotation_start(float value) {
		PyObject_SetAttrString(pyobjref, "rotation_start", Py_BuildValue("f", value));
	}

	enum translation_unit_enum {
		translation_unit_PIXELS = 0,
		translation_unit_PERCENT = 1,
	};

	/** Getter:  */
	translation_unit_enum translation_unit() { /* not implemented */ throw NULL; }
	/** Setter:  */
	void translation_unit(translation_unit_enum value) { /* not implemented */ }

	enum interpolation_enum {
		interpolation_NONE = 0,
		interpolation_BILINEAR = 1,
		interpolation_BICUBIC = 2,
	};

	/** Getter:  */
	interpolation_enum interpolation() { /* not implemented */ throw NULL; }
	/** Setter:  */
	void interpolation(interpolation_enum value) { /* not implemented */ }

};

/**************** Wipe Sequence ****************/

/**
 * Sequence strip creating a wipe transition
 */
class WipeSequence : public EffectSequence {
public:
	WipeSequence(PyObject* pyobj) : EffectSequence(pyobj) {}

	WipeSequence() : EffectSequence(0)
	{
		// not implemented
	}

	/** Getter:  */
	int input_count() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "input_count"));
	}

	/** Setter:  */
	void input_count(int value) {
		PyObject_SetAttrString(pyobjref, "input_count", Py_BuildValue("i", value));
	}

	/** Getter: First input for the effect strip */
	Sequence input_1() {
		/* not implemented */ throw NULL;
	}

	/** Getter: Width of the blur edge, in percentage relative to the image size */
	float blur_width() { /* not implemented */ throw NULL; }
	/** Setter: Width of the blur edge, in percentage relative to the image size */
	void blur_width(float value) {
		PyObject_SetAttrString(pyobjref, "blur_width", Py_BuildValue("f", value));
	}

	/** Getter: Edge angle */
	float angle() { /* not implemented */ throw NULL; }
	/** Setter: Edge angle */
	void angle(float value) {
		PyObject_SetAttrString(pyobjref, "angle", Py_BuildValue("f", value));
	}

	enum direction_enum {
		direction_OUT = 0,
		direction_IN = 1,
	};

	/** Getter: Wipe direction */
	direction_enum direction() { /* not implemented */ throw NULL; }
	/** Setter: Wipe direction */
	void direction(direction_enum value) { /* not implemented */ }

	enum transition_type_enum {
		transition_type_SINGLE = 0,
		transition_type_DOUBLE = 1,
		transition_type_IRIS = 4,
		transition_type_CLOCK = 5,
	};

	/** Getter:  */
	transition_type_enum transition_type() { /* not implemented */ throw NULL; }
	/** Setter:  */
	void transition_type(transition_type_enum value) { /* not implemented */ }

};

/**************** Gaussian Blur Sequence ****************/

/**
 * Sequence strip creating a gaussian blur
 */
class GaussianBlurSequence : public EffectSequence {
public:
	GaussianBlurSequence(PyObject* pyobj) : EffectSequence(pyobj) {}

	GaussianBlurSequence() : EffectSequence(0)
	{
		// not implemented
	}

	/** Getter:  */
	int input_count() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "input_count"));
	}

	/** Setter:  */
	void input_count(int value) {
		PyObject_SetAttrString(pyobjref, "input_count", Py_BuildValue("i", value));
	}

	/** Getter: First input for the effect strip */
	Sequence input_1() {
		/* not implemented */ throw NULL;
	}

	/** Getter: Size of the blur along X axis */
	float size_x() { /* not implemented */ throw NULL; }
	/** Setter: Size of the blur along X axis */
	void size_x(float value) {
		PyObject_SetAttrString(pyobjref, "size_x", Py_BuildValue("f", value));
	}

	/** Getter: Size of the blur along Y axis */
	float size_y() { /* not implemented */ throw NULL; }
	/** Setter: Size of the blur along Y axis */
	void size_y(float value) {
		PyObject_SetAttrString(pyobjref, "size_y", Py_BuildValue("f", value));
	}

};

/**************** SequenceModifier ****************/

/**
 * Modifier for sequence strip
 */
class SequenceModifier : public pyUniplug {
public:
	SequenceModifier(PyObject* pyobj) : pyUniplug(pyobj) {}

	SequenceModifier() : pyUniplug(0)
	{
		// not implemented
	}

	/** Getter:  */
	std::string name() { /* not implemented */ throw NULL; }
	/** Setter:  */
	void name(const std::string& value) { /* not implemented */ }

	enum type_enum {
		type_COLOR_BALANCE = 1,
		type_CURVES = 2,
		type_HUE_CORRECT = 3,
		type_BRIGHT_CONTRAST = 4,
		type_MASK = 5,
	};

	/** Getter:  */
	type_enum type() { /* not implemented */ throw NULL; }
	/** Setter:  */
	void type(type_enum value) { /* not implemented */ }

	/** Getter: Mute this modifier */
	bool mute() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "mute")) == 1;
	}

	/** Setter: Mute this modifier */
	void mute(bool value) {
		PyObject_SetAttrString(pyobjref, "mute", Py_BuildValue("i", value));
	}

	/** Getter: Mute expanded settings for the modifier */
	bool show_expanded() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "show_expanded")) == 1;
	}

	/** Setter: Mute expanded settings for the modifier */
	void show_expanded(bool value) {
		PyObject_SetAttrString(pyobjref, "show_expanded", Py_BuildValue("i", value));
	}

	enum input_mask_type_enum {
		input_mask_type_STRIP = 0,
		input_mask_type_ID = 1,
	};

	/** Getter: Type of input data used for mask */
	input_mask_type_enum input_mask_type() { /* not implemented */ throw NULL; }
	/** Setter: Type of input data used for mask */
	void input_mask_type(input_mask_type_enum value) { /* not implemented */ }

	/** Getter: Strip used as mask input for the modifier */
	Sequence input_mask_strip() {
		/* not implemented */ throw NULL;
	}

	/** Getter: Mask ID used as mask input for the modifier */
	Mask input_mask_id();

};

/**************** ColorBalanceModifier ****************/

/**
 * Color balance modifier for sequence strip
 */
class ColorBalanceModifier : public SequenceModifier {
public:
	ColorBalanceModifier(PyObject* pyobj) : SequenceModifier(pyobj) {}

	ColorBalanceModifier() : SequenceModifier(0)
	{
		// not implemented
	}

	/** Getter:  */
	SequenceColorBalanceData color_balance() {
		/* not implemented */ throw NULL;
	}

	/** Getter:  */
	float color_multiply() { /* not implemented */ throw NULL; }
	/** Setter:  */
	void color_multiply(float value) {
		PyObject_SetAttrString(pyobjref, "color_multiply", Py_BuildValue("f", value));
	}

};

/**************** CurvesModifier ****************/

/**
 * RGB curves modifier for sequence strip
 */
class CurvesModifier : public SequenceModifier {
public:
	CurvesModifier(PyObject* pyobj) : SequenceModifier(pyobj) {}

	CurvesModifier() : SequenceModifier(0)
	{
		// not implemented
	}

	/** Getter:  */
	CurveMapping curve_mapping() {
		/* not implemented */ throw NULL;
	}

};

/**************** HueCorrectModifier ****************/

/**
 * Hue correction modifier for sequence strip
 */
class HueCorrectModifier : public SequenceModifier {
public:
	HueCorrectModifier(PyObject* pyobj) : SequenceModifier(pyobj) {}

	HueCorrectModifier() : SequenceModifier(0)
	{
		// not implemented
	}

	/** Getter:  */
	CurveMapping curve_mapping() {
		/* not implemented */ throw NULL;
	}

};

/**************** BrightContrastModifier ****************/

/**
 * Bright/contrast modifier data for sequence strip
 */
class BrightContrastModifier : public SequenceModifier {
public:
	BrightContrastModifier(PyObject* pyobj) : SequenceModifier(pyobj) {}

	BrightContrastModifier() : SequenceModifier(0)
	{
		// not implemented
	}

	/** Getter:  */
	float bright() { /* not implemented */ throw NULL; }
	/** Setter:  */
	void bright(float value) {
		PyObject_SetAttrString(pyobjref, "bright", Py_BuildValue("f", value));
	}

	/** Getter:  */
	float contrast() { /* not implemented */ throw NULL; }
	/** Setter:  */
	void contrast(float value) {
		PyObject_SetAttrString(pyobjref, "contrast", Py_BuildValue("f", value));
	}

};

/**************** Domain Settings ****************/

/**
 * Smoke domain settings
 */
class SmokeDomainSettings : public pyUniplug {
public:
	SmokeDomainSettings(PyObject* pyobj) : pyUniplug(pyobj) {}

	SmokeDomainSettings() : pyUniplug(0)
	{
		// not implemented
	}

	/** Getter: Maximal resolution used in the fluid domain */
	int resolution_max() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "resolution_max"));
	}

	/** Setter: Maximal resolution used in the fluid domain */
	void resolution_max(int value) {
		PyObject_SetAttrString(pyobjref, "resolution_max", Py_BuildValue("i", value));
	}

	/** Getter: Enhance the resolution of smoke by this factor using noise */
	int amplify() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "amplify"));
	}

	/** Setter: Enhance the resolution of smoke by this factor using noise */
	void amplify(int value) {
		PyObject_SetAttrString(pyobjref, "amplify", Py_BuildValue("i", value));
	}

	/** Getter: Enable high resolution (using amplification) */
	bool use_high_resolution() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_high_resolution")) == 1;
	}

	/** Setter: Enable high resolution (using amplification) */
	void use_high_resolution(bool value) {
		PyObject_SetAttrString(pyobjref, "use_high_resolution", Py_BuildValue("i", value));
	}

	/** Getter: Show high resolution (using amplification) */
	bool show_high_resolution() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "show_high_resolution")) == 1;
	}

	/** Setter: Show high resolution (using amplification) */
	void show_high_resolution(bool value) {
		PyObject_SetAttrString(pyobjref, "show_high_resolution", Py_BuildValue("i", value));
	}

	enum noise_type_enum {
		noise_type_NOISEWAVE = 1,
		noise_type_NOISEFFT = 2,
	};

	/** Getter: Noise method which is used for creating the high resolution */
	noise_type_enum noise_type() { /* not implemented */ throw NULL; }
	/** Setter: Noise method which is used for creating the high resolution */
	void noise_type(noise_type_enum value) { /* not implemented */ }

	/** Getter: How much density affects smoke motion (higher value results in faster rising smoke) */
	float alpha() { /* not implemented */ throw NULL; }
	/** Setter: How much density affects smoke motion (higher value results in faster rising smoke) */
	void alpha(float value) {
		PyObject_SetAttrString(pyobjref, "alpha", Py_BuildValue("f", value));
	}

	/** Getter: How much heat affects smoke motion (higher value results in faster rising smoke) */
	float beta() { /* not implemented */ throw NULL; }
	/** Setter: How much heat affects smoke motion (higher value results in faster rising smoke) */
	void beta(float value) {
		PyObject_SetAttrString(pyobjref, "beta", Py_BuildValue("f", value));
	}

	/** Getter: Limit collisions to this group */
	Group collision_group() {
		/* not implemented */ throw NULL;
	}

	/** Getter: Limit fluid objects to this group */
	Group fluid_group() {
		/* not implemented */ throw NULL;
	}

	/** Getter: Limit effectors to this group */
	Group effector_group() {
		/* not implemented */ throw NULL;
	}

	/** Getter: Strength of noise */
	float strength() { /* not implemented */ throw NULL; }
	/** Setter: Strength of noise */
	void strength(float value) {
		PyObject_SetAttrString(pyobjref, "strength", Py_BuildValue("f", value));
	}

	/** Getter: Dissolve Speed */
	int dissolve_speed() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "dissolve_speed"));
	}

	/** Setter: Dissolve Speed */
	void dissolve_speed(int value) {
		PyObject_SetAttrString(pyobjref, "dissolve_speed", Py_BuildValue("i", value));
	}

	/** Getter: Enable smoke to disappear over time */
	bool use_dissolve_smoke() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_dissolve_smoke")) == 1;
	}

	/** Setter: Enable smoke to disappear over time */
	void use_dissolve_smoke(bool value) {
		PyObject_SetAttrString(pyobjref, "use_dissolve_smoke", Py_BuildValue("i", value));
	}

	/** Getter: Using 1/x  */
	bool use_dissolve_smoke_log() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_dissolve_smoke_log")) == 1;
	}

	/** Setter: Using 1/x  */
	void use_dissolve_smoke_log(bool value) {
		PyObject_SetAttrString(pyobjref, "use_dissolve_smoke_log", Py_BuildValue("i", value));
	}

	/** Getter:  */
	PointCache point_cache() {
		/* not implemented */ throw NULL;
	}

	enum point_cache_compress_type_enum {
		point_cache_compress_type_CACHELIGHT = 0,
		point_cache_compress_type_CACHEHEAVY = 1,
	};

	/** Getter: Compression method to be used */
	point_cache_compress_type_enum point_cache_compress_type() { /* not implemented */ throw NULL; }
	/** Setter: Compression method to be used */
	void point_cache_compress_type(point_cache_compress_type_enum value) { /* not implemented */ }

	enum collision_extents_enum {
		collision_extents_BORDEROPEN = 0,
		collision_extents_BORDERVERTICAL = 1,
		collision_extents_BORDERCLOSED = 2,
	};

	/** Getter: Select which domain border will be treated as collision object */
	collision_extents_enum collision_extents() { /* not implemented */ throw NULL; }
	/** Setter: Select which domain border will be treated as collision object */
	void collision_extents(collision_extents_enum value) { /* not implemented */ }

	/** Getter:  */
	EffectorWeights effector_weights() {
		/* not implemented */ throw NULL;
	}

	enum highres_sampling_enum {
		highres_sampling_FULLSAMPLE = 2,
		highres_sampling_LINEAR = 1,
		highres_sampling_NEAREST = 0,
	};

	/** Getter: Method for sampling the high resolution flow */
	highres_sampling_enum highres_sampling() { /* not implemented */ throw NULL; }
	/** Setter: Method for sampling the high resolution flow */
	void highres_sampling(highres_sampling_enum value) { /* not implemented */ }

	/** Getter: Adjust simulation speed */
	float time_scale() { /* not implemented */ throw NULL; }
	/** Setter: Adjust simulation speed */
	void time_scale(float value) {
		PyObject_SetAttrString(pyobjref, "time_scale", Py_BuildValue("f", value));
	}

	/** Getter: Amount of turbulence/rotation in fluid */
	float vorticity() { /* not implemented */ throw NULL; }
	/** Setter: Amount of turbulence/rotation in fluid */
	void vorticity(float value) {
		PyObject_SetAttrString(pyobjref, "vorticity", Py_BuildValue("f", value));
	}

	/** Getter: Smoke density grid */
	std::array<float, 32> density_grid() {
		// TODO: MISSING DEREF! USE #DEFINE!
		PyObject *seqval = PyObject_GetAttrString(pyobjref, "density_grid");
		std::array<float, 32> resarr;
		for (int i = 0; i < 32; i++)
			resarr[i] = (float)PyFloat_AsDouble(PySequence_GetItem(seqval, i));
		return resarr;
	}

	/** Setter: Smoke density grid */
	void density_grid(float values[32]) { /* not implemented */ }

	/** Getter: Smoke flame grid */
	std::array<float, 32> flame_grid() {
		// TODO: MISSING DEREF! USE #DEFINE!
		PyObject *seqval = PyObject_GetAttrString(pyobjref, "flame_grid");
		std::array<float, 32> resarr;
		for (int i = 0; i < 32; i++)
			resarr[i] = (float)PyFloat_AsDouble(PySequence_GetItem(seqval, i));
		return resarr;
	}

	/** Setter: Smoke flame grid */
	void flame_grid(float values[32]) { /* not implemented */ }

	/** Getter: Smoke color grid */
	std::array<float, 32> color_grid() {
		// TODO: MISSING DEREF! USE #DEFINE!
		PyObject *seqval = PyObject_GetAttrString(pyobjref, "color_grid");
		std::array<float, 32> resarr;
		for (int i = 0; i < 32; i++)
			resarr[i] = (float)PyFloat_AsDouble(PySequence_GetItem(seqval, i));
		return resarr;
	}

	/** Setter: Smoke color grid */
	void color_grid(float values[32]) { /* not implemented */ }

	/** Getter: Cell Size */
	std::array<float, 3> cell_size() {
		// TODO: MISSING DEREF! USE #DEFINE!
		PyObject *seqval = PyObject_GetAttrString(pyobjref, "cell_size");
		std::array<float, 3> resarr;
		for (int i = 0; i < 3; i++)
			resarr[i] = (float)PyFloat_AsDouble(PySequence_GetItem(seqval, i));
		return resarr;
	}

	/** Setter: Cell Size */
	void cell_size(float values[3]) { /* not implemented */ }

	/** Getter: Start point */
	std::array<float, 3> start_point() {
		// TODO: MISSING DEREF! USE #DEFINE!
		PyObject *seqval = PyObject_GetAttrString(pyobjref, "start_point");
		std::array<float, 3> resarr;
		for (int i = 0; i < 3; i++)
			resarr[i] = (float)PyFloat_AsDouble(PySequence_GetItem(seqval, i));
		return resarr;
	}

	/** Setter: Start point */
	void start_point(float values[3]) { /* not implemented */ }

	/** Getter: Smoke Grid Resolution */
	std::array<int, 3> domain_resolution() {
		// TODO: MISSING DEREF! USE #DEFINE!
		PyObject *seqval = PyObject_GetAttrString(pyobjref, "domain_resolution");
		std::array<int, 3> resarr;
		for (int i = 0; i < 3; i++)
			resarr[i] = PyLong_AsLong(PySequence_GetItem(seqval, i));
		return resarr;
	}

	/** Setter: Smoke Grid Resolution */
	void domain_resolution(int values[3]) { /* not implemented */ }

	/** Getter: Speed of the burning reaction (use larger values for smaller flame) */
	float burning_rate() { /* not implemented */ throw NULL; }
	/** Setter: Speed of the burning reaction (use larger values for smaller flame) */
	void burning_rate(float value) {
		PyObject_SetAttrString(pyobjref, "burning_rate", Py_BuildValue("f", value));
	}

	/** Getter: Amount of smoke created by burning fuel */
	float flame_smoke() { /* not implemented */ throw NULL; }
	/** Setter: Amount of smoke created by burning fuel */
	void flame_smoke(float value) {
		PyObject_SetAttrString(pyobjref, "flame_smoke", Py_BuildValue("f", value));
	}

	/** Getter: Additional vorticity for the flames */
	float flame_vorticity() { /* not implemented */ throw NULL; }
	/** Setter: Additional vorticity for the flames */
	void flame_vorticity(float value) {
		PyObject_SetAttrString(pyobjref, "flame_vorticity", Py_BuildValue("f", value));
	}

	/** Getter: Minimum temperature of flames */
	float flame_ignition() { /* not implemented */ throw NULL; }
	/** Setter: Minimum temperature of flames */
	void flame_ignition(float value) {
		PyObject_SetAttrString(pyobjref, "flame_ignition", Py_BuildValue("f", value));
	}

	/** Getter: Maximum temperature of flames */
	float flame_max_temp() { /* not implemented */ throw NULL; }
	/** Setter: Maximum temperature of flames */
	void flame_max_temp(float value) {
		PyObject_SetAttrString(pyobjref, "flame_max_temp", Py_BuildValue("f", value));
	}

	/** Getter: Color of smoke emitted from burning fuel */
	std::array<float, 3> flame_smoke_color() {
		// TODO: MISSING DEREF! USE #DEFINE!
		PyObject *seqval = PyObject_GetAttrString(pyobjref, "flame_smoke_color");
		std::array<float, 3> resarr;
		for (int i = 0; i < 3; i++)
			resarr[i] = (float)PyFloat_AsDouble(PySequence_GetItem(seqval, i));
		return resarr;
	}

	/** Setter: Color of smoke emitted from burning fuel */
	void flame_smoke_color(float values[3]) { /* not implemented */ }

	/** Getter: Adapt simulation resolution and size to fluid */
	bool use_adaptive_domain() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_adaptive_domain")) == 1;
	}

	/** Setter: Adapt simulation resolution and size to fluid */
	void use_adaptive_domain(bool value) {
		PyObject_SetAttrString(pyobjref, "use_adaptive_domain", Py_BuildValue("i", value));
	}

	/** Getter: Maximum number of additional cells */
	int additional_res() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "additional_res"));
	}

	/** Setter: Maximum number of additional cells */
	void additional_res(int value) {
		PyObject_SetAttrString(pyobjref, "additional_res", Py_BuildValue("i", value));
	}

	/** Getter: Margin added around fluid to minimize boundary interference */
	int adapt_margin() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "adapt_margin"));
	}

	/** Setter: Margin added around fluid to minimize boundary interference */
	void adapt_margin(int value) {
		PyObject_SetAttrString(pyobjref, "adapt_margin", Py_BuildValue("i", value));
	}

	/** Getter: Maximum amount of fluid cell can contain before it is considered empty */
	float adapt_threshold() { /* not implemented */ throw NULL; }
	/** Setter: Maximum amount of fluid cell can contain before it is considered empty */
	void adapt_threshold(float value) {
		PyObject_SetAttrString(pyobjref, "adapt_threshold", Py_BuildValue("f", value));
	}

};

/**************** Flow Settings ****************/

/**
 * Smoke flow settings
 */
class SmokeFlowSettings : public pyUniplug {
public:
	SmokeFlowSettings(PyObject* pyobj) : pyUniplug(pyobj) {}

	SmokeFlowSettings() : pyUniplug(0)
	{
		// not implemented
	}

	/** Getter:  */
	float density() { /* not implemented */ throw NULL; }
	/** Setter:  */
	void density(float value) {
		PyObject_SetAttrString(pyobjref, "density", Py_BuildValue("f", value));
	}

	/** Getter: Color of smoke */
	std::array<float, 3> smoke_color() {
		// TODO: MISSING DEREF! USE #DEFINE!
		PyObject *seqval = PyObject_GetAttrString(pyobjref, "smoke_color");
		std::array<float, 3> resarr;
		for (int i = 0; i < 3; i++)
			resarr[i] = (float)PyFloat_AsDouble(PySequence_GetItem(seqval, i));
		return resarr;
	}

	/** Setter: Color of smoke */
	void smoke_color(float values[3]) { /* not implemented */ }

	/** Getter:  */
	float fuel_amount() { /* not implemented */ throw NULL; }
	/** Setter:  */
	void fuel_amount(float value) {
		PyObject_SetAttrString(pyobjref, "fuel_amount", Py_BuildValue("f", value));
	}

	/** Getter: Temperature difference to ambient temperature */
	float temperature() { /* not implemented */ throw NULL; }
	/** Setter: Temperature difference to ambient temperature */
	void temperature(float value) {
		PyObject_SetAttrString(pyobjref, "temperature", Py_BuildValue("f", value));
	}

	/** Getter: Particle systems emitted from the object */
	ParticleSystem particle_system() {
		/* not implemented */ throw NULL;
	}

	enum smoke_flow_type_enum {
		smoke_flow_type_OUTFLOW = 2,
		smoke_flow_type_SMOKE = 0,
		smoke_flow_type_BOTH = 3,
		smoke_flow_type_FIRE = 1,
	};

	/** Getter: Change how flow affects the simulation */
	smoke_flow_type_enum smoke_flow_type() { /* not implemented */ throw NULL; }
	/** Setter: Change how flow affects the simulation */
	void smoke_flow_type(smoke_flow_type_enum value) { /* not implemented */ }

	enum smoke_flow_source_enum {
		smoke_flow_source_PARTICLES = 0,
		smoke_flow_source_MESH = 1,
	};

	/** Getter: Change how smoke is emitted */
	smoke_flow_source_enum smoke_flow_source() { /* not implemented */ throw NULL; }
	/** Setter: Change how smoke is emitted */
	void smoke_flow_source(smoke_flow_source_enum value) { /* not implemented */ }

	/** Getter: Only allow given density value in emitter area */
	bool use_absolute() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_absolute")) == 1;
	}

	/** Setter: Only allow given density value in emitter area */
	void use_absolute(bool value) {
		PyObject_SetAttrString(pyobjref, "use_absolute", Py_BuildValue("i", value));
	}

	/** Getter: Smoke has some initial velocity when it is emitted */
	bool use_initial_velocity() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_initial_velocity")) == 1;
	}

	/** Setter: Smoke has some initial velocity when it is emitted */
	void use_initial_velocity(bool value) {
		PyObject_SetAttrString(pyobjref, "use_initial_velocity", Py_BuildValue("i", value));
	}

	/** Getter: Multiplier of source velocity passed to smoke */
	float velocity_factor() { /* not implemented */ throw NULL; }
	/** Setter: Multiplier of source velocity passed to smoke */
	void velocity_factor(float value) {
		PyObject_SetAttrString(pyobjref, "velocity_factor", Py_BuildValue("f", value));
	}

	/** Getter: Amount of normal directional velocity */
	float velocity_normal() { /* not implemented */ throw NULL; }
	/** Setter: Amount of normal directional velocity */
	void velocity_normal(float value) {
		PyObject_SetAttrString(pyobjref, "velocity_normal", Py_BuildValue("f", value));
	}

	/** Getter: Amount of random velocity */
	float velocity_random() { /* not implemented */ throw NULL; }
	/** Setter: Amount of random velocity */
	void velocity_random(float value) {
		PyObject_SetAttrString(pyobjref, "velocity_random", Py_BuildValue("f", value));
	}

	/** Getter: Factor for smoke emitted from inside the mesh volume */
	float volume_density() { /* not implemented */ throw NULL; }
	/** Setter: Factor for smoke emitted from inside the mesh volume */
	void volume_density(float value) {
		PyObject_SetAttrString(pyobjref, "volume_density", Py_BuildValue("f", value));
	}

	/** Getter: Maximum distance from mesh surface to emit smoke */
	float surface_distance() { /* not implemented */ throw NULL; }
	/** Setter: Maximum distance from mesh surface to emit smoke */
	void surface_distance(float value) {
		PyObject_SetAttrString(pyobjref, "surface_distance", Py_BuildValue("f", value));
	}

	/** Getter: Particle size in simulation cells */
	float particle_size() { /* not implemented */ throw NULL; }
	/** Setter: Particle size in simulation cells */
	void particle_size(float value) {
		PyObject_SetAttrString(pyobjref, "particle_size", Py_BuildValue("f", value));
	}

	/** Getter: Set particle size in simulation cells or use nearest cell */
	bool use_particle_size() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_particle_size")) == 1;
	}

	/** Setter: Set particle size in simulation cells or use nearest cell */
	void use_particle_size(bool value) {
		PyObject_SetAttrString(pyobjref, "use_particle_size", Py_BuildValue("i", value));
	}

	/** Getter: Number of additional samples to take between frames to improve quality of fast moving flows */
	int subframes() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "subframes"));
	}

	/** Setter: Number of additional samples to take between frames to improve quality of fast moving flows */
	void subframes(int value) {
		PyObject_SetAttrString(pyobjref, "subframes", Py_BuildValue("i", value));
	}

	/** Getter: Name of vertex group which determines surface emission rate */
	std::string density_vertex_group() { /* not implemented */ throw NULL; }
	/** Setter: Name of vertex group which determines surface emission rate */
	void density_vertex_group(const std::string& value) { /* not implemented */ }

	/** Getter: Use a texture to control emission strength */
	bool use_texture() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_texture")) == 1;
	}

	/** Setter: Use a texture to control emission strength */
	void use_texture(bool value) {
		PyObject_SetAttrString(pyobjref, "use_texture", Py_BuildValue("i", value));
	}

	enum texture_map_type_enum {
		texture_map_type_AUTO = 0,
		texture_map_type_UV = 1,
	};

	/** Getter: Texture mapping type */
	texture_map_type_enum texture_map_type() { /* not implemented */ throw NULL; }
	/** Setter: Texture mapping type */
	void texture_map_type(texture_map_type_enum value) { /* not implemented */ }

	/** Getter: UV map name */
	std::string uv_layer() { /* not implemented */ throw NULL; }
	/** Setter: UV map name */
	void uv_layer(const std::string& value) { /* not implemented */ }

	/** Getter: Texture that controls emission strength */
	Texture noise_texture() {
		/* not implemented */ throw NULL;
	}

	/** Getter: Size of texture mapping */
	float texture_size() { /* not implemented */ throw NULL; }
	/** Setter: Size of texture mapping */
	void texture_size(float value) {
		PyObject_SetAttrString(pyobjref, "texture_size", Py_BuildValue("f", value));
	}

	/** Getter: Z-offset of texture mapping */
	float texture_offset() { /* not implemented */ throw NULL; }
	/** Setter: Z-offset of texture mapping */
	void texture_offset(float value) {
		PyObject_SetAttrString(pyobjref, "texture_offset", Py_BuildValue("f", value));
	}

};

/**************** Collision Settings ****************/

/**
 * Smoke collision settings
 */
class SmokeCollSettings : public pyUniplug {
public:
	SmokeCollSettings(PyObject* pyobj) : pyUniplug(pyobj) {}

	SmokeCollSettings() : pyUniplug(0)
	{
		// not implemented
	}

	enum collision_type_enum {
		collision_type_COLLSTATIC = 0,
		collision_type_COLLRIGID = 1,
		collision_type_COLLANIMATED = 2,
	};

	/** Getter: Collision type */
	collision_type_enum collision_type() { /* not implemented */ throw NULL; }
	/** Setter: Collision type */
	void collision_type(collision_type_enum value) { /* not implemented */ }

};

/**************** Space ****************/

/**
 * Space data for a screen area
 */
class Space : public pyUniplug {
public:
	Space(PyObject* pyobj) : pyUniplug(pyobj) {}

	Space() : pyUniplug(0)
	{
		// not implemented
	}

	enum type_enum {
		type_EMPTY = 0,
		type_VIEW_3D = 1,
		type_TIMELINE = 15,
		type_GRAPH_EDITOR = 2,
		type_DOPESHEET_EDITOR = 12,
		type_NLA_EDITOR = 13,
		type_IMAGE_EDITOR = 6,
		type_SEQUENCE_EDITOR = 8,
		type_CLIP_EDITOR = 20,
		type_TEXT_EDITOR = 9,
		type_NODE_EDITOR = 16,
		type_LOGIC_EDITOR = 17,
		type_PROPERTIES = 4,
		type_OUTLINER = 3,
		type_USER_PREFERENCES = 19,
		type_INFO = 7,
		type_FILE_BROWSER = 5,
		type_CONSOLE = 18,
	};

	/** Getter: Space data type */
	type_enum type() { /* not implemented */ throw NULL; }
	/** Setter: Space data type */
	void type(type_enum value) { /* not implemented */ }

	/** Getter:  */
	bool show_locked_time() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "show_locked_time")) == 1;
	}

	/** Setter:  */
	void show_locked_time(bool value) {
		PyObject_SetAttrString(pyobjref, "show_locked_time", Py_BuildValue("i", value));
	}

};

/**************** Space Image Editor ****************/

/**
 * Image and UV editor space data
 */
class SpaceImageEditor : public Space {
public:
	SpaceImageEditor(PyObject* pyobj) : Space(pyobj) {}

	SpaceImageEditor() : Space(0)
	{
		// not implemented
	}

	/** Getter: Image displayed and edited in this space */
	Image image() {
		/* not implemented */ throw NULL;
	}

	/** Getter: Parameters defining which layer, pass and frame of the image is displayed */
	ImageUser image_user() {
		/* not implemented */ throw NULL;
	}

	/** Getter: Scopes to visualize image statistics */
	Scopes scopes() {
		/* not implemented */ throw NULL;
	}

	/** Getter: Display current image regardless of object selection */
	bool use_image_pin() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_image_pin")) == 1;
	}

	/** Setter: Display current image regardless of object selection */
	void use_image_pin(bool value) {
		PyObject_SetAttrString(pyobjref, "use_image_pin", Py_BuildValue("i", value));
	}

	/** Getter: Sampled colors along line */
	Histogram sample_histogram() {
		/* not implemented */ throw NULL;
	}

	/** Getter: Zoom factor */
	std::array<float, 2> zoom() {
		// TODO: MISSING DEREF! USE #DEFINE!
		PyObject *seqval = PyObject_GetAttrString(pyobjref, "zoom");
		std::array<float, 2> resarr;
		for (int i = 0; i < 2; i++)
			resarr[i] = (float)PyFloat_AsDouble(PySequence_GetItem(seqval, i));
		return resarr;
	}

	/** Setter: Zoom factor */
	void zoom(float values[2]) { /* not implemented */ }

	/** Getter: Draw the image repeated outside of the main view */
	bool show_repeat() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "show_repeat")) == 1;
	}

	/** Setter: Draw the image repeated outside of the main view */
	void show_repeat(bool value) {
		PyObject_SetAttrString(pyobjref, "show_repeat", Py_BuildValue("i", value));
	}

	/** Getter: Show grease pencil for this view */
	bool show_grease_pencil() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "show_grease_pencil")) == 1;
	}

	/** Setter: Show grease pencil for this view */
	void show_grease_pencil(bool value) {
		PyObject_SetAttrString(pyobjref, "show_grease_pencil", Py_BuildValue("i", value));
	}

	enum draw_channels_enum {
		draw_channels_COLOR_ALPHA = 4096,
		draw_channels_COLOR = 0,
		draw_channels_ALPHA = 8192,
		draw_channels_Z_BUFFER = 16384,
	};

	/** Getter: Channels of the image to draw */
	draw_channels_enum draw_channels() { /* not implemented */ throw NULL; }
	/** Setter: Channels of the image to draw */
	void draw_channels(draw_channels_enum value) { /* not implemented */ }

	/** Getter: Display the image in Stereo 3D */
	bool show_stereo_3d() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "show_stereo_3d")) == 1;
	}

	/** Setter: Display the image in Stereo 3D */
	void show_stereo_3d(bool value) {
		PyObject_SetAttrString(pyobjref, "show_stereo_3d", Py_BuildValue("i", value));
	}

	/** Getter: UV editor settings */
	SpaceUVEditor uv_editor();

	enum mode_enum {
		mode_VIEW = 0,
		mode_PAINT = 1,
		mode_MASK = 2,
	};

	/** Getter: Editing context being displayed */
	mode_enum mode() { /* not implemented */ throw NULL; }
	/** Setter: Editing context being displayed */
	void mode(mode_enum value) { /* not implemented */ }

	/** Getter: 2D cursor location for this view */
	std::array<float, 2> cursor_location() {
		// TODO: MISSING DEREF! USE #DEFINE!
		PyObject *seqval = PyObject_GetAttrString(pyobjref, "cursor_location");
		std::array<float, 2> resarr;
		for (int i = 0; i < 2; i++)
			resarr[i] = (float)PyFloat_AsDouble(PySequence_GetItem(seqval, i));
		return resarr;
	}

	/** Setter: 2D cursor location for this view */
	void cursor_location(float values[2]) { /* not implemented */ }

	enum pivot_point_enum {
		pivot_point_BOUNDING_BOX_CENTER = 0,
		pivot_point_CURSOR = 1,
		pivot_point_INDIVIDUAL_ORIGINS = 2,
		pivot_point_MEDIAN_POINT = 3,
		pivot_point_ACTIVE_ELEMENT = 4,
	};

	/** Getter: Rotation/Scaling Pivot */
	pivot_point_enum pivot_point() { /* not implemented */ throw NULL; }
	/** Setter: Rotation/Scaling Pivot */
	void pivot_point(pivot_point_enum value) { /* not implemented */ }

	/** Getter: Grease pencil data for this space */
	GreasePencil grease_pencil() {
		/* not implemented */ throw NULL;
	}

	/** Getter: Update other affected window spaces automatically to reflect changes during interactive operations such as transform */
	bool use_realtime_update() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_realtime_update")) == 1;
	}

	/** Setter: Update other affected window spaces automatically to reflect changes during interactive operations such as transform */
	void use_realtime_update(bool value) {
		PyObject_SetAttrString(pyobjref, "use_realtime_update", Py_BuildValue("i", value));
	}

	/** Getter: Show render related properties */
	bool show_render() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "show_render")) == 1;
	}

	/** Setter: Show render related properties */
	void show_render(bool value) {
		PyObject_SetAttrString(pyobjref, "show_render", Py_BuildValue("i", value));
	}

	/** Getter: Show paint related properties */
	bool show_paint() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "show_paint")) == 1;
	}

	/** Setter: Show paint related properties */
	void show_paint(bool value) {
		PyObject_SetAttrString(pyobjref, "show_paint", Py_BuildValue("i", value));
	}

	/** Getter: Show UV editing related properties */
	bool show_uvedit() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "show_uvedit")) == 1;
	}

	/** Setter: Show UV editing related properties */
	void show_uvedit(bool value) {
		PyObject_SetAttrString(pyobjref, "show_uvedit", Py_BuildValue("i", value));
	}

	/** Getter: Show Mask editing related properties */
	bool show_maskedit() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "show_maskedit")) == 1;
	}

	/** Setter: Show Mask editing related properties */
	void show_maskedit(bool value) {
		PyObject_SetAttrString(pyobjref, "show_maskedit", Py_BuildValue("i", value));
	}

	/** Getter: Mask displayed and edited in this space */
	Mask mask();

	enum mask_draw_type_enum {
		mask_draw_type_OUTLINE = 0,
		mask_draw_type_DASH = 1,
		mask_draw_type_BLACK = 2,
		mask_draw_type_WHITE = 3,
	};

	/** Getter: Draw type for mask splines */
	mask_draw_type_enum mask_draw_type() { /* not implemented */ throw NULL; }
	/** Setter: Draw type for mask splines */
	void mask_draw_type(mask_draw_type_enum value) { /* not implemented */ }

	/** Getter:  */
	bool show_mask_smooth() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "show_mask_smooth")) == 1;
	}

	/** Setter:  */
	void show_mask_smooth(bool value) {
		PyObject_SetAttrString(pyobjref, "show_mask_smooth", Py_BuildValue("i", value));
	}

	/** Getter:  */
	bool show_mask_overlay() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "show_mask_overlay")) == 1;
	}

	/** Setter:  */
	void show_mask_overlay(bool value) {
		PyObject_SetAttrString(pyobjref, "show_mask_overlay", Py_BuildValue("i", value));
	}

	enum mask_overlay_mode_enum {
		mask_overlay_mode_ALPHACHANNEL = 0,
		mask_overlay_mode_COMBINED = 1,
	};

	/** Getter: Overlay mode of rasterized mask */
	mask_overlay_mode_enum mask_overlay_mode() { /* not implemented */ throw NULL; }
	/** Setter: Overlay mode of rasterized mask */
	void mask_overlay_mode(mask_overlay_mode_enum value) { /* not implemented */ }

};

/**************** Space UV Editor ****************/

/**
 * UV editor data for the image editor space
 */
class SpaceUVEditor : public pyUniplug {
public:
	SpaceUVEditor(PyObject* pyobj) : pyUniplug(pyobj) {}

	SpaceUVEditor() : pyUniplug(0)
	{
		// not implemented
	}

	enum sticky_select_mode_enum {
		sticky_select_mode_DISABLED = 1,
		sticky_select_mode_SHARED_LOCATION = 0,
		sticky_select_mode_SHARED_VERTEX = 2,
	};

	/** Getter: Automatically select also UVs sharing the same vertex as the ones being selected */
	sticky_select_mode_enum sticky_select_mode() { /* not implemented */ throw NULL; }
	/** Setter: Automatically select also UVs sharing the same vertex as the ones being selected */
	void sticky_select_mode(sticky_select_mode_enum value) { /* not implemented */ }

	enum edge_draw_type_enum {
		edge_draw_type_OUTLINE = 0,
		edge_draw_type_DASH = 1,
		edge_draw_type_BLACK = 2,
		edge_draw_type_WHITE = 3,
	};

	/** Getter: Draw type for drawing UV edges */
	edge_draw_type_enum edge_draw_type() { /* not implemented */ throw NULL; }
	/** Setter: Draw type for drawing UV edges */
	void edge_draw_type(edge_draw_type_enum value) { /* not implemented */ }

	/** Getter: Draw UV edges anti-aliased */
	bool show_smooth_edges() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "show_smooth_edges")) == 1;
	}

	/** Setter: Draw UV edges anti-aliased */
	void show_smooth_edges(bool value) {
		PyObject_SetAttrString(pyobjref, "show_smooth_edges", Py_BuildValue("i", value));
	}

	/** Getter: Draw faces colored according to the difference in shape between UVs and their 3D coordinates (blue for low distortion, red for high distortion) */
	bool show_stretch() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "show_stretch")) == 1;
	}

	/** Setter: Draw faces colored according to the difference in shape between UVs and their 3D coordinates (blue for low distortion, red for high distortion) */
	void show_stretch(bool value) {
		PyObject_SetAttrString(pyobjref, "show_stretch", Py_BuildValue("i", value));
	}

	enum draw_stretch_type_enum {
		draw_stretch_type_ANGLE = 0,
		draw_stretch_type_AREA = 1,
	};

	/** Getter: Type of stretch to draw */
	draw_stretch_type_enum draw_stretch_type() { /* not implemented */ throw NULL; }
	/** Setter: Type of stretch to draw */
	void draw_stretch_type(draw_stretch_type_enum value) { /* not implemented */ }

	/** Getter: Draw edges after modifiers are applied */
	bool show_modified_edges() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "show_modified_edges")) == 1;
	}

	/** Setter: Draw edges after modifiers are applied */
	void show_modified_edges(bool value) {
		PyObject_SetAttrString(pyobjref, "show_modified_edges", Py_BuildValue("i", value));
	}

	/** Getter: Draw other selected objects that share the same image */
	bool show_other_objects() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "show_other_objects")) == 1;
	}

	/** Setter: Draw other selected objects that share the same image */
	void show_other_objects(bool value) {
		PyObject_SetAttrString(pyobjref, "show_other_objects", Py_BuildValue("i", value));
	}

	/** Getter: Draw metadata properties of the image */
	bool show_metadata() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "show_metadata")) == 1;
	}

	/** Setter: Draw metadata properties of the image */
	void show_metadata(bool value) {
		PyObject_SetAttrString(pyobjref, "show_metadata", Py_BuildValue("i", value));
	}

	/** Getter: Draw overlay of texture paint uv layer */
	bool show_texpaint() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "show_texpaint")) == 1;
	}

	/** Setter: Draw overlay of texture paint uv layer */
	void show_texpaint(bool value) {
		PyObject_SetAttrString(pyobjref, "show_texpaint", Py_BuildValue("i", value));
	}

	/** Getter: Display UV coordinates from 0.0 to 1.0 rather than in pixels */
	bool show_normalized_coords() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "show_normalized_coords")) == 1;
	}

	/** Setter: Display UV coordinates from 0.0 to 1.0 rather than in pixels */
	void show_normalized_coords(bool value) {
		PyObject_SetAttrString(pyobjref, "show_normalized_coords", Py_BuildValue("i", value));
	}

	/** Getter: Draw faces over the image */
	bool show_faces() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "show_faces")) == 1;
	}

	/** Setter: Draw faces over the image */
	void show_faces(bool value) {
		PyObject_SetAttrString(pyobjref, "show_faces", Py_BuildValue("i", value));
	}

	/** Getter: Snap UVs to pixel locations while editing */
	bool use_snap_to_pixels() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_snap_to_pixels")) == 1;
	}

	/** Setter: Snap UVs to pixel locations while editing */
	void use_snap_to_pixels(bool value) {
		PyObject_SetAttrString(pyobjref, "use_snap_to_pixels", Py_BuildValue("i", value));
	}

	/** Getter: Constraint to stay within the image bounds while editing */
	bool lock_bounds() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "lock_bounds")) == 1;
	}

	/** Setter: Constraint to stay within the image bounds while editing */
	void lock_bounds(bool value) {
		PyObject_SetAttrString(pyobjref, "lock_bounds", Py_BuildValue("i", value));
	}

	/** Getter: Continuously unwrap the selected UV island while transforming pinned vertices */
	bool use_live_unwrap() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_live_unwrap")) == 1;
	}

	/** Setter: Continuously unwrap the selected UV island while transforming pinned vertices */
	void use_live_unwrap(bool value) {
		PyObject_SetAttrString(pyobjref, "use_live_unwrap", Py_BuildValue("i", value));
	}

};

/**************** Space Sequence Editor ****************/

/**
 * Sequence editor space data
 */
class SpaceSequenceEditor : public Space {
public:
	SpaceSequenceEditor(PyObject* pyobj) : Space(pyobj) {}

	SpaceSequenceEditor() : Space(0)
	{
		// not implemented
	}

	enum view_type_enum {
		view_type_SEQUENCER = 1,
		view_type_PREVIEW = 2,
		view_type_SEQUENCER_PREVIEW = 3,
	};

	/** Getter: Type of the Sequencer view (sequencer, preview or both) */
	view_type_enum view_type() { /* not implemented */ throw NULL; }
	/** Setter: Type of the Sequencer view (sequencer, preview or both) */
	void view_type(view_type_enum value) { /* not implemented */ }

	enum display_mode_enum {
		display_mode_IMAGE = 1,
		display_mode_WAVEFORM = 2,
		display_mode_VECTOR_SCOPE = 3,
		display_mode_HISTOGRAM = 4,
	};

	/** Getter: View mode to use for displaying sequencer output */
	display_mode_enum display_mode() { /* not implemented */ throw NULL; }
	/** Setter: View mode to use for displaying sequencer output */
	void display_mode(display_mode_enum value) { /* not implemented */ }

	/** Getter: Show frame number beside the current frame indicator line */
	bool show_frame_indicator() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "show_frame_indicator")) == 1;
	}

	/** Setter: Show frame number beside the current frame indicator line */
	void show_frame_indicator(bool value) {
		PyObject_SetAttrString(pyobjref, "show_frame_indicator", Py_BuildValue("i", value));
	}

	/** Getter: Draw frames rather than seconds */
	bool show_frames() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "show_frames")) == 1;
	}

	/** Setter: Draw frames rather than seconds */
	void show_frames(bool value) {
		PyObject_SetAttrString(pyobjref, "show_frames", Py_BuildValue("i", value));
	}

	/** Getter: Transform markers as well as strips */
	bool use_marker_sync() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_marker_sync")) == 1;
	}

	/** Setter: Transform markers as well as strips */
	void use_marker_sync(bool value) {
		PyObject_SetAttrString(pyobjref, "use_marker_sync", Py_BuildValue("i", value));
	}

	/** Getter: Separate color channels in preview */
	bool show_separate_color() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "show_separate_color")) == 1;
	}

	/** Setter: Separate color channels in preview */
	void show_separate_color(bool value) {
		PyObject_SetAttrString(pyobjref, "show_separate_color", Py_BuildValue("i", value));
	}

	/** Getter: Show TV title safe and action safe areas in preview */
	bool show_safe_areas() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "show_safe_areas")) == 1;
	}

	/** Setter: Show TV title safe and action safe areas in preview */
	void show_safe_areas(bool value) {
		PyObject_SetAttrString(pyobjref, "show_safe_areas", Py_BuildValue("i", value));
	}

	/** Getter: Show safe areas to fit content in a different aspect ratio */
	bool show_safe_center() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "show_safe_center")) == 1;
	}

	/** Setter: Show safe areas to fit content in a different aspect ratio */
	void show_safe_center(bool value) {
		PyObject_SetAttrString(pyobjref, "show_safe_center", Py_BuildValue("i", value));
	}

	/** Getter: Show metadata of first visible strip */
	bool show_metadata() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "show_metadata")) == 1;
	}

	/** Setter: Show metadata of first visible strip */
	void show_metadata(bool value) {
		PyObject_SetAttrString(pyobjref, "show_metadata", Py_BuildValue("i", value));
	}

	/** Getter: Show timing in seconds not frames */
	bool show_seconds() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "show_seconds")) == 1;
	}

	/** Setter: Show timing in seconds not frames */
	void show_seconds(bool value) {
		PyObject_SetAttrString(pyobjref, "show_seconds", Py_BuildValue("i", value));
	}

	/** Getter: Show grease pencil for this view */
	bool show_grease_pencil() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "show_grease_pencil")) == 1;
	}

	/** Setter: Show grease pencil for this view */
	void show_grease_pencil(bool value) {
		PyObject_SetAttrString(pyobjref, "show_grease_pencil", Py_BuildValue("i", value));
	}

	/** Getter: The channel number shown in the image preview. 0 is the result of all strips combined */
	int display_channel() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "display_channel"));
	}

	/** Setter: The channel number shown in the image preview. 0 is the result of all strips combined */
	void display_channel(int value) {
		PyObject_SetAttrString(pyobjref, "display_channel", Py_BuildValue("i", value));
	}

	enum preview_channels_enum {
		preview_channels_COLOR_ALPHA = 64,
		preview_channels_COLOR = 0,
	};

	/** Getter: Channels of the preview to draw */
	preview_channels_enum preview_channels() { /* not implemented */ throw NULL; }
	/** Setter: Channels of the preview to draw */
	void preview_channels(preview_channels_enum value) { /* not implemented */ }

	enum waveform_draw_type_enum {
		waveform_draw_type_NO_WAVEFORMS = 256,
		waveform_draw_type_ALL_WAVEFORMS = 128,
		waveform_draw_type_DEFAULT_WAVEFORMS = 0,
	};

	/** Getter: How Waveforms are drawn */
	waveform_draw_type_enum waveform_draw_type() { /* not implemented */ throw NULL; }
	/** Setter: How Waveforms are drawn */
	void waveform_draw_type(waveform_draw_type_enum value) { /* not implemented */ }

	/** Getter: Show overexposed areas with zebra stripes */
	int draw_overexposed() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "draw_overexposed"));
	}

	/** Setter: Show overexposed areas with zebra stripes */
	void draw_overexposed(int value) {
		PyObject_SetAttrString(pyobjref, "draw_overexposed", Py_BuildValue("i", value));
	}

	enum proxy_render_size_enum {
		proxy_render_size_NONE = -1,
		proxy_render_size_SCENE = 0,
		proxy_render_size_PROXY_25 = 25,
		proxy_render_size_PROXY_50 = 50,
		proxy_render_size_PROXY_75 = 75,
		proxy_render_size_PROXY_100 = 99,
		proxy_render_size_FULL = 100,
	};

	/** Getter: Draw preview using full resolution or different proxy resolutions */
	proxy_render_size_enum proxy_render_size() { /* not implemented */ throw NULL; }
	/** Setter: Draw preview using full resolution or different proxy resolutions */
	void proxy_render_size(proxy_render_size_enum value) { /* not implemented */ }

	/** Getter: Grease pencil data for this space */
	GreasePencil grease_pencil() {
		/* not implemented */ throw NULL;
	}

	enum overlay_type_enum {
		overlay_type_RECTANGLE = 0,
		overlay_type_REFERENCE = 1,
		overlay_type_CURRENT = 2,
	};

	/** Getter: Overlay draw type */
	overlay_type_enum overlay_type() { /* not implemented */ throw NULL; }
	/** Setter: Overlay draw type */
	void overlay_type(overlay_type_enum value) { /* not implemented */ }

	/** Getter: Display result under strips */
	bool show_backdrop() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "show_backdrop")) == 1;
	}

	/** Setter: Display result under strips */
	void show_backdrop(bool value) {
		PyObject_SetAttrString(pyobjref, "show_backdrop", Py_BuildValue("i", value));
	}

	/** Getter: Display strip in/out offsets */
	bool show_strip_offset() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "show_strip_offset")) == 1;
	}

	/** Setter: Display strip in/out offsets */
	void show_strip_offset(bool value) {
		PyObject_SetAttrString(pyobjref, "show_strip_offset", Py_BuildValue("i", value));
	}

};

/**************** Space Text Editor ****************/

/**
 * Text editor space data
 */
class SpaceTextEditor : public Space {
public:
	SpaceTextEditor(PyObject* pyobj) : Space(pyobj) {}

	SpaceTextEditor() : Space(0)
	{
		// not implemented
	}

	/** Getter: Text displayed and edited in this space */
	Text text();

	/** Getter: Wrap words if there is not enough horizontal space */
	bool show_word_wrap() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "show_word_wrap")) == 1;
	}

	/** Setter: Wrap words if there is not enough horizontal space */
	void show_word_wrap(bool value) {
		PyObject_SetAttrString(pyobjref, "show_word_wrap", Py_BuildValue("i", value));
	}

	/** Getter: Show line numbers next to the text */
	bool show_line_numbers() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "show_line_numbers")) == 1;
	}

	/** Setter: Show line numbers next to the text */
	void show_line_numbers(bool value) {
		PyObject_SetAttrString(pyobjref, "show_line_numbers", Py_BuildValue("i", value));
	}

	/** Getter: Syntax highlight for scripting */
	bool show_syntax_highlight() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "show_syntax_highlight")) == 1;
	}

	/** Setter: Syntax highlight for scripting */
	void show_syntax_highlight(bool value) {
		PyObject_SetAttrString(pyobjref, "show_syntax_highlight", Py_BuildValue("i", value));
	}

	/** Getter: Highlight the current line */
	bool show_line_highlight() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "show_line_highlight")) == 1;
	}

	/** Setter: Highlight the current line */
	void show_line_highlight(bool value) {
		PyObject_SetAttrString(pyobjref, "show_line_highlight", Py_BuildValue("i", value));
	}

	/** Getter: Number of spaces to display tabs with */
	int tab_width() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "tab_width"));
	}

	/** Setter: Number of spaces to display tabs with */
	void tab_width(int value) {
		PyObject_SetAttrString(pyobjref, "tab_width", Py_BuildValue("i", value));
	}

	/** Getter: Font size to use for displaying the text */
	int font_size() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "font_size"));
	}

	/** Setter: Font size to use for displaying the text */
	void font_size(int value) {
		PyObject_SetAttrString(pyobjref, "font_size", Py_BuildValue("i", value));
	}

	/** Getter: Show right margin */
	bool show_margin() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "show_margin")) == 1;
	}

	/** Setter: Show right margin */
	void show_margin(bool value) {
		PyObject_SetAttrString(pyobjref, "show_margin", Py_BuildValue("i", value));
	}

	/** Getter: Column number to show right margin at */
	int margin_column() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "margin_column"));
	}

	/** Setter: Column number to show right margin at */
	void margin_column(int value) {
		PyObject_SetAttrString(pyobjref, "margin_column", Py_BuildValue("i", value));
	}

	/** Getter: Top line visible */
	int top() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "top"));
	}

	/** Setter: Top line visible */
	void top(int value) {
		PyObject_SetAttrString(pyobjref, "top", Py_BuildValue("i", value));
	}

	/** Getter: Amount of lines that can be visible in current editor */
	int visible_lines() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "visible_lines"));
	}

	/** Setter: Amount of lines that can be visible in current editor */
	void visible_lines(int value) {
		PyObject_SetAttrString(pyobjref, "visible_lines", Py_BuildValue("i", value));
	}

	/** Getter: Overwrite characters when typing rather than inserting them */
	bool use_overwrite() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_overwrite")) == 1;
	}

	/** Setter: Overwrite characters when typing rather than inserting them */
	void use_overwrite(bool value) {
		PyObject_SetAttrString(pyobjref, "use_overwrite", Py_BuildValue("i", value));
	}

	/** Getter: Run python while editing */
	bool use_live_edit() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_live_edit")) == 1;
	}

	/** Setter: Run python while editing */
	void use_live_edit(bool value) {
		PyObject_SetAttrString(pyobjref, "use_live_edit", Py_BuildValue("i", value));
	}

	/** Getter: Search in all text datablocks, instead of only the active one */
	bool use_find_all() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_find_all")) == 1;
	}

	/** Setter: Search in all text datablocks, instead of only the active one */
	void use_find_all(bool value) {
		PyObject_SetAttrString(pyobjref, "use_find_all", Py_BuildValue("i", value));
	}

	/** Getter: Search again from the start of the file when reaching the end */
	bool use_find_wrap() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_find_wrap")) == 1;
	}

	/** Setter: Search again from the start of the file when reaching the end */
	void use_find_wrap(bool value) {
		PyObject_SetAttrString(pyobjref, "use_find_wrap", Py_BuildValue("i", value));
	}

	/** Getter: Search string is sensitive to uppercase and lowercase letters */
	bool use_match_case() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_match_case")) == 1;
	}

	/** Setter: Search string is sensitive to uppercase and lowercase letters */
	void use_match_case(bool value) {
		PyObject_SetAttrString(pyobjref, "use_match_case", Py_BuildValue("i", value));
	}

	/** Getter: Text to search for with the find tool */
	std::string find_text() { /* not implemented */ throw NULL; }
	/** Setter: Text to search for with the find tool */
	void find_text(const std::string& value) { /* not implemented */ }

	/** Getter: Text to replace selected text with using the replace tool */
	std::string replace_text() { /* not implemented */ throw NULL; }
	/** Setter: Text to replace selected text with using the replace tool */
	void replace_text(const std::string& value) { /* not implemented */ }

	/**
	 * Retrieve the region position from the given line and character position
	 * @param Line index
	 * @param Column index
	 * @return Region coordinates
	 */
	std::array<int, 2> region_location_from_cursor(int line, int column)
	{
		// not implemented
		throw NULL;
	}

};

/**************** File Select Parameters ****************/

/**
 * File Select Parameters
 */
class FileSelectParams : public pyUniplug {
public:
	FileSelectParams(PyObject* pyobj) : pyUniplug(pyobj) {}

	FileSelectParams() : pyUniplug(0)
	{
		// not implemented
	}

	/** Getter: Title for the file browser */
	std::string title() { /* not implemented */ throw NULL; }
	/** Setter: Title for the file browser */
	void title(const std::string& value) { /* not implemented */ }

	/** Getter: Directory displayed in the file browser */
	std::string directory() { /* not implemented */ throw NULL; }
	/** Setter: Directory displayed in the file browser */
	void directory(const std::string& value) { /* not implemented */ }

	/** Getter: Active file in the file browser */
	std::string filename() { /* not implemented */ throw NULL; }
	/** Setter: Active file in the file browser */
	void filename(const std::string& value) { /* not implemented */ }

	enum display_type_enum {
		display_type_FILE_SHORTDISPLAY = 1,
		display_type_FILE_LONGDISPLAY = 2,
		display_type_FILE_IMGDISPLAY = 3,
	};

	/** Getter: Display mode for the file list */
	display_type_enum display_type() { /* not implemented */ throw NULL; }
	/** Setter: Display mode for the file list */
	void display_type(display_type_enum value) { /* not implemented */ }

	/** Getter: Enable filtering of files */
	bool use_filter() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_filter")) == 1;
	}

	/** Setter: Enable filtering of files */
	void use_filter(bool value) {
		PyObject_SetAttrString(pyobjref, "use_filter", Py_BuildValue("i", value));
	}

	/** Getter: Show hidden dot files */
	bool show_hidden() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "show_hidden")) == 1;
	}

	/** Setter: Show hidden dot files */
	void show_hidden(bool value) {
		PyObject_SetAttrString(pyobjref, "show_hidden", Py_BuildValue("i", value));
	}

	enum sort_method_enum {
		sort_method_FILE_SORT_ALPHA = 1,
		sort_method_FILE_SORT_EXTENSION = 2,
		sort_method_FILE_SORT_TIME = 3,
		sort_method_FILE_SORT_SIZE = 4,
	};

	/** Getter:  */
	sort_method_enum sort_method() { /* not implemented */ throw NULL; }
	/** Setter:  */
	void sort_method(sort_method_enum value) { /* not implemented */ }

	/** Getter: Show image files */
	bool use_filter_image() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_filter_image")) == 1;
	}

	/** Setter: Show image files */
	void use_filter_image(bool value) {
		PyObject_SetAttrString(pyobjref, "use_filter_image", Py_BuildValue("i", value));
	}

	/** Getter: Show .blend files */
	bool use_filter_blender() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_filter_blender")) == 1;
	}

	/** Setter: Show .blend files */
	void use_filter_blender(bool value) {
		PyObject_SetAttrString(pyobjref, "use_filter_blender", Py_BuildValue("i", value));
	}

	/** Getter: Show .blend1, .blend2, etc. files */
	bool use_filter_backup() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_filter_backup")) == 1;
	}

	/** Setter: Show .blend1, .blend2, etc. files */
	void use_filter_backup(bool value) {
		PyObject_SetAttrString(pyobjref, "use_filter_backup", Py_BuildValue("i", value));
	}

	/** Getter: Show movie files */
	bool use_filter_movie() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_filter_movie")) == 1;
	}

	/** Setter: Show movie files */
	void use_filter_movie(bool value) {
		PyObject_SetAttrString(pyobjref, "use_filter_movie", Py_BuildValue("i", value));
	}

	/** Getter: Show script files */
	bool use_filter_script() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_filter_script")) == 1;
	}

	/** Setter: Show script files */
	void use_filter_script(bool value) {
		PyObject_SetAttrString(pyobjref, "use_filter_script", Py_BuildValue("i", value));
	}

	/** Getter: Show font files */
	bool use_filter_font() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_filter_font")) == 1;
	}

	/** Setter: Show font files */
	void use_filter_font(bool value) {
		PyObject_SetAttrString(pyobjref, "use_filter_font", Py_BuildValue("i", value));
	}

	/** Getter: Show sound files */
	bool use_filter_sound() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_filter_sound")) == 1;
	}

	/** Setter: Show sound files */
	void use_filter_sound(bool value) {
		PyObject_SetAttrString(pyobjref, "use_filter_sound", Py_BuildValue("i", value));
	}

	/** Getter: Show text files */
	bool use_filter_text() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_filter_text")) == 1;
	}

	/** Setter: Show text files */
	void use_filter_text(bool value) {
		PyObject_SetAttrString(pyobjref, "use_filter_text", Py_BuildValue("i", value));
	}

	/** Getter: Show folders */
	bool use_filter_folder() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_filter_folder")) == 1;
	}

	/** Setter: Show folders */
	void use_filter_folder(bool value) {
		PyObject_SetAttrString(pyobjref, "use_filter_folder", Py_BuildValue("i", value));
	}

	/** Getter:  */
	std::string filter_glob() { /* not implemented */ throw NULL; }
	/** Setter:  */
	void filter_glob(const std::string& value) { /* not implemented */ }

	/** Getter: Filter by name, supports '*' wildcard */
	std::string filter_search() { /* not implemented */ throw NULL; }
	/** Setter: Filter by name, supports '*' wildcard */
	void filter_search(const std::string& value) { /* not implemented */ }

	enum thumbnail_size_enum {
		thumbnail_size_TINY = 32,
		thumbnail_size_SMALL = 64,
		thumbnail_size_NORMAL = 128,
		thumbnail_size_LARGE = 256,
	};

	/** Getter: Change the size of the thumbnails */
	thumbnail_size_enum thumbnail_size() { /* not implemented */ throw NULL; }
	/** Setter: Change the size of the thumbnails */
	void thumbnail_size(thumbnail_size_enum value) { /* not implemented */ }

};

/**************** File Select Parameters ****************/

/**
 * File Select Parameters
 */
class FileBrowserFSMenuEntry : public pyUniplug {
public:
	FileBrowserFSMenuEntry(PyObject* pyobj) : pyUniplug(pyobj) {}

	FileBrowserFSMenuEntry() : pyUniplug(0)
	{
		// not implemented
	}

	/** Getter:  */
	std::string path() { /* not implemented */ throw NULL; }
	/** Setter:  */
	void path(const std::string& value) { /* not implemented */ }

	/** Getter:  */
	std::string name() { /* not implemented */ throw NULL; }
	/** Setter:  */
	void name(const std::string& value) { /* not implemented */ }

	/** Getter: Whether this path is saved in bookmarks, or generated from OS */
	bool use_save() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_save")) == 1;
	}

	/** Setter: Whether this path is saved in bookmarks, or generated from OS */
	void use_save(bool value) {
		PyObject_SetAttrString(pyobjref, "use_save", Py_BuildValue("i", value));
	}

	/** Getter: Whether this path is currently reachable */
	bool is_valid() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "is_valid")) == 1;
	}

	/** Setter: Whether this path is currently reachable */
	void is_valid(bool value) {
		PyObject_SetAttrString(pyobjref, "is_valid", Py_BuildValue("i", value));
	}

};

/**************** Space File Browser ****************/

/**
 * File browser space data
 */
class SpaceFileBrowser : public Space {
public:
	SpaceFileBrowser(PyObject* pyobj) : Space(pyobj) {}

	SpaceFileBrowser() : Space(0)
	{
		// not implemented
	}

	/** Getter: Parameters and Settings for the Filebrowser */
	FileSelectParams params_value() {
		/* not implemented */ throw NULL;
	}

	/** Getter:  */
	Operator active_operator();

	/** Getter:  */
	Operator operator_value();

	/** Getter: System's folders (usually root, available hard drives, etc) */
	std::map<std::string, FileBrowserFSMenuEntry> system_folders() {
		// TODO: MISSING DEREF! USE #DEFINE!
		PyObject *seqval = PyObject_GetAttrString(pyobjref, "system_folders");
		PyObject *seqkeys = PyObject_CallMethod(seqval, "keys", NULL);
		std::map<std::string, FileBrowserFSMenuEntry> resmap;
		for (int i = 0; i < PySequence_Length(seqval); i++) {
			PyObject *keyobj = PySequence_GetItem(seqkeys, i);
			std::string key = PyBytes_AsString(PyUnicode_AsASCIIString(keyobj));
			FileBrowserFSMenuEntry value = FileBrowserFSMenuEntry(PySequence_GetItem(seqval, i));
			resmap.insert(std::pair<std::string,FileBrowserFSMenuEntry>(key, value));
		}
		return resmap;
	}

	/** Setter: System's folders (usually root, available hard drives, etc) */
	void system_folders(std::map<std::string, FileBrowserFSMenuEntry> value) { /* not implemented */ }

	/** Getter: Index of active system folder (-1 if none) */
	int system_folders_active() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "system_folders_active"));
	}

	/** Setter: Index of active system folder (-1 if none) */
	void system_folders_active(int value) {
		PyObject_SetAttrString(pyobjref, "system_folders_active", Py_BuildValue("i", value));
	}

	/** Getter: System's bookmarks */
	std::map<std::string, FileBrowserFSMenuEntry> system_bookmarks() {
		// TODO: MISSING DEREF! USE #DEFINE!
		PyObject *seqval = PyObject_GetAttrString(pyobjref, "system_bookmarks");
		PyObject *seqkeys = PyObject_CallMethod(seqval, "keys", NULL);
		std::map<std::string, FileBrowserFSMenuEntry> resmap;
		for (int i = 0; i < PySequence_Length(seqval); i++) {
			PyObject *keyobj = PySequence_GetItem(seqkeys, i);
			std::string key = PyBytes_AsString(PyUnicode_AsASCIIString(keyobj));
			FileBrowserFSMenuEntry value = FileBrowserFSMenuEntry(PySequence_GetItem(seqval, i));
			resmap.insert(std::pair<std::string,FileBrowserFSMenuEntry>(key, value));
		}
		return resmap;
	}

	/** Setter: System's bookmarks */
	void system_bookmarks(std::map<std::string, FileBrowserFSMenuEntry> value) { /* not implemented */ }

	/** Getter: Index of active system bookmark (-1 if none) */
	int system_bookmarks_active() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "system_bookmarks_active"));
	}

	/** Setter: Index of active system bookmark (-1 if none) */
	void system_bookmarks_active(int value) {
		PyObject_SetAttrString(pyobjref, "system_bookmarks_active", Py_BuildValue("i", value));
	}

	/** Getter: User's bookmarks */
	std::map<std::string, FileBrowserFSMenuEntry> bookmarks() {
		// TODO: MISSING DEREF! USE #DEFINE!
		PyObject *seqval = PyObject_GetAttrString(pyobjref, "bookmarks");
		PyObject *seqkeys = PyObject_CallMethod(seqval, "keys", NULL);
		std::map<std::string, FileBrowserFSMenuEntry> resmap;
		for (int i = 0; i < PySequence_Length(seqval); i++) {
			PyObject *keyobj = PySequence_GetItem(seqkeys, i);
			std::string key = PyBytes_AsString(PyUnicode_AsASCIIString(keyobj));
			FileBrowserFSMenuEntry value = FileBrowserFSMenuEntry(PySequence_GetItem(seqval, i));
			resmap.insert(std::pair<std::string,FileBrowserFSMenuEntry>(key, value));
		}
		return resmap;
	}

	/** Setter: User's bookmarks */
	void bookmarks(std::map<std::string, FileBrowserFSMenuEntry> value) { /* not implemented */ }

	/** Getter: Index of active bookmark (-1 if none) */
	int bookmarks_active() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "bookmarks_active"));
	}

	/** Setter: Index of active bookmark (-1 if none) */
	void bookmarks_active(int value) {
		PyObject_SetAttrString(pyobjref, "bookmarks_active", Py_BuildValue("i", value));
	}

	/** Getter:  */
	std::map<std::string, FileBrowserFSMenuEntry> recent_folders() {
		// TODO: MISSING DEREF! USE #DEFINE!
		PyObject *seqval = PyObject_GetAttrString(pyobjref, "recent_folders");
		PyObject *seqkeys = PyObject_CallMethod(seqval, "keys", NULL);
		std::map<std::string, FileBrowserFSMenuEntry> resmap;
		for (int i = 0; i < PySequence_Length(seqval); i++) {
			PyObject *keyobj = PySequence_GetItem(seqkeys, i);
			std::string key = PyBytes_AsString(PyUnicode_AsASCIIString(keyobj));
			FileBrowserFSMenuEntry value = FileBrowserFSMenuEntry(PySequence_GetItem(seqval, i));
			resmap.insert(std::pair<std::string,FileBrowserFSMenuEntry>(key, value));
		}
		return resmap;
	}

	/** Setter:  */
	void recent_folders(std::map<std::string, FileBrowserFSMenuEntry> value) { /* not implemented */ }

	/** Getter: Index of active recent folder (-1 if none) */
	int recent_folders_active() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "recent_folders_active"));
	}

	/** Setter: Index of active recent folder (-1 if none) */
	void recent_folders_active(int value) {
		PyObject_SetAttrString(pyobjref, "recent_folders_active", Py_BuildValue("i", value));
	}

};

/**************** Space Outliner ****************/

/**
 * Outliner space data
 */
class SpaceOutliner : public Space {
public:
	SpaceOutliner(PyObject* pyobj) : Space(pyobj) {}

	SpaceOutliner() : Space(0)
	{
		// not implemented
	}

	enum display_mode_enum {
		display_mode_ALL_SCENES = 0,
		display_mode_CURRENT_SCENE = 1,
		display_mode_VISIBLE_LAYERS = 2,
		display_mode_SELECTED = 3,
		display_mode_ACTIVE = 4,
		display_mode_SAME_TYPES = 5,
		display_mode_GROUPS = 6,
		display_mode_SEQUENCE = 10,
		display_mode_LIBRARIES = 7,
		display_mode_DATABLOCKS = 11,
		display_mode_USER_PREFERENCES = 12,
		display_mode_ORPHAN_DATA = 14,
	};

	/** Getter: Type of information to display */
	display_mode_enum display_mode() { /* not implemented */ throw NULL; }
	/** Setter: Type of information to display */
	void display_mode(display_mode_enum value) { /* not implemented */ }

	/** Getter: Live search filtering string */
	std::string filter_text() { /* not implemented */ throw NULL; }
	/** Setter: Live search filtering string */
	void filter_text(const std::string& value) { /* not implemented */ }

	/** Getter: Only use case sensitive matches of search string */
	bool use_filter_case_sensitive() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_filter_case_sensitive")) == 1;
	}

	/** Setter: Only use case sensitive matches of search string */
	void use_filter_case_sensitive(bool value) {
		PyObject_SetAttrString(pyobjref, "use_filter_case_sensitive", Py_BuildValue("i", value));
	}

	/** Getter: Only use complete matches of search string */
	bool use_filter_complete() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_filter_complete")) == 1;
	}

	/** Setter: Only use complete matches of search string */
	void use_filter_complete(bool value) {
		PyObject_SetAttrString(pyobjref, "use_filter_complete", Py_BuildValue("i", value));
	}

	/** Getter:  */
	bool use_sort_alpha() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_sort_alpha")) == 1;
	}

	/** Setter:  */
	void use_sort_alpha(bool value) {
		PyObject_SetAttrString(pyobjref, "use_sort_alpha", Py_BuildValue("i", value));
	}

	/** Getter: Show column */
	bool show_restrict_columns() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "show_restrict_columns")) == 1;
	}

	/** Setter: Show column */
	void show_restrict_columns(bool value) {
		PyObject_SetAttrString(pyobjref, "show_restrict_columns", Py_BuildValue("i", value));
	}

};

/**************** Background Image ****************/

/**
 * Image and settings for display in the 3D View background
 */
class BackgroundImage : public pyUniplug {
public:
	BackgroundImage(PyObject* pyobj) : pyUniplug(pyobj) {}

	BackgroundImage() : pyUniplug(0)
	{
		// not implemented
	}

	enum source_enum {
		source_IMAGE = 0,
		source_MOVIE_CLIP = 1,
	};

	/** Getter: Data source used for background */
	source_enum source() { /* not implemented */ throw NULL; }
	/** Setter: Data source used for background */
	void source(source_enum value) { /* not implemented */ }

	/** Getter: Image displayed and edited in this space */
	Image image() {
		/* not implemented */ throw NULL;
	}

	/** Getter: Movie clip displayed and edited in this space */
	MovieClip clip();

	/** Getter: Parameters defining which layer, pass and frame of the image is displayed */
	ImageUser image_user() {
		/* not implemented */ throw NULL;
	}

	/** Getter: Parameters defining which frame of the movie clip is displayed */
	MovieClipUser clip_user();

	/** Getter: Offset image horizontally from the world origin */
	float offset_x() { /* not implemented */ throw NULL; }
	/** Setter: Offset image horizontally from the world origin */
	void offset_x(float value) {
		PyObject_SetAttrString(pyobjref, "offset_x", Py_BuildValue("f", value));
	}

	/** Getter: Offset image vertically from the world origin */
	float offset_y() { /* not implemented */ throw NULL; }
	/** Setter: Offset image vertically from the world origin */
	void offset_y(float value) {
		PyObject_SetAttrString(pyobjref, "offset_y", Py_BuildValue("f", value));
	}

	/** Getter: Size of the background image (ortho view only) */
	float size() { /* not implemented */ throw NULL; }
	/** Setter: Size of the background image (ortho view only) */
	void size(float value) {
		PyObject_SetAttrString(pyobjref, "size", Py_BuildValue("f", value));
	}

	/** Getter: Rotation for the background image (ortho view only) */
	float rotation() { /* not implemented */ throw NULL; }
	/** Setter: Rotation for the background image (ortho view only) */
	void rotation(float value) {
		PyObject_SetAttrString(pyobjref, "rotation", Py_BuildValue("f", value));
	}

	/** Getter: Flip the background image horizontally */
	bool use_flip_x() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_flip_x")) == 1;
	}

	/** Setter: Flip the background image horizontally */
	void use_flip_x(bool value) {
		PyObject_SetAttrString(pyobjref, "use_flip_x", Py_BuildValue("i", value));
	}

	/** Getter: Flip the background image vertically */
	bool use_flip_y() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_flip_y")) == 1;
	}

	/** Setter: Flip the background image vertically */
	void use_flip_y(bool value) {
		PyObject_SetAttrString(pyobjref, "use_flip_y", Py_BuildValue("i", value));
	}

	/** Getter: Image opacity to blend the image against the background color */
	float opacity() { /* not implemented */ throw NULL; }
	/** Setter: Image opacity to blend the image against the background color */
	void opacity(float value) {
		PyObject_SetAttrString(pyobjref, "opacity", Py_BuildValue("f", value));
	}

	enum view_axis_enum {
		view_axis_LEFT = 8,
		view_axis_RIGHT = 16,
		view_axis_BACK = 4,
		view_axis_FRONT = 2,
		view_axis_BOTTOM = 64,
		view_axis_TOP = 32,
		view_axis_ALL = 0,
		view_axis_CAMERA = 256,
	};

	/** Getter: The axis to display the image on */
	view_axis_enum view_axis() { /* not implemented */ throw NULL; }
	/** Setter: The axis to display the image on */
	void view_axis(view_axis_enum value) { /* not implemented */ }

	/** Getter: Show the expanded in the user interface */
	bool show_expanded() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "show_expanded")) == 1;
	}

	/** Setter: Show the expanded in the user interface */
	void show_expanded(bool value) {
		PyObject_SetAttrString(pyobjref, "show_expanded", Py_BuildValue("i", value));
	}

	/** Getter: Use movie clip from active scene camera */
	bool use_camera_clip() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_camera_clip")) == 1;
	}

	/** Setter: Use movie clip from active scene camera */
	void use_camera_clip(bool value) {
		PyObject_SetAttrString(pyobjref, "use_camera_clip", Py_BuildValue("i", value));
	}

	/** Getter: Show this image as background */
	bool show_background_image() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "show_background_image")) == 1;
	}

	/** Setter: Show this image as background */
	void show_background_image(bool value) {
		PyObject_SetAttrString(pyobjref, "show_background_image", Py_BuildValue("i", value));
	}

	/** Getter: Show this image in front of objects in viewport */
	bool show_on_foreground() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "show_on_foreground")) == 1;
	}

	/** Setter: Show this image in front of objects in viewport */
	void show_on_foreground(bool value) {
		PyObject_SetAttrString(pyobjref, "show_on_foreground", Py_BuildValue("i", value));
	}

	enum draw_depth_enum {
		draw_depth_BACK = 0,
		draw_depth_FRONT = 16,
	};

	/** Getter: Draw under or over everything */
	draw_depth_enum draw_depth() { /* not implemented */ throw NULL; }
	/** Setter: Draw under or over everything */
	void draw_depth(draw_depth_enum value) { /* not implemented */ }

	enum frame_method_enum {
		frame_method_STRETCH = 0,
		frame_method_FIT = 32,
		frame_method_CROP = 96,
	};

	/** Getter: How the image fits in the camera frame */
	frame_method_enum frame_method() { /* not implemented */ throw NULL; }
	/** Setter: How the image fits in the camera frame */
	void frame_method(frame_method_enum value) { /* not implemented */ }

};

/**************** 3D View Space ****************/

/**
 * 3D View space data
 */
class SpaceView3D : public Space {
public:
	SpaceView3D(PyObject* pyobj) : Space(pyobj) {}

	SpaceView3D() : Space(0)
	{
		// not implemented
	}

	/** Getter: Active camera used in this view (when unlocked from the scene's active camera) */
	Object camera() {
		/* not implemented */ throw NULL;
	}

	/** Getter: Use a region within the frame size for rendered viewport (when not viewing through the camera) */
	bool use_render_border() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_render_border")) == 1;
	}

	/** Setter: Use a region within the frame size for rendered viewport (when not viewing through the camera) */
	void use_render_border(bool value) {
		PyObject_SetAttrString(pyobjref, "use_render_border", Py_BuildValue("i", value));
	}

	/** Getter: Minimum X value to for the render border */
	float render_border_min_x() { /* not implemented */ throw NULL; }
	/** Setter: Minimum X value to for the render border */
	void render_border_min_x(float value) {
		PyObject_SetAttrString(pyobjref, "render_border_min_x", Py_BuildValue("f", value));
	}

	/** Getter: Minimum Y value for the render border */
	float render_border_min_y() { /* not implemented */ throw NULL; }
	/** Setter: Minimum Y value for the render border */
	void render_border_min_y(float value) {
		PyObject_SetAttrString(pyobjref, "render_border_min_y", Py_BuildValue("f", value));
	}

	/** Getter: Maximum X value for the render border */
	float render_border_max_x() { /* not implemented */ throw NULL; }
	/** Setter: Maximum X value for the render border */
	void render_border_max_x(float value) {
		PyObject_SetAttrString(pyobjref, "render_border_max_x", Py_BuildValue("f", value));
	}

	/** Getter: Maximum Y value for the render border */
	float render_border_max_y() { /* not implemented */ throw NULL; }
	/** Setter: Maximum Y value for the render border */
	void render_border_max_y(float value) {
		PyObject_SetAttrString(pyobjref, "render_border_max_y", Py_BuildValue("f", value));
	}

	/** Getter: 3D View center is locked to this object's position */
	Object lock_object() {
		/* not implemented */ throw NULL;
	}

	/** Getter: 3D View center is locked to this bone's position */
	std::string lock_bone() { /* not implemented */ throw NULL; }
	/** Setter: 3D View center is locked to this bone's position */
	void lock_bone(const std::string& value) { /* not implemented */ }

	/** Getter: 3D View center is locked to the cursor's position */
	bool lock_cursor() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "lock_cursor")) == 1;
	}

	/** Setter: 3D View center is locked to the cursor's position */
	void lock_cursor(bool value) {
		PyObject_SetAttrString(pyobjref, "lock_cursor", Py_BuildValue("i", value));
	}

	enum viewport_shade_enum {
		viewport_shade_BOUNDBOX = 1,
		viewport_shade_WIREFRAME = 2,
		viewport_shade_SOLID = 3,
		viewport_shade_TEXTURED = 5,
		viewport_shade_MATERIAL = 4,
		viewport_shade_RENDERED = 6,
	};

	/** Getter: Method to display/shade objects in the 3D View */
	viewport_shade_enum viewport_shade() { /* not implemented */ throw NULL; }
	/** Setter: Method to display/shade objects in the 3D View */
	void viewport_shade(viewport_shade_enum value) { /* not implemented */ }

	/** Getter: Display an isolated sub-set of objects, apart from the scene visibility */
	SpaceView3D local_view() {
		/* not implemented */ throw NULL;
	}

	/** Getter: 3D cursor location for this view (dependent on local view setting) */
	std::array<float, 3> cursor_location() {
		// TODO: MISSING DEREF! USE #DEFINE!
		PyObject *seqval = PyObject_GetAttrString(pyobjref, "cursor_location");
		std::array<float, 3> resarr;
		for (int i = 0; i < 3; i++)
			resarr[i] = (float)PyFloat_AsDouble(PySequence_GetItem(seqval, i));
		return resarr;
	}

	/** Setter: 3D cursor location for this view (dependent on local view setting) */
	void cursor_location(float values[3]) { /* not implemented */ }

	/** Getter: Viewport lens angle */
	float lens() { /* not implemented */ throw NULL; }
	/** Setter: Viewport lens angle */
	void lens(float value) {
		PyObject_SetAttrString(pyobjref, "lens", Py_BuildValue("f", value));
	}

	/** Getter: 3D View near clipping distance (perspective view only) */
	float clip_start() { /* not implemented */ throw NULL; }
	/** Setter: 3D View near clipping distance (perspective view only) */
	void clip_start(float value) {
		PyObject_SetAttrString(pyobjref, "clip_start", Py_BuildValue("f", value));
	}

	/** Getter: 3D View far clipping distance */
	float clip_end() { /* not implemented */ throw NULL; }
	/** Setter: 3D View far clipping distance */
	void clip_end(float value) {
		PyObject_SetAttrString(pyobjref, "clip_end", Py_BuildValue("f", value));
	}

	/** Getter: Distance between 3D View grid lines */
	float grid_scale() { /* not implemented */ throw NULL; }
	/** Setter: Distance between 3D View grid lines */
	void grid_scale(float value) {
		PyObject_SetAttrString(pyobjref, "grid_scale", Py_BuildValue("f", value));
	}

	/** Getter: Number of grid lines to display in perspective view */
	int grid_lines() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "grid_lines"));
	}

	/** Setter: Number of grid lines to display in perspective view */
	void grid_lines(int value) {
		PyObject_SetAttrString(pyobjref, "grid_lines", Py_BuildValue("i", value));
	}

	/** Getter: Number of subdivisions between grid lines */
	int grid_subdivisions() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "grid_subdivisions"));
	}

	/** Setter: Number of subdivisions between grid lines */
	void grid_subdivisions(int value) {
		PyObject_SetAttrString(pyobjref, "grid_subdivisions", Py_BuildValue("i", value));
	}

	/** Getter: Grid cell size scaled by scene unit system settings */
	float grid_scale_unit() { /* not implemented */ throw NULL; }
	/** Setter: Grid cell size scaled by scene unit system settings */
	void grid_scale_unit(float value) {
		PyObject_SetAttrString(pyobjref, "grid_scale_unit", Py_BuildValue("f", value));
	}

	/** Getter: Show the ground plane grid in perspective view */
	bool show_floor() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "show_floor")) == 1;
	}

	/** Setter: Show the ground plane grid in perspective view */
	void show_floor(bool value) {
		PyObject_SetAttrString(pyobjref, "show_floor", Py_BuildValue("i", value));
	}

	/** Getter: Show the X axis line in perspective view */
	bool show_axis_x() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "show_axis_x")) == 1;
	}

	/** Setter: Show the X axis line in perspective view */
	void show_axis_x(bool value) {
		PyObject_SetAttrString(pyobjref, "show_axis_x", Py_BuildValue("i", value));
	}

	/** Getter: Show the Y axis line in perspective view */
	bool show_axis_y() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "show_axis_y")) == 1;
	}

	/** Setter: Show the Y axis line in perspective view */
	void show_axis_y(bool value) {
		PyObject_SetAttrString(pyobjref, "show_axis_y", Py_BuildValue("i", value));
	}

	/** Getter: Show the Z axis line in perspective view */
	bool show_axis_z() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "show_axis_z")) == 1;
	}

	/** Setter: Show the Z axis line in perspective view */
	void show_axis_z(bool value) {
		PyObject_SetAttrString(pyobjref, "show_axis_z", Py_BuildValue("i", value));
	}

	/** Getter: Show an outline highlight around selected objects in non-wireframe views */
	bool show_outline_selected() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "show_outline_selected")) == 1;
	}

	/** Setter: Show an outline highlight around selected objects in non-wireframe views */
	void show_outline_selected(bool value) {
		PyObject_SetAttrString(pyobjref, "show_outline_selected", Py_BuildValue("i", value));
	}

	/** Getter: Show the object origin center dot for all (selected and unselected) objects */
	bool show_all_objects_origin() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "show_all_objects_origin")) == 1;
	}

	/** Setter: Show the object origin center dot for all (selected and unselected) objects */
	void show_all_objects_origin(bool value) {
		PyObject_SetAttrString(pyobjref, "show_all_objects_origin", Py_BuildValue("i", value));
	}

	/** Getter: Show dashed lines indicating parent or constraint relationships */
	bool show_relationship_lines() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "show_relationship_lines")) == 1;
	}

	/** Setter: Show dashed lines indicating parent or constraint relationships */
	void show_relationship_lines(bool value) {
		PyObject_SetAttrString(pyobjref, "show_relationship_lines", Py_BuildValue("i", value));
	}

	/** Getter: Show grease pencil for this view */
	bool show_grease_pencil() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "show_grease_pencil")) == 1;
	}

	/** Setter: Show grease pencil for this view */
	void show_grease_pencil(bool value) {
		PyObject_SetAttrString(pyobjref, "show_grease_pencil", Py_BuildValue("i", value));
	}

	/** Getter: Display face-assigned textures in solid view */
	bool show_textured_solid() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "show_textured_solid")) == 1;
	}

	/** Setter: Display face-assigned textures in solid view */
	void show_textured_solid(bool value) {
		PyObject_SetAttrString(pyobjref, "show_textured_solid", Py_BuildValue("i", value));
	}

	/** Getter: Use back face culling to hide the back side of faces */
	bool show_backface_culling() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "show_backface_culling")) == 1;
	}

	/** Setter: Use back face culling to hide the back side of faces */
	void show_backface_culling(bool value) {
		PyObject_SetAttrString(pyobjref, "show_backface_culling", Py_BuildValue("i", value));
	}

	/** Getter: Show shadeless texture without lighting in textured draw mode */
	bool show_textured_shadeless() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "show_textured_shadeless")) == 1;
	}

	/** Setter: Show shadeless texture without lighting in textured draw mode */
	void show_textured_shadeless(bool value) {
		PyObject_SetAttrString(pyobjref, "show_textured_shadeless", Py_BuildValue("i", value));
	}

	/** Getter: Use hidden wireframe display */
	bool show_occlude_wire() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "show_occlude_wire")) == 1;
	}

	/** Setter: Use hidden wireframe display */
	void show_occlude_wire(bool value) {
		PyObject_SetAttrString(pyobjref, "show_occlude_wire", Py_BuildValue("i", value));
	}

	/** Getter: Enable view navigation within the camera view */
	bool lock_camera() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "lock_camera")) == 1;
	}

	/** Setter: Enable view navigation within the camera view */
	void lock_camera(bool value) {
		PyObject_SetAttrString(pyobjref, "lock_camera", Py_BuildValue("i", value));
	}

	/** Getter: Display only objects which will be rendered */
	bool show_only_render() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "show_only_render")) == 1;
	}

	/** Setter: Display only objects which will be rendered */
	void show_only_render(bool value) {
		PyObject_SetAttrString(pyobjref, "show_only_render", Py_BuildValue("i", value));
	}

	/** Getter: Display world colors in the background */
	bool show_world() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "show_world")) == 1;
	}

	/** Setter: Display world colors in the background */
	void show_world(bool value) {
		PyObject_SetAttrString(pyobjref, "show_world", Py_BuildValue("i", value));
	}

	/** Getter: Limit selection to visible (clipped with depth buffer) */
	bool use_occlude_geometry() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_occlude_geometry")) == 1;
	}

	/** Setter: Limit selection to visible (clipped with depth buffer) */
	void use_occlude_geometry(bool value) {
		PyObject_SetAttrString(pyobjref, "use_occlude_geometry", Py_BuildValue("i", value));
	}

	/** Getter: List of background images */
	std::map<std::string, BackgroundImage> background_images() {
		// TODO: MISSING DEREF! USE #DEFINE!
		PyObject *seqval = PyObject_GetAttrString(pyobjref, "background_images");
		PyObject *seqkeys = PyObject_CallMethod(seqval, "keys", NULL);
		std::map<std::string, BackgroundImage> resmap;
		for (int i = 0; i < PySequence_Length(seqval); i++) {
			PyObject *keyobj = PySequence_GetItem(seqkeys, i);
			std::string key = PyBytes_AsString(PyUnicode_AsASCIIString(keyobj));
			BackgroundImage value = BackgroundImage(PySequence_GetItem(seqval, i));
			resmap.insert(std::pair<std::string,BackgroundImage>(key, value));
		}
		return resmap;
	}

	/** Setter: List of background images */
	void background_images(std::map<std::string, BackgroundImage> value) { /* not implemented */ }

	/** Getter: Display reference images behind objects in the 3D View */
	bool show_background_images() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "show_background_images")) == 1;
	}

	/** Setter: Display reference images behind objects in the 3D View */
	void show_background_images(bool value) {
		PyObject_SetAttrString(pyobjref, "show_background_images", Py_BuildValue("i", value));
	}

	enum pivot_point_enum {
		pivot_point_BOUNDING_BOX_CENTER = 0,
		pivot_point_CURSOR = 1,
		pivot_point_INDIVIDUAL_ORIGINS = 2,
		pivot_point_MEDIAN_POINT = 3,
		pivot_point_ACTIVE_ELEMENT = 4,
	};

	/** Getter: Pivot center for rotation/scaling */
	pivot_point_enum pivot_point() { /* not implemented */ throw NULL; }
	/** Setter: Pivot center for rotation/scaling */
	void pivot_point(pivot_point_enum value) { /* not implemented */ }

	/** Getter: Manipulate center points (object and pose mode only) */
	bool use_pivot_point_align() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_pivot_point_align")) == 1;
	}

	/** Setter: Manipulate center points (object and pose mode only) */
	void use_pivot_point_align(bool value) {
		PyObject_SetAttrString(pyobjref, "use_pivot_point_align", Py_BuildValue("i", value));
	}

	/** Getter: Use a 3D manipulator widget for controlling transforms */
	bool show_manipulator() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "show_manipulator")) == 1;
	}

	/** Setter: Use a 3D manipulator widget for controlling transforms */
	void show_manipulator(bool value) {
		PyObject_SetAttrString(pyobjref, "show_manipulator", Py_BuildValue("i", value));
	}

	enum transform_manipulators_enum {
		transform_manipulators_TRANSLATE = 1,
		transform_manipulators_ROTATE = 2,
		transform_manipulators_SCALE = 4,
	};

	/** Getter: Transformation manipulators */
	transform_manipulators_enum transform_manipulators() { /* not implemented */ throw NULL; }
	/** Setter: Transformation manipulators */
	void transform_manipulators(transform_manipulators_enum value) { /* not implemented */ }

	enum transform_orientation_enum {
		transform_orientation_GLOBAL = 0,
		transform_orientation_LOCAL = 1,
		transform_orientation_NORMAL = 2,
		transform_orientation_GIMBAL = 4,
		transform_orientation_VIEW = 3,
	};

	/** Getter: Transformation orientation */
	transform_orientation_enum transform_orientation() { /* not implemented */ throw NULL; }
	/** Setter: Transformation orientation */
	void transform_orientation(transform_orientation_enum value) { /* not implemented */ }

	/** Getter: Current transformation orientation */
	TransformOrientation current_orientation() {
		/* not implemented */ throw NULL;
	}

	/** Getter: Use the scene's active camera and layers in this view, rather than local layers */
	bool lock_camera_and_layers() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "lock_camera_and_layers")) == 1;
	}

	/** Setter: Use the scene's active camera and layers in this view, rather than local layers */
	void lock_camera_and_layers(bool value) {
		PyObject_SetAttrString(pyobjref, "lock_camera_and_layers", Py_BuildValue("i", value));
	}

	/** Getter: Layers visible in this 3D View */
	std::array<bool, 20> layers() {
		// TODO: MISSING DEREF! USE #DEFINE!
		PyObject *seqval = PyObject_GetAttrString(pyobjref, "layers");
		std::array<bool, 20> resarr;
		for (int i = 0; i < 20; i++)
			resarr[i] = PyLong_AsLong(PySequence_GetItem(seqval, i)) == 1;
		return resarr;
	}

	/** Setter: Layers visible in this 3D View */
	void layers(bool values[20]) { /* not implemented */ }

	/** Getter: Local view layers visible in this 3D View */
	std::array<bool, 8> layers_local_view() {
		// TODO: MISSING DEREF! USE #DEFINE!
		PyObject *seqval = PyObject_GetAttrString(pyobjref, "layers_local_view");
		std::array<bool, 8> resarr;
		for (int i = 0; i < 8; i++)
			resarr[i] = PyLong_AsLong(PySequence_GetItem(seqval, i)) == 1;
		return resarr;
	}

	/** Setter: Local view layers visible in this 3D View */
	void layers_local_view(bool values[8]) { /* not implemented */ }

	/** Getter: Layers that contain something */
	std::array<bool, 20> layers_used() {
		// TODO: MISSING DEREF! USE #DEFINE!
		PyObject *seqval = PyObject_GetAttrString(pyobjref, "layers_used");
		std::array<bool, 20> resarr;
		for (int i = 0; i < 20; i++)
			resarr[i] = PyLong_AsLong(PySequence_GetItem(seqval, i)) == 1;
		return resarr;
	}

	/** Setter: Layers that contain something */
	void layers_used(bool values[20]) { /* not implemented */ }

	/** Getter: 3D region in this space, in case of quad view the camera region */
	RegionView3D region_3d();

	/** Getter: 3D regions (the third one defines quad view settings, the forth one is same as 'region_3d') */
	std::map<std::string, RegionView3D> region_quadviews();
	/** Setter: 3D regions (the third one defines quad view settings, the forth one is same as 'region_3d') */
	void region_quadviews(std::map<std::string, RegionView3D> value);

	/** Getter: Display reconstruction data from active movie clip */
	bool show_reconstruction() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "show_reconstruction")) == 1;
	}

	/** Setter: Display reconstruction data from active movie clip */
	void show_reconstruction(bool value) {
		PyObject_SetAttrString(pyobjref, "show_reconstruction", Py_BuildValue("i", value));
	}

	/** Getter: Display size of tracks from reconstructed data */
	float tracks_draw_size() { /* not implemented */ throw NULL; }
	/** Setter: Display size of tracks from reconstructed data */
	void tracks_draw_size(float value) {
		PyObject_SetAttrString(pyobjref, "tracks_draw_size", Py_BuildValue("f", value));
	}

	enum tracks_draw_type_enum {
		tracks_draw_type_PLAIN_AXES = 2,
		tracks_draw_type_ARROWS = 1,
		tracks_draw_type_SINGLE_ARROW = 4,
		tracks_draw_type_CIRCLE = 3,
		tracks_draw_type_CUBE = 5,
		tracks_draw_type_SPHERE = 6,
		tracks_draw_type_CONE = 7,
	};

	/** Getter: Viewport display style for tracks */
	tracks_draw_type_enum tracks_draw_type() { /* not implemented */ throw NULL; }
	/** Setter: Viewport display style for tracks */
	void tracks_draw_type(tracks_draw_type_enum value) { /* not implemented */ }

	/** Getter: Show reconstructed camera path */
	bool show_camera_path() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "show_camera_path")) == 1;
	}

	/** Setter: Show reconstructed camera path */
	void show_camera_path(bool value) {
		PyObject_SetAttrString(pyobjref, "show_camera_path", Py_BuildValue("i", value));
	}

	/** Getter: Show names for reconstructed tracks objects */
	bool show_bundle_names() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "show_bundle_names")) == 1;
	}

	/** Setter: Show names for reconstructed tracks objects */
	void show_bundle_names(bool value) {
		PyObject_SetAttrString(pyobjref, "show_bundle_names", Py_BuildValue("i", value));
	}

	/** Getter: Active Objects draw images mapped on normals, enhancing Solid Draw Mode */
	bool use_matcap() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_matcap")) == 1;
	}

	/** Setter: Active Objects draw images mapped on normals, enhancing Solid Draw Mode */
	void use_matcap(bool value) {
		PyObject_SetAttrString(pyobjref, "use_matcap", Py_BuildValue("i", value));
	}

	enum matcap_icon_enum {
		matcap_icon_01 = 812,
		matcap_icon_02 = 813,
		matcap_icon_03 = 814,
		matcap_icon_04 = 815,
		matcap_icon_05 = 816,
		matcap_icon_06 = 817,
		matcap_icon_07 = 818,
		matcap_icon_08 = 819,
		matcap_icon_09 = 820,
		matcap_icon_10 = 821,
		matcap_icon_11 = 822,
		matcap_icon_12 = 823,
		matcap_icon_13 = 824,
		matcap_icon_14 = 825,
		matcap_icon_15 = 826,
		matcap_icon_16 = 827,
		matcap_icon_17 = 828,
		matcap_icon_18 = 829,
		matcap_icon_19 = 830,
		matcap_icon_20 = 831,
		matcap_icon_21 = 832,
		matcap_icon_22 = 833,
		matcap_icon_23 = 834,
		matcap_icon_24 = 835,
	};

	/** Getter: Image to use for Material Capture, active objects only */
	matcap_icon_enum matcap_icon() { /* not implemented */ throw NULL; }
	/** Setter: Image to use for Material Capture, active objects only */
	void matcap_icon(matcap_icon_enum value) { /* not implemented */ }

	/** Getter: Options used for real time compositing */
	GPUFXSettings fx_settings() {
		/* not implemented */ throw NULL;
	}

	enum stereo_3d_eye_enum {
		stereo_3d_eye_LEFT_EYE = 0,
		stereo_3d_eye_RIGHT_EYE = 1,
	};

	/** Getter: Current stereo eye being drawn */
	stereo_3d_eye_enum stereo_3d_eye() { /* not implemented */ throw NULL; }
	/** Setter: Current stereo eye being drawn */
	void stereo_3d_eye(stereo_3d_eye_enum value) { /* not implemented */ }

	enum stereo_3d_camera_enum {
		stereo_3d_camera_LEFT = 0,
		stereo_3d_camera_RIGHT = 1,
		stereo_3d_camera_S3D = 2,
	};

	/** Getter:  */
	stereo_3d_camera_enum stereo_3d_camera() { /* not implemented */ throw NULL; }
	/** Setter:  */
	void stereo_3d_camera(stereo_3d_camera_enum value) { /* not implemented */ }

	/** Getter: Show the left and right cameras */
	bool show_stereo_3d_cameras() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "show_stereo_3d_cameras")) == 1;
	}

	/** Setter: Show the left and right cameras */
	void show_stereo_3d_cameras(bool value) {
		PyObject_SetAttrString(pyobjref, "show_stereo_3d_cameras", Py_BuildValue("i", value));
	}

	/** Getter: Show the stereo 3d convergence plane */
	bool show_stereo_3d_convergence_plane() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "show_stereo_3d_convergence_plane")) == 1;
	}

	/** Setter: Show the stereo 3d convergence plane */
	void show_stereo_3d_convergence_plane(bool value) {
		PyObject_SetAttrString(pyobjref, "show_stereo_3d_convergence_plane", Py_BuildValue("i", value));
	}

	/** Getter: Opacity (alpha) of the convergence plane */
	float stereo_3d_convergence_plane_alpha() { /* not implemented */ throw NULL; }
	/** Setter: Opacity (alpha) of the convergence plane */
	void stereo_3d_convergence_plane_alpha(float value) {
		PyObject_SetAttrString(pyobjref, "stereo_3d_convergence_plane_alpha", Py_BuildValue("f", value));
	}

	/** Getter: Show the stereo 3d frustum volume */
	bool show_stereo_3d_volume() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "show_stereo_3d_volume")) == 1;
	}

	/** Setter: Show the stereo 3d frustum volume */
	void show_stereo_3d_volume(bool value) {
		PyObject_SetAttrString(pyobjref, "show_stereo_3d_volume", Py_BuildValue("i", value));
	}

	/** Getter: Opacity (alpha) of the cameras' frustum volume */
	float stereo_3d_volume_alpha() { /* not implemented */ throw NULL; }
	/** Setter: Opacity (alpha) of the cameras' frustum volume */
	void stereo_3d_volume_alpha(float value) {
		PyObject_SetAttrString(pyobjref, "stereo_3d_volume_alpha", Py_BuildValue("f", value));
	}

};

/**************** 3D View Region ****************/

/**
 * 3D View region data
 */
class RegionView3D : public pyUniplug {
public:
	RegionView3D(PyObject* pyobj) : pyUniplug(pyobj) {}

	RegionView3D() : pyUniplug(0)
	{
		// not implemented
	}

	/** Getter: Lock view rotation in side views */
	bool lock_rotation() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "lock_rotation")) == 1;
	}

	/** Setter: Lock view rotation in side views */
	void lock_rotation(bool value) {
		PyObject_SetAttrString(pyobjref, "lock_rotation", Py_BuildValue("i", value));
	}

	/** Getter: Sync view position between side views */
	bool show_sync_view() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "show_sync_view")) == 1;
	}

	/** Setter: Sync view position between side views */
	void show_sync_view(bool value) {
		PyObject_SetAttrString(pyobjref, "show_sync_view", Py_BuildValue("i", value));
	}

	/** Getter: Clip objects based on what's visible in other side views */
	bool use_box_clip() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_box_clip")) == 1;
	}

	/** Setter: Clip objects based on what's visible in other side views */
	void use_box_clip(bool value) {
		PyObject_SetAttrString(pyobjref, "use_box_clip", Py_BuildValue("i", value));
	}

	/** Getter: Current perspective matrix (``window_matrix * view_matrix``) */
	std::array<float, 16> perspective_matrix() {
		// TODO: MISSING DEREF! USE #DEFINE!
		PyObject *seqval = PyObject_GetAttrString(pyobjref, "perspective_matrix");
		std::array<float, 16> resarr;
		for (int i = 0; i < 16; i++)
			resarr[i] = (float)PyFloat_AsDouble(PySequence_GetItem(seqval, i));
		return resarr;
	}

	/** Setter: Current perspective matrix (``window_matrix * view_matrix``) */
	void perspective_matrix(float values[16]) { /* not implemented */ }

	/** Getter: Current window matrix */
	std::array<float, 16> window_matrix() {
		// TODO: MISSING DEREF! USE #DEFINE!
		PyObject *seqval = PyObject_GetAttrString(pyobjref, "window_matrix");
		std::array<float, 16> resarr;
		for (int i = 0; i < 16; i++)
			resarr[i] = (float)PyFloat_AsDouble(PySequence_GetItem(seqval, i));
		return resarr;
	}

	/** Setter: Current window matrix */
	void window_matrix(float values[16]) { /* not implemented */ }

	/** Getter: Current view matrix */
	std::array<float, 16> view_matrix() {
		// TODO: MISSING DEREF! USE #DEFINE!
		PyObject *seqval = PyObject_GetAttrString(pyobjref, "view_matrix");
		std::array<float, 16> resarr;
		for (int i = 0; i < 16; i++)
			resarr[i] = (float)PyFloat_AsDouble(PySequence_GetItem(seqval, i));
		return resarr;
	}

	/** Setter: Current view matrix */
	void view_matrix(float values[16]) { /* not implemented */ }

	enum view_perspective_enum {
		view_perspective_PERSP = 1,
		view_perspective_ORTHO = 0,
		view_perspective_CAMERA = 2,
	};

	/** Getter: View Perspective */
	view_perspective_enum view_perspective() { /* not implemented */ throw NULL; }
	/** Setter: View Perspective */
	void view_perspective(view_perspective_enum value) { /* not implemented */ }

	/** Getter:  */
	bool is_perspective() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "is_perspective")) == 1;
	}

	/** Setter:  */
	void is_perspective(bool value) {
		PyObject_SetAttrString(pyobjref, "is_perspective", Py_BuildValue("i", value));
	}

	/** Getter: View pivot location */
	std::array<float, 3> view_location() {
		// TODO: MISSING DEREF! USE #DEFINE!
		PyObject *seqval = PyObject_GetAttrString(pyobjref, "view_location");
		std::array<float, 3> resarr;
		for (int i = 0; i < 3; i++)
			resarr[i] = (float)PyFloat_AsDouble(PySequence_GetItem(seqval, i));
		return resarr;
	}

	/** Setter: View pivot location */
	void view_location(float values[3]) { /* not implemented */ }

	/** Getter: Rotation in quaternions (keep normalized) */
	std::array<float, 4> view_rotation() {
		// TODO: MISSING DEREF! USE #DEFINE!
		PyObject *seqval = PyObject_GetAttrString(pyobjref, "view_rotation");
		std::array<float, 4> resarr;
		for (int i = 0; i < 4; i++)
			resarr[i] = (float)PyFloat_AsDouble(PySequence_GetItem(seqval, i));
		return resarr;
	}

	/** Setter: Rotation in quaternions (keep normalized) */
	void view_rotation(float values[4]) { /* not implemented */ }

	/** Getter: Distance to the view location */
	float view_distance() { /* not implemented */ throw NULL; }
	/** Setter: Distance to the view location */
	void view_distance(float value) {
		PyObject_SetAttrString(pyobjref, "view_distance", Py_BuildValue("f", value));
	}

	/** Getter: Zoom factor in camera view */
	float view_camera_zoom() { /* not implemented */ throw NULL; }
	/** Setter: Zoom factor in camera view */
	void view_camera_zoom(float value) {
		PyObject_SetAttrString(pyobjref, "view_camera_zoom", Py_BuildValue("f", value));
	}

	/** Getter: View shift in camera view */
	std::array<float, 2> view_camera_offset() {
		// TODO: MISSING DEREF! USE #DEFINE!
		PyObject *seqval = PyObject_GetAttrString(pyobjref, "view_camera_offset");
		std::array<float, 2> resarr;
		for (int i = 0; i < 2; i++)
			resarr[i] = (float)PyFloat_AsDouble(PySequence_GetItem(seqval, i));
		return resarr;
	}

	/** Setter: View shift in camera view */
	void view_camera_offset(float values[2]) { /* not implemented */ }

	/**
	 * Recalculate the view matrices
	 */
	void update()
	{
		// not implemented
	}

};

/**************** Properties Space ****************/

/**
 * Properties space data
 */
class SpaceProperties : public Space {
public:
	SpaceProperties(PyObject* pyobj) : Space(pyobj) {}

	SpaceProperties() : Space(0)
	{
		// not implemented
	}

	enum context_enum {
		context_SCENE = 1,
		context_RENDER = 0,
		context_RENDER_LAYER = 13,
		context_WORLD = 2,
		context_OBJECT = 3,
		context_CONSTRAINT = 11,
		context_MODIFIER = 10,
		context_DATA = 4,
		context_BONE = 9,
		context_BONE_CONSTRAINT = 12,
		context_MATERIAL = 5,
		context_TEXTURE = 6,
		context_PARTICLES = 7,
		context_PHYSICS = 8,
	};

	/** Getter: Type of active data to display and edit */
	context_enum context() { /* not implemented */ throw NULL; }
	/** Setter: Type of active data to display and edit */
	void context(context_enum value) { /* not implemented */ }

	enum align_enum {
		align_HORIZONTAL = 1,
		align_VERTICAL = 2,
	};

	/** Getter: Arrangement of the panels */
	align_enum align() { /* not implemented */ throw NULL; }
	/** Setter: Arrangement of the panels */
	void align(align_enum value) { /* not implemented */ }

	enum texture_context_enum {
		texture_context_MATERIAL = 0,
		texture_context_WORLD = 1,
		texture_context_LAMP = 2,
		texture_context_PARTICLES = 3,
		texture_context_LINESTYLE = 5,
		texture_context_OTHER = 4,
	};

	/** Getter: Type of texture data to display and edit */
	texture_context_enum texture_context() { /* not implemented */ throw NULL; }
	/** Setter: Type of texture data to display and edit */
	void texture_context(texture_context_enum value) { /* not implemented */ }

	/** Getter: Use the limited version of texture user (for 'old shading' mode) */
	bool use_limited_texture_context() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_limited_texture_context")) == 1;
	}

	/** Setter: Use the limited version of texture user (for 'old shading' mode) */
	void use_limited_texture_context(bool value) {
		PyObject_SetAttrString(pyobjref, "use_limited_texture_context", Py_BuildValue("i", value));
	}

	/** Getter:  */
	ID pin_id() {
		/* not implemented */ throw NULL;
	}

	/** Getter: Use the pinned context */
	bool use_pin_id() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_pin_id")) == 1;
	}

	/** Setter: Use the pinned context */
	void use_pin_id(bool value) {
		PyObject_SetAttrString(pyobjref, "use_pin_id", Py_BuildValue("i", value));
	}

};

/**************** Space Dope Sheet Editor ****************/

/**
 * Dope Sheet space data
 */
class SpaceDopeSheetEditor : public Space {
public:
	SpaceDopeSheetEditor(PyObject* pyobj) : Space(pyobj) {}

	SpaceDopeSheetEditor() : Space(0)
	{
		// not implemented
	}

	/** Getter: Action displayed and edited in this space */
	Action action() {
		/* not implemented */ throw NULL;
	}

	enum mode_enum {
		mode_DOPESHEET = 3,
		mode_ACTION = 0,
		mode_SHAPEKEY = 1,
		mode_GPENCIL = 2,
		mode_MASK = 4,
	};

	/** Getter: Editing context being displayed */
	mode_enum mode() { /* not implemented */ throw NULL; }
	/** Setter: Editing context being displayed */
	void mode(mode_enum value) { /* not implemented */ }

	/** Getter: Show timing in seconds not frames */
	bool show_seconds() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "show_seconds")) == 1;
	}

	/** Setter: Show timing in seconds not frames */
	void show_seconds(bool value) {
		PyObject_SetAttrString(pyobjref, "show_seconds", Py_BuildValue("i", value));
	}

	/** Getter: Show frame number beside the current frame indicator line */
	bool show_frame_indicator() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "show_frame_indicator")) == 1;
	}

	/** Setter: Show frame number beside the current frame indicator line */
	void show_frame_indicator(bool value) {
		PyObject_SetAttrString(pyobjref, "show_frame_indicator", Py_BuildValue("i", value));
	}

	/** Getter: Show sliders beside F-Curve channels */
	bool show_sliders() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "show_sliders")) == 1;
	}

	/** Setter: Show sliders beside F-Curve channels */
	void show_sliders(bool value) {
		PyObject_SetAttrString(pyobjref, "show_sliders", Py_BuildValue("i", value));
	}

	/** Getter: Show markers belonging to the active action instead of Scene markers (Action and Shape Key Editors only) */
	bool show_pose_markers() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "show_pose_markers")) == 1;
	}

	/** Setter: Show markers belonging to the active action instead of Scene markers (Action and Shape Key Editors only) */
	void show_pose_markers(bool value) {
		PyObject_SetAttrString(pyobjref, "show_pose_markers", Py_BuildValue("i", value));
	}

	/** Getter: Draw groups and channels with colors matching their corresponding groups (pose bones only currently) */
	bool show_group_colors() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "show_group_colors")) == 1;
	}

	/** Setter: Draw groups and channels with colors matching their corresponding groups (pose bones only currently) */
	void show_group_colors(bool value) {
		PyObject_SetAttrString(pyobjref, "show_group_colors", Py_BuildValue("i", value));
	}

	/** Getter: Automatically merge nearby keyframes */
	bool use_auto_merge_keyframes() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_auto_merge_keyframes")) == 1;
	}

	/** Setter: Automatically merge nearby keyframes */
	void use_auto_merge_keyframes(bool value) {
		PyObject_SetAttrString(pyobjref, "use_auto_merge_keyframes", Py_BuildValue("i", value));
	}

	/** Getter: When transforming keyframes, changes to the animation data are flushed to other views */
	bool use_realtime_update() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_realtime_update")) == 1;
	}

	/** Setter: When transforming keyframes, changes to the animation data are flushed to other views */
	void use_realtime_update(bool value) {
		PyObject_SetAttrString(pyobjref, "use_realtime_update", Py_BuildValue("i", value));
	}

	/** Getter: Sync Markers with keyframe edits */
	bool use_marker_sync() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_marker_sync")) == 1;
	}

	/** Setter: Sync Markers with keyframe edits */
	void use_marker_sync(bool value) {
		PyObject_SetAttrString(pyobjref, "use_marker_sync", Py_BuildValue("i", value));
	}

	/** Getter: Settings for filtering animation data */
	DopeSheet dopesheet() {
		/* not implemented */ throw NULL;
	}

	enum auto_snap_enum {
		auto_snap_NONE = 0,
		auto_snap_STEP = 1,
		auto_snap_TIME_STEP = 5,
		auto_snap_FRAME = 2,
		auto_snap_SECOND = 4,
		auto_snap_MARKER = 3,
	};

	/** Getter: Automatic time snapping settings for transformations */
	auto_snap_enum auto_snap() { /* not implemented */ throw NULL; }
	/** Setter: Automatic time snapping settings for transformations */
	void auto_snap(auto_snap_enum value) { /* not implemented */ }

};

/**************** Space Graph Editor ****************/

/**
 * Graph Editor space data
 */
class SpaceGraphEditor : public Space {
public:
	SpaceGraphEditor(PyObject* pyobj) : Space(pyobj) {}

	SpaceGraphEditor() : Space(0)
	{
		// not implemented
	}

	enum mode_enum {
		mode_FCURVES = 0,
		mode_DRIVERS = 1,
	};

	/** Getter: Editing context being displayed */
	mode_enum mode() { /* not implemented */ throw NULL; }
	/** Setter: Editing context being displayed */
	void mode(mode_enum value) { /* not implemented */ }

	/** Getter: Show timing in seconds not frames */
	bool show_seconds() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "show_seconds")) == 1;
	}

	/** Setter: Show timing in seconds not frames */
	void show_seconds(bool value) {
		PyObject_SetAttrString(pyobjref, "show_seconds", Py_BuildValue("i", value));
	}

	/** Getter: Show frame number beside the current frame indicator line */
	bool show_frame_indicator() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "show_frame_indicator")) == 1;
	}

	/** Setter: Show frame number beside the current frame indicator line */
	void show_frame_indicator(bool value) {
		PyObject_SetAttrString(pyobjref, "show_frame_indicator", Py_BuildValue("i", value));
	}

	/** Getter: Show sliders beside F-Curve channels */
	bool show_sliders() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "show_sliders")) == 1;
	}

	/** Setter: Show sliders beside F-Curve channels */
	void show_sliders(bool value) {
		PyObject_SetAttrString(pyobjref, "show_sliders", Py_BuildValue("i", value));
	}

	/** Getter: Show handles of Bezier control points */
	bool show_handles() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "show_handles")) == 1;
	}

	/** Setter: Show handles of Bezier control points */
	void show_handles(bool value) {
		PyObject_SetAttrString(pyobjref, "show_handles", Py_BuildValue("i", value));
	}

	/** Getter: Only keyframes of selected F-Curves are visible and editable */
	bool use_only_selected_curves_handles() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_only_selected_curves_handles")) == 1;
	}

	/** Setter: Only keyframes of selected F-Curves are visible and editable */
	void use_only_selected_curves_handles(bool value) {
		PyObject_SetAttrString(pyobjref, "use_only_selected_curves_handles", Py_BuildValue("i", value));
	}

	/** Getter: Only show and edit handles of selected keyframes */
	bool use_only_selected_keyframe_handles() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_only_selected_keyframe_handles")) == 1;
	}

	/** Setter: Only show and edit handles of selected keyframes */
	void use_only_selected_keyframe_handles(bool value) {
		PyObject_SetAttrString(pyobjref, "use_only_selected_keyframe_handles", Py_BuildValue("i", value));
	}

	/** Getter: Draw F-Curves using Anti-Aliasing and other fancy effects (disable for better performance) */
	bool use_beauty_drawing() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_beauty_drawing")) == 1;
	}

	/** Setter: Draw F-Curves using Anti-Aliasing and other fancy effects (disable for better performance) */
	void use_beauty_drawing(bool value) {
		PyObject_SetAttrString(pyobjref, "use_beauty_drawing", Py_BuildValue("i", value));
	}

	/** Getter: Draw groups and channels with colors matching their corresponding groups */
	bool show_group_colors() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "show_group_colors")) == 1;
	}

	/** Setter: Draw groups and channels with colors matching their corresponding groups */
	void show_group_colors(bool value) {
		PyObject_SetAttrString(pyobjref, "show_group_colors", Py_BuildValue("i", value));
	}

	/** Getter: Automatically merge nearby keyframes */
	bool use_auto_merge_keyframes() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_auto_merge_keyframes")) == 1;
	}

	/** Setter: Automatically merge nearby keyframes */
	void use_auto_merge_keyframes(bool value) {
		PyObject_SetAttrString(pyobjref, "use_auto_merge_keyframes", Py_BuildValue("i", value));
	}

	/** Getter: When transforming keyframes, changes to the animation data are flushed to other views */
	bool use_realtime_update() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_realtime_update")) == 1;
	}

	/** Setter: When transforming keyframes, changes to the animation data are flushed to other views */
	void use_realtime_update(bool value) {
		PyObject_SetAttrString(pyobjref, "use_realtime_update", Py_BuildValue("i", value));
	}

	/** Getter: Show 2D cursor */
	bool show_cursor() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "show_cursor")) == 1;
	}

	/** Setter: Show 2D cursor */
	void show_cursor(bool value) {
		PyObject_SetAttrString(pyobjref, "show_cursor", Py_BuildValue("i", value));
	}

	/** Getter: Graph Editor 2D-Value cursor - Y-Value component */
	float cursor_position_y() { /* not implemented */ throw NULL; }
	/** Setter: Graph Editor 2D-Value cursor - Y-Value component */
	void cursor_position_y(float value) {
		PyObject_SetAttrString(pyobjref, "cursor_position_y", Py_BuildValue("f", value));
	}

	enum pivot_point_enum {
		pivot_point_BOUNDING_BOX_CENTER = 0,
		pivot_point_CURSOR = 1,
		pivot_point_INDIVIDUAL_ORIGINS = 2,
	};

	/** Getter: Pivot center for rotation/scaling */
	pivot_point_enum pivot_point() { /* not implemented */ throw NULL; }
	/** Setter: Pivot center for rotation/scaling */
	void pivot_point(pivot_point_enum value) { /* not implemented */ }

	/** Getter: Settings for filtering animation data */
	DopeSheet dopesheet() {
		/* not implemented */ throw NULL;
	}

	enum auto_snap_enum {
		auto_snap_NONE = 0,
		auto_snap_STEP = 1,
		auto_snap_TIME_STEP = 5,
		auto_snap_FRAME = 2,
		auto_snap_SECOND = 4,
		auto_snap_MARKER = 3,
	};

	/** Getter: Automatic time snapping settings for transformations */
	auto_snap_enum auto_snap() { /* not implemented */ throw NULL; }
	/** Setter: Automatic time snapping settings for transformations */
	void auto_snap(auto_snap_enum value) { /* not implemented */ }

	/** Getter: Graph Editor instance has some ghost curves stored */
	bool has_ghost_curves() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "has_ghost_curves")) == 1;
	}

	/** Setter: Graph Editor instance has some ghost curves stored */
	void has_ghost_curves(bool value) {
		PyObject_SetAttrString(pyobjref, "has_ghost_curves", Py_BuildValue("i", value));
	}

	/** Getter: Display curves in normalized to -1..1 range, for easier editing of multiple curves with different ranges */
	bool use_normalization() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_normalization")) == 1;
	}

	/** Setter: Display curves in normalized to -1..1 range, for easier editing of multiple curves with different ranges */
	void use_normalization(bool value) {
		PyObject_SetAttrString(pyobjref, "use_normalization", Py_BuildValue("i", value));
	}

	/** Getter: Automatically recalculate curve normalization on every curve edit */
	bool use_auto_normalization() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_auto_normalization")) == 1;
	}

	/** Setter: Automatically recalculate curve normalization on every curve edit */
	void use_auto_normalization(bool value) {
		PyObject_SetAttrString(pyobjref, "use_auto_normalization", Py_BuildValue("i", value));
	}

};

/**************** Space Nla Editor ****************/

/**
 * NLA editor space data
 */
class SpaceNLA : public Space {
public:
	SpaceNLA(PyObject* pyobj) : Space(pyobj) {}

	SpaceNLA() : Space(0)
	{
		// not implemented
	}

	/** Getter: Show timing in seconds not frames */
	bool show_seconds() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "show_seconds")) == 1;
	}

	/** Setter: Show timing in seconds not frames */
	void show_seconds(bool value) {
		PyObject_SetAttrString(pyobjref, "show_seconds", Py_BuildValue("i", value));
	}

	/** Getter: Show frame number beside the current frame indicator line */
	bool show_frame_indicator() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "show_frame_indicator")) == 1;
	}

	/** Setter: Show frame number beside the current frame indicator line */
	void show_frame_indicator(bool value) {
		PyObject_SetAttrString(pyobjref, "show_frame_indicator", Py_BuildValue("i", value));
	}

	/** Getter: Show influence F-Curves on strips */
	bool show_strip_curves() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "show_strip_curves")) == 1;
	}

	/** Setter: Show influence F-Curves on strips */
	void show_strip_curves(bool value) {
		PyObject_SetAttrString(pyobjref, "show_strip_curves", Py_BuildValue("i", value));
	}

	/** Getter: When transforming strips, changes to the animation data are flushed to other views */
	bool use_realtime_update() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_realtime_update")) == 1;
	}

	/** Setter: When transforming strips, changes to the animation data are flushed to other views */
	void use_realtime_update(bool value) {
		PyObject_SetAttrString(pyobjref, "use_realtime_update", Py_BuildValue("i", value));
	}

	/** Getter: Settings for filtering animation data */
	DopeSheet dopesheet() {
		/* not implemented */ throw NULL;
	}

	enum auto_snap_enum {
		auto_snap_NONE = 0,
		auto_snap_STEP = 1,
		auto_snap_TIME_STEP = 5,
		auto_snap_FRAME = 2,
		auto_snap_SECOND = 4,
		auto_snap_MARKER = 3,
	};

	/** Getter: Automatic time snapping settings for transformations */
	auto_snap_enum auto_snap() { /* not implemented */ throw NULL; }
	/** Setter: Automatic time snapping settings for transformations */
	void auto_snap(auto_snap_enum value) { /* not implemented */ }

};

/**************** Space Timeline Editor ****************/

/**
 * Timeline editor space data
 */
class SpaceTimeline : public Space {
public:
	SpaceTimeline(PyObject* pyobj) : Space(pyobj) {}

	SpaceTimeline() : Space(0)
	{
		// not implemented
	}

	/** Getter: Show frame number beside the current frame indicator line */
	bool show_frame_indicator() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "show_frame_indicator")) == 1;
	}

	/** Setter: Show frame number beside the current frame indicator line */
	void show_frame_indicator(bool value) {
		PyObject_SetAttrString(pyobjref, "show_frame_indicator", Py_BuildValue("i", value));
	}

	/** Getter: Show timing in seconds not frames */
	bool show_seconds() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "show_seconds")) == 1;
	}

	/** Setter: Show timing in seconds not frames */
	void show_seconds(bool value) {
		PyObject_SetAttrString(pyobjref, "show_seconds", Py_BuildValue("i", value));
	}

	/** Getter: Show the status of cached frames in the timeline */
	bool show_cache() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "show_cache")) == 1;
	}

	/** Setter: Show the status of cached frames in the timeline */
	void show_cache(bool value) {
		PyObject_SetAttrString(pyobjref, "show_cache", Py_BuildValue("i", value));
	}

	/** Getter: Show the active object's softbody point cache */
	bool cache_softbody() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "cache_softbody")) == 1;
	}

	/** Setter: Show the active object's softbody point cache */
	void cache_softbody(bool value) {
		PyObject_SetAttrString(pyobjref, "cache_softbody", Py_BuildValue("i", value));
	}

	/** Getter: Show the active object's particle point cache */
	bool cache_particles() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "cache_particles")) == 1;
	}

	/** Setter: Show the active object's particle point cache */
	void cache_particles(bool value) {
		PyObject_SetAttrString(pyobjref, "cache_particles", Py_BuildValue("i", value));
	}

	/** Getter: Show the active object's cloth point cache */
	bool cache_cloth() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "cache_cloth")) == 1;
	}

	/** Setter: Show the active object's cloth point cache */
	void cache_cloth(bool value) {
		PyObject_SetAttrString(pyobjref, "cache_cloth", Py_BuildValue("i", value));
	}

	/** Getter: Show the active object's smoke cache */
	bool cache_smoke() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "cache_smoke")) == 1;
	}

	/** Setter: Show the active object's smoke cache */
	void cache_smoke(bool value) {
		PyObject_SetAttrString(pyobjref, "cache_smoke", Py_BuildValue("i", value));
	}

	/** Getter: Show the active object's Dynamic Paint cache */
	bool cache_dynamicpaint() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "cache_dynamicpaint")) == 1;
	}

	/** Setter: Show the active object's Dynamic Paint cache */
	void cache_dynamicpaint(bool value) {
		PyObject_SetAttrString(pyobjref, "cache_dynamicpaint", Py_BuildValue("i", value));
	}

	/** Getter: Show the active object's Rigid Body cache */
	bool cache_rigidbody() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "cache_rigidbody")) == 1;
	}

	/** Setter: Show the active object's Rigid Body cache */
	void cache_rigidbody(bool value) {
		PyObject_SetAttrString(pyobjref, "cache_rigidbody", Py_BuildValue("i", value));
	}

};

/**************** Space Console ****************/

/**
 * Interactive python console
 */
class SpaceConsole : public Space {
public:
	SpaceConsole(PyObject* pyobj) : Space(pyobj) {}

	SpaceConsole() : Space(0)
	{
		// not implemented
	}

	/** Getter: Font size to use for displaying the text */
	int font_size() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "font_size"));
	}

	/** Setter: Font size to use for displaying the text */
	void font_size(int value) {
		PyObject_SetAttrString(pyobjref, "font_size", Py_BuildValue("i", value));
	}

	/** Getter:  */
	int select_start() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "select_start"));
	}

	/** Setter:  */
	void select_start(int value) {
		PyObject_SetAttrString(pyobjref, "select_start", Py_BuildValue("i", value));
	}

	/** Getter:  */
	int select_end() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "select_end"));
	}

	/** Setter:  */
	void select_end(int value) {
		PyObject_SetAttrString(pyobjref, "select_end", Py_BuildValue("i", value));
	}

	/** Getter: Command line prompt */
	std::string prompt() { /* not implemented */ throw NULL; }
	/** Setter: Command line prompt */
	void prompt(const std::string& value) { /* not implemented */ }

	/** Getter: Command line prompt language */
	std::string language() { /* not implemented */ throw NULL; }
	/** Setter: Command line prompt language */
	void language(const std::string& value) { /* not implemented */ }

	/** Getter: Command history */
	std::map<std::string, ConsoleLine> history();
	/** Setter: Command history */
	void history(std::map<std::string, ConsoleLine> value);

	/** Getter: Command output */
	std::map<std::string, ConsoleLine> scrollback();
	/** Setter: Command output */
	void scrollback(std::map<std::string, ConsoleLine> value);

};

/**************** Console Input ****************/

/**
 * Input line for the interactive console
 */
class ConsoleLine : public pyUniplug {
public:
	ConsoleLine(PyObject* pyobj) : pyUniplug(pyobj) {}

	ConsoleLine() : pyUniplug(0)
	{
		// not implemented
	}

	/** Getter: Text in the line */
	std::string body() { /* not implemented */ throw NULL; }
	/** Setter: Text in the line */
	void body(const std::string& value) { /* not implemented */ }

	/** Getter:  */
	int current_character() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "current_character"));
	}

	/** Setter:  */
	void current_character(int value) {
		PyObject_SetAttrString(pyobjref, "current_character", Py_BuildValue("i", value));
	}

	enum type_enum {
		type_OUTPUT = 0,
		type_INPUT = 1,
		type_INFO = 2,
		type_ERROR = 3,
	};

	/** Getter: Console line type when used in scrollback */
	type_enum type() { /* not implemented */ throw NULL; }
	/** Setter: Console line type when used in scrollback */
	void type(type_enum value) { /* not implemented */ }

};

/**************** Space Info ****************/

/**
 * Info space data
 */
class SpaceInfo : public Space {
public:
	SpaceInfo(PyObject* pyobj) : Space(pyobj) {}

	SpaceInfo() : Space(0)
	{
		// not implemented
	}

	/** Getter: Display debug reporting info */
	bool show_report_debug() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "show_report_debug")) == 1;
	}

	/** Setter: Display debug reporting info */
	void show_report_debug(bool value) {
		PyObject_SetAttrString(pyobjref, "show_report_debug", Py_BuildValue("i", value));
	}

	/** Getter: Display general information */
	bool show_report_info() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "show_report_info")) == 1;
	}

	/** Setter: Display general information */
	void show_report_info(bool value) {
		PyObject_SetAttrString(pyobjref, "show_report_info", Py_BuildValue("i", value));
	}

	/** Getter: Display the operator log */
	bool show_report_operator() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "show_report_operator")) == 1;
	}

	/** Setter: Display the operator log */
	void show_report_operator(bool value) {
		PyObject_SetAttrString(pyobjref, "show_report_operator", Py_BuildValue("i", value));
	}

	/** Getter: Display warnings */
	bool show_report_warning() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "show_report_warning")) == 1;
	}

	/** Setter: Display warnings */
	void show_report_warning(bool value) {
		PyObject_SetAttrString(pyobjref, "show_report_warning", Py_BuildValue("i", value));
	}

	/** Getter: Display error text */
	bool show_report_error() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "show_report_error")) == 1;
	}

	/** Setter: Display error text */
	void show_report_error(bool value) {
		PyObject_SetAttrString(pyobjref, "show_report_error", Py_BuildValue("i", value));
	}

};

/**************** Space User Preferences ****************/

/**
 * User preferences space data
 */
class SpaceUserPreferences : public Space {
public:
	SpaceUserPreferences(PyObject* pyobj) : Space(pyobj) {}

	SpaceUserPreferences() : Space(0)
	{
		// not implemented
	}

	enum filter_type_enum {
		filter_type_NAME = 0,
		filter_type_KEY = 1,
	};

	/** Getter: Filter method */
	filter_type_enum filter_type() { /* not implemented */ throw NULL; }
	/** Setter: Filter method */
	void filter_type(filter_type_enum value) { /* not implemented */ }

	/** Getter: Search term for filtering in the UI */
	std::string filter_text() { /* not implemented */ throw NULL; }
	/** Setter: Search term for filtering in the UI */
	void filter_text(const std::string& value) { /* not implemented */ }

};

/**************** Node Tree Path ****************/

/**
 * Element of the node space tree path
 */
class NodeTreePath : public pyUniplug {
public:
	NodeTreePath(PyObject* pyobj) : pyUniplug(pyobj) {}

	NodeTreePath() : pyUniplug(0)
	{
		// not implemented
	}

	/** Getter: Base node tree from context */
	NodeTree node_tree() {
		/* not implemented */ throw NULL;
	}

};

/**************** Space Node Editor ****************/

/**
 * Node editor space data
 */
class SpaceNodeEditor : public Space {
public:
	SpaceNodeEditor(PyObject* pyobj) : Space(pyobj) {}

	SpaceNodeEditor() : Space(0)
	{
		// not implemented
	}

	enum tree_type_enum {
		tree_type_DUMMY = 0,
	};

	/** Getter: Node tree type to display and edit */
	tree_type_enum tree_type() { /* not implemented */ throw NULL; }
	/** Setter: Node tree type to display and edit */
	void tree_type(tree_type_enum value) { /* not implemented */ }

	enum texture_type_enum {
		texture_type_OBJECT = 0,
		texture_type_WORLD = 1,
		texture_type_BRUSH = 2,
		texture_type_LINESTYLE = 3,
	};

	/** Getter: Type of data to take texture from */
	texture_type_enum texture_type() { /* not implemented */ throw NULL; }
	/** Setter: Type of data to take texture from */
	void texture_type(texture_type_enum value) { /* not implemented */ }

	enum shader_type_enum {
		shader_type_OBJECT = 0,
		shader_type_WORLD = 1,
		shader_type_LINESTYLE = 2,
	};

	/** Getter: Type of data to take shader from */
	shader_type_enum shader_type() { /* not implemented */ throw NULL; }
	/** Setter: Type of data to take shader from */
	void shader_type(shader_type_enum value) { /* not implemented */ }

	/** Getter: Datablock whose nodes are being edited */
	ID id() {
		/* not implemented */ throw NULL;
	}

	/** Getter: Datablock from which the edited datablock is linked */
	ID id_from() {
		/* not implemented */ throw NULL;
	}

	/** Getter: Path from the data block to the currently edited node tree */
	std::map<std::string, NodeTreePath> path() {
		// TODO: MISSING DEREF! USE #DEFINE!
		PyObject *seqval = PyObject_GetAttrString(pyobjref, "path");
		PyObject *seqkeys = PyObject_CallMethod(seqval, "keys", NULL);
		std::map<std::string, NodeTreePath> resmap;
		for (int i = 0; i < PySequence_Length(seqval); i++) {
			PyObject *keyobj = PySequence_GetItem(seqkeys, i);
			std::string key = PyBytes_AsString(PyUnicode_AsASCIIString(keyobj));
			NodeTreePath value = NodeTreePath(PySequence_GetItem(seqval, i));
			resmap.insert(std::pair<std::string,NodeTreePath>(key, value));
		}
		return resmap;
	}

	/** Setter: Path from the data block to the currently edited node tree */
	void path(std::map<std::string, NodeTreePath> value) { /* not implemented */ }

	/** Getter: Base node tree from context */
	NodeTree node_tree() {
		/* not implemented */ throw NULL;
	}

	/** Getter: Node tree being displayed and edited */
	NodeTree edit_tree() {
		/* not implemented */ throw NULL;
	}

	/** Getter: Use the pinned node tree */
	bool pin() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "pin")) == 1;
	}

	/** Setter: Use the pinned node tree */
	void pin(bool value) {
		PyObject_SetAttrString(pyobjref, "pin", Py_BuildValue("i", value));
	}

	/** Getter: Use active Viewer Node output as backdrop for compositing nodes */
	bool show_backdrop() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "show_backdrop")) == 1;
	}

	/** Setter: Use active Viewer Node output as backdrop for compositing nodes */
	void show_backdrop(bool value) {
		PyObject_SetAttrString(pyobjref, "show_backdrop", Py_BuildValue("i", value));
	}

	/** Getter: Show grease pencil for this view */
	bool show_grease_pencil() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "show_grease_pencil")) == 1;
	}

	/** Setter: Show grease pencil for this view */
	void show_grease_pencil(bool value) {
		PyObject_SetAttrString(pyobjref, "show_grease_pencil", Py_BuildValue("i", value));
	}

	/** Getter: Re-render and composite changed layers on 3D edits */
	bool use_auto_render() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_auto_render")) == 1;
	}

	/** Setter: Re-render and composite changed layers on 3D edits */
	void use_auto_render(bool value) {
		PyObject_SetAttrString(pyobjref, "use_auto_render", Py_BuildValue("i", value));
	}

	/** Getter: Backdrop zoom factor */
	float backdrop_zoom() { /* not implemented */ throw NULL; }
	/** Setter: Backdrop zoom factor */
	void backdrop_zoom(float value) {
		PyObject_SetAttrString(pyobjref, "backdrop_zoom", Py_BuildValue("f", value));
	}

	/** Getter: Backdrop X offset */
	float backdrop_x() { /* not implemented */ throw NULL; }
	/** Setter: Backdrop X offset */
	void backdrop_x(float value) {
		PyObject_SetAttrString(pyobjref, "backdrop_x", Py_BuildValue("f", value));
	}

	/** Getter: Backdrop Y offset */
	float backdrop_y() { /* not implemented */ throw NULL; }
	/** Setter: Backdrop Y offset */
	void backdrop_y(float value) {
		PyObject_SetAttrString(pyobjref, "backdrop_y", Py_BuildValue("f", value));
	}

	enum backdrop_channels_enum {
		backdrop_channels_COLOR_ALPHA = 8,
		backdrop_channels_COLOR = 0,
		backdrop_channels_ALPHA = 16,
		backdrop_channels_RED = 128,
		backdrop_channels_GREEN = 256,
		backdrop_channels_BLUE = 512,
	};

	/** Getter: Channels of the image to draw */
	backdrop_channels_enum backdrop_channels() { /* not implemented */ throw NULL; }
	/** Setter: Channels of the image to draw */
	void backdrop_channels(backdrop_channels_enum value) { /* not implemented */ }

	/** Getter: Highlight nodes that are being calculated */
	bool show_highlight() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "show_highlight")) == 1;
	}

	/** Setter: Highlight nodes that are being calculated */
	void show_highlight(bool value) {
		PyObject_SetAttrString(pyobjref, "show_highlight", Py_BuildValue("i", value));
	}

	/** Getter: Location for adding new nodes */
	std::array<float, 2> cursor_location() {
		// TODO: MISSING DEREF! USE #DEFINE!
		PyObject *seqval = PyObject_GetAttrString(pyobjref, "cursor_location");
		std::array<float, 2> resarr;
		for (int i = 0; i < 2; i++)
			resarr[i] = (float)PyFloat_AsDouble(PySequence_GetItem(seqval, i));
		return resarr;
	}

	/** Setter: Location for adding new nodes */
	void cursor_location(float values[2]) { /* not implemented */ }

	/**
	 * Set the cursor location using region coordinates
	 * @param Region x coordinate
	 * @param Region y coordinate
	 */
	void cursor_location_from_region(int x, int y)
	{
		// not implemented
	}

};

/**************** Space Logic Editor ****************/

/**
 * Logic editor space data
 */
class SpaceLogicEditor : public Space {
public:
	SpaceLogicEditor(PyObject* pyobj) : Space(pyobj) {}

	SpaceLogicEditor() : Space(0)
	{
		// not implemented
	}

	/** Getter: Show sensors of all selected objects */
	bool show_sensors_selected_objects() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "show_sensors_selected_objects")) == 1;
	}

	/** Setter: Show sensors of all selected objects */
	void show_sensors_selected_objects(bool value) {
		PyObject_SetAttrString(pyobjref, "show_sensors_selected_objects", Py_BuildValue("i", value));
	}

	/** Getter: Show sensors of active object */
	bool show_sensors_active_object() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "show_sensors_active_object")) == 1;
	}

	/** Setter: Show sensors of active object */
	void show_sensors_active_object(bool value) {
		PyObject_SetAttrString(pyobjref, "show_sensors_active_object", Py_BuildValue("i", value));
	}

	/** Getter: Show linked objects to the controller */
	bool show_sensors_linked_controller() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "show_sensors_linked_controller")) == 1;
	}

	/** Setter: Show linked objects to the controller */
	void show_sensors_linked_controller(bool value) {
		PyObject_SetAttrString(pyobjref, "show_sensors_linked_controller", Py_BuildValue("i", value));
	}

	/** Getter: Show only sensors connected to active states */
	bool show_sensors_active_states() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "show_sensors_active_states")) == 1;
	}

	/** Setter: Show only sensors connected to active states */
	void show_sensors_active_states(bool value) {
		PyObject_SetAttrString(pyobjref, "show_sensors_active_states", Py_BuildValue("i", value));
	}

	/** Getter: Show controllers of all selected objects */
	bool show_controllers_selected_objects() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "show_controllers_selected_objects")) == 1;
	}

	/** Setter: Show controllers of all selected objects */
	void show_controllers_selected_objects(bool value) {
		PyObject_SetAttrString(pyobjref, "show_controllers_selected_objects", Py_BuildValue("i", value));
	}

	/** Getter: Show controllers of active object */
	bool show_controllers_active_object() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "show_controllers_active_object")) == 1;
	}

	/** Setter: Show controllers of active object */
	void show_controllers_active_object(bool value) {
		PyObject_SetAttrString(pyobjref, "show_controllers_active_object", Py_BuildValue("i", value));
	}

	/** Getter: Show linked objects to sensor/actuator */
	bool show_controllers_linked_controller() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "show_controllers_linked_controller")) == 1;
	}

	/** Setter: Show linked objects to sensor/actuator */
	void show_controllers_linked_controller(bool value) {
		PyObject_SetAttrString(pyobjref, "show_controllers_linked_controller", Py_BuildValue("i", value));
	}

	/** Getter: Show actuators of all selected objects */
	bool show_actuators_selected_objects() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "show_actuators_selected_objects")) == 1;
	}

	/** Setter: Show actuators of all selected objects */
	void show_actuators_selected_objects(bool value) {
		PyObject_SetAttrString(pyobjref, "show_actuators_selected_objects", Py_BuildValue("i", value));
	}

	/** Getter: Show actuators of active object */
	bool show_actuators_active_object() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "show_actuators_active_object")) == 1;
	}

	/** Setter: Show actuators of active object */
	void show_actuators_active_object(bool value) {
		PyObject_SetAttrString(pyobjref, "show_actuators_active_object", Py_BuildValue("i", value));
	}

	/** Getter: Show linked objects to the actuator */
	bool show_actuators_linked_controller() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "show_actuators_linked_controller")) == 1;
	}

	/** Setter: Show linked objects to the actuator */
	void show_actuators_linked_controller(bool value) {
		PyObject_SetAttrString(pyobjref, "show_actuators_linked_controller", Py_BuildValue("i", value));
	}

	/** Getter: Show only actuators connected to active states */
	bool show_actuators_active_states() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "show_actuators_active_states")) == 1;
	}

	/** Setter: Show only actuators connected to active states */
	void show_actuators_active_states(bool value) {
		PyObject_SetAttrString(pyobjref, "show_actuators_active_states", Py_BuildValue("i", value));
	}

};

/**************** Space Clip Editor ****************/

/**
 * Clip editor space data
 */
class SpaceClipEditor : public Space {
public:
	SpaceClipEditor(PyObject* pyobj) : Space(pyobj) {}

	SpaceClipEditor() : Space(0)
	{
		// not implemented
	}

	/** Getter: Movie clip displayed and edited in this space */
	MovieClip clip();

	/** Getter: Parameters defining which frame of the movie clip is displayed */
	MovieClipUser clip_user();

	/** Getter: Mask displayed and edited in this space */
	Mask mask();

	enum mask_draw_type_enum {
		mask_draw_type_OUTLINE = 0,
		mask_draw_type_DASH = 1,
		mask_draw_type_BLACK = 2,
		mask_draw_type_WHITE = 3,
	};

	/** Getter: Draw type for mask splines */
	mask_draw_type_enum mask_draw_type() { /* not implemented */ throw NULL; }
	/** Setter: Draw type for mask splines */
	void mask_draw_type(mask_draw_type_enum value) { /* not implemented */ }

	/** Getter:  */
	bool show_mask_smooth() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "show_mask_smooth")) == 1;
	}

	/** Setter:  */
	void show_mask_smooth(bool value) {
		PyObject_SetAttrString(pyobjref, "show_mask_smooth", Py_BuildValue("i", value));
	}

	/** Getter:  */
	bool show_mask_overlay() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "show_mask_overlay")) == 1;
	}

	/** Setter:  */
	void show_mask_overlay(bool value) {
		PyObject_SetAttrString(pyobjref, "show_mask_overlay", Py_BuildValue("i", value));
	}

	enum mask_overlay_mode_enum {
		mask_overlay_mode_ALPHACHANNEL = 0,
		mask_overlay_mode_COMBINED = 1,
	};

	/** Getter: Overlay mode of rasterized mask */
	mask_overlay_mode_enum mask_overlay_mode() { /* not implemented */ throw NULL; }
	/** Setter: Overlay mode of rasterized mask */
	void mask_overlay_mode(mask_overlay_mode_enum value) { /* not implemented */ }

	enum mode_enum {
		mode_TRACKING = 0,
		mode_MASK = 3,
	};

	/** Getter: Editing context being displayed */
	mode_enum mode() { /* not implemented */ throw NULL; }
	/** Setter: Editing context being displayed */
	void mode(mode_enum value) { /* not implemented */ }

	enum view_enum {
		view_CLIP = 0,
		view_GRAPH = 1,
		view_DOPESHEET = 2,
	};

	/** Getter: Type of the clip editor view */
	view_enum view() { /* not implemented */ throw NULL; }
	/** Setter: Type of the clip editor view */
	void view(view_enum value) { /* not implemented */ }

	/** Getter: Show pattern boundbox for markers */
	bool show_marker_pattern() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "show_marker_pattern")) == 1;
	}

	/** Setter: Show pattern boundbox for markers */
	void show_marker_pattern(bool value) {
		PyObject_SetAttrString(pyobjref, "show_marker_pattern", Py_BuildValue("i", value));
	}

	/** Getter: Show search boundbox for markers */
	bool show_marker_search() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "show_marker_search")) == 1;
	}

	/** Setter: Show search boundbox for markers */
	void show_marker_search(bool value) {
		PyObject_SetAttrString(pyobjref, "show_marker_search", Py_BuildValue("i", value));
	}

	/** Getter: Lock viewport to selected markers during playback */
	bool lock_selection() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "lock_selection")) == 1;
	}

	/** Setter: Lock viewport to selected markers during playback */
	void lock_selection(bool value) {
		PyObject_SetAttrString(pyobjref, "lock_selection", Py_BuildValue("i", value));
	}

	/** Getter: Lock curves view to time cursor during playback and tracking */
	bool lock_time_cursor() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "lock_time_cursor")) == 1;
	}

	/** Setter: Lock curves view to time cursor during playback and tracking */
	void lock_time_cursor(bool value) {
		PyObject_SetAttrString(pyobjref, "lock_time_cursor", Py_BuildValue("i", value));
	}

	/** Getter: Show path of how track moves */
	bool show_track_path() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "show_track_path")) == 1;
	}

	/** Setter: Show path of how track moves */
	void show_track_path(bool value) {
		PyObject_SetAttrString(pyobjref, "show_track_path", Py_BuildValue("i", value));
	}

	/** Getter: Length of displaying path, in frames */
	int path_length() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "path_length"));
	}

	/** Setter: Length of displaying path, in frames */
	void path_length(int value) {
		PyObject_SetAttrString(pyobjref, "path_length", Py_BuildValue("i", value));
	}

	/** Getter: Show markers in a more compact manner */
	bool show_tiny_markers() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "show_tiny_markers")) == 1;
	}

	/** Setter: Show markers in a more compact manner */
	void show_tiny_markers(bool value) {
		PyObject_SetAttrString(pyobjref, "show_tiny_markers", Py_BuildValue("i", value));
	}

	/** Getter: Show projection of 3D markers into footage */
	bool show_bundles() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "show_bundles")) == 1;
	}

	/** Setter: Show projection of 3D markers into footage */
	void show_bundles(bool value) {
		PyObject_SetAttrString(pyobjref, "show_bundles", Py_BuildValue("i", value));
	}

	/** Getter: Mute footage and show black background instead */
	bool use_mute_footage() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_mute_footage")) == 1;
	}

	/** Setter: Mute footage and show black background instead */
	void use_mute_footage(bool value) {
		PyObject_SetAttrString(pyobjref, "use_mute_footage", Py_BuildValue("i", value));
	}

	/** Getter: Show disabled tracks from the footage */
	bool show_disabled() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "show_disabled")) == 1;
	}

	/** Setter: Show disabled tracks from the footage */
	void show_disabled(bool value) {
		PyObject_SetAttrString(pyobjref, "show_disabled", Py_BuildValue("i", value));
	}

	/** Getter: Scopes to visualize movie clip statistics */
	MovieClipScopes scopes();

	/** Getter: Show track names and status */
	bool show_names() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "show_names")) == 1;
	}

	/** Setter: Show track names and status */
	void show_names(bool value) {
		PyObject_SetAttrString(pyobjref, "show_names", Py_BuildValue("i", value));
	}

	/** Getter: Show grid showing lens distortion */
	bool show_grid() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "show_grid")) == 1;
	}

	/** Setter: Show grid showing lens distortion */
	void show_grid(bool value) {
		PyObject_SetAttrString(pyobjref, "show_grid", Py_BuildValue("i", value));
	}

	/** Getter: Show stable footage in editor (if stabilization is enabled) */
	bool show_stable() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "show_stable")) == 1;
	}

	/** Setter: Show stable footage in editor (if stabilization is enabled) */
	void show_stable(bool value) {
		PyObject_SetAttrString(pyobjref, "show_stable", Py_BuildValue("i", value));
	}

	/** Getter: Use manual calibration helpers */
	bool use_manual_calibration() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_manual_calibration")) == 1;
	}

	/** Setter: Use manual calibration helpers */
	void use_manual_calibration(bool value) {
		PyObject_SetAttrString(pyobjref, "use_manual_calibration", Py_BuildValue("i", value));
	}

	/** Getter: Show grease pencil for this view */
	bool show_grease_pencil() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "show_grease_pencil")) == 1;
	}

	/** Setter: Show grease pencil for this view */
	void show_grease_pencil(bool value) {
		PyObject_SetAttrString(pyobjref, "show_grease_pencil", Py_BuildValue("i", value));
	}

	/** Getter: Show filters for graph editor */
	bool show_filters() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "show_filters")) == 1;
	}

	/** Setter: Show filters for graph editor */
	void show_filters(bool value) {
		PyObject_SetAttrString(pyobjref, "show_filters", Py_BuildValue("i", value));
	}

	/** Getter: Show curve for per-frame average error (camera motion should be solved first) */
	bool show_graph_frames() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "show_graph_frames")) == 1;
	}

	/** Setter: Show curve for per-frame average error (camera motion should be solved first) */
	void show_graph_frames(bool value) {
		PyObject_SetAttrString(pyobjref, "show_graph_frames", Py_BuildValue("i", value));
	}

	/** Getter: Display the speed curves (in "x" direction red, in "y" direction green) for the selected tracks */
	bool show_graph_tracks_motion() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "show_graph_tracks_motion")) == 1;
	}

	/** Setter: Display the speed curves (in "x" direction red, in "y" direction green) for the selected tracks */
	void show_graph_tracks_motion(bool value) {
		PyObject_SetAttrString(pyobjref, "show_graph_tracks_motion", Py_BuildValue("i", value));
	}

	/** Getter: Display the reprojection error curve for selected tracks */
	bool show_graph_tracks_error() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "show_graph_tracks_error")) == 1;
	}

	/** Setter: Display the reprojection error curve for selected tracks */
	void show_graph_tracks_error(bool value) {
		PyObject_SetAttrString(pyobjref, "show_graph_tracks_error", Py_BuildValue("i", value));
	}

	/** Getter: Only include channels relating to selected objects and data */
	bool show_graph_only_selected() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "show_graph_only_selected")) == 1;
	}

	/** Setter: Only include channels relating to selected objects and data */
	void show_graph_only_selected(bool value) {
		PyObject_SetAttrString(pyobjref, "show_graph_only_selected", Py_BuildValue("i", value));
	}

	/** Getter: Include channels from objects/bone that aren't visible */
	bool show_graph_hidden() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "show_graph_hidden")) == 1;
	}

	/** Setter: Include channels from objects/bone that aren't visible */
	void show_graph_hidden(bool value) {
		PyObject_SetAttrString(pyobjref, "show_graph_hidden", Py_BuildValue("i", value));
	}

	/** Getter: Show red channel in the frame */
	bool show_red_channel() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "show_red_channel")) == 1;
	}

	/** Setter: Show red channel in the frame */
	void show_red_channel(bool value) {
		PyObject_SetAttrString(pyobjref, "show_red_channel", Py_BuildValue("i", value));
	}

	/** Getter: Show green channel in the frame */
	bool show_green_channel() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "show_green_channel")) == 1;
	}

	/** Setter: Show green channel in the frame */
	void show_green_channel(bool value) {
		PyObject_SetAttrString(pyobjref, "show_green_channel", Py_BuildValue("i", value));
	}

	/** Getter: Show blue channel in the frame */
	bool show_blue_channel() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "show_blue_channel")) == 1;
	}

	/** Setter: Show blue channel in the frame */
	void show_blue_channel(bool value) {
		PyObject_SetAttrString(pyobjref, "show_blue_channel", Py_BuildValue("i", value));
	}

	/** Getter: Display frame in grayscale mode */
	bool use_grayscale_preview() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_grayscale_preview")) == 1;
	}

	/** Setter: Display frame in grayscale mode */
	void use_grayscale_preview(bool value) {
		PyObject_SetAttrString(pyobjref, "use_grayscale_preview", Py_BuildValue("i", value));
	}

	/** Getter: Show timing in seconds not frames */
	bool show_seconds() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "show_seconds")) == 1;
	}

	/** Setter: Show timing in seconds not frames */
	void show_seconds(bool value) {
		PyObject_SetAttrString(pyobjref, "show_seconds", Py_BuildValue("i", value));
	}

	enum grease_pencil_source_enum {
		grease_pencil_source_CLIP = 0,
		grease_pencil_source_TRACK = 1,
	};

	/** Getter: Where the grease pencil comes from */
	grease_pencil_source_enum grease_pencil_source() { /* not implemented */ throw NULL; }
	/** Setter: Where the grease pencil comes from */
	void grease_pencil_source(grease_pencil_source_enum value) { /* not implemented */ }

	enum pivot_point_enum {
		pivot_point_BOUNDING_BOX_CENTER = 0,
		pivot_point_CURSOR = 1,
		pivot_point_INDIVIDUAL_ORIGINS = 2,
		pivot_point_MEDIAN_POINT = 3,
	};

	/** Getter: Pivot center for rotation/scaling */
	pivot_point_enum pivot_point() { /* not implemented */ throw NULL; }
	/** Setter: Pivot center for rotation/scaling */
	void pivot_point(pivot_point_enum value) { /* not implemented */ }

};

/**************** Speaker ****************/

/**
 * Speaker datablock for 3D audio speaker objects
 */
class Speaker : public ID {
public:
	Speaker(PyObject* pyobj) : ID(pyobj) {}

	Speaker() : ID(0)
	{
		// not implemented
	}

	/** Getter: Mute the speaker */
	bool muted() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "muted")) == 1;
	}

	/** Setter: Mute the speaker */
	void muted(bool value) {
		PyObject_SetAttrString(pyobjref, "muted", Py_BuildValue("i", value));
	}

	/** Getter: Whether the source is relative to the camera or not */
	bool relative() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "relative")) == 1;
	}

	/** Setter: Whether the source is relative to the camera or not */
	void relative(bool value) {
		PyObject_SetAttrString(pyobjref, "relative", Py_BuildValue("i", value));
	}

	/** Getter: Sound datablock used by this speaker */
	Sound sound();

	/** Getter: Maximum volume, no matter how near the object is */
	float volume_max() { /* not implemented */ throw NULL; }
	/** Setter: Maximum volume, no matter how near the object is */
	void volume_max(float value) {
		PyObject_SetAttrString(pyobjref, "volume_max", Py_BuildValue("f", value));
	}

	/** Getter: Minimum volume, no matter how far away the object is */
	float volume_min() { /* not implemented */ throw NULL; }
	/** Setter: Minimum volume, no matter how far away the object is */
	void volume_min(float value) {
		PyObject_SetAttrString(pyobjref, "volume_min", Py_BuildValue("f", value));
	}

	/** Getter: Maximum distance for volume calculation, no matter how far away the object is */
	float distance_max() { /* not implemented */ throw NULL; }
	/** Setter: Maximum distance for volume calculation, no matter how far away the object is */
	void distance_max(float value) {
		PyObject_SetAttrString(pyobjref, "distance_max", Py_BuildValue("f", value));
	}

	/** Getter: Reference distance at which volume is 100 % */
	float distance_reference() { /* not implemented */ throw NULL; }
	/** Setter: Reference distance at which volume is 100 % */
	void distance_reference(float value) {
		PyObject_SetAttrString(pyobjref, "distance_reference", Py_BuildValue("f", value));
	}

	/** Getter: How strong the distance affects volume, depending on distance model */
	float attenuation() { /* not implemented */ throw NULL; }
	/** Setter: How strong the distance affects volume, depending on distance model */
	void attenuation(float value) {
		PyObject_SetAttrString(pyobjref, "attenuation", Py_BuildValue("f", value));
	}

	/** Getter: Angle of the outer cone, in degrees, outside this cone the volume is the outer cone volume, between inner and outer cone the volume is interpolated */
	float cone_angle_outer() { /* not implemented */ throw NULL; }
	/** Setter: Angle of the outer cone, in degrees, outside this cone the volume is the outer cone volume, between inner and outer cone the volume is interpolated */
	void cone_angle_outer(float value) {
		PyObject_SetAttrString(pyobjref, "cone_angle_outer", Py_BuildValue("f", value));
	}

	/** Getter: Angle of the inner cone, in degrees, inside the cone the volume is 100 % */
	float cone_angle_inner() { /* not implemented */ throw NULL; }
	/** Setter: Angle of the inner cone, in degrees, inside the cone the volume is 100 % */
	void cone_angle_inner(float value) {
		PyObject_SetAttrString(pyobjref, "cone_angle_inner", Py_BuildValue("f", value));
	}

	/** Getter: Volume outside the outer cone */
	float cone_volume_outer() { /* not implemented */ throw NULL; }
	/** Setter: Volume outside the outer cone */
	void cone_volume_outer(float value) {
		PyObject_SetAttrString(pyobjref, "cone_volume_outer", Py_BuildValue("f", value));
	}

	/** Getter: How loud the sound is */
	float volume() { /* not implemented */ throw NULL; }
	/** Setter: How loud the sound is */
	void volume(float value) {
		PyObject_SetAttrString(pyobjref, "volume", Py_BuildValue("f", value));
	}

	/** Getter: Playback pitch of the sound */
	float pitch() { /* not implemented */ throw NULL; }
	/** Setter: Playback pitch of the sound */
	void pitch(float value) {
		PyObject_SetAttrString(pyobjref, "pitch", Py_BuildValue("f", value));
	}

	/** Getter: Animation data for this datablock */
	AnimData animation_data() {
		/* not implemented */ throw NULL;
	}

};

/**************** Text Line ****************/

/**
 * Line of text in a Text datablock
 */
class TextLine : public pyUniplug {
public:
	TextLine(PyObject* pyobj) : pyUniplug(pyobj) {}

	TextLine() : pyUniplug(0)
	{
		// not implemented
	}

	/** Getter: Text in the line */
	std::string body() { /* not implemented */ throw NULL; }
	/** Setter: Text in the line */
	void body(const std::string& value) { /* not implemented */ }

};

/**************** Text ****************/

/**
 * Text datablock referencing an external or packed text file
 */
class Text : public ID {
public:
	Text(PyObject* pyobj) : ID(pyobj) {}

	Text() : ID(0)
	{
		// not implemented
	}

	/** Getter: Filename of the text file */
	std::string filepath() { /* not implemented */ throw NULL; }
	/** Setter: Filename of the text file */
	void filepath(const std::string& value) { /* not implemented */ }

	/** Getter: Text file has been edited since last save */
	bool is_dirty() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "is_dirty")) == 1;
	}

	/** Setter: Text file has been edited since last save */
	void is_dirty(bool value) {
		PyObject_SetAttrString(pyobjref, "is_dirty", Py_BuildValue("i", value));
	}

	/** Getter: Text file on disk is different than the one in memory */
	bool is_modified() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "is_modified")) == 1;
	}

	/** Setter: Text file on disk is different than the one in memory */
	void is_modified(bool value) {
		PyObject_SetAttrString(pyobjref, "is_modified", Py_BuildValue("i", value));
	}

	/** Getter: Text file is in memory, without a corresponding file on disk */
	bool is_in_memory() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "is_in_memory")) == 1;
	}

	/** Setter: Text file is in memory, without a corresponding file on disk */
	void is_in_memory(bool value) {
		PyObject_SetAttrString(pyobjref, "is_in_memory", Py_BuildValue("i", value));
	}

	/** Getter: Register this text as a module on loading, Text name must end with ".py" */
	bool use_module() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_module")) == 1;
	}

	/** Setter: Register this text as a module on loading, Text name must end with ".py" */
	void use_module(bool value) {
		PyObject_SetAttrString(pyobjref, "use_module", Py_BuildValue("i", value));
	}

	/** Getter: Automatically converts all new tabs into spaces */
	bool use_tabs_as_spaces() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_tabs_as_spaces")) == 1;
	}

	/** Setter: Automatically converts all new tabs into spaces */
	void use_tabs_as_spaces(bool value) {
		PyObject_SetAttrString(pyobjref, "use_tabs_as_spaces", Py_BuildValue("i", value));
	}

	/** Getter: Lines of text */
	std::map<std::string, TextLine> lines() {
		// TODO: MISSING DEREF! USE #DEFINE!
		PyObject *seqval = PyObject_GetAttrString(pyobjref, "lines");
		PyObject *seqkeys = PyObject_CallMethod(seqval, "keys", NULL);
		std::map<std::string, TextLine> resmap;
		for (int i = 0; i < PySequence_Length(seqval); i++) {
			PyObject *keyobj = PySequence_GetItem(seqkeys, i);
			std::string key = PyBytes_AsString(PyUnicode_AsASCIIString(keyobj));
			TextLine value = TextLine(PySequence_GetItem(seqval, i));
			resmap.insert(std::pair<std::string,TextLine>(key, value));
		}
		return resmap;
	}

	/** Setter: Lines of text */
	void lines(std::map<std::string, TextLine> value) { /* not implemented */ }

	/** Getter: Current line, and start line of selection if one exists */
	TextLine current_line() {
		/* not implemented */ throw NULL;
	}

	/** Getter: Index of current character in current line, and also start index of character in selection if one exists */
	int current_character() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "current_character"));
	}

	/** Setter: Index of current character in current line, and also start index of character in selection if one exists */
	void current_character(int value) {
		PyObject_SetAttrString(pyobjref, "current_character", Py_BuildValue("i", value));
	}

	/** Getter: Index of current TextLine in TextLine collection */
	int current_line_index() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "current_line_index"));
	}

	/** Setter: Index of current TextLine in TextLine collection */
	void current_line_index(int value) {
		PyObject_SetAttrString(pyobjref, "current_line_index", Py_BuildValue("i", value));
	}

	/** Getter: End line of selection */
	TextLine select_end_line() {
		/* not implemented */ throw NULL;
	}

	/** Getter: Index of character after end of selection in the selection end line */
	int select_end_character() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "select_end_character"));
	}

	/** Setter: Index of character after end of selection in the selection end line */
	void select_end_character(int value) {
		PyObject_SetAttrString(pyobjref, "select_end_character", Py_BuildValue("i", value));
	}

	/**
	 * clear the text block
	 */
	void clear()
	{
		// not implemented
	}

	/**
	 * write text at the cursor location and advance to the end of the text block
	 * @param New text for this datablock
	 */
	void write(const std::string text)
	{
		// not implemented
	}

};

/**************** Marker ****************/

/**
 * Marker for noting points in the timeline
 */
class TimelineMarker : public pyUniplug {
public:
	TimelineMarker(PyObject* pyobj) : pyUniplug(pyobj) {}

	TimelineMarker() : pyUniplug(0)
	{
		// not implemented
	}

	/** Getter:  */
	std::string name() { /* not implemented */ throw NULL; }
	/** Setter:  */
	void name(const std::string& value) { /* not implemented */ }

	/** Getter: The frame on which the timeline marker appears */
	int frame() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "frame"));
	}

	/** Setter: The frame on which the timeline marker appears */
	void frame(int value) {
		PyObject_SetAttrString(pyobjref, "frame", Py_BuildValue("i", value));
	}

	/** Getter: Marker selection state */
	bool select() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "select")) == 1;
	}

	/** Setter: Marker selection state */
	void select(bool value) {
		PyObject_SetAttrString(pyobjref, "select", Py_BuildValue("i", value));
	}

	/** Getter: Camera this timeline sets to active */
	Object camera() {
		/* not implemented */ throw NULL;
	}

};

/**************** Sound ****************/

/**
 * Sound datablock referencing an external or packed sound file
 */
class Sound : public ID {
public:
	Sound(PyObject* pyobj) : ID(pyobj) {}

	Sound() : ID(0)
	{
		// not implemented
	}

	/** Getter: Sound sample file used by this Sound datablock */
	std::string filepath() { /* not implemented */ throw NULL; }
	/** Setter: Sound sample file used by this Sound datablock */
	void filepath(const std::string& value) { /* not implemented */ }

	/** Getter:  */
	PackedFile packed_file() {
		/* not implemented */ throw NULL;
	}

	/** Getter: The sound file is decoded and loaded into RAM */
	bool use_memory_cache() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_memory_cache")) == 1;
	}

	/** Setter: The sound file is decoded and loaded into RAM */
	void use_memory_cache(bool value) {
		PyObject_SetAttrString(pyobjref, "use_memory_cache", Py_BuildValue("i", value));
	}

	/** Getter: If the file contains multiple audio channels they are rendered to a single one */
	bool use_mono() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_mono")) == 1;
	}

	/** Setter: If the file contains multiple audio channels they are rendered to a single one */
	void use_mono(bool value) {
		PyObject_SetAttrString(pyobjref, "use_mono", Py_BuildValue("i", value));
	}

	/**
	 * Pack the sound into the current blend file
	 */
	void pack()
	{
		// not implemented
	}

	/**
	 * Enum: unpack_method_items
	 */
	enum unpack_method_items {
		unpack_method_items_USE_LOCAL = 5,	
		unpack_method_items_WRITE_LOCAL = 4,	
		unpack_method_items_USE_ORIGINAL = 6,	
		unpack_method_items_WRITE_ORIGINAL = 3	
	};

	/**
	 * Unpack the sound to the samples filename
	 * @param How to unpack
	 */
	void unpack(unpack_method_items method = unpack_method_items_USE_LOCAL)
	{
		// not implemented
	}

};

/**************** UI Layout ****************/

/**
 * User interface layout in a panel or header
 */
class UILayout : public pyUniplug {
public:
	UILayout(PyObject* pyobj) : pyUniplug(pyobj) {}

	UILayout() : pyUniplug(0)
	{
		// not implemented
	}

	/** Getter:  */
	bool active() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "active")) == 1;
	}

	/** Setter:  */
	void active(bool value) {
		PyObject_SetAttrString(pyobjref, "active", Py_BuildValue("i", value));
	}

	enum operator_context_enum {
		operator_context_INVOKE_DEFAULT = 0,
		operator_context_INVOKE_REGION_WIN = 1,
		operator_context_INVOKE_REGION_CHANNELS = 2,
		operator_context_INVOKE_REGION_PREVIEW = 3,
		operator_context_INVOKE_AREA = 4,
		operator_context_INVOKE_SCREEN = 5,
		operator_context_EXEC_DEFAULT = 6,
		operator_context_EXEC_REGION_WIN = 7,
		operator_context_EXEC_REGION_CHANNELS = 8,
		operator_context_EXEC_REGION_PREVIEW = 9,
		operator_context_EXEC_AREA = 10,
		operator_context_EXEC_SCREEN = 11,
	};

	/** Getter:  */
	operator_context_enum operator_context() { /* not implemented */ throw NULL; }
	/** Setter:  */
	void operator_context(operator_context_enum value) { /* not implemented */ }

	/** Getter: When false, this (sub)layout is grayed out */
	bool enabled() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "enabled")) == 1;
	}

	/** Setter: When false, this (sub)layout is grayed out */
	void enabled(bool value) {
		PyObject_SetAttrString(pyobjref, "enabled", Py_BuildValue("i", value));
	}

	/** Getter:  */
	bool alert() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "alert")) == 1;
	}

	/** Setter:  */
	void alert(bool value) {
		PyObject_SetAttrString(pyobjref, "alert", Py_BuildValue("i", value));
	}

	enum alignment_enum {
		alignment_EXPAND = 0,
		alignment_LEFT = 1,
		alignment_CENTER = 2,
		alignment_RIGHT = 3,
	};

	/** Getter:  */
	alignment_enum alignment() { /* not implemented */ throw NULL; }
	/** Setter:  */
	void alignment(alignment_enum value) { /* not implemented */ }

	/** Getter: Scale factor along the X for items in this (sub)layout */
	float scale_x() { /* not implemented */ throw NULL; }
	/** Setter: Scale factor along the X for items in this (sub)layout */
	void scale_x(float value) {
		PyObject_SetAttrString(pyobjref, "scale_x", Py_BuildValue("f", value));
	}

	/** Getter: Scale factor along the Y for items in this (sub)layout */
	float scale_y() { /* not implemented */ throw NULL; }
	/** Setter: Scale factor along the Y for items in this (sub)layout */
	void scale_y(float value) {
		PyObject_SetAttrString(pyobjref, "scale_y", Py_BuildValue("f", value));
	}

	/**
	 * Sub-layout. Items placed in this sublayout are placed next to each other in a row
	 * @return Sub-layout to put items in
	 * @param Align buttons to each other
	 */
	UILayout row(bool align = false)
	{
		// not implemented
		return UILayout();
	}

	/**
	 * Sub-layout. Items placed in this sublayout are placed under each other in a column
	 * @return Sub-layout to put items in
	 * @param Align buttons to each other
	 */
	UILayout column(bool align = false)
	{
		// not implemented
		return UILayout();
	}

	/**
	 * Function: column_flow
	 * @param Number of columns, 0 is automatic
	 * @return Sub-layout to put items in
	 * @param Align buttons to each other
	 */
	UILayout column_flow(int columns = 0, bool align = false)
	{
		// not implemented
		return UILayout();
	}

	/**
	 * Sublayout (items placed in this sublayout are placed under each other in a column and are surrounded by a box)
	 * @return Sub-layout to put items in
	 */
	UILayout box()
	{
		// not implemented
		return UILayout();
	}

	/**
	 * Function: split
	 * @return Sub-layout to put items in
	 * @param Percentage of width to split at
	 * @param Align buttons to each other
	 */
	UILayout split(float percentage = 0.000000f, bool align = false)
	{
		// not implemented
		return UILayout();
	}

	/**
	 * Sublayout. Items placed in this sublayout are placed in a radial fashion around the menu center)
	 * @return Sub-layout to put items in
	 */
	UILayout menu_pie()
	{
		// not implemented
		return UILayout();
	}

	/**
	 * Return the custom icon for this data, use it e.g. to get materials or texture icons
	 * @return Icon identifier
	 * @param Data from which to take the icon
	 */
	int icon(AnyType data)
	{
		// not implemented
		throw NULL;
	}

	/**
	 * Return the UI name for this enum item
	 * @return UI name of the enum item
	 * @param Data from which to take property
	 * @param Identifier of property in data
	 * @param Identifier of the enum item
	 */
	const std::string enum_item_name(AnyType data, const std::string property, const std::string identifier)
	{
		// not implemented
		throw NULL;
	}

	/**
	 * Return the UI description for this enum item
	 * @return UI description of the enum item
	 * @param Data from which to take property
	 * @param Identifier of property in data
	 * @param Identifier of the enum item
	 */
	const std::string enum_item_description(AnyType data, const std::string property, const std::string identifier)
	{
		// not implemented
		throw NULL;
	}

	/**
	 * Return the icon for this enum item
	 * @return Icon identifier
	 * @param Data from which to take property
	 * @param Identifier of property in data
	 * @param Identifier of the enum item
	 */
	int enum_item_icon(AnyType data, const std::string property, const std::string identifier)
	{
		// not implemented
		throw NULL;
	}

	/**
	 * Enum: icon_items
	 */
	enum icon_items {
		icon_items_NONE = 0,	
		icon_items_QUESTION = 1,	
		icon_items_ERROR = 2,	
		icon_items_CANCEL = 3,	
		icon_items_TRIA_RIGHT = 4,	
		icon_items_TRIA_DOWN = 5,	
		icon_items_TRIA_LEFT = 6,	
		icon_items_TRIA_UP = 7,	
		icon_items_ARROW_LEFTRIGHT = 8,	
		icon_items_PLUS = 9,	
		icon_items_DISCLOSURE_TRI_DOWN = 10,	
		icon_items_DISCLOSURE_TRI_RIGHT = 11,	
		icon_items_RADIOBUT_OFF = 12,	
		icon_items_RADIOBUT_ON = 13,	
		icon_items_MENU_PANEL = 14,	
		icon_items_BLENDER = 15,	
		icon_items_GRIP = 16,	
		icon_items_DOT = 17,	
		icon_items_COLLAPSEMENU = 18,	
		icon_items_X = 19,	
		icon_items_GO_LEFT = 21,	
		icon_items_PLUG = 22,	
		icon_items_UI = 23,	
		icon_items_NODE = 24,	
		icon_items_NODE_SEL = 25,	
		icon_items_FULLSCREEN = 26,	
		icon_items_SPLITSCREEN = 27,	
		icon_items_RIGHTARROW_THIN = 28,	
		icon_items_BORDERMOVE = 29,	
		icon_items_VIEWZOOM = 30,	
		icon_items_ZOOMIN = 31,	
		icon_items_ZOOMOUT = 32,	
		icon_items_PANEL_CLOSE = 33,	
		icon_items_COPY_ID = 34,	
		icon_items_EYEDROPPER = 35,	
		icon_items_LINK_AREA = 36,	
		icon_items_AUTO = 37,	
		icon_items_CHECKBOX_DEHLT = 38,	
		icon_items_CHECKBOX_HLT = 39,	
		icon_items_UNLOCKED = 40,	
		icon_items_LOCKED = 41,	
		icon_items_UNPINNED = 42,	
		icon_items_PINNED = 43,	
		icon_items_SCREEN_BACK = 44,	
		icon_items_RIGHTARROW = 45,	
		icon_items_DOWNARROW_HLT = 46,	
		icon_items_DOTSUP = 47,	
		icon_items_DOTSDOWN = 48,	
		icon_items_LINK = 49,	
		icon_items_INLINK = 50,	
		icon_items_PLUGIN = 51,	
		icon_items_HELP = 52,	
		icon_items_GHOST_ENABLED = 53,	
		icon_items_COLOR = 54,	
		icon_items_LINKED = 55,	
		icon_items_UNLINKED = 56,	
		icon_items_HAND = 57,	
		icon_items_ZOOM_ALL = 58,	
		icon_items_ZOOM_SELECTED = 59,	
		icon_items_ZOOM_PREVIOUS = 60,	
		icon_items_ZOOM_IN = 61,	
		icon_items_ZOOM_OUT = 62,	
		icon_items_RENDER_REGION = 63,	
		icon_items_BORDER_RECT = 64,	
		icon_items_BORDER_LASSO = 65,	
		icon_items_FREEZE = 66,	
		icon_items_STYLUS_PRESSURE = 67,	
		icon_items_GHOST_DISABLED = 68,	
		icon_items_NEW = 69,	
		icon_items_FILE_TICK = 70,	
		icon_items_QUIT = 71,	
		icon_items_URL = 72,	
		icon_items_RECOVER_LAST = 73,	
		icon_items_FULLSCREEN_ENTER = 75,	
		icon_items_FULLSCREEN_EXIT = 76,	
		icon_items_BLANK1 = 77,	
		icon_items_LAMP = 78,	
		icon_items_MATERIAL = 79,	
		icon_items_TEXTURE = 80,	
		icon_items_ANIM = 81,	
		icon_items_WORLD = 82,	
		icon_items_SCENE = 83,	
		icon_items_EDIT = 84,	
		icon_items_GAME = 85,	
		icon_items_RADIO = 86,	
		icon_items_SCRIPT = 87,	
		icon_items_PARTICLES = 88,	
		icon_items_PHYSICS = 89,	
		icon_items_SPEAKER = 90,	
		icon_items_TEXTURE_SHADED = 91,	
		icon_items_VIEW3D = 104,	
		icon_items_IPO = 105,	
		icon_items_OOPS = 106,	
		icon_items_BUTS = 107,	
		icon_items_FILESEL = 108,	
		icon_items_IMAGE_COL = 109,	
		icon_items_INFO = 110,	
		icon_items_SEQUENCE = 111,	
		icon_items_TEXT = 112,	
		icon_items_IMASEL = 113,	
		icon_items_SOUND = 114,	
		icon_items_ACTION = 115,	
		icon_items_NLA = 116,	
		icon_items_SCRIPTWIN = 117,	
		icon_items_TIME = 118,	
		icon_items_NODETREE = 119,	
		icon_items_LOGIC = 120,	
		icon_items_CONSOLE = 121,	
		icon_items_PREFERENCES = 122,	
		icon_items_CLIP = 123,	
		icon_items_ASSET_MANAGER = 124,	
		icon_items_OBJECT_DATAMODE = 130,	
		icon_items_EDITMODE_HLT = 131,	
		icon_items_FACESEL_HLT = 132,	
		icon_items_VPAINT_HLT = 133,	
		icon_items_TPAINT_HLT = 134,	
		icon_items_WPAINT_HLT = 135,	
		icon_items_SCULPTMODE_HLT = 136,	
		icon_items_POSE_HLT = 137,	
		icon_items_PARTICLEMODE = 138,	
		icon_items_LIGHTPAINT = 139,	
		icon_items_SCENE_DATA = 156,	
		icon_items_RENDERLAYERS = 157,	
		icon_items_WORLD_DATA = 158,	
		icon_items_OBJECT_DATA = 159,	
		icon_items_MESH_DATA = 160,	
		icon_items_CURVE_DATA = 161,	
		icon_items_META_DATA = 162,	
		icon_items_LATTICE_DATA = 163,	
		icon_items_LAMP_DATA = 164,	
		icon_items_MATERIAL_DATA = 165,	
		icon_items_TEXTURE_DATA = 166,	
		icon_items_ANIM_DATA = 167,	
		icon_items_CAMERA_DATA = 168,	
		icon_items_PARTICLE_DATA = 169,	
		icon_items_LIBRARY_DATA_DIRECT = 170,	
		icon_items_GROUP = 171,	
		icon_items_ARMATURE_DATA = 172,	
		icon_items_POSE_DATA = 173,	
		icon_items_BONE_DATA = 174,	
		icon_items_CONSTRAINT = 175,	
		icon_items_SHAPEKEY_DATA = 176,	
		icon_items_CONSTRAINT_BONE = 177,	
		icon_items_CAMERA_STEREO = 178,	
		icon_items_PACKAGE = 179,	
		icon_items_UGLYPACKAGE = 180,	
		icon_items_BRUSH_DATA = 182,	
		icon_items_IMAGE_DATA = 183,	
		icon_items_FILE = 184,	
		icon_items_FCURVE = 185,	
		icon_items_FONT_DATA = 186,	
		icon_items_RENDER_RESULT = 187,	
		icon_items_SURFACE_DATA = 188,	
		icon_items_EMPTY_DATA = 189,	
		icon_items_SETTINGS = 190,	
		icon_items_RENDER_ANIMATION = 191,	
		icon_items_RENDER_STILL = 192,	
		icon_items_BOIDS = 194,	
		icon_items_STRANDS = 195,	
		icon_items_LIBRARY_DATA_INDIRECT = 196,	
		icon_items_GREASEPENCIL = 197,	
		icon_items_LINE_DATA = 198,	
		icon_items_GROUP_BONE = 200,	
		icon_items_GROUP_VERTEX = 201,	
		icon_items_GROUP_VCOL = 202,	
		icon_items_GROUP_UVS = 203,	
		icon_items_RNA = 206,	
		icon_items_RNA_ADD = 207,	
		icon_items_OUTLINER_OB_EMPTY = 234,	
		icon_items_OUTLINER_OB_MESH = 235,	
		icon_items_OUTLINER_OB_CURVE = 236,	
		icon_items_OUTLINER_OB_LATTICE = 237,	
		icon_items_OUTLINER_OB_META = 238,	
		icon_items_OUTLINER_OB_LAMP = 239,	
		icon_items_OUTLINER_OB_CAMERA = 240,	
		icon_items_OUTLINER_OB_ARMATURE = 241,	
		icon_items_OUTLINER_OB_FONT = 242,	
		icon_items_OUTLINER_OB_SURFACE = 243,	
		icon_items_OUTLINER_OB_SPEAKER = 244,	
		icon_items_RESTRICT_VIEW_OFF = 253,	
		icon_items_RESTRICT_VIEW_ON = 254,	
		icon_items_RESTRICT_SELECT_OFF = 255,	
		icon_items_RESTRICT_SELECT_ON = 256,	
		icon_items_RESTRICT_RENDER_OFF = 257,	
		icon_items_RESTRICT_RENDER_ON = 258,	
		icon_items_OUTLINER_DATA_EMPTY = 260,	
		icon_items_OUTLINER_DATA_MESH = 261,	
		icon_items_OUTLINER_DATA_CURVE = 262,	
		icon_items_OUTLINER_DATA_LATTICE = 263,	
		icon_items_OUTLINER_DATA_META = 264,	
		icon_items_OUTLINER_DATA_LAMP = 265,	
		icon_items_OUTLINER_DATA_CAMERA = 266,	
		icon_items_OUTLINER_DATA_ARMATURE = 267,	
		icon_items_OUTLINER_DATA_FONT = 268,	
		icon_items_OUTLINER_DATA_SURFACE = 269,	
		icon_items_OUTLINER_DATA_SPEAKER = 270,	
		icon_items_OUTLINER_DATA_POSE = 271,	
		icon_items_MESH_PLANE = 286,	
		icon_items_MESH_CUBE = 287,	
		icon_items_MESH_CIRCLE = 288,	
		icon_items_MESH_UVSPHERE = 289,	
		icon_items_MESH_ICOSPHERE = 290,	
		icon_items_MESH_GRID = 291,	
		icon_items_MESH_MONKEY = 292,	
		icon_items_MESH_CYLINDER = 293,	
		icon_items_MESH_TORUS = 294,	
		icon_items_MESH_CONE = 295,	
		icon_items_LAMP_POINT = 298,	
		icon_items_LAMP_SUN = 299,	
		icon_items_LAMP_SPOT = 300,	
		icon_items_LAMP_HEMI = 301,	
		icon_items_LAMP_AREA = 302,	
		icon_items_META_EMPTY = 305,	
		icon_items_META_PLANE = 306,	
		icon_items_META_CUBE = 307,	
		icon_items_META_BALL = 308,	
		icon_items_META_ELLIPSOID = 309,	
		icon_items_META_CAPSULE = 310,	
		icon_items_SURFACE_NCURVE = 312,	
		icon_items_SURFACE_NCIRCLE = 313,	
		icon_items_SURFACE_NSURFACE = 314,	
		icon_items_SURFACE_NCYLINDER = 315,	
		icon_items_SURFACE_NSPHERE = 316,	
		icon_items_SURFACE_NTORUS = 317,	
		icon_items_CURVE_BEZCURVE = 321,	
		icon_items_CURVE_BEZCIRCLE = 322,	
		icon_items_CURVE_NCURVE = 323,	
		icon_items_CURVE_NCIRCLE = 324,	
		icon_items_CURVE_PATH = 325,	
		icon_items_COLOR_RED = 331,	
		icon_items_COLOR_GREEN = 332,	
		icon_items_COLOR_BLUE = 333,	
		icon_items_TRIA_RIGHT_BAR = 334,	
		icon_items_TRIA_DOWN_BAR = 335,	
		icon_items_TRIA_LEFT_BAR = 336,	
		icon_items_TRIA_UP_BAR = 337,	
		icon_items_FORCE_FORCE = 338,	
		icon_items_FORCE_WIND = 339,	
		icon_items_FORCE_VORTEX = 340,	
		icon_items_FORCE_MAGNETIC = 341,	
		icon_items_FORCE_HARMONIC = 342,	
		icon_items_FORCE_CHARGE = 343,	
		icon_items_FORCE_LENNARDJONES = 344,	
		icon_items_FORCE_TEXTURE = 345,	
		icon_items_FORCE_CURVE = 346,	
		icon_items_FORCE_BOID = 347,	
		icon_items_FORCE_TURBULENCE = 348,	
		icon_items_FORCE_DRAG = 349,	
		icon_items_FORCE_SMOKEFLOW = 350,	
		icon_items_MODIFIER = 442,	
		icon_items_MOD_WAVE = 443,	
		icon_items_MOD_BUILD = 444,	
		icon_items_MOD_DECIM = 445,	
		icon_items_MOD_MIRROR = 446,	
		icon_items_MOD_SOFT = 447,	
		icon_items_MOD_SUBSURF = 448,	
		icon_items_HOOK = 449,	
		icon_items_MOD_PHYSICS = 450,	
		icon_items_MOD_PARTICLES = 451,	
		icon_items_MOD_BOOLEAN = 452,	
		icon_items_MOD_EDGESPLIT = 453,	
		icon_items_MOD_ARRAY = 454,	
		icon_items_MOD_UVPROJECT = 455,	
		icon_items_MOD_DISPLACE = 456,	
		icon_items_MOD_CURVE = 457,	
		icon_items_MOD_LATTICE = 458,	
		icon_items_CONSTRAINT_DATA = 459,	
		icon_items_MOD_ARMATURE = 460,	
		icon_items_MOD_SHRINKWRAP = 461,	
		icon_items_MOD_CAST = 462,	
		icon_items_MOD_MESHDEFORM = 463,	
		icon_items_MOD_BEVEL = 464,	
		icon_items_MOD_SMOOTH = 465,	
		icon_items_MOD_SIMPLEDEFORM = 466,	
		icon_items_MOD_MASK = 467,	
		icon_items_MOD_CLOTH = 468,	
		icon_items_MOD_EXPLODE = 469,	
		icon_items_MOD_FLUIDSIM = 470,	
		icon_items_MOD_MULTIRES = 471,	
		icon_items_MOD_SMOKE = 472,	
		icon_items_MOD_SOLIDIFY = 473,	
		icon_items_MOD_SCREW = 474,	
		icon_items_MOD_VERTEX_WEIGHT = 475,	
		icon_items_MOD_DYNAMICPAINT = 476,	
		icon_items_MOD_REMESH = 477,	
		icon_items_MOD_OCEAN = 478,	
		icon_items_MOD_WARP = 479,	
		icon_items_MOD_SKIN = 480,	
		icon_items_MOD_TRIANGULATE = 481,	
		icon_items_MOD_WIREFRAME = 482,	
		icon_items_MOD_DATA_TRANSFER = 483,	
		icon_items_MOD_NORMALEDIT = 484,	
		icon_items_REC = 494,	
		icon_items_PLAY = 495,	
		icon_items_FF = 496,	
		icon_items_REW = 497,	
		icon_items_PAUSE = 498,	
		icon_items_PREV_KEYFRAME = 499,	
		icon_items_NEXT_KEYFRAME = 500,	
		icon_items_PLAY_AUDIO = 501,	
		icon_items_PLAY_REVERSE = 502,	
		icon_items_PREVIEW_RANGE = 503,	
		icon_items_ACTION_TWEAK = 504,	
		icon_items_PMARKER_ACT = 505,	
		icon_items_PMARKER_SEL = 506,	
		icon_items_PMARKER = 507,	
		icon_items_MARKER_HLT = 508,	
		icon_items_MARKER = 509,	
		icon_items_SPACE2 = 510,	
		icon_items_SPACE3 = 511,	
		icon_items_KEYINGSET = 512,	
		icon_items_KEY_DEHLT = 513,	
		icon_items_KEY_HLT = 514,	
		icon_items_MUTE_IPO_OFF = 515,	
		icon_items_MUTE_IPO_ON = 516,	
		icon_items_VISIBLE_IPO_OFF = 517,	
		icon_items_VISIBLE_IPO_ON = 518,	
		icon_items_DRIVER = 519,	
		icon_items_SOLO_OFF = 520,	
		icon_items_SOLO_ON = 521,	
		icon_items_FRAME_PREV = 522,	
		icon_items_FRAME_NEXT = 523,	
		icon_items_NLA_PUSHDOWN = 524,	
		icon_items_IPO_CONSTANT = 525,	
		icon_items_IPO_LINEAR = 526,	
		icon_items_IPO_BEZIER = 527,	
		icon_items_IPO_SINE = 528,	
		icon_items_IPO_QUAD = 529,	
		icon_items_IPO_CUBIC = 530,	
		icon_items_IPO_QUART = 531,	
		icon_items_IPO_QUINT = 532,	
		icon_items_IPO_EXPO = 533,	
		icon_items_IPO_CIRC = 534,	
		icon_items_IPO_BOUNCE = 535,	
		icon_items_IPO_ELASTIC = 536,	
		icon_items_IPO_BACK = 537,	
		icon_items_IPO_EASE_IN = 538,	
		icon_items_IPO_EASE_OUT = 539,	
		icon_items_IPO_EASE_IN_OUT = 540,	
		icon_items_VERTEXSEL = 546,	
		icon_items_EDGESEL = 547,	
		icon_items_FACESEL = 548,	
		icon_items_LOOPSEL = 549,	
		icon_items_ROTATE = 551,	
		icon_items_CURSOR = 552,	
		icon_items_ROTATECOLLECTION = 553,	
		icon_items_ROTATECENTER = 554,	
		icon_items_ROTACTIVE = 555,	
		icon_items_ALIGN = 556,	
		icon_items_SMOOTHCURVE = 558,	
		icon_items_SPHERECURVE = 559,	
		icon_items_ROOTCURVE = 560,	
		icon_items_SHARPCURVE = 561,	
		icon_items_LINCURVE = 562,	
		icon_items_NOCURVE = 563,	
		icon_items_RNDCURVE = 564,	
		icon_items_PROP_OFF = 565,	
		icon_items_PROP_ON = 566,	
		icon_items_PROP_CON = 567,	
		icon_items_SCULPT_DYNTOPO = 568,	
		icon_items_PARTICLE_POINT = 569,	
		icon_items_PARTICLE_TIP = 570,	
		icon_items_PARTICLE_PATH = 571,	
		icon_items_MAN_TRANS = 572,	
		icon_items_MAN_ROT = 573,	
		icon_items_MAN_SCALE = 574,	
		icon_items_MANIPUL = 575,	
		icon_items_SNAP_OFF = 576,	
		icon_items_SNAP_ON = 577,	
		icon_items_SNAP_NORMAL = 578,	
		icon_items_SNAP_INCREMENT = 579,	
		icon_items_SNAP_VERTEX = 580,	
		icon_items_SNAP_EDGE = 581,	
		icon_items_SNAP_FACE = 582,	
		icon_items_SNAP_VOLUME = 583,	
		icon_items_STICKY_UVS_LOC = 585,	
		icon_items_STICKY_UVS_DISABLE = 586,	
		icon_items_STICKY_UVS_VERT = 587,	
		icon_items_CLIPUV_DEHLT = 588,	
		icon_items_CLIPUV_HLT = 589,	
		icon_items_SNAP_PEEL_OBJECT = 590,	
		icon_items_GRID = 591,	
		icon_items_PASTEDOWN = 598,	
		icon_items_COPYDOWN = 599,	
		icon_items_PASTEFLIPUP = 600,	
		icon_items_PASTEFLIPDOWN = 601,	
		icon_items_SNAP_SURFACE = 606,	
		icon_items_AUTOMERGE_ON = 607,	
		icon_items_AUTOMERGE_OFF = 608,	
		icon_items_RETOPO = 609,	
		icon_items_UV_VERTEXSEL = 610,	
		icon_items_UV_EDGESEL = 611,	
		icon_items_UV_FACESEL = 612,	
		icon_items_UV_ISLANDSEL = 613,	
		icon_items_UV_SYNC_SELECT = 614,	
		icon_items_BBOX = 624,	
		icon_items_WIRE = 625,	
		icon_items_SOLID = 626,	
		icon_items_SMOOTH = 627,	
		icon_items_POTATO = 628,	
		icon_items_ORTHO = 630,	
		icon_items_LOCKVIEW_OFF = 633,	
		icon_items_LOCKVIEW_ON = 634,	
		icon_items_AXIS_SIDE = 636,	
		icon_items_AXIS_FRONT = 637,	
		icon_items_AXIS_TOP = 638,	
		icon_items_NDOF_DOM = 639,	
		icon_items_NDOF_TURN = 640,	
		icon_items_NDOF_FLY = 641,	
		icon_items_NDOF_TRANS = 642,	
		icon_items_LAYER_USED = 643,	
		icon_items_LAYER_ACTIVE = 644,	
		icon_items_SORTALPHA = 676,	
		icon_items_SORTBYEXT = 677,	
		icon_items_SORTTIME = 678,	
		icon_items_SORTSIZE = 679,	
		icon_items_LONGDISPLAY = 680,	
		icon_items_SHORTDISPLAY = 681,	
		icon_items_GHOST = 682,	
		icon_items_IMGDISPLAY = 683,	
		icon_items_SAVE_AS = 684,	
		icon_items_SAVE_COPY = 685,	
		icon_items_BOOKMARKS = 686,	
		icon_items_FONTPREVIEW = 687,	
		icon_items_FILTER = 688,	
		icon_items_NEWFOLDER = 689,	
		icon_items_OPEN_RECENT = 690,	
		icon_items_FILE_PARENT = 691,	
		icon_items_FILE_REFRESH = 692,	
		icon_items_FILE_FOLDER = 693,	
		icon_items_FILE_BLANK = 694,	
		icon_items_FILE_BLEND = 695,	
		icon_items_FILE_IMAGE = 696,	
		icon_items_FILE_MOVIE = 697,	
		icon_items_FILE_SCRIPT = 698,	
		icon_items_FILE_SOUND = 699,	
		icon_items_FILE_FONT = 700,	
		icon_items_FILE_TEXT = 701,	
		icon_items_RECOVER_AUTO = 702,	
		icon_items_SAVE_PREFS = 703,	
		icon_items_LINK_BLEND = 704,	
		icon_items_APPEND_BLEND = 705,	
		icon_items_IMPORT = 706,	
		icon_items_EXPORT = 707,	
		icon_items_EXTERNAL_DATA = 708,	
		icon_items_LOAD_FACTORY = 709,	
		icon_items_LOOP_BACK = 715,	
		icon_items_LOOP_FORWARDS = 716,	
		icon_items_BACK = 717,	
		icon_items_FORWARD = 718,	
		icon_items_FILE_HIDDEN = 725,	
		icon_items_FILE_BACKUP = 726,	
		icon_items_DISK_DRIVE = 727,	
		icon_items_MATPLANE = 728,	
		icon_items_MATSPHERE = 729,	
		icon_items_MATCUBE = 730,	
		icon_items_MONKEY = 731,	
		icon_items_HAIR = 732,	
		icon_items_ALIASED = 733,	
		icon_items_ANTIALIASED = 734,	
		icon_items_MAT_SPHERE_SKY = 735,	
		icon_items_WORDWRAP_OFF = 740,	
		icon_items_WORDWRAP_ON = 741,	
		icon_items_SYNTAX_OFF = 742,	
		icon_items_SYNTAX_ON = 743,	
		icon_items_LINENUMBERS_OFF = 744,	
		icon_items_LINENUMBERS_ON = 745,	
		icon_items_SCRIPTPLUGINS = 746,	
		icon_items_SEQ_SEQUENCER = 754,	
		icon_items_SEQ_PREVIEW = 755,	
		icon_items_SEQ_LUMA_WAVEFORM = 756,	
		icon_items_SEQ_CHROMA_SCOPE = 757,	
		icon_items_SEQ_HISTOGRAM = 758,	
		icon_items_SEQ_SPLITVIEW = 759,	
		icon_items_IMAGE_RGB = 763,	
		icon_items_IMAGE_RGB_ALPHA = 764,	
		icon_items_IMAGE_ALPHA = 765,	
		icon_items_IMAGE_ZDEPTH = 766,	
		icon_items_IMAGEFILE = 767,	
		icon_items_BRUSH_ADD = 780,	
		icon_items_BRUSH_BLOB = 781,	
		icon_items_BRUSH_BLUR = 782,	
		icon_items_BRUSH_CLAY = 783,	
		icon_items_BRUSH_CLAY_STRIPS = 784,	
		icon_items_BRUSH_CLONE = 785,	
		icon_items_BRUSH_CREASE = 786,	
		icon_items_BRUSH_DARKEN = 787,	
		icon_items_BRUSH_FILL = 788,	
		icon_items_BRUSH_FLATTEN = 789,	
		icon_items_BRUSH_GRAB = 790,	
		icon_items_BRUSH_INFLATE = 791,	
		icon_items_BRUSH_LAYER = 792,	
		icon_items_BRUSH_LIGHTEN = 793,	
		icon_items_BRUSH_MASK = 794,	
		icon_items_BRUSH_MIX = 795,	
		icon_items_BRUSH_MULTIPLY = 796,	
		icon_items_BRUSH_NUDGE = 797,	
		icon_items_BRUSH_PINCH = 798,	
		icon_items_BRUSH_SCRAPE = 799,	
		icon_items_BRUSH_SCULPT_DRAW = 800,	
		icon_items_BRUSH_SMEAR = 801,	
		icon_items_BRUSH_SMOOTH = 802,	
		icon_items_BRUSH_SNAKE_HOOK = 803,	
		icon_items_BRUSH_SOFTEN = 804,	
		icon_items_BRUSH_SUBTRACT = 805,	
		icon_items_BRUSH_TEXDRAW = 806,	
		icon_items_BRUSH_TEXFILL = 807,	
		icon_items_BRUSH_TEXMASK = 808,	
		icon_items_BRUSH_THUMB = 809,	
		icon_items_BRUSH_ROTATE = 810,	
		icon_items_BRUSH_VERTEXDRAW = 811,	
		icon_items_MATCAP_01 = 812,	
		icon_items_MATCAP_02 = 813,	
		icon_items_MATCAP_03 = 814,	
		icon_items_MATCAP_04 = 815,	
		icon_items_MATCAP_05 = 816,	
		icon_items_MATCAP_06 = 817,	
		icon_items_MATCAP_07 = 818,	
		icon_items_MATCAP_08 = 819,	
		icon_items_MATCAP_09 = 820,	
		icon_items_MATCAP_10 = 821,	
		icon_items_MATCAP_11 = 822,	
		icon_items_MATCAP_12 = 823,	
		icon_items_MATCAP_13 = 824,	
		icon_items_MATCAP_14 = 825,	
		icon_items_MATCAP_15 = 826,	
		icon_items_MATCAP_16 = 827,	
		icon_items_MATCAP_17 = 828,	
		icon_items_MATCAP_18 = 829,	
		icon_items_MATCAP_19 = 830,	
		icon_items_MATCAP_20 = 831,	
		icon_items_MATCAP_21 = 832,	
		icon_items_MATCAP_22 = 833,	
		icon_items_MATCAP_23 = 834,	
		icon_items_MATCAP_24 = 835,	
		icon_items_VIEW3D_VEC = 836,	
		icon_items_EDIT_VEC = 837,	
		icon_items_EDITMODE_VEC_DEHLT = 838,	
		icon_items_EDITMODE_VEC_HLT = 839,	
		icon_items_DISCLOSURE_TRI_RIGHT_VEC = 840,	
		icon_items_DISCLOSURE_TRI_DOWN_VEC = 841,	
		icon_items_MOVE_UP_VEC = 842,	
		icon_items_MOVE_DOWN_VEC = 843,	
		icon_items_X_VEC = 844,	
		icon_items_SMALL_TRI_RIGHT_VEC = 845	
	};

	/**
	 * Item. Exposes an RNA item and places it into the layout
	 * @param Data from which to take property
	 * @param Identifier of property in data
	 * @param Override automatic text of the item
	 * @param Override automatic translation context of the given text
	 * @param Translate the given text, when UI translation is enabled
	 * @param Override automatic icon of the item
	 * @param Expand button to show more detail
	 * @param Use slider widget for numeric values
	 * @param Use toggle widget for boolean values
	 * @param Draw only icons in buttons, no text
	 * @param Use button to input key events
	 * @param Use button to input full events including modifiers
	 * @param Draw the button itself, just the icon/text
	 * @param The index of this button, when set a single member of an array can be accessed, when set to -1 all array members are used
	 * @param Override automatic icon of the item (use it e.g. with custom material icons returned by icon()...)
	 */
	void prop(AnyType data, const std::string property, const std::string text = NULL, const std::string text_ctxt = NULL, bool translate = true, icon_items icon = icon_items_NONE, bool expand = false, bool slider = false, bool toggle = false, bool icon_only = false, bool event = false, bool full_event = false, bool emboss = true, int index = -1, int icon_value = 0)
	{
		// not implemented
	}

	/**
	 * Function: props_enum
	 * @param Data from which to take property
	 * @param Identifier of property in data
	 */
	void props_enum(AnyType data, const std::string property)
	{
		// not implemented
	}

	/**
	 * Function: prop_menu_enum
	 * @param Data from which to take property
	 * @param Identifier of property in data
	 * @param Override automatic text of the item
	 * @param Override automatic translation context of the given text
	 * @param Translate the given text, when UI translation is enabled
	 * @param Override automatic icon of the item
	 */
	void prop_menu_enum(AnyType data, const std::string property, const std::string text = NULL, const std::string text_ctxt = NULL, bool translate = true, icon_items icon = icon_items_NONE)
	{
		// not implemented
	}

	/**
	 * Function: prop_enum
	 * @param Data from which to take property
	 * @param Identifier of property in data
	 * @param Enum property value
	 * @param Override automatic text of the item
	 * @param Override automatic translation context of the given text
	 * @param Translate the given text, when UI translation is enabled
	 * @param Override automatic icon of the item
	 */
	void prop_enum(AnyType data, const std::string property, const std::string value, const std::string text = NULL, const std::string text_ctxt = NULL, bool translate = true, icon_items icon = icon_items_NONE)
	{
		// not implemented
	}

	/**
	 * Function: prop_search
	 * @param Data from which to take property
	 * @param Identifier of property in data
	 * @param Data from which to take collection to search in
	 * @param Identifier of search collection property
	 * @param Override automatic text of the item
	 * @param Override automatic translation context of the given text
	 * @param Translate the given text, when UI translation is enabled
	 * @param Override automatic icon of the item
	 */
	void prop_search(AnyType data, const std::string property, AnyType search_data, const std::string search_property, const std::string text = NULL, const std::string text_ctxt = NULL, bool translate = true, icon_items icon = icon_items_NONE)
	{
		// not implemented
	}

	/**
	 * Item. Places a button into the layout to call an Operator
	 * @param Identifier of the operator
	 * @param Override automatic text of the item
	 * @param Override automatic translation context of the given text
	 * @param Translate the given text, when UI translation is enabled
	 * @param Override automatic icon of the item
	 * @param Draw the button itself, just the icon/text
	 * @param Override automatic icon of the item (use it e.g. with custom material icons returned by icon()...)
	 * @return Operator properties to fill in, return when 'properties' is set to true
	 */
	OperatorProperties operator_value(const std::string operator_value, const std::string text = NULL, const std::string text_ctxt = NULL, bool translate = true, icon_items icon = icon_items_NONE, bool emboss = true, int icon_value = 0);

	/**
	 * Function: operator_enum
	 * @param Identifier of the operator
	 * @param Identifier of property in operator
	 */
	void operator_enum(const std::string operator_value, const std::string property)
	{
		// not implemented
	}

	/**
	 * Function: operator_menu_enum
	 * @param Identifier of the operator
	 * @param Identifier of property in operator
	 * @param Override automatic text of the item
	 * @param Override automatic translation context of the given text
	 * @param Translate the given text, when UI translation is enabled
	 * @param Override automatic icon of the item
	 */
	void operator_menu_enum(const std::string operator_value, const std::string property, const std::string text = NULL, const std::string text_ctxt = NULL, bool translate = true, icon_items icon = icon_items_NONE)
	{
		// not implemented
	}

	/**
	 * Item. Display text and/or icon in the layout
	 * @param Override automatic text of the item
	 * @param Override automatic translation context of the given text
	 * @param Translate the given text, when UI translation is enabled
	 * @param Override automatic icon of the item
	 * @param Override automatic icon of the item (use it e.g. with custom material icons returned by icon()...)
	 */
	void label(const std::string text = NULL, const std::string text_ctxt = NULL, bool translate = true, icon_items icon = icon_items_NONE, int icon_value = 0)
	{
		// not implemented
	}

	/**
	 * Function: menu
	 * @param Identifier of the menu
	 * @param Override automatic text of the item
	 * @param Override automatic translation context of the given text
	 * @param Translate the given text, when UI translation is enabled
	 * @param Override automatic icon of the item
	 */
	void menu(const std::string menu, const std::string text = NULL, const std::string text_ctxt = NULL, bool translate = true, icon_items icon = icon_items_NONE)
	{
		// not implemented
	}

	/**
	 * Item. Inserts empty space into the layout between items
	 */
	void separator()
	{
		// not implemented
	}

	/**
	 * Function: context_pointer_set
	 * @param Name of entry in the context
	 * @param Pointer to put in context
	 */
	void context_pointer_set(const std::string name, AnyType data)
	{
		// not implemented
	}

	/**
	 * Function: template_header
	 */
	void template_header()
	{
		// not implemented
	}

	/**
	 * Function: template_ID
	 * @param Data from which to take property
	 * @param Identifier of property in data
	 * @param Operator identifier to create a new ID block
	 * @param Operator identifier to open a file for creating a new ID block
	 * @param Operator identifier to unlink the ID block
	 */
	void template_ID(AnyType data, const std::string property, const std::string create = NULL, const std::string open = NULL, const std::string unlink = NULL)
	{
		// not implemented
	}

	/**
	 * Function: template_ID_preview
	 * @param Data from which to take property
	 * @param Identifier of property in data
	 * @param Operator identifier to create a new ID block
	 * @param Operator identifier to open a file for creating a new ID block
	 * @param Operator identifier to unlink the ID block
	 * @param Param 'rows'
	 * @param Param 'cols'
	 */
	void template_ID_preview(AnyType data, const std::string property, const std::string create = NULL, const std::string open = NULL, const std::string unlink = NULL, int rows = 0, int cols = 0)
	{
		// not implemented
	}

	/**
	 * Function: template_any_ID
	 * @param Data from which to take property
	 * @param Identifier of property in data
	 * @param Identifier of property in data giving the type of the ID-blocks to use
	 * @param Override automatic text of the item
	 * @param Override automatic translation context of the given text
	 * @param Translate the given text, when UI translation is enabled
	 */
	void template_any_ID(AnyType data, const std::string property, const std::string type_property, const std::string text = NULL, const std::string text_ctxt = NULL, bool translate = true)
	{
		// not implemented
	}

	/**
	 * Function: template_path_builder
	 * @param Data from which to take property
	 * @param Identifier of property in data
	 * @param ID-block from which path is evaluated from
	 * @param Override automatic text of the item
	 * @param Override automatic translation context of the given text
	 * @param Translate the given text, when UI translation is enabled
	 */
	void template_path_builder(AnyType data, const std::string property, ID root, const std::string text = NULL, const std::string text_ctxt = NULL, bool translate = true)
	{
		// not implemented
	}

	/**
	 * Generates the UI layout for modifiers
	 * @param Modifier data
	 * @return Sub-layout to put items in
	 */
	UILayout template_modifier(Modifier data)
	{
		// not implemented
		return UILayout();
	}

	/**
	 * Generates the UI layout for constraints
	 * @param Constraint data
	 * @return Sub-layout to put items in
	 */
	UILayout template_constraint(Constraint data)
	{
		// not implemented
		return UILayout();
	}

	/**
	 * Item. A preview window for materials, textures, lamps or worlds
	 * @param ID datablock
	 * @param Show preview buttons?
	 * @param ID datablock
	 * @param Texture slot
	 * @param Identifier of this preview widget, if not set the ID type will be used (i.e. all previews of materials without explicit ID will have the same size...)
	 */
	void template_preview(ID id, bool show_buttons, ID parent, TextureSlot slot, const std::string preview_id = NULL)
	{
		// not implemented
	}

	/**
	 * Enum: curve_type_items
	 */
	enum curve_type_items {
		curve_type_items_NONE = 0,	
		curve_type_items_VECTOR = 118,	
		curve_type_items_COLOR = 99,	
		curve_type_items_HUE = 104	
	};

	/**
	 * Item. A curve mapping widget used for e.g falloff curves for lamps
	 * @param Data from which to take property
	 * @param Identifier of property in data
	 * @param Type of curves to display
	 * @param Show black/white levels
	 * @param Show brush options
	 * @param Use a negative slope by default
	 */
	void template_curve_mapping(AnyType data, const std::string property, curve_type_items type = curve_type_items_NONE, bool levels = false, bool brush = false, bool use_negative_slope = false)
	{
		// not implemented
	}

	/**
	 * Item. A color ramp widget
	 * @param Data from which to take property
	 * @param Identifier of property in data
	 * @param Expand button to show more detail
	 */
	void template_color_ramp(AnyType data, const std::string property, bool expand = false)
	{
		// not implemented
	}

	/**
	 * Enum. Large widget showing Icon previews
	 * @param Data from which to take property
	 * @param Identifier of property in data
	 */
	void template_icon_view(AnyType data, const std::string property)
	{
		// not implemented
	}

	/**
	 * Item. A histogramm widget to analyze imaga data
	 * @param Data from which to take property
	 * @param Identifier of property in data
	 */
	void template_histogram(AnyType data, const std::string property)
	{
		// not implemented
	}

	/**
	 * Item. A waveform widget to analyze imaga data
	 * @param Data from which to take property
	 * @param Identifier of property in data
	 */
	void template_waveform(AnyType data, const std::string property)
	{
		// not implemented
	}

	/**
	 * Item. A vectorscope widget to analyze imaga data
	 * @param Data from which to take property
	 * @param Identifier of property in data
	 */
	void template_vectorscope(AnyType data, const std::string property)
	{
		// not implemented
	}

	/**
	 * Function: template_layers
	 * @param Data from which to take property
	 * @param Identifier of property in data
	 * @param Data from which to take property
	 * @param Identifier of property in data
	 * @param Param 'active_layer'
	 */
	void template_layers(AnyType data, const std::string property, AnyType used_layers_data, const std::string used_layers_property, int active_layer)
	{
		// not implemented
	}

	/**
	 * Item. A color wheel widget to pick colors
	 * @param Data from which to take property
	 * @param Identifier of property in data
	 * @param Display the value slider to the right of the color wheel
	 * @param Lock the color wheel display to value 1.0 regardless of actual color
	 * @param Keep the color at its original vector length
	 * @param Cubic saturation for picking values close to white
	 */
	void template_color_picker(AnyType data, const std::string property, bool value_slider = false, bool lock_value = false, bool lock_luminosity = false, bool cubic = false)
	{
		// not implemented
	}

	/**
	 * Item. A palette used to pick colors
	 * @param Data from which to take property
	 * @param Identifier of property in data
	 * @param Display the colors as colors or values
	 */
	void template_palette(AnyType data, const std::string property, bool color = false)
	{
		// not implemented
	}

	/**
	 * Function: template_image_layers
	 * @param Param 'image'
	 * @param Param 'image_user'
	 */
	void template_image_layers(Image image, ImageUser image_user)
	{
		// not implemented
	}

	/**
	 * Item(s). User interface for selecting images and their source paths
	 * @param Data from which to take property
	 * @param Identifier of property in data
	 * @param Param 'image_user'
	 * @param Use more compact layout
	 */
	void template_image(AnyType data, const std::string property, ImageUser image_user, bool compact = false)
	{
		// not implemented
	}

	/**
	 * User interface for setting image format options
	 * @param Param 'image_settings'
	 * @param Show color management settings
	 */
	void template_image_settings(ImageFormatSettings image_settings, bool color_management = false)
	{
		// not implemented
	}

	/**
	 * User interface for setting image stereo 3d options
	 * @param Param 'stereo_3d_format'
	 */
	void template_image_stereo_3d(Stereo3dFormat stereo_3d_format)
	{
		// not implemented
	}

	/**
	 * User interface for setting image views output options
	 * @param Param 'image_settings'
	 */
	void template_image_views(ImageFormatSettings image_settings)
	{
		// not implemented
	}

	/**
	 * Item(s). User interface for selecting movie clips and their source paths
	 * @param Data from which to take property
	 * @param Identifier of property in data
	 * @param Use more compact layout
	 */
	void template_movieclip(AnyType data, const std::string property, bool compact = false)
	{
		// not implemented
	}

	/**
	 * Item. A movie-track widget to preview tracking image.
	 * @param Data from which to take property
	 * @param Identifier of property in data
	 */
	void template_track(AnyType data, const std::string property)
	{
		// not implemented
	}

	/**
	 * Item. A widget to control single marker settings.
	 * @param Data from which to take property
	 * @param Identifier of property in data
	 * @param Param 'clip_user'
	 * @param Param 'track'
	 * @param Use more compact layout
	 */
	void template_marker(AnyType data, const std::string property, MovieClipUser clip_user, MovieTrackingTrack track, bool compact = false);

	/**
	 * Item. Movie clip information data.
	 * @param Data from which to take property
	 * @param Identifier of property in data
	 * @param Param 'clip_user'
	 */
	void template_movieclip_information(AnyType data, const std::string property, MovieClipUser clip_user);

	/**
	 * Enum: uilist_layout_type_items
	 */
	enum uilist_layout_type_items {
		uilist_layout_type_items_DEFAULT = 0,	/**< Use the default, multi-rows layout */
		uilist_layout_type_items_COMPACT = 1,	/**< Use the compact, single-row layout */
		uilist_layout_type_items_GRID = 2	/**< Use the grid-based layout */
	};

	/**
	 * Item. A list widget to display data, e.g. vertexgroups.
	 * @param Identifier of the list type to use
	 * @param Identifier of this list widget (mandatory when using default "UI_UL_list" class). If this is set, the uilist gets a custom ID, otherwise it takes the name of the class used to define the uilist (for example, if the class name is "OBJECT_UL_vgroups", and list_id is not set by the script, then bl_idname = "OBJECT_UL_vgroups")
	 * @param Data from which to take the Collection property
	 * @param Identifier of the Collection property in data
	 * @param Data from which to take the integer property, index of the active item
	 * @param Identifier of the integer property in active_data, index of the active item
	 * @param Identifier of a string property in items, to use as tooltip content
	 * @param Default and minimum number of rows to display
	 * @param Default maximum number of rows to display
	 * @param Type of layout to use
	 * @param Number of items to display per row, for GRID layout
	 */
	void template_list(const std::string listtype_name, const std::string list_id, AnyType dataptr, const std::string propname, AnyType active_dataptr, const std::string active_propname, const std::string item_dyntip_propname = NULL, int rows = 5, int maxrows = 5, uilist_layout_type_items type = uilist_layout_type_items_DEFAULT, int columns = 9)
	{
		// not implemented
	}

	/**
	 * Function: template_running_jobs
	 */
	void template_running_jobs()
	{
		// not implemented
	}

	/**
	 * Function: template_operator_search
	 */
	void template_operator_search()
	{
		// not implemented
	}

	/**
	 * Function: template_header_3D
	 */
	void template_header_3D()
	{
		// not implemented
	}

	/**
	 * Function: template_edit_mode_selection
	 */
	void template_edit_mode_selection()
	{
		// not implemented
	}

	/**
	 * Function: template_reports_banner
	 */
	void template_reports_banner()
	{
		// not implemented
	}

	/**
	 * Function: template_node_link
	 * @param Param 'ntree'
	 * @param Param 'node'
	 * @param Param 'socket'
	 */
	void template_node_link(NodeTree ntree, Node node, NodeSocket socket)
	{
		// not implemented
	}

	/**
	 * Function: template_node_view
	 * @param Param 'ntree'
	 * @param Param 'node'
	 * @param Param 'socket'
	 */
	void template_node_view(NodeTree ntree, Node node, NodeSocket socket)
	{
		// not implemented
	}

	/**
	 * Function: template_texture_user
	 */
	void template_texture_user()
	{
		// not implemented
	}

	/**
	 * Function: template_keymap_item_properties
	 * @param Param 'item'
	 */
	void template_keymap_item_properties(KeyMapItem item);

	/**
	 * Item. Display expanded property in a popup menu
	 * @param Data from which to take property
	 * @param Identifier of property in data
	 * @param Param 'name'
	 */
	void template_component_menu(AnyType data, const std::string property, const std::string name = NULL)
	{
		// not implemented
	}

	/**
	 * Function: introspect
	 * @return DESCR
	 */
	const std::string introspect()
	{
		// not implemented
		throw NULL;
	}

	/**
	 * Item. A widget to control input color space settings.
	 * @param Data from which to take property
	 * @param Identifier of property in data
	 */
	void template_colorspace_settings(AnyType data, const std::string property)
	{
		// not implemented
	}

	/**
	 * Item. A widget to control color managed view settings settings.
	 * @param Data from which to take property
	 * @param Identifier of property in data
	 */
	void template_colormanaged_view_settings(AnyType data, const std::string property)
	{
		// not implemented
	}

	/**
	 * Node Socket Icon
	 * @param Param 'color'
	 */
	void template_node_socket(float color[4])
	{
		// not implemented
	}

};

/**************** Panel ****************/

/**
 * Panel containing UI elements
 */
class Panel : public pyUniplug {
public:
	Panel(PyObject* pyobj) : pyUniplug(pyobj) {}

	Panel() : pyUniplug(0)
	{
		// not implemented
	}

	/** Getter: Defines the structure of the panel in the UI */
	UILayout layout() {
		/* not implemented */ throw NULL;
	}

	/** Getter: XXX todo */
	std::string text() { /* not implemented */ throw NULL; }
	/** Setter: XXX todo */
	void text(const std::string& value) { /* not implemented */ }

	/** Getter: If this is set, the panel gets a custom ID, otherwise it takes the name of the class used to define the panel. For example, if the class name is "OBJECT_PT_hello", and bl_idname is not set by the script, then bl_idname = "OBJECT_PT_hello" */
	std::string bl_idname() { /* not implemented */ throw NULL; }
	/** Setter: If this is set, the panel gets a custom ID, otherwise it takes the name of the class used to define the panel. For example, if the class name is "OBJECT_PT_hello", and bl_idname is not set by the script, then bl_idname = "OBJECT_PT_hello" */
	void bl_idname(const std::string& value) { /* not implemented */ }

	/** Getter: The panel label, shows up in the panel header at the right of the triangle used to collapse the panel */
	std::string bl_label() { /* not implemented */ throw NULL; }
	/** Setter: The panel label, shows up in the panel header at the right of the triangle used to collapse the panel */
	void bl_label(const std::string& value) { /* not implemented */ }

	/** Getter:  */
	std::string bl_translation_context() { /* not implemented */ throw NULL; }
	/** Setter:  */
	void bl_translation_context(const std::string& value) { /* not implemented */ }

	/** Getter:  */
	std::string bl_category() { /* not implemented */ throw NULL; }
	/** Setter:  */
	void bl_category(const std::string& value) { /* not implemented */ }

	enum bl_space_type_enum {
		bl_space_type_EMPTY = 0,
		bl_space_type_VIEW_3D = 1,
		bl_space_type_TIMELINE = 15,
		bl_space_type_GRAPH_EDITOR = 2,
		bl_space_type_DOPESHEET_EDITOR = 12,
		bl_space_type_NLA_EDITOR = 13,
		bl_space_type_IMAGE_EDITOR = 6,
		bl_space_type_SEQUENCE_EDITOR = 8,
		bl_space_type_CLIP_EDITOR = 20,
		bl_space_type_TEXT_EDITOR = 9,
		bl_space_type_NODE_EDITOR = 16,
		bl_space_type_LOGIC_EDITOR = 17,
		bl_space_type_PROPERTIES = 4,
		bl_space_type_OUTLINER = 3,
		bl_space_type_USER_PREFERENCES = 19,
		bl_space_type_INFO = 7,
		bl_space_type_FILE_BROWSER = 5,
		bl_space_type_CONSOLE = 18,
	};

	/** Getter: The space where the panel is going to be used in */
	bl_space_type_enum bl_space_type() { /* not implemented */ throw NULL; }
	/** Setter: The space where the panel is going to be used in */
	void bl_space_type(bl_space_type_enum value) { /* not implemented */ }

	enum bl_region_type_enum {
		bl_region_type_WINDOW = 0,
		bl_region_type_HEADER = 1,
		bl_region_type_CHANNELS = 2,
		bl_region_type_TEMPORARY = 3,
		bl_region_type_UI = 4,
		bl_region_type_TOOLS = 5,
		bl_region_type_TOOL_PROPS = 6,
		bl_region_type_PREVIEW = 7,
	};

	/** Getter: The region where the panel is going to be used in */
	bl_region_type_enum bl_region_type() { /* not implemented */ throw NULL; }
	/** Setter: The region where the panel is going to be used in */
	void bl_region_type(bl_region_type_enum value) { /* not implemented */ }

	/** Getter: The context in which the panel belongs to. (TODO: explain the possible combinations bl_context/bl_region_type/bl_space_type) */
	std::string bl_context() { /* not implemented */ throw NULL; }
	/** Setter: The context in which the panel belongs to. (TODO: explain the possible combinations bl_context/bl_region_type/bl_space_type) */
	void bl_context(const std::string& value) { /* not implemented */ }

	enum bl_options_enum {
		bl_options_DEFAULT_CLOSED = 1,
		bl_options_HIDE_HEADER = 2,
	};

	/** Getter: Options for this panel type */
	bl_options_enum bl_options() { /* not implemented */ throw NULL; }
	/** Setter: Options for this panel type */
	void bl_options(bl_options_enum value) { /* not implemented */ }

	/** Getter:  */
	bool use_pin() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_pin")) == 1;
	}

	/** Setter:  */
	void use_pin(bool value) {
		PyObject_SetAttrString(pyobjref, "use_pin", Py_BuildValue("i", value));
	}

};

/**************** UIList ****************/

/**
 * UI list containing the elements of a collection
 */
class UIList : public pyUniplug {
public:
	UIList(PyObject* pyobj) : pyUniplug(pyobj) {}

	UIList() : pyUniplug(0)
	{
		// not implemented
	}

	/** Getter: If this is set, the uilist gets a custom ID, otherwise it takes the name of the class used to define the uilist (for example, if the class name is "OBJECT_UL_vgroups", and bl_idname is not set by the script, then bl_idname = "OBJECT_UL_vgroups") */
	std::string bl_idname() { /* not implemented */ throw NULL; }
	/** Setter: If this is set, the uilist gets a custom ID, otherwise it takes the name of the class used to define the uilist (for example, if the class name is "OBJECT_UL_vgroups", and bl_idname is not set by the script, then bl_idname = "OBJECT_UL_vgroups") */
	void bl_idname(const std::string& value) { /* not implemented */ }

	enum layout_type_enum {
		layout_type_DEFAULT = 0,
		layout_type_COMPACT = 1,
		layout_type_GRID = 2,
	};

	/** Getter:  */
	layout_type_enum layout_type() { /* not implemented */ throw NULL; }
	/** Setter:  */
	void layout_type(layout_type_enum value) { /* not implemented */ }

	/** Getter: Show filtering options */
	bool use_filter_show() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_filter_show")) == 1;
	}

	/** Setter: Show filtering options */
	void use_filter_show(bool value) {
		PyObject_SetAttrString(pyobjref, "use_filter_show", Py_BuildValue("i", value));
	}

	/** Getter: Only show items matching this name (use '*' as wildcard) */
	std::string filter_name() { /* not implemented */ throw NULL; }
	/** Setter: Only show items matching this name (use '*' as wildcard) */
	void filter_name(const std::string& value) { /* not implemented */ }

	/** Getter: Invert filtering (show hidden items, and vice-versa) */
	bool use_filter_invert() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_filter_invert")) == 1;
	}

	/** Setter: Invert filtering (show hidden items, and vice-versa) */
	void use_filter_invert(bool value) {
		PyObject_SetAttrString(pyobjref, "use_filter_invert", Py_BuildValue("i", value));
	}

	/** Getter: Sort items by their name */
	bool use_filter_sort_alpha() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_filter_sort_alpha")) == 1;
	}

	/** Setter: Sort items by their name */
	void use_filter_sort_alpha(bool value) {
		PyObject_SetAttrString(pyobjref, "use_filter_sort_alpha", Py_BuildValue("i", value));
	}

	/** Getter: Invert the order of shown items */
	bool use_filter_sort_reverse() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_filter_sort_reverse")) == 1;
	}

	/** Setter: Invert the order of shown items */
	void use_filter_sort_reverse(bool value) {
		PyObject_SetAttrString(pyobjref, "use_filter_sort_reverse", Py_BuildValue("i", value));
	}

	/** Getter: The value of the reserved bitflag 'FILTER_ITEM' (in filter_flags values) */
	int bitflag_filter_item() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "bitflag_filter_item"));
	}

	/** Setter: The value of the reserved bitflag 'FILTER_ITEM' (in filter_flags values) */
	void bitflag_filter_item(int value) {
		PyObject_SetAttrString(pyobjref, "bitflag_filter_item", Py_BuildValue("i", value));
	}

};

/**************** Header ****************/

/**
 * Editor header containing UI elements
 */
class Header : public pyUniplug {
public:
	Header(PyObject* pyobj) : pyUniplug(pyobj) {}

	Header() : pyUniplug(0)
	{
		// not implemented
	}

	/** Getter: Structure of the header in the UI */
	UILayout layout() {
		/* not implemented */ throw NULL;
	}

	/** Getter: If this is set, the header gets a custom ID, otherwise it takes the name of the class used to define the panel; for example, if the class name is "OBJECT_HT_hello", and bl_idname is not set by the script, then bl_idname = "OBJECT_HT_hello" */
	std::string bl_idname() { /* not implemented */ throw NULL; }
	/** Setter: If this is set, the header gets a custom ID, otherwise it takes the name of the class used to define the panel; for example, if the class name is "OBJECT_HT_hello", and bl_idname is not set by the script, then bl_idname = "OBJECT_HT_hello" */
	void bl_idname(const std::string& value) { /* not implemented */ }

	enum bl_space_type_enum {
		bl_space_type_EMPTY = 0,
		bl_space_type_VIEW_3D = 1,
		bl_space_type_TIMELINE = 15,
		bl_space_type_GRAPH_EDITOR = 2,
		bl_space_type_DOPESHEET_EDITOR = 12,
		bl_space_type_NLA_EDITOR = 13,
		bl_space_type_IMAGE_EDITOR = 6,
		bl_space_type_SEQUENCE_EDITOR = 8,
		bl_space_type_CLIP_EDITOR = 20,
		bl_space_type_TEXT_EDITOR = 9,
		bl_space_type_NODE_EDITOR = 16,
		bl_space_type_LOGIC_EDITOR = 17,
		bl_space_type_PROPERTIES = 4,
		bl_space_type_OUTLINER = 3,
		bl_space_type_USER_PREFERENCES = 19,
		bl_space_type_INFO = 7,
		bl_space_type_FILE_BROWSER = 5,
		bl_space_type_CONSOLE = 18,
	};

	/** Getter: The space where the header is going to be used in */
	bl_space_type_enum bl_space_type() { /* not implemented */ throw NULL; }
	/** Setter: The space where the header is going to be used in */
	void bl_space_type(bl_space_type_enum value) { /* not implemented */ }

};

/**************** Menu ****************/

/**
 * Editor menu containing buttons
 */
class Menu : public pyUniplug {
public:
	Menu(PyObject* pyobj) : pyUniplug(pyobj) {}

	Menu() : pyUniplug(0)
	{
		// not implemented
	}

	/** Getter: Defines the structure of the menu in the UI */
	UILayout layout() {
		/* not implemented */ throw NULL;
	}

	/** Getter: If this is set, the menu gets a custom ID, otherwise it takes the name of the class used to define the menu (for example, if the class name is "OBJECT_MT_hello", and bl_idname is not set by the script, then bl_idname = "OBJECT_MT_hello") */
	std::string bl_idname() { /* not implemented */ throw NULL; }
	/** Setter: If this is set, the menu gets a custom ID, otherwise it takes the name of the class used to define the menu (for example, if the class name is "OBJECT_MT_hello", and bl_idname is not set by the script, then bl_idname = "OBJECT_MT_hello") */
	void bl_idname(const std::string& value) { /* not implemented */ }

	/** Getter: The menu label */
	std::string bl_label() { /* not implemented */ throw NULL; }
	/** Setter: The menu label */
	void bl_label(const std::string& value) { /* not implemented */ }

	/** Getter:  */
	std::string bl_translation_context() { /* not implemented */ throw NULL; }
	/** Setter:  */
	void bl_translation_context(const std::string& value) { /* not implemented */ }

	/** Getter:  */
	std::string bl_description() { /* not implemented */ throw NULL; }
	/** Setter:  */
	void bl_description(const std::string& value) { /* not implemented */ }

};

/**************** Font Style ****************/

/**
 * Theme settings for Font
 */
class ThemeFontStyle : public pyUniplug {
public:
	ThemeFontStyle(PyObject* pyobj) : pyUniplug(pyobj) {}

	ThemeFontStyle() : pyUniplug(0)
	{
		// not implemented
	}

	/** Getter:  */
	int points() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "points"));
	}

	/** Setter:  */
	void points(int value) {
		PyObject_SetAttrString(pyobjref, "points", Py_BuildValue("i", value));
	}

	enum font_kerning_style_enum {
		font_kerning_style_UNFITTED = 0,
		font_kerning_style_FITTED = 1,
	};

	/** Getter: Which style to use for font kerning */
	font_kerning_style_enum font_kerning_style() { /* not implemented */ throw NULL; }
	/** Setter: Which style to use for font kerning */
	void font_kerning_style(font_kerning_style_enum value) { /* not implemented */ }

	/** Getter: Shadow size (0, 3 and 5 supported) */
	int shadow() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "shadow"));
	}

	/** Setter: Shadow size (0, 3 and 5 supported) */
	void shadow(int value) {
		PyObject_SetAttrString(pyobjref, "shadow", Py_BuildValue("i", value));
	}

	/** Getter: Shadow offset in pixels */
	int shadow_offset_x() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "shadow_offset_x"));
	}

	/** Setter: Shadow offset in pixels */
	void shadow_offset_x(int value) {
		PyObject_SetAttrString(pyobjref, "shadow_offset_x", Py_BuildValue("i", value));
	}

	/** Getter: Shadow offset in pixels */
	int shadow_offset_y() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "shadow_offset_y"));
	}

	/** Setter: Shadow offset in pixels */
	void shadow_offset_y(int value) {
		PyObject_SetAttrString(pyobjref, "shadow_offset_y", Py_BuildValue("i", value));
	}

	/** Getter:  */
	float shadow_alpha() { /* not implemented */ throw NULL; }
	/** Setter:  */
	void shadow_alpha(float value) {
		PyObject_SetAttrString(pyobjref, "shadow_alpha", Py_BuildValue("f", value));
	}

	/** Getter: Shadow color in gray value */
	float shadow_value() { /* not implemented */ throw NULL; }
	/** Setter: Shadow color in gray value */
	void shadow_value(float value) {
		PyObject_SetAttrString(pyobjref, "shadow_value", Py_BuildValue("f", value));
	}

};

/**************** Style ****************/

/**
 * Theme settings for style sets
 */
class ThemeStyle : public pyUniplug {
public:
	ThemeStyle(PyObject* pyobj) : pyUniplug(pyobj) {}

	ThemeStyle() : pyUniplug(0)
	{
		// not implemented
	}

	/** Getter:  */
	ThemeFontStyle panel_title() {
		/* not implemented */ throw NULL;
	}

	/** Getter:  */
	ThemeFontStyle widget_label() {
		/* not implemented */ throw NULL;
	}

	/** Getter:  */
	ThemeFontStyle widget() {
		/* not implemented */ throw NULL;
	}

};

/**************** Theme Widget Color Set ****************/

/**
 * Theme settings for widget color sets
 */
class ThemeWidgetColors : public pyUniplug {
public:
	ThemeWidgetColors(PyObject* pyobj) : pyUniplug(pyobj) {}

	ThemeWidgetColors() : pyUniplug(0)
	{
		// not implemented
	}

	/** Getter:  */
	std::array<float, 3> outline() {
		// TODO: MISSING DEREF! USE #DEFINE!
		PyObject *seqval = PyObject_GetAttrString(pyobjref, "outline");
		std::array<float, 3> resarr;
		for (int i = 0; i < 3; i++)
			resarr[i] = (float)PyFloat_AsDouble(PySequence_GetItem(seqval, i));
		return resarr;
	}

	/** Setter:  */
	void outline(float values[3]) { /* not implemented */ }

	/** Getter:  */
	std::array<float, 4> inner() {
		// TODO: MISSING DEREF! USE #DEFINE!
		PyObject *seqval = PyObject_GetAttrString(pyobjref, "inner");
		std::array<float, 4> resarr;
		for (int i = 0; i < 4; i++)
			resarr[i] = (float)PyFloat_AsDouble(PySequence_GetItem(seqval, i));
		return resarr;
	}

	/** Setter:  */
	void inner(float values[4]) { /* not implemented */ }

	/** Getter:  */
	std::array<float, 4> inner_sel() {
		// TODO: MISSING DEREF! USE #DEFINE!
		PyObject *seqval = PyObject_GetAttrString(pyobjref, "inner_sel");
		std::array<float, 4> resarr;
		for (int i = 0; i < 4; i++)
			resarr[i] = (float)PyFloat_AsDouble(PySequence_GetItem(seqval, i));
		return resarr;
	}

	/** Setter:  */
	void inner_sel(float values[4]) { /* not implemented */ }

	/** Getter:  */
	std::array<float, 4> item() {
		// TODO: MISSING DEREF! USE #DEFINE!
		PyObject *seqval = PyObject_GetAttrString(pyobjref, "item");
		std::array<float, 4> resarr;
		for (int i = 0; i < 4; i++)
			resarr[i] = (float)PyFloat_AsDouble(PySequence_GetItem(seqval, i));
		return resarr;
	}

	/** Setter:  */
	void item(float values[4]) { /* not implemented */ }

	/** Getter:  */
	std::array<float, 3> text() {
		// TODO: MISSING DEREF! USE #DEFINE!
		PyObject *seqval = PyObject_GetAttrString(pyobjref, "text");
		std::array<float, 3> resarr;
		for (int i = 0; i < 3; i++)
			resarr[i] = (float)PyFloat_AsDouble(PySequence_GetItem(seqval, i));
		return resarr;
	}

	/** Setter:  */
	void text(float values[3]) { /* not implemented */ }

	/** Getter:  */
	std::array<float, 3> text_sel() {
		// TODO: MISSING DEREF! USE #DEFINE!
		PyObject *seqval = PyObject_GetAttrString(pyobjref, "text_sel");
		std::array<float, 3> resarr;
		for (int i = 0; i < 3; i++)
			resarr[i] = (float)PyFloat_AsDouble(PySequence_GetItem(seqval, i));
		return resarr;
	}

	/** Setter:  */
	void text_sel(float values[3]) { /* not implemented */ }

	/** Getter:  */
	bool show_shaded() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "show_shaded")) == 1;
	}

	/** Setter:  */
	void show_shaded(bool value) {
		PyObject_SetAttrString(pyobjref, "show_shaded", Py_BuildValue("i", value));
	}

	/** Getter:  */
	int shadetop() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "shadetop"));
	}

	/** Setter:  */
	void shadetop(int value) {
		PyObject_SetAttrString(pyobjref, "shadetop", Py_BuildValue("i", value));
	}

	/** Getter:  */
	int shadedown() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "shadedown"));
	}

	/** Setter:  */
	void shadedown(int value) {
		PyObject_SetAttrString(pyobjref, "shadedown", Py_BuildValue("i", value));
	}

};

/**************** Theme Widget State Color ****************/

/**
 * Theme settings for widget state colors
 */
class ThemeWidgetStateColors : public pyUniplug {
public:
	ThemeWidgetStateColors(PyObject* pyobj) : pyUniplug(pyobj) {}

	ThemeWidgetStateColors() : pyUniplug(0)
	{
		// not implemented
	}

	/** Getter:  */
	std::array<float, 3> inner_anim() {
		// TODO: MISSING DEREF! USE #DEFINE!
		PyObject *seqval = PyObject_GetAttrString(pyobjref, "inner_anim");
		std::array<float, 3> resarr;
		for (int i = 0; i < 3; i++)
			resarr[i] = (float)PyFloat_AsDouble(PySequence_GetItem(seqval, i));
		return resarr;
	}

	/** Setter:  */
	void inner_anim(float values[3]) { /* not implemented */ }

	/** Getter:  */
	std::array<float, 3> inner_anim_sel() {
		// TODO: MISSING DEREF! USE #DEFINE!
		PyObject *seqval = PyObject_GetAttrString(pyobjref, "inner_anim_sel");
		std::array<float, 3> resarr;
		for (int i = 0; i < 3; i++)
			resarr[i] = (float)PyFloat_AsDouble(PySequence_GetItem(seqval, i));
		return resarr;
	}

	/** Setter:  */
	void inner_anim_sel(float values[3]) { /* not implemented */ }

	/** Getter:  */
	std::array<float, 3> inner_key() {
		// TODO: MISSING DEREF! USE #DEFINE!
		PyObject *seqval = PyObject_GetAttrString(pyobjref, "inner_key");
		std::array<float, 3> resarr;
		for (int i = 0; i < 3; i++)
			resarr[i] = (float)PyFloat_AsDouble(PySequence_GetItem(seqval, i));
		return resarr;
	}

	/** Setter:  */
	void inner_key(float values[3]) { /* not implemented */ }

	/** Getter:  */
	std::array<float, 3> inner_key_sel() {
		// TODO: MISSING DEREF! USE #DEFINE!
		PyObject *seqval = PyObject_GetAttrString(pyobjref, "inner_key_sel");
		std::array<float, 3> resarr;
		for (int i = 0; i < 3; i++)
			resarr[i] = (float)PyFloat_AsDouble(PySequence_GetItem(seqval, i));
		return resarr;
	}

	/** Setter:  */
	void inner_key_sel(float values[3]) { /* not implemented */ }

	/** Getter:  */
	std::array<float, 3> inner_driven() {
		// TODO: MISSING DEREF! USE #DEFINE!
		PyObject *seqval = PyObject_GetAttrString(pyobjref, "inner_driven");
		std::array<float, 3> resarr;
		for (int i = 0; i < 3; i++)
			resarr[i] = (float)PyFloat_AsDouble(PySequence_GetItem(seqval, i));
		return resarr;
	}

	/** Setter:  */
	void inner_driven(float values[3]) { /* not implemented */ }

	/** Getter:  */
	std::array<float, 3> inner_driven_sel() {
		// TODO: MISSING DEREF! USE #DEFINE!
		PyObject *seqval = PyObject_GetAttrString(pyobjref, "inner_driven_sel");
		std::array<float, 3> resarr;
		for (int i = 0; i < 3; i++)
			resarr[i] = (float)PyFloat_AsDouble(PySequence_GetItem(seqval, i));
		return resarr;
	}

	/** Setter:  */
	void inner_driven_sel(float values[3]) { /* not implemented */ }

	/** Getter:  */
	float blend() { /* not implemented */ throw NULL; }
	/** Setter:  */
	void blend(float value) {
		PyObject_SetAttrString(pyobjref, "blend", Py_BuildValue("f", value));
	}

};

/**************** Theme Panel Color ****************/

/**
 * Theme settings for panel colors
 */
class ThemePanelColors : public pyUniplug {
public:
	ThemePanelColors(PyObject* pyobj) : pyUniplug(pyobj) {}

	ThemePanelColors() : pyUniplug(0)
	{
		// not implemented
	}

	/** Getter:  */
	std::array<float, 4> header() {
		// TODO: MISSING DEREF! USE #DEFINE!
		PyObject *seqval = PyObject_GetAttrString(pyobjref, "header");
		std::array<float, 4> resarr;
		for (int i = 0; i < 4; i++)
			resarr[i] = (float)PyFloat_AsDouble(PySequence_GetItem(seqval, i));
		return resarr;
	}

	/** Setter:  */
	void header(float values[4]) { /* not implemented */ }

	/** Getter:  */
	std::array<float, 4> back() {
		// TODO: MISSING DEREF! USE #DEFINE!
		PyObject *seqval = PyObject_GetAttrString(pyobjref, "back");
		std::array<float, 4> resarr;
		for (int i = 0; i < 4; i++)
			resarr[i] = (float)PyFloat_AsDouble(PySequence_GetItem(seqval, i));
		return resarr;
	}

	/** Setter:  */
	void back(float values[4]) { /* not implemented */ }

	/** Getter:  */
	bool show_header() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "show_header")) == 1;
	}

	/** Setter:  */
	void show_header(bool value) {
		PyObject_SetAttrString(pyobjref, "show_header", Py_BuildValue("i", value));
	}

	/** Getter:  */
	bool show_back() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "show_back")) == 1;
	}

	/** Setter:  */
	void show_back(bool value) {
		PyObject_SetAttrString(pyobjref, "show_back", Py_BuildValue("i", value));
	}

};

/**************** Theme Background Color ****************/

/**
 * Theme settings for background colors and gradient
 */
class ThemeGradientColors : public pyUniplug {
public:
	ThemeGradientColors(PyObject* pyobj) : pyUniplug(pyobj) {}

	ThemeGradientColors() : pyUniplug(0)
	{
		// not implemented
	}

	/** Getter: Do a gradient for the background of the viewport working area */
	bool show_grad() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "show_grad")) == 1;
	}

	/** Setter: Do a gradient for the background of the viewport working area */
	void show_grad(bool value) {
		PyObject_SetAttrString(pyobjref, "show_grad", Py_BuildValue("i", value));
	}

	/** Getter:  */
	std::array<float, 3> gradient() {
		// TODO: MISSING DEREF! USE #DEFINE!
		PyObject *seqval = PyObject_GetAttrString(pyobjref, "gradient");
		std::array<float, 3> resarr;
		for (int i = 0; i < 3; i++)
			resarr[i] = (float)PyFloat_AsDouble(PySequence_GetItem(seqval, i));
		return resarr;
	}

	/** Setter:  */
	void gradient(float values[3]) { /* not implemented */ }

	/** Getter:  */
	std::array<float, 3> high_gradient() {
		// TODO: MISSING DEREF! USE #DEFINE!
		PyObject *seqval = PyObject_GetAttrString(pyobjref, "high_gradient");
		std::array<float, 3> resarr;
		for (int i = 0; i < 3; i++)
			resarr[i] = (float)PyFloat_AsDouble(PySequence_GetItem(seqval, i));
		return resarr;
	}

	/** Setter:  */
	void high_gradient(float values[3]) { /* not implemented */ }

};

/**************** Theme User Interface ****************/

/**
 * Theme settings for user interface elements
 */
class ThemeUserInterface : public pyUniplug {
public:
	ThemeUserInterface(PyObject* pyobj) : pyUniplug(pyobj) {}

	ThemeUserInterface() : pyUniplug(0)
	{
		// not implemented
	}

	/** Getter:  */
	ThemeWidgetColors wcol_regular() {
		/* not implemented */ throw NULL;
	}

	/** Getter:  */
	ThemeWidgetColors wcol_tool() {
		/* not implemented */ throw NULL;
	}

	/** Getter:  */
	ThemeWidgetColors wcol_radio() {
		/* not implemented */ throw NULL;
	}

	/** Getter:  */
	ThemeWidgetColors wcol_text() {
		/* not implemented */ throw NULL;
	}

	/** Getter:  */
	ThemeWidgetColors wcol_option() {
		/* not implemented */ throw NULL;
	}

	/** Getter:  */
	ThemeWidgetColors wcol_toggle() {
		/* not implemented */ throw NULL;
	}

	/** Getter:  */
	ThemeWidgetColors wcol_num() {
		/* not implemented */ throw NULL;
	}

	/** Getter:  */
	ThemeWidgetColors wcol_numslider() {
		/* not implemented */ throw NULL;
	}

	/** Getter:  */
	ThemeWidgetColors wcol_box() {
		/* not implemented */ throw NULL;
	}

	/** Getter:  */
	ThemeWidgetColors wcol_menu() {
		/* not implemented */ throw NULL;
	}

	/** Getter:  */
	ThemeWidgetColors wcol_pulldown() {
		/* not implemented */ throw NULL;
	}

	/** Getter:  */
	ThemeWidgetColors wcol_menu_back() {
		/* not implemented */ throw NULL;
	}

	/** Getter:  */
	ThemeWidgetColors wcol_pie_menu() {
		/* not implemented */ throw NULL;
	}

	/** Getter:  */
	ThemeWidgetColors wcol_tooltip() {
		/* not implemented */ throw NULL;
	}

	/** Getter:  */
	ThemeWidgetColors wcol_menu_item() {
		/* not implemented */ throw NULL;
	}

	/** Getter:  */
	ThemeWidgetColors wcol_scroll() {
		/* not implemented */ throw NULL;
	}

	/** Getter:  */
	ThemeWidgetColors wcol_progress() {
		/* not implemented */ throw NULL;
	}

	/** Getter:  */
	ThemeWidgetColors wcol_list_item() {
		/* not implemented */ throw NULL;
	}

	/** Getter:  */
	ThemeWidgetStateColors wcol_state() {
		/* not implemented */ throw NULL;
	}

	/** Getter: Blending factor for menu shadows */
	float menu_shadow_fac() { /* not implemented */ throw NULL; }
	/** Setter: Blending factor for menu shadows */
	void menu_shadow_fac(float value) {
		PyObject_SetAttrString(pyobjref, "menu_shadow_fac", Py_BuildValue("f", value));
	}

	/** Getter: Width of menu shadows, set to zero to disable */
	int menu_shadow_width() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "menu_shadow_width"));
	}

	/** Setter: Width of menu shadows, set to zero to disable */
	void menu_shadow_width(int value) {
		PyObject_SetAttrString(pyobjref, "menu_shadow_width", Py_BuildValue("i", value));
	}

	/** Getter:  */
	std::string icon_file() { /* not implemented */ throw NULL; }
	/** Setter:  */
	void icon_file(const std::string& value) { /* not implemented */ }

	/** Getter: Transparency of icons in the interface, to reduce contrast */
	float icon_alpha() { /* not implemented */ throw NULL; }
	/** Setter: Transparency of icons in the interface, to reduce contrast */
	void icon_alpha(float value) {
		PyObject_SetAttrString(pyobjref, "icon_alpha", Py_BuildValue("f", value));
	}

	/** Getter: Color of the 1px shadow line underlying widgets */
	std::array<float, 4> widget_emboss() {
		// TODO: MISSING DEREF! USE #DEFINE!
		PyObject *seqval = PyObject_GetAttrString(pyobjref, "widget_emboss");
		std::array<float, 4> resarr;
		for (int i = 0; i < 4; i++)
			resarr[i] = (float)PyFloat_AsDouble(PySequence_GetItem(seqval, i));
		return resarr;
	}

	/** Setter: Color of the 1px shadow line underlying widgets */
	void widget_emboss(float values[4]) { /* not implemented */ }

	/** Getter:  */
	std::array<float, 3> axis_x() {
		// TODO: MISSING DEREF! USE #DEFINE!
		PyObject *seqval = PyObject_GetAttrString(pyobjref, "axis_x");
		std::array<float, 3> resarr;
		for (int i = 0; i < 3; i++)
			resarr[i] = (float)PyFloat_AsDouble(PySequence_GetItem(seqval, i));
		return resarr;
	}

	/** Setter:  */
	void axis_x(float values[3]) { /* not implemented */ }

	/** Getter:  */
	std::array<float, 3> axis_y() {
		// TODO: MISSING DEREF! USE #DEFINE!
		PyObject *seqval = PyObject_GetAttrString(pyobjref, "axis_y");
		std::array<float, 3> resarr;
		for (int i = 0; i < 3; i++)
			resarr[i] = (float)PyFloat_AsDouble(PySequence_GetItem(seqval, i));
		return resarr;
	}

	/** Setter:  */
	void axis_y(float values[3]) { /* not implemented */ }

	/** Getter:  */
	std::array<float, 3> axis_z() {
		// TODO: MISSING DEREF! USE #DEFINE!
		PyObject *seqval = PyObject_GetAttrString(pyobjref, "axis_z");
		std::array<float, 3> resarr;
		for (int i = 0; i < 3; i++)
			resarr[i] = (float)PyFloat_AsDouble(PySequence_GetItem(seqval, i));
		return resarr;
	}

	/** Setter:  */
	void axis_z(float values[3]) { /* not implemented */ }

};

/**************** Theme Space Settings ****************/

/**
 * 
 */
class ThemeSpaceGeneric : public pyUniplug {
public:
	ThemeSpaceGeneric(PyObject* pyobj) : pyUniplug(pyobj) {}

	ThemeSpaceGeneric() : pyUniplug(0)
	{
		// not implemented
	}

	/** Getter:  */
	std::array<float, 3> back() {
		// TODO: MISSING DEREF! USE #DEFINE!
		PyObject *seqval = PyObject_GetAttrString(pyobjref, "back");
		std::array<float, 3> resarr;
		for (int i = 0; i < 3; i++)
			resarr[i] = (float)PyFloat_AsDouble(PySequence_GetItem(seqval, i));
		return resarr;
	}

	/** Setter:  */
	void back(float values[3]) { /* not implemented */ }

	/** Getter:  */
	std::array<float, 3> title() {
		// TODO: MISSING DEREF! USE #DEFINE!
		PyObject *seqval = PyObject_GetAttrString(pyobjref, "title");
		std::array<float, 3> resarr;
		for (int i = 0; i < 3; i++)
			resarr[i] = (float)PyFloat_AsDouble(PySequence_GetItem(seqval, i));
		return resarr;
	}

	/** Setter:  */
	void title(float values[3]) { /* not implemented */ }

	/** Getter:  */
	std::array<float, 3> text() {
		// TODO: MISSING DEREF! USE #DEFINE!
		PyObject *seqval = PyObject_GetAttrString(pyobjref, "text");
		std::array<float, 3> resarr;
		for (int i = 0; i < 3; i++)
			resarr[i] = (float)PyFloat_AsDouble(PySequence_GetItem(seqval, i));
		return resarr;
	}

	/** Setter:  */
	void text(float values[3]) { /* not implemented */ }

	/** Getter:  */
	std::array<float, 3> text_hi() {
		// TODO: MISSING DEREF! USE #DEFINE!
		PyObject *seqval = PyObject_GetAttrString(pyobjref, "text_hi");
		std::array<float, 3> resarr;
		for (int i = 0; i < 3; i++)
			resarr[i] = (float)PyFloat_AsDouble(PySequence_GetItem(seqval, i));
		return resarr;
	}

	/** Setter:  */
	void text_hi(float values[3]) { /* not implemented */ }

	/** Getter:  */
	std::array<float, 3> header() {
		// TODO: MISSING DEREF! USE #DEFINE!
		PyObject *seqval = PyObject_GetAttrString(pyobjref, "header");
		std::array<float, 3> resarr;
		for (int i = 0; i < 3; i++)
			resarr[i] = (float)PyFloat_AsDouble(PySequence_GetItem(seqval, i));
		return resarr;
	}

	/** Setter:  */
	void header(float values[3]) { /* not implemented */ }

	/** Getter:  */
	std::array<float, 3> header_text() {
		// TODO: MISSING DEREF! USE #DEFINE!
		PyObject *seqval = PyObject_GetAttrString(pyobjref, "header_text");
		std::array<float, 3> resarr;
		for (int i = 0; i < 3; i++)
			resarr[i] = (float)PyFloat_AsDouble(PySequence_GetItem(seqval, i));
		return resarr;
	}

	/** Setter:  */
	void header_text(float values[3]) { /* not implemented */ }

	/** Getter:  */
	std::array<float, 3> header_text_hi() {
		// TODO: MISSING DEREF! USE #DEFINE!
		PyObject *seqval = PyObject_GetAttrString(pyobjref, "header_text_hi");
		std::array<float, 3> resarr;
		for (int i = 0; i < 3; i++)
			resarr[i] = (float)PyFloat_AsDouble(PySequence_GetItem(seqval, i));
		return resarr;
	}

	/** Setter:  */
	void header_text_hi(float values[3]) { /* not implemented */ }

	/** Getter:  */
	ThemePanelColors panelcolors() {
		/* not implemented */ throw NULL;
	}

	/** Getter:  */
	std::array<float, 4> button() {
		// TODO: MISSING DEREF! USE #DEFINE!
		PyObject *seqval = PyObject_GetAttrString(pyobjref, "button");
		std::array<float, 4> resarr;
		for (int i = 0; i < 4; i++)
			resarr[i] = (float)PyFloat_AsDouble(PySequence_GetItem(seqval, i));
		return resarr;
	}

	/** Setter:  */
	void button(float values[4]) { /* not implemented */ }

	/** Getter:  */
	std::array<float, 3> button_title() {
		// TODO: MISSING DEREF! USE #DEFINE!
		PyObject *seqval = PyObject_GetAttrString(pyobjref, "button_title");
		std::array<float, 3> resarr;
		for (int i = 0; i < 3; i++)
			resarr[i] = (float)PyFloat_AsDouble(PySequence_GetItem(seqval, i));
		return resarr;
	}

	/** Setter:  */
	void button_title(float values[3]) { /* not implemented */ }

	/** Getter:  */
	std::array<float, 3> button_text() {
		// TODO: MISSING DEREF! USE #DEFINE!
		PyObject *seqval = PyObject_GetAttrString(pyobjref, "button_text");
		std::array<float, 3> resarr;
		for (int i = 0; i < 3; i++)
			resarr[i] = (float)PyFloat_AsDouble(PySequence_GetItem(seqval, i));
		return resarr;
	}

	/** Setter:  */
	void button_text(float values[3]) { /* not implemented */ }

	/** Getter:  */
	std::array<float, 3> button_text_hi() {
		// TODO: MISSING DEREF! USE #DEFINE!
		PyObject *seqval = PyObject_GetAttrString(pyobjref, "button_text_hi");
		std::array<float, 3> resarr;
		for (int i = 0; i < 3; i++)
			resarr[i] = (float)PyFloat_AsDouble(PySequence_GetItem(seqval, i));
		return resarr;
	}

	/** Setter:  */
	void button_text_hi(float values[3]) { /* not implemented */ }

	/** Getter:  */
	std::array<float, 3> tab_active() {
		// TODO: MISSING DEREF! USE #DEFINE!
		PyObject *seqval = PyObject_GetAttrString(pyobjref, "tab_active");
		std::array<float, 3> resarr;
		for (int i = 0; i < 3; i++)
			resarr[i] = (float)PyFloat_AsDouble(PySequence_GetItem(seqval, i));
		return resarr;
	}

	/** Setter:  */
	void tab_active(float values[3]) { /* not implemented */ }

	/** Getter:  */
	std::array<float, 3> tab_inactive() {
		// TODO: MISSING DEREF! USE #DEFINE!
		PyObject *seqval = PyObject_GetAttrString(pyobjref, "tab_inactive");
		std::array<float, 3> resarr;
		for (int i = 0; i < 3; i++)
			resarr[i] = (float)PyFloat_AsDouble(PySequence_GetItem(seqval, i));
		return resarr;
	}

	/** Setter:  */
	void tab_inactive(float values[3]) { /* not implemented */ }

	/** Getter:  */
	std::array<float, 4> tab_back() {
		// TODO: MISSING DEREF! USE #DEFINE!
		PyObject *seqval = PyObject_GetAttrString(pyobjref, "tab_back");
		std::array<float, 4> resarr;
		for (int i = 0; i < 4; i++)
			resarr[i] = (float)PyFloat_AsDouble(PySequence_GetItem(seqval, i));
		return resarr;
	}

	/** Setter:  */
	void tab_back(float values[4]) { /* not implemented */ }

	/** Getter:  */
	std::array<float, 3> tab_outline() {
		// TODO: MISSING DEREF! USE #DEFINE!
		PyObject *seqval = PyObject_GetAttrString(pyobjref, "tab_outline");
		std::array<float, 3> resarr;
		for (int i = 0; i < 3; i++)
			resarr[i] = (float)PyFloat_AsDouble(PySequence_GetItem(seqval, i));
		return resarr;
	}

	/** Setter:  */
	void tab_outline(float values[3]) { /* not implemented */ }

};

/**************** Theme Space Settings ****************/

/**
 * 
 */
class ThemeSpaceGradient : public pyUniplug {
public:
	ThemeSpaceGradient(PyObject* pyobj) : pyUniplug(pyobj) {}

	ThemeSpaceGradient() : pyUniplug(0)
	{
		// not implemented
	}

	/** Getter:  */
	ThemeGradientColors gradients() {
		/* not implemented */ throw NULL;
	}

	/** Getter:  */
	std::array<float, 3> title() {
		// TODO: MISSING DEREF! USE #DEFINE!
		PyObject *seqval = PyObject_GetAttrString(pyobjref, "title");
		std::array<float, 3> resarr;
		for (int i = 0; i < 3; i++)
			resarr[i] = (float)PyFloat_AsDouble(PySequence_GetItem(seqval, i));
		return resarr;
	}

	/** Setter:  */
	void title(float values[3]) { /* not implemented */ }

	/** Getter:  */
	std::array<float, 3> text() {
		// TODO: MISSING DEREF! USE #DEFINE!
		PyObject *seqval = PyObject_GetAttrString(pyobjref, "text");
		std::array<float, 3> resarr;
		for (int i = 0; i < 3; i++)
			resarr[i] = (float)PyFloat_AsDouble(PySequence_GetItem(seqval, i));
		return resarr;
	}

	/** Setter:  */
	void text(float values[3]) { /* not implemented */ }

	/** Getter:  */
	std::array<float, 3> text_hi() {
		// TODO: MISSING DEREF! USE #DEFINE!
		PyObject *seqval = PyObject_GetAttrString(pyobjref, "text_hi");
		std::array<float, 3> resarr;
		for (int i = 0; i < 3; i++)
			resarr[i] = (float)PyFloat_AsDouble(PySequence_GetItem(seqval, i));
		return resarr;
	}

	/** Setter:  */
	void text_hi(float values[3]) { /* not implemented */ }

	/** Getter:  */
	std::array<float, 3> header() {
		// TODO: MISSING DEREF! USE #DEFINE!
		PyObject *seqval = PyObject_GetAttrString(pyobjref, "header");
		std::array<float, 3> resarr;
		for (int i = 0; i < 3; i++)
			resarr[i] = (float)PyFloat_AsDouble(PySequence_GetItem(seqval, i));
		return resarr;
	}

	/** Setter:  */
	void header(float values[3]) { /* not implemented */ }

	/** Getter:  */
	std::array<float, 3> header_text() {
		// TODO: MISSING DEREF! USE #DEFINE!
		PyObject *seqval = PyObject_GetAttrString(pyobjref, "header_text");
		std::array<float, 3> resarr;
		for (int i = 0; i < 3; i++)
			resarr[i] = (float)PyFloat_AsDouble(PySequence_GetItem(seqval, i));
		return resarr;
	}

	/** Setter:  */
	void header_text(float values[3]) { /* not implemented */ }

	/** Getter:  */
	std::array<float, 3> header_text_hi() {
		// TODO: MISSING DEREF! USE #DEFINE!
		PyObject *seqval = PyObject_GetAttrString(pyobjref, "header_text_hi");
		std::array<float, 3> resarr;
		for (int i = 0; i < 3; i++)
			resarr[i] = (float)PyFloat_AsDouble(PySequence_GetItem(seqval, i));
		return resarr;
	}

	/** Setter:  */
	void header_text_hi(float values[3]) { /* not implemented */ }

	/** Getter:  */
	ThemePanelColors panelcolors() {
		/* not implemented */ throw NULL;
	}

	/** Getter:  */
	std::array<float, 4> button() {
		// TODO: MISSING DEREF! USE #DEFINE!
		PyObject *seqval = PyObject_GetAttrString(pyobjref, "button");
		std::array<float, 4> resarr;
		for (int i = 0; i < 4; i++)
			resarr[i] = (float)PyFloat_AsDouble(PySequence_GetItem(seqval, i));
		return resarr;
	}

	/** Setter:  */
	void button(float values[4]) { /* not implemented */ }

	/** Getter:  */
	std::array<float, 3> button_title() {
		// TODO: MISSING DEREF! USE #DEFINE!
		PyObject *seqval = PyObject_GetAttrString(pyobjref, "button_title");
		std::array<float, 3> resarr;
		for (int i = 0; i < 3; i++)
			resarr[i] = (float)PyFloat_AsDouble(PySequence_GetItem(seqval, i));
		return resarr;
	}

	/** Setter:  */
	void button_title(float values[3]) { /* not implemented */ }

	/** Getter:  */
	std::array<float, 3> button_text() {
		// TODO: MISSING DEREF! USE #DEFINE!
		PyObject *seqval = PyObject_GetAttrString(pyobjref, "button_text");
		std::array<float, 3> resarr;
		for (int i = 0; i < 3; i++)
			resarr[i] = (float)PyFloat_AsDouble(PySequence_GetItem(seqval, i));
		return resarr;
	}

	/** Setter:  */
	void button_text(float values[3]) { /* not implemented */ }

	/** Getter:  */
	std::array<float, 3> button_text_hi() {
		// TODO: MISSING DEREF! USE #DEFINE!
		PyObject *seqval = PyObject_GetAttrString(pyobjref, "button_text_hi");
		std::array<float, 3> resarr;
		for (int i = 0; i < 3; i++)
			resarr[i] = (float)PyFloat_AsDouble(PySequence_GetItem(seqval, i));
		return resarr;
	}

	/** Setter:  */
	void button_text_hi(float values[3]) { /* not implemented */ }

	/** Getter:  */
	std::array<float, 3> tab_active() {
		// TODO: MISSING DEREF! USE #DEFINE!
		PyObject *seqval = PyObject_GetAttrString(pyobjref, "tab_active");
		std::array<float, 3> resarr;
		for (int i = 0; i < 3; i++)
			resarr[i] = (float)PyFloat_AsDouble(PySequence_GetItem(seqval, i));
		return resarr;
	}

	/** Setter:  */
	void tab_active(float values[3]) { /* not implemented */ }

	/** Getter:  */
	std::array<float, 3> tab_inactive() {
		// TODO: MISSING DEREF! USE #DEFINE!
		PyObject *seqval = PyObject_GetAttrString(pyobjref, "tab_inactive");
		std::array<float, 3> resarr;
		for (int i = 0; i < 3; i++)
			resarr[i] = (float)PyFloat_AsDouble(PySequence_GetItem(seqval, i));
		return resarr;
	}

	/** Setter:  */
	void tab_inactive(float values[3]) { /* not implemented */ }

	/** Getter:  */
	std::array<float, 4> tab_back() {
		// TODO: MISSING DEREF! USE #DEFINE!
		PyObject *seqval = PyObject_GetAttrString(pyobjref, "tab_back");
		std::array<float, 4> resarr;
		for (int i = 0; i < 4; i++)
			resarr[i] = (float)PyFloat_AsDouble(PySequence_GetItem(seqval, i));
		return resarr;
	}

	/** Setter:  */
	void tab_back(float values[4]) { /* not implemented */ }

	/** Getter:  */
	std::array<float, 3> tab_outline() {
		// TODO: MISSING DEREF! USE #DEFINE!
		PyObject *seqval = PyObject_GetAttrString(pyobjref, "tab_outline");
		std::array<float, 3> resarr;
		for (int i = 0; i < 3; i++)
			resarr[i] = (float)PyFloat_AsDouble(PySequence_GetItem(seqval, i));
		return resarr;
	}

	/** Setter:  */
	void tab_outline(float values[3]) { /* not implemented */ }

};

/**************** Theme Space List Settings ****************/

/**
 * 
 */
class ThemeSpaceListGeneric : public pyUniplug {
public:
	ThemeSpaceListGeneric(PyObject* pyobj) : pyUniplug(pyobj) {}

	ThemeSpaceListGeneric() : pyUniplug(0)
	{
		// not implemented
	}

	/** Getter:  */
	std::array<float, 3> list() {
		// TODO: MISSING DEREF! USE #DEFINE!
		PyObject *seqval = PyObject_GetAttrString(pyobjref, "list");
		std::array<float, 3> resarr;
		for (int i = 0; i < 3; i++)
			resarr[i] = (float)PyFloat_AsDouble(PySequence_GetItem(seqval, i));
		return resarr;
	}

	/** Setter:  */
	void list(float values[3]) { /* not implemented */ }

	/** Getter:  */
	std::array<float, 3> list_title() {
		// TODO: MISSING DEREF! USE #DEFINE!
		PyObject *seqval = PyObject_GetAttrString(pyobjref, "list_title");
		std::array<float, 3> resarr;
		for (int i = 0; i < 3; i++)
			resarr[i] = (float)PyFloat_AsDouble(PySequence_GetItem(seqval, i));
		return resarr;
	}

	/** Setter:  */
	void list_title(float values[3]) { /* not implemented */ }

	/** Getter:  */
	std::array<float, 3> list_text() {
		// TODO: MISSING DEREF! USE #DEFINE!
		PyObject *seqval = PyObject_GetAttrString(pyobjref, "list_text");
		std::array<float, 3> resarr;
		for (int i = 0; i < 3; i++)
			resarr[i] = (float)PyFloat_AsDouble(PySequence_GetItem(seqval, i));
		return resarr;
	}

	/** Setter:  */
	void list_text(float values[3]) { /* not implemented */ }

	/** Getter:  */
	std::array<float, 3> list_text_hi() {
		// TODO: MISSING DEREF! USE #DEFINE!
		PyObject *seqval = PyObject_GetAttrString(pyobjref, "list_text_hi");
		std::array<float, 3> resarr;
		for (int i = 0; i < 3; i++)
			resarr[i] = (float)PyFloat_AsDouble(PySequence_GetItem(seqval, i));
		return resarr;
	}

	/** Setter:  */
	void list_text_hi(float values[3]) { /* not implemented */ }

};

/**************** Theme 3D View ****************/

/**
 * Theme settings for the 3D View
 */
class ThemeView3D : public pyUniplug {
public:
	ThemeView3D(PyObject* pyobj) : pyUniplug(pyobj) {}

	ThemeView3D() : pyUniplug(0)
	{
		// not implemented
	}

	/** Getter: Settings for space */
	ThemeSpaceGradient space() {
		/* not implemented */ throw NULL;
	}

	/** Getter:  */
	std::array<float, 3> grid() {
		// TODO: MISSING DEREF! USE #DEFINE!
		PyObject *seqval = PyObject_GetAttrString(pyobjref, "grid");
		std::array<float, 3> resarr;
		for (int i = 0; i < 3; i++)
			resarr[i] = (float)PyFloat_AsDouble(PySequence_GetItem(seqval, i));
		return resarr;
	}

	/** Setter:  */
	void grid(float values[3]) { /* not implemented */ }

	/** Getter:  */
	std::array<float, 3> wire() {
		// TODO: MISSING DEREF! USE #DEFINE!
		PyObject *seqval = PyObject_GetAttrString(pyobjref, "wire");
		std::array<float, 3> resarr;
		for (int i = 0; i < 3; i++)
			resarr[i] = (float)PyFloat_AsDouble(PySequence_GetItem(seqval, i));
		return resarr;
	}

	/** Setter:  */
	void wire(float values[3]) { /* not implemented */ }

	/** Getter:  */
	std::array<float, 3> wire_edit() {
		// TODO: MISSING DEREF! USE #DEFINE!
		PyObject *seqval = PyObject_GetAttrString(pyobjref, "wire_edit");
		std::array<float, 3> resarr;
		for (int i = 0; i < 3; i++)
			resarr[i] = (float)PyFloat_AsDouble(PySequence_GetItem(seqval, i));
		return resarr;
	}

	/** Setter:  */
	void wire_edit(float values[3]) { /* not implemented */ }

	/** Getter:  */
	std::array<float, 3> gp_vertex() {
		// TODO: MISSING DEREF! USE #DEFINE!
		PyObject *seqval = PyObject_GetAttrString(pyobjref, "gp_vertex");
		std::array<float, 3> resarr;
		for (int i = 0; i < 3; i++)
			resarr[i] = (float)PyFloat_AsDouble(PySequence_GetItem(seqval, i));
		return resarr;
	}

	/** Setter:  */
	void gp_vertex(float values[3]) { /* not implemented */ }

	/** Getter:  */
	std::array<float, 3> gp_vertex_select() {
		// TODO: MISSING DEREF! USE #DEFINE!
		PyObject *seqval = PyObject_GetAttrString(pyobjref, "gp_vertex_select");
		std::array<float, 3> resarr;
		for (int i = 0; i < 3; i++)
			resarr[i] = (float)PyFloat_AsDouble(PySequence_GetItem(seqval, i));
		return resarr;
	}

	/** Setter:  */
	void gp_vertex_select(float values[3]) { /* not implemented */ }

	/** Getter:  */
	int gp_vertex_size() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "gp_vertex_size"));
	}

	/** Setter:  */
	void gp_vertex_size(int value) {
		PyObject_SetAttrString(pyobjref, "gp_vertex_size", Py_BuildValue("i", value));
	}

	/** Getter:  */
	std::array<float, 4> lamp() {
		// TODO: MISSING DEREF! USE #DEFINE!
		PyObject *seqval = PyObject_GetAttrString(pyobjref, "lamp");
		std::array<float, 4> resarr;
		for (int i = 0; i < 4; i++)
			resarr[i] = (float)PyFloat_AsDouble(PySequence_GetItem(seqval, i));
		return resarr;
	}

	/** Setter:  */
	void lamp(float values[4]) { /* not implemented */ }

	/** Getter:  */
	std::array<float, 3> speaker() {
		// TODO: MISSING DEREF! USE #DEFINE!
		PyObject *seqval = PyObject_GetAttrString(pyobjref, "speaker");
		std::array<float, 3> resarr;
		for (int i = 0; i < 3; i++)
			resarr[i] = (float)PyFloat_AsDouble(PySequence_GetItem(seqval, i));
		return resarr;
	}

	/** Setter:  */
	void speaker(float values[3]) { /* not implemented */ }

	/** Getter:  */
	std::array<float, 3> camera() {
		// TODO: MISSING DEREF! USE #DEFINE!
		PyObject *seqval = PyObject_GetAttrString(pyobjref, "camera");
		std::array<float, 3> resarr;
		for (int i = 0; i < 3; i++)
			resarr[i] = (float)PyFloat_AsDouble(PySequence_GetItem(seqval, i));
		return resarr;
	}

	/** Setter:  */
	void camera(float values[3]) { /* not implemented */ }

	/** Getter:  */
	std::array<float, 3> view_overlay() {
		// TODO: MISSING DEREF! USE #DEFINE!
		PyObject *seqval = PyObject_GetAttrString(pyobjref, "view_overlay");
		std::array<float, 3> resarr;
		for (int i = 0; i < 3; i++)
			resarr[i] = (float)PyFloat_AsDouble(PySequence_GetItem(seqval, i));
		return resarr;
	}

	/** Setter:  */
	void view_overlay(float values[3]) { /* not implemented */ }

	/** Getter:  */
	std::array<float, 3> empty() {
		// TODO: MISSING DEREF! USE #DEFINE!
		PyObject *seqval = PyObject_GetAttrString(pyobjref, "empty");
		std::array<float, 3> resarr;
		for (int i = 0; i < 3; i++)
			resarr[i] = (float)PyFloat_AsDouble(PySequence_GetItem(seqval, i));
		return resarr;
	}

	/** Setter:  */
	void empty(float values[3]) { /* not implemented */ }

	/** Getter:  */
	std::array<float, 3> object_selected() {
		// TODO: MISSING DEREF! USE #DEFINE!
		PyObject *seqval = PyObject_GetAttrString(pyobjref, "object_selected");
		std::array<float, 3> resarr;
		for (int i = 0; i < 3; i++)
			resarr[i] = (float)PyFloat_AsDouble(PySequence_GetItem(seqval, i));
		return resarr;
	}

	/** Setter:  */
	void object_selected(float values[3]) { /* not implemented */ }

	/** Getter:  */
	std::array<float, 3> object_active() {
		// TODO: MISSING DEREF! USE #DEFINE!
		PyObject *seqval = PyObject_GetAttrString(pyobjref, "object_active");
		std::array<float, 3> resarr;
		for (int i = 0; i < 3; i++)
			resarr[i] = (float)PyFloat_AsDouble(PySequence_GetItem(seqval, i));
		return resarr;
	}

	/** Setter:  */
	void object_active(float values[3]) { /* not implemented */ }

	/** Getter:  */
	std::array<float, 3> object_grouped() {
		// TODO: MISSING DEREF! USE #DEFINE!
		PyObject *seqval = PyObject_GetAttrString(pyobjref, "object_grouped");
		std::array<float, 3> resarr;
		for (int i = 0; i < 3; i++)
			resarr[i] = (float)PyFloat_AsDouble(PySequence_GetItem(seqval, i));
		return resarr;
	}

	/** Setter:  */
	void object_grouped(float values[3]) { /* not implemented */ }

	/** Getter:  */
	std::array<float, 3> object_grouped_active() {
		// TODO: MISSING DEREF! USE #DEFINE!
		PyObject *seqval = PyObject_GetAttrString(pyobjref, "object_grouped_active");
		std::array<float, 3> resarr;
		for (int i = 0; i < 3; i++)
			resarr[i] = (float)PyFloat_AsDouble(PySequence_GetItem(seqval, i));
		return resarr;
	}

	/** Setter:  */
	void object_grouped_active(float values[3]) { /* not implemented */ }

	/** Getter:  */
	std::array<float, 3> transform() {
		// TODO: MISSING DEREF! USE #DEFINE!
		PyObject *seqval = PyObject_GetAttrString(pyobjref, "transform");
		std::array<float, 3> resarr;
		for (int i = 0; i < 3; i++)
			resarr[i] = (float)PyFloat_AsDouble(PySequence_GetItem(seqval, i));
		return resarr;
	}

	/** Setter:  */
	void transform(float values[3]) { /* not implemented */ }

	/** Getter:  */
	std::array<float, 3> vertex() {
		// TODO: MISSING DEREF! USE #DEFINE!
		PyObject *seqval = PyObject_GetAttrString(pyobjref, "vertex");
		std::array<float, 3> resarr;
		for (int i = 0; i < 3; i++)
			resarr[i] = (float)PyFloat_AsDouble(PySequence_GetItem(seqval, i));
		return resarr;
	}

	/** Setter:  */
	void vertex(float values[3]) { /* not implemented */ }

	/** Getter:  */
	std::array<float, 3> vertex_select() {
		// TODO: MISSING DEREF! USE #DEFINE!
		PyObject *seqval = PyObject_GetAttrString(pyobjref, "vertex_select");
		std::array<float, 3> resarr;
		for (int i = 0; i < 3; i++)
			resarr[i] = (float)PyFloat_AsDouble(PySequence_GetItem(seqval, i));
		return resarr;
	}

	/** Setter:  */
	void vertex_select(float values[3]) { /* not implemented */ }

	/** Getter:  */
	int vertex_size() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "vertex_size"));
	}

	/** Setter:  */
	void vertex_size(int value) {
		PyObject_SetAttrString(pyobjref, "vertex_size", Py_BuildValue("i", value));
	}

	/** Getter:  */
	std::array<float, 3> vertex_unreferenced() {
		// TODO: MISSING DEREF! USE #DEFINE!
		PyObject *seqval = PyObject_GetAttrString(pyobjref, "vertex_unreferenced");
		std::array<float, 3> resarr;
		for (int i = 0; i < 3; i++)
			resarr[i] = (float)PyFloat_AsDouble(PySequence_GetItem(seqval, i));
		return resarr;
	}

	/** Setter:  */
	void vertex_unreferenced(float values[3]) { /* not implemented */ }

	/** Getter:  */
	std::array<float, 3> edge_select() {
		// TODO: MISSING DEREF! USE #DEFINE!
		PyObject *seqval = PyObject_GetAttrString(pyobjref, "edge_select");
		std::array<float, 3> resarr;
		for (int i = 0; i < 3; i++)
			resarr[i] = (float)PyFloat_AsDouble(PySequence_GetItem(seqval, i));
		return resarr;
	}

	/** Setter:  */
	void edge_select(float values[3]) { /* not implemented */ }

	/** Getter:  */
	std::array<float, 3> edge_seam() {
		// TODO: MISSING DEREF! USE #DEFINE!
		PyObject *seqval = PyObject_GetAttrString(pyobjref, "edge_seam");
		std::array<float, 3> resarr;
		for (int i = 0; i < 3; i++)
			resarr[i] = (float)PyFloat_AsDouble(PySequence_GetItem(seqval, i));
		return resarr;
	}

	/** Setter:  */
	void edge_seam(float values[3]) { /* not implemented */ }

	/** Getter:  */
	std::array<float, 3> edge_sharp() {
		// TODO: MISSING DEREF! USE #DEFINE!
		PyObject *seqval = PyObject_GetAttrString(pyobjref, "edge_sharp");
		std::array<float, 3> resarr;
		for (int i = 0; i < 3; i++)
			resarr[i] = (float)PyFloat_AsDouble(PySequence_GetItem(seqval, i));
		return resarr;
	}

	/** Setter:  */
	void edge_sharp(float values[3]) { /* not implemented */ }

	/** Getter:  */
	std::array<float, 3> edge_crease() {
		// TODO: MISSING DEREF! USE #DEFINE!
		PyObject *seqval = PyObject_GetAttrString(pyobjref, "edge_crease");
		std::array<float, 3> resarr;
		for (int i = 0; i < 3; i++)
			resarr[i] = (float)PyFloat_AsDouble(PySequence_GetItem(seqval, i));
		return resarr;
	}

	/** Setter:  */
	void edge_crease(float values[3]) { /* not implemented */ }

	/** Getter:  */
	std::array<float, 3> edge_facesel() {
		// TODO: MISSING DEREF! USE #DEFINE!
		PyObject *seqval = PyObject_GetAttrString(pyobjref, "edge_facesel");
		std::array<float, 3> resarr;
		for (int i = 0; i < 3; i++)
			resarr[i] = (float)PyFloat_AsDouble(PySequence_GetItem(seqval, i));
		return resarr;
	}

	/** Setter:  */
	void edge_facesel(float values[3]) { /* not implemented */ }

	/** Getter:  */
	std::array<float, 3> freestyle_edge_mark() {
		// TODO: MISSING DEREF! USE #DEFINE!
		PyObject *seqval = PyObject_GetAttrString(pyobjref, "freestyle_edge_mark");
		std::array<float, 3> resarr;
		for (int i = 0; i < 3; i++)
			resarr[i] = (float)PyFloat_AsDouble(PySequence_GetItem(seqval, i));
		return resarr;
	}

	/** Setter:  */
	void freestyle_edge_mark(float values[3]) { /* not implemented */ }

	/** Getter:  */
	std::array<float, 4> face() {
		// TODO: MISSING DEREF! USE #DEFINE!
		PyObject *seqval = PyObject_GetAttrString(pyobjref, "face");
		std::array<float, 4> resarr;
		for (int i = 0; i < 4; i++)
			resarr[i] = (float)PyFloat_AsDouble(PySequence_GetItem(seqval, i));
		return resarr;
	}

	/** Setter:  */
	void face(float values[4]) { /* not implemented */ }

	/** Getter:  */
	std::array<float, 4> face_select() {
		// TODO: MISSING DEREF! USE #DEFINE!
		PyObject *seqval = PyObject_GetAttrString(pyobjref, "face_select");
		std::array<float, 4> resarr;
		for (int i = 0; i < 4; i++)
			resarr[i] = (float)PyFloat_AsDouble(PySequence_GetItem(seqval, i));
		return resarr;
	}

	/** Setter:  */
	void face_select(float values[4]) { /* not implemented */ }

	/** Getter:  */
	std::array<float, 3> face_dot() {
		// TODO: MISSING DEREF! USE #DEFINE!
		PyObject *seqval = PyObject_GetAttrString(pyobjref, "face_dot");
		std::array<float, 3> resarr;
		for (int i = 0; i < 3; i++)
			resarr[i] = (float)PyFloat_AsDouble(PySequence_GetItem(seqval, i));
		return resarr;
	}

	/** Setter:  */
	void face_dot(float values[3]) { /* not implemented */ }

	/** Getter:  */
	int facedot_size() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "facedot_size"));
	}

	/** Setter:  */
	void facedot_size(int value) {
		PyObject_SetAttrString(pyobjref, "facedot_size", Py_BuildValue("i", value));
	}

	/** Getter:  */
	std::array<float, 4> freestyle_face_mark() {
		// TODO: MISSING DEREF! USE #DEFINE!
		PyObject *seqval = PyObject_GetAttrString(pyobjref, "freestyle_face_mark");
		std::array<float, 4> resarr;
		for (int i = 0; i < 4; i++)
			resarr[i] = (float)PyFloat_AsDouble(PySequence_GetItem(seqval, i));
		return resarr;
	}

	/** Setter:  */
	void freestyle_face_mark(float values[4]) { /* not implemented */ }

	/** Getter:  */
	std::array<float, 3> nurb_uline() {
		// TODO: MISSING DEREF! USE #DEFINE!
		PyObject *seqval = PyObject_GetAttrString(pyobjref, "nurb_uline");
		std::array<float, 3> resarr;
		for (int i = 0; i < 3; i++)
			resarr[i] = (float)PyFloat_AsDouble(PySequence_GetItem(seqval, i));
		return resarr;
	}

	/** Setter:  */
	void nurb_uline(float values[3]) { /* not implemented */ }

	/** Getter:  */
	std::array<float, 3> nurb_vline() {
		// TODO: MISSING DEREF! USE #DEFINE!
		PyObject *seqval = PyObject_GetAttrString(pyobjref, "nurb_vline");
		std::array<float, 3> resarr;
		for (int i = 0; i < 3; i++)
			resarr[i] = (float)PyFloat_AsDouble(PySequence_GetItem(seqval, i));
		return resarr;
	}

	/** Setter:  */
	void nurb_vline(float values[3]) { /* not implemented */ }

	/** Getter:  */
	std::array<float, 3> nurb_sel_uline() {
		// TODO: MISSING DEREF! USE #DEFINE!
		PyObject *seqval = PyObject_GetAttrString(pyobjref, "nurb_sel_uline");
		std::array<float, 3> resarr;
		for (int i = 0; i < 3; i++)
			resarr[i] = (float)PyFloat_AsDouble(PySequence_GetItem(seqval, i));
		return resarr;
	}

	/** Setter:  */
	void nurb_sel_uline(float values[3]) { /* not implemented */ }

	/** Getter:  */
	std::array<float, 3> nurb_sel_vline() {
		// TODO: MISSING DEREF! USE #DEFINE!
		PyObject *seqval = PyObject_GetAttrString(pyobjref, "nurb_sel_vline");
		std::array<float, 3> resarr;
		for (int i = 0; i < 3; i++)
			resarr[i] = (float)PyFloat_AsDouble(PySequence_GetItem(seqval, i));
		return resarr;
	}

	/** Setter:  */
	void nurb_sel_vline(float values[3]) { /* not implemented */ }

	/** Getter:  */
	std::array<float, 3> act_spline() {
		// TODO: MISSING DEREF! USE #DEFINE!
		PyObject *seqval = PyObject_GetAttrString(pyobjref, "act_spline");
		std::array<float, 3> resarr;
		for (int i = 0; i < 3; i++)
			resarr[i] = (float)PyFloat_AsDouble(PySequence_GetItem(seqval, i));
		return resarr;
	}

	/** Setter:  */
	void act_spline(float values[3]) { /* not implemented */ }

	/** Getter:  */
	std::array<float, 3> handle_free() {
		// TODO: MISSING DEREF! USE #DEFINE!
		PyObject *seqval = PyObject_GetAttrString(pyobjref, "handle_free");
		std::array<float, 3> resarr;
		for (int i = 0; i < 3; i++)
			resarr[i] = (float)PyFloat_AsDouble(PySequence_GetItem(seqval, i));
		return resarr;
	}

	/** Setter:  */
	void handle_free(float values[3]) { /* not implemented */ }

	/** Getter:  */
	std::array<float, 3> handle_auto() {
		// TODO: MISSING DEREF! USE #DEFINE!
		PyObject *seqval = PyObject_GetAttrString(pyobjref, "handle_auto");
		std::array<float, 3> resarr;
		for (int i = 0; i < 3; i++)
			resarr[i] = (float)PyFloat_AsDouble(PySequence_GetItem(seqval, i));
		return resarr;
	}

	/** Setter:  */
	void handle_auto(float values[3]) { /* not implemented */ }

	/** Getter:  */
	std::array<float, 3> handle_vect() {
		// TODO: MISSING DEREF! USE #DEFINE!
		PyObject *seqval = PyObject_GetAttrString(pyobjref, "handle_vect");
		std::array<float, 3> resarr;
		for (int i = 0; i < 3; i++)
			resarr[i] = (float)PyFloat_AsDouble(PySequence_GetItem(seqval, i));
		return resarr;
	}

	/** Setter:  */
	void handle_vect(float values[3]) { /* not implemented */ }

	/** Getter:  */
	std::array<float, 3> handle_sel_vect() {
		// TODO: MISSING DEREF! USE #DEFINE!
		PyObject *seqval = PyObject_GetAttrString(pyobjref, "handle_sel_vect");
		std::array<float, 3> resarr;
		for (int i = 0; i < 3; i++)
			resarr[i] = (float)PyFloat_AsDouble(PySequence_GetItem(seqval, i));
		return resarr;
	}

	/** Setter:  */
	void handle_sel_vect(float values[3]) { /* not implemented */ }

	/** Getter:  */
	std::array<float, 3> handle_align() {
		// TODO: MISSING DEREF! USE #DEFINE!
		PyObject *seqval = PyObject_GetAttrString(pyobjref, "handle_align");
		std::array<float, 3> resarr;
		for (int i = 0; i < 3; i++)
			resarr[i] = (float)PyFloat_AsDouble(PySequence_GetItem(seqval, i));
		return resarr;
	}

	/** Setter:  */
	void handle_align(float values[3]) { /* not implemented */ }

	/** Getter:  */
	std::array<float, 3> handle_sel_free() {
		// TODO: MISSING DEREF! USE #DEFINE!
		PyObject *seqval = PyObject_GetAttrString(pyobjref, "handle_sel_free");
		std::array<float, 3> resarr;
		for (int i = 0; i < 3; i++)
			resarr[i] = (float)PyFloat_AsDouble(PySequence_GetItem(seqval, i));
		return resarr;
	}

	/** Setter:  */
	void handle_sel_free(float values[3]) { /* not implemented */ }

	/** Getter:  */
	std::array<float, 3> handle_sel_auto() {
		// TODO: MISSING DEREF! USE #DEFINE!
		PyObject *seqval = PyObject_GetAttrString(pyobjref, "handle_sel_auto");
		std::array<float, 3> resarr;
		for (int i = 0; i < 3; i++)
			resarr[i] = (float)PyFloat_AsDouble(PySequence_GetItem(seqval, i));
		return resarr;
	}

	/** Setter:  */
	void handle_sel_auto(float values[3]) { /* not implemented */ }

	/** Getter:  */
	std::array<float, 3> handle_sel_align() {
		// TODO: MISSING DEREF! USE #DEFINE!
		PyObject *seqval = PyObject_GetAttrString(pyobjref, "handle_sel_align");
		std::array<float, 3> resarr;
		for (int i = 0; i < 3; i++)
			resarr[i] = (float)PyFloat_AsDouble(PySequence_GetItem(seqval, i));
		return resarr;
	}

	/** Setter:  */
	void handle_sel_align(float values[3]) { /* not implemented */ }

	/** Getter:  */
	std::array<float, 3> lastsel_point() {
		// TODO: MISSING DEREF! USE #DEFINE!
		PyObject *seqval = PyObject_GetAttrString(pyobjref, "lastsel_point");
		std::array<float, 3> resarr;
		for (int i = 0; i < 3; i++)
			resarr[i] = (float)PyFloat_AsDouble(PySequence_GetItem(seqval, i));
		return resarr;
	}

	/** Setter:  */
	void lastsel_point(float values[3]) { /* not implemented */ }

	/** Getter:  */
	std::array<float, 3> extra_edge_len() {
		// TODO: MISSING DEREF! USE #DEFINE!
		PyObject *seqval = PyObject_GetAttrString(pyobjref, "extra_edge_len");
		std::array<float, 3> resarr;
		for (int i = 0; i < 3; i++)
			resarr[i] = (float)PyFloat_AsDouble(PySequence_GetItem(seqval, i));
		return resarr;
	}

	/** Setter:  */
	void extra_edge_len(float values[3]) { /* not implemented */ }

	/** Getter:  */
	std::array<float, 3> extra_edge_angle() {
		// TODO: MISSING DEREF! USE #DEFINE!
		PyObject *seqval = PyObject_GetAttrString(pyobjref, "extra_edge_angle");
		std::array<float, 3> resarr;
		for (int i = 0; i < 3; i++)
			resarr[i] = (float)PyFloat_AsDouble(PySequence_GetItem(seqval, i));
		return resarr;
	}

	/** Setter:  */
	void extra_edge_angle(float values[3]) { /* not implemented */ }

	/** Getter:  */
	std::array<float, 3> extra_face_angle() {
		// TODO: MISSING DEREF! USE #DEFINE!
		PyObject *seqval = PyObject_GetAttrString(pyobjref, "extra_face_angle");
		std::array<float, 3> resarr;
		for (int i = 0; i < 3; i++)
			resarr[i] = (float)PyFloat_AsDouble(PySequence_GetItem(seqval, i));
		return resarr;
	}

	/** Setter:  */
	void extra_face_angle(float values[3]) { /* not implemented */ }

	/** Getter:  */
	std::array<float, 3> extra_face_area() {
		// TODO: MISSING DEREF! USE #DEFINE!
		PyObject *seqval = PyObject_GetAttrString(pyobjref, "extra_face_area");
		std::array<float, 3> resarr;
		for (int i = 0; i < 3; i++)
			resarr[i] = (float)PyFloat_AsDouble(PySequence_GetItem(seqval, i));
		return resarr;
	}

	/** Setter:  */
	void extra_face_area(float values[3]) { /* not implemented */ }

	/** Getter:  */
	std::array<float, 4> editmesh_active() {
		// TODO: MISSING DEREF! USE #DEFINE!
		PyObject *seqval = PyObject_GetAttrString(pyobjref, "editmesh_active");
		std::array<float, 4> resarr;
		for (int i = 0; i < 4; i++)
			resarr[i] = (float)PyFloat_AsDouble(PySequence_GetItem(seqval, i));
		return resarr;
	}

	/** Setter:  */
	void editmesh_active(float values[4]) { /* not implemented */ }

	/** Getter:  */
	std::array<float, 3> normal() {
		// TODO: MISSING DEREF! USE #DEFINE!
		PyObject *seqval = PyObject_GetAttrString(pyobjref, "normal");
		std::array<float, 3> resarr;
		for (int i = 0; i < 3; i++)
			resarr[i] = (float)PyFloat_AsDouble(PySequence_GetItem(seqval, i));
		return resarr;
	}

	/** Setter:  */
	void normal(float values[3]) { /* not implemented */ }

	/** Getter:  */
	std::array<float, 3> vertex_normal() {
		// TODO: MISSING DEREF! USE #DEFINE!
		PyObject *seqval = PyObject_GetAttrString(pyobjref, "vertex_normal");
		std::array<float, 3> resarr;
		for (int i = 0; i < 3; i++)
			resarr[i] = (float)PyFloat_AsDouble(PySequence_GetItem(seqval, i));
		return resarr;
	}

	/** Setter:  */
	void vertex_normal(float values[3]) { /* not implemented */ }

	/** Getter:  */
	std::array<float, 3> split_normal() {
		// TODO: MISSING DEREF! USE #DEFINE!
		PyObject *seqval = PyObject_GetAttrString(pyobjref, "split_normal");
		std::array<float, 3> resarr;
		for (int i = 0; i < 3; i++)
			resarr[i] = (float)PyFloat_AsDouble(PySequence_GetItem(seqval, i));
		return resarr;
	}

	/** Setter:  */
	void split_normal(float values[3]) { /* not implemented */ }

	/** Getter:  */
	std::array<float, 3> bone_solid() {
		// TODO: MISSING DEREF! USE #DEFINE!
		PyObject *seqval = PyObject_GetAttrString(pyobjref, "bone_solid");
		std::array<float, 3> resarr;
		for (int i = 0; i < 3; i++)
			resarr[i] = (float)PyFloat_AsDouble(PySequence_GetItem(seqval, i));
		return resarr;
	}

	/** Setter:  */
	void bone_solid(float values[3]) { /* not implemented */ }

	/** Getter:  */
	std::array<float, 3> bone_pose() {
		// TODO: MISSING DEREF! USE #DEFINE!
		PyObject *seqval = PyObject_GetAttrString(pyobjref, "bone_pose");
		std::array<float, 3> resarr;
		for (int i = 0; i < 3; i++)
			resarr[i] = (float)PyFloat_AsDouble(PySequence_GetItem(seqval, i));
		return resarr;
	}

	/** Setter:  */
	void bone_pose(float values[3]) { /* not implemented */ }

	/** Getter:  */
	std::array<float, 3> bone_pose_active() {
		// TODO: MISSING DEREF! USE #DEFINE!
		PyObject *seqval = PyObject_GetAttrString(pyobjref, "bone_pose_active");
		std::array<float, 3> resarr;
		for (int i = 0; i < 3; i++)
			resarr[i] = (float)PyFloat_AsDouble(PySequence_GetItem(seqval, i));
		return resarr;
	}

	/** Setter:  */
	void bone_pose_active(float values[3]) { /* not implemented */ }

	/** Getter:  */
	std::array<float, 3> frame_current() {
		// TODO: MISSING DEREF! USE #DEFINE!
		PyObject *seqval = PyObject_GetAttrString(pyobjref, "frame_current");
		std::array<float, 3> resarr;
		for (int i = 0; i < 3; i++)
			resarr[i] = (float)PyFloat_AsDouble(PySequence_GetItem(seqval, i));
		return resarr;
	}

	/** Setter:  */
	void frame_current(float values[3]) { /* not implemented */ }

	/** Getter:  */
	int outline_width() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "outline_width"));
	}

	/** Setter:  */
	void outline_width(int value) {
		PyObject_SetAttrString(pyobjref, "outline_width", Py_BuildValue("i", value));
	}

	/** Getter:  */
	std::array<float, 3> bundle_solid() {
		// TODO: MISSING DEREF! USE #DEFINE!
		PyObject *seqval = PyObject_GetAttrString(pyobjref, "bundle_solid");
		std::array<float, 3> resarr;
		for (int i = 0; i < 3; i++)
			resarr[i] = (float)PyFloat_AsDouble(PySequence_GetItem(seqval, i));
		return resarr;
	}

	/** Setter:  */
	void bundle_solid(float values[3]) { /* not implemented */ }

	/** Getter:  */
	std::array<float, 3> camera_path() {
		// TODO: MISSING DEREF! USE #DEFINE!
		PyObject *seqval = PyObject_GetAttrString(pyobjref, "camera_path");
		std::array<float, 3> resarr;
		for (int i = 0; i < 3; i++)
			resarr[i] = (float)PyFloat_AsDouble(PySequence_GetItem(seqval, i));
		return resarr;
	}

	/** Setter:  */
	void camera_path(float values[3]) { /* not implemented */ }

	/** Getter:  */
	std::array<float, 3> skin_root() {
		// TODO: MISSING DEREF! USE #DEFINE!
		PyObject *seqval = PyObject_GetAttrString(pyobjref, "skin_root");
		std::array<float, 3> resarr;
		for (int i = 0; i < 3; i++)
			resarr[i] = (float)PyFloat_AsDouble(PySequence_GetItem(seqval, i));
		return resarr;
	}

	/** Setter:  */
	void skin_root(float values[3]) { /* not implemented */ }

	/** Getter:  */
	std::array<float, 4> clipping_border_3d() {
		// TODO: MISSING DEREF! USE #DEFINE!
		PyObject *seqval = PyObject_GetAttrString(pyobjref, "clipping_border_3d");
		std::array<float, 4> resarr;
		for (int i = 0; i < 4; i++)
			resarr[i] = (float)PyFloat_AsDouble(PySequence_GetItem(seqval, i));
		return resarr;
	}

	/** Setter:  */
	void clipping_border_3d(float values[4]) { /* not implemented */ }

	/** Getter:  */
	std::array<float, 4> paint_curve_handle() {
		// TODO: MISSING DEREF! USE #DEFINE!
		PyObject *seqval = PyObject_GetAttrString(pyobjref, "paint_curve_handle");
		std::array<float, 4> resarr;
		for (int i = 0; i < 4; i++)
			resarr[i] = (float)PyFloat_AsDouble(PySequence_GetItem(seqval, i));
		return resarr;
	}

	/** Setter:  */
	void paint_curve_handle(float values[4]) { /* not implemented */ }

	/** Getter:  */
	std::array<float, 4> paint_curve_pivot() {
		// TODO: MISSING DEREF! USE #DEFINE!
		PyObject *seqval = PyObject_GetAttrString(pyobjref, "paint_curve_pivot");
		std::array<float, 4> resarr;
		for (int i = 0; i < 4; i++)
			resarr[i] = (float)PyFloat_AsDouble(PySequence_GetItem(seqval, i));
		return resarr;
	}

	/** Setter:  */
	void paint_curve_pivot(float values[4]) { /* not implemented */ }

};

/**************** Theme Graph Editor ****************/

/**
 * Theme settings for the graph editor
 */
class ThemeGraphEditor : public pyUniplug {
public:
	ThemeGraphEditor(PyObject* pyobj) : pyUniplug(pyobj) {}

	ThemeGraphEditor() : pyUniplug(0)
	{
		// not implemented
	}

	/** Getter: Settings for space */
	ThemeSpaceGeneric space() {
		/* not implemented */ throw NULL;
	}

	/** Getter: Settings for space list */
	ThemeSpaceListGeneric space_list() {
		/* not implemented */ throw NULL;
	}

	/** Getter:  */
	std::array<float, 3> grid() {
		// TODO: MISSING DEREF! USE #DEFINE!
		PyObject *seqval = PyObject_GetAttrString(pyobjref, "grid");
		std::array<float, 3> resarr;
		for (int i = 0; i < 3; i++)
			resarr[i] = (float)PyFloat_AsDouble(PySequence_GetItem(seqval, i));
		return resarr;
	}

	/** Setter:  */
	void grid(float values[3]) { /* not implemented */ }

	/** Getter:  */
	std::array<float, 3> frame_current() {
		// TODO: MISSING DEREF! USE #DEFINE!
		PyObject *seqval = PyObject_GetAttrString(pyobjref, "frame_current");
		std::array<float, 3> resarr;
		for (int i = 0; i < 3; i++)
			resarr[i] = (float)PyFloat_AsDouble(PySequence_GetItem(seqval, i));
		return resarr;
	}

	/** Setter:  */
	void frame_current(float values[3]) { /* not implemented */ }

	/** Getter:  */
	std::array<float, 3> window_sliders() {
		// TODO: MISSING DEREF! USE #DEFINE!
		PyObject *seqval = PyObject_GetAttrString(pyobjref, "window_sliders");
		std::array<float, 3> resarr;
		for (int i = 0; i < 3; i++)
			resarr[i] = (float)PyFloat_AsDouble(PySequence_GetItem(seqval, i));
		return resarr;
	}

	/** Setter:  */
	void window_sliders(float values[3]) { /* not implemented */ }

	/** Getter:  */
	std::array<float, 3> channels_region() {
		// TODO: MISSING DEREF! USE #DEFINE!
		PyObject *seqval = PyObject_GetAttrString(pyobjref, "channels_region");
		std::array<float, 3> resarr;
		for (int i = 0; i < 3; i++)
			resarr[i] = (float)PyFloat_AsDouble(PySequence_GetItem(seqval, i));
		return resarr;
	}

	/** Setter:  */
	void channels_region(float values[3]) { /* not implemented */ }

	/** Getter:  */
	std::array<float, 3> dopesheet_channel() {
		// TODO: MISSING DEREF! USE #DEFINE!
		PyObject *seqval = PyObject_GetAttrString(pyobjref, "dopesheet_channel");
		std::array<float, 3> resarr;
		for (int i = 0; i < 3; i++)
			resarr[i] = (float)PyFloat_AsDouble(PySequence_GetItem(seqval, i));
		return resarr;
	}

	/** Setter:  */
	void dopesheet_channel(float values[3]) { /* not implemented */ }

	/** Getter:  */
	std::array<float, 3> dopesheet_subchannel() {
		// TODO: MISSING DEREF! USE #DEFINE!
		PyObject *seqval = PyObject_GetAttrString(pyobjref, "dopesheet_subchannel");
		std::array<float, 3> resarr;
		for (int i = 0; i < 3; i++)
			resarr[i] = (float)PyFloat_AsDouble(PySequence_GetItem(seqval, i));
		return resarr;
	}

	/** Setter:  */
	void dopesheet_subchannel(float values[3]) { /* not implemented */ }

	/** Getter:  */
	std::array<float, 3> channel_group() {
		// TODO: MISSING DEREF! USE #DEFINE!
		PyObject *seqval = PyObject_GetAttrString(pyobjref, "channel_group");
		std::array<float, 3> resarr;
		for (int i = 0; i < 3; i++)
			resarr[i] = (float)PyFloat_AsDouble(PySequence_GetItem(seqval, i));
		return resarr;
	}

	/** Setter:  */
	void channel_group(float values[3]) { /* not implemented */ }

	/** Getter:  */
	std::array<float, 3> active_channels_group() {
		// TODO: MISSING DEREF! USE #DEFINE!
		PyObject *seqval = PyObject_GetAttrString(pyobjref, "active_channels_group");
		std::array<float, 3> resarr;
		for (int i = 0; i < 3; i++)
			resarr[i] = (float)PyFloat_AsDouble(PySequence_GetItem(seqval, i));
		return resarr;
	}

	/** Setter:  */
	void active_channels_group(float values[3]) { /* not implemented */ }

	/** Getter:  */
	std::array<float, 3> vertex() {
		// TODO: MISSING DEREF! USE #DEFINE!
		PyObject *seqval = PyObject_GetAttrString(pyobjref, "vertex");
		std::array<float, 3> resarr;
		for (int i = 0; i < 3; i++)
			resarr[i] = (float)PyFloat_AsDouble(PySequence_GetItem(seqval, i));
		return resarr;
	}

	/** Setter:  */
	void vertex(float values[3]) { /* not implemented */ }

	/** Getter:  */
	std::array<float, 3> vertex_select() {
		// TODO: MISSING DEREF! USE #DEFINE!
		PyObject *seqval = PyObject_GetAttrString(pyobjref, "vertex_select");
		std::array<float, 3> resarr;
		for (int i = 0; i < 3; i++)
			resarr[i] = (float)PyFloat_AsDouble(PySequence_GetItem(seqval, i));
		return resarr;
	}

	/** Setter:  */
	void vertex_select(float values[3]) { /* not implemented */ }

	/** Getter:  */
	int vertex_size() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "vertex_size"));
	}

	/** Setter:  */
	void vertex_size(int value) {
		PyObject_SetAttrString(pyobjref, "vertex_size", Py_BuildValue("i", value));
	}

	/** Getter:  */
	std::array<float, 3> vertex_unreferenced() {
		// TODO: MISSING DEREF! USE #DEFINE!
		PyObject *seqval = PyObject_GetAttrString(pyobjref, "vertex_unreferenced");
		std::array<float, 3> resarr;
		for (int i = 0; i < 3; i++)
			resarr[i] = (float)PyFloat_AsDouble(PySequence_GetItem(seqval, i));
		return resarr;
	}

	/** Setter:  */
	void vertex_unreferenced(float values[3]) { /* not implemented */ }

	/** Getter:  */
	std::array<float, 3> handle_free() {
		// TODO: MISSING DEREF! USE #DEFINE!
		PyObject *seqval = PyObject_GetAttrString(pyobjref, "handle_free");
		std::array<float, 3> resarr;
		for (int i = 0; i < 3; i++)
			resarr[i] = (float)PyFloat_AsDouble(PySequence_GetItem(seqval, i));
		return resarr;
	}

	/** Setter:  */
	void handle_free(float values[3]) { /* not implemented */ }

	/** Getter:  */
	std::array<float, 3> handle_auto() {
		// TODO: MISSING DEREF! USE #DEFINE!
		PyObject *seqval = PyObject_GetAttrString(pyobjref, "handle_auto");
		std::array<float, 3> resarr;
		for (int i = 0; i < 3; i++)
			resarr[i] = (float)PyFloat_AsDouble(PySequence_GetItem(seqval, i));
		return resarr;
	}

	/** Setter:  */
	void handle_auto(float values[3]) { /* not implemented */ }

	/** Getter:  */
	std::array<float, 3> handle_vect() {
		// TODO: MISSING DEREF! USE #DEFINE!
		PyObject *seqval = PyObject_GetAttrString(pyobjref, "handle_vect");
		std::array<float, 3> resarr;
		for (int i = 0; i < 3; i++)
			resarr[i] = (float)PyFloat_AsDouble(PySequence_GetItem(seqval, i));
		return resarr;
	}

	/** Setter:  */
	void handle_vect(float values[3]) { /* not implemented */ }

	/** Getter:  */
	std::array<float, 3> handle_sel_vect() {
		// TODO: MISSING DEREF! USE #DEFINE!
		PyObject *seqval = PyObject_GetAttrString(pyobjref, "handle_sel_vect");
		std::array<float, 3> resarr;
		for (int i = 0; i < 3; i++)
			resarr[i] = (float)PyFloat_AsDouble(PySequence_GetItem(seqval, i));
		return resarr;
	}

	/** Setter:  */
	void handle_sel_vect(float values[3]) { /* not implemented */ }

	/** Getter:  */
	std::array<float, 3> handle_align() {
		// TODO: MISSING DEREF! USE #DEFINE!
		PyObject *seqval = PyObject_GetAttrString(pyobjref, "handle_align");
		std::array<float, 3> resarr;
		for (int i = 0; i < 3; i++)
			resarr[i] = (float)PyFloat_AsDouble(PySequence_GetItem(seqval, i));
		return resarr;
	}

	/** Setter:  */
	void handle_align(float values[3]) { /* not implemented */ }

	/** Getter:  */
	std::array<float, 3> handle_sel_free() {
		// TODO: MISSING DEREF! USE #DEFINE!
		PyObject *seqval = PyObject_GetAttrString(pyobjref, "handle_sel_free");
		std::array<float, 3> resarr;
		for (int i = 0; i < 3; i++)
			resarr[i] = (float)PyFloat_AsDouble(PySequence_GetItem(seqval, i));
		return resarr;
	}

	/** Setter:  */
	void handle_sel_free(float values[3]) { /* not implemented */ }

	/** Getter:  */
	std::array<float, 3> handle_sel_auto() {
		// TODO: MISSING DEREF! USE #DEFINE!
		PyObject *seqval = PyObject_GetAttrString(pyobjref, "handle_sel_auto");
		std::array<float, 3> resarr;
		for (int i = 0; i < 3; i++)
			resarr[i] = (float)PyFloat_AsDouble(PySequence_GetItem(seqval, i));
		return resarr;
	}

	/** Setter:  */
	void handle_sel_auto(float values[3]) { /* not implemented */ }

	/** Getter:  */
	std::array<float, 3> handle_sel_align() {
		// TODO: MISSING DEREF! USE #DEFINE!
		PyObject *seqval = PyObject_GetAttrString(pyobjref, "handle_sel_align");
		std::array<float, 3> resarr;
		for (int i = 0; i < 3; i++)
			resarr[i] = (float)PyFloat_AsDouble(PySequence_GetItem(seqval, i));
		return resarr;
	}

	/** Setter:  */
	void handle_sel_align(float values[3]) { /* not implemented */ }

	/** Getter:  */
	std::array<float, 3> handle_auto_clamped() {
		// TODO: MISSING DEREF! USE #DEFINE!
		PyObject *seqval = PyObject_GetAttrString(pyobjref, "handle_auto_clamped");
		std::array<float, 3> resarr;
		for (int i = 0; i < 3; i++)
			resarr[i] = (float)PyFloat_AsDouble(PySequence_GetItem(seqval, i));
		return resarr;
	}

	/** Setter:  */
	void handle_auto_clamped(float values[3]) { /* not implemented */ }

	/** Getter:  */
	std::array<float, 3> handle_sel_auto_clamped() {
		// TODO: MISSING DEREF! USE #DEFINE!
		PyObject *seqval = PyObject_GetAttrString(pyobjref, "handle_sel_auto_clamped");
		std::array<float, 3> resarr;
		for (int i = 0; i < 3; i++)
			resarr[i] = (float)PyFloat_AsDouble(PySequence_GetItem(seqval, i));
		return resarr;
	}

	/** Setter:  */
	void handle_sel_auto_clamped(float values[3]) { /* not implemented */ }

	/** Getter:  */
	std::array<float, 3> lastsel_point() {
		// TODO: MISSING DEREF! USE #DEFINE!
		PyObject *seqval = PyObject_GetAttrString(pyobjref, "lastsel_point");
		std::array<float, 3> resarr;
		for (int i = 0; i < 3; i++)
			resarr[i] = (float)PyFloat_AsDouble(PySequence_GetItem(seqval, i));
		return resarr;
	}

	/** Setter:  */
	void lastsel_point(float values[3]) { /* not implemented */ }

	/** Getter:  */
	std::array<float, 3> handle_vertex() {
		// TODO: MISSING DEREF! USE #DEFINE!
		PyObject *seqval = PyObject_GetAttrString(pyobjref, "handle_vertex");
		std::array<float, 3> resarr;
		for (int i = 0; i < 3; i++)
			resarr[i] = (float)PyFloat_AsDouble(PySequence_GetItem(seqval, i));
		return resarr;
	}

	/** Setter:  */
	void handle_vertex(float values[3]) { /* not implemented */ }

	/** Getter:  */
	std::array<float, 3> handle_vertex_select() {
		// TODO: MISSING DEREF! USE #DEFINE!
		PyObject *seqval = PyObject_GetAttrString(pyobjref, "handle_vertex_select");
		std::array<float, 3> resarr;
		for (int i = 0; i < 3; i++)
			resarr[i] = (float)PyFloat_AsDouble(PySequence_GetItem(seqval, i));
		return resarr;
	}

	/** Setter:  */
	void handle_vertex_select(float values[3]) { /* not implemented */ }

	/** Getter:  */
	int handle_vertex_size() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "handle_vertex_size"));
	}

	/** Setter:  */
	void handle_vertex_size(int value) {
		PyObject_SetAttrString(pyobjref, "handle_vertex_size", Py_BuildValue("i", value));
	}

};

/**************** Theme File Browser ****************/

/**
 * Theme settings for the File Browser
 */
class ThemeFileBrowser : public pyUniplug {
public:
	ThemeFileBrowser(PyObject* pyobj) : pyUniplug(pyobj) {}

	ThemeFileBrowser() : pyUniplug(0)
	{
		// not implemented
	}

	/** Getter: Settings for space */
	ThemeSpaceGeneric space() {
		/* not implemented */ throw NULL;
	}

	/** Getter: Settings for space list */
	ThemeSpaceListGeneric space_list() {
		/* not implemented */ throw NULL;
	}

	/** Getter:  */
	std::array<float, 3> selected_file() {
		// TODO: MISSING DEREF! USE #DEFINE!
		PyObject *seqval = PyObject_GetAttrString(pyobjref, "selected_file");
		std::array<float, 3> resarr;
		for (int i = 0; i < 3; i++)
			resarr[i] = (float)PyFloat_AsDouble(PySequence_GetItem(seqval, i));
		return resarr;
	}

	/** Setter:  */
	void selected_file(float values[3]) { /* not implemented */ }

	/** Getter:  */
	std::array<float, 3> scrollbar() {
		// TODO: MISSING DEREF! USE #DEFINE!
		PyObject *seqval = PyObject_GetAttrString(pyobjref, "scrollbar");
		std::array<float, 3> resarr;
		for (int i = 0; i < 3; i++)
			resarr[i] = (float)PyFloat_AsDouble(PySequence_GetItem(seqval, i));
		return resarr;
	}

	/** Setter:  */
	void scrollbar(float values[3]) { /* not implemented */ }

	/** Getter:  */
	std::array<float, 3> scroll_handle() {
		// TODO: MISSING DEREF! USE #DEFINE!
		PyObject *seqval = PyObject_GetAttrString(pyobjref, "scroll_handle");
		std::array<float, 3> resarr;
		for (int i = 0; i < 3; i++)
			resarr[i] = (float)PyFloat_AsDouble(PySequence_GetItem(seqval, i));
		return resarr;
	}

	/** Setter:  */
	void scroll_handle(float values[3]) { /* not implemented */ }

	/** Getter:  */
	std::array<float, 3> active_file() {
		// TODO: MISSING DEREF! USE #DEFINE!
		PyObject *seqval = PyObject_GetAttrString(pyobjref, "active_file");
		std::array<float, 3> resarr;
		for (int i = 0; i < 3; i++)
			resarr[i] = (float)PyFloat_AsDouble(PySequence_GetItem(seqval, i));
		return resarr;
	}

	/** Setter:  */
	void active_file(float values[3]) { /* not implemented */ }

	/** Getter:  */
	std::array<float, 3> active_file_text() {
		// TODO: MISSING DEREF! USE #DEFINE!
		PyObject *seqval = PyObject_GetAttrString(pyobjref, "active_file_text");
		std::array<float, 3> resarr;
		for (int i = 0; i < 3; i++)
			resarr[i] = (float)PyFloat_AsDouble(PySequence_GetItem(seqval, i));
		return resarr;
	}

	/** Setter:  */
	void active_file_text(float values[3]) { /* not implemented */ }

};

/**************** Theme NLA Editor ****************/

/**
 * Theme settings for the NLA Editor
 */
class ThemeNLAEditor : public pyUniplug {
public:
	ThemeNLAEditor(PyObject* pyobj) : pyUniplug(pyobj) {}

	ThemeNLAEditor() : pyUniplug(0)
	{
		// not implemented
	}

	/** Getter: Settings for space */
	ThemeSpaceGeneric space() {
		/* not implemented */ throw NULL;
	}

	/** Getter: Settings for space list */
	ThemeSpaceListGeneric space_list() {
		/* not implemented */ throw NULL;
	}

	/** Getter:  */
	std::array<float, 3> grid() {
		// TODO: MISSING DEREF! USE #DEFINE!
		PyObject *seqval = PyObject_GetAttrString(pyobjref, "grid");
		std::array<float, 3> resarr;
		for (int i = 0; i < 3; i++)
			resarr[i] = (float)PyFloat_AsDouble(PySequence_GetItem(seqval, i));
		return resarr;
	}

	/** Setter:  */
	void grid(float values[3]) { /* not implemented */ }

	/** Getter:  */
	std::array<float, 3> view_sliders() {
		// TODO: MISSING DEREF! USE #DEFINE!
		PyObject *seqval = PyObject_GetAttrString(pyobjref, "view_sliders");
		std::array<float, 3> resarr;
		for (int i = 0; i < 3; i++)
			resarr[i] = (float)PyFloat_AsDouble(PySequence_GetItem(seqval, i));
		return resarr;
	}

	/** Setter:  */
	void view_sliders(float values[3]) { /* not implemented */ }

	/** Getter: Animation data block has active action */
	std::array<float, 4> active_action() {
		// TODO: MISSING DEREF! USE #DEFINE!
		PyObject *seqval = PyObject_GetAttrString(pyobjref, "active_action");
		std::array<float, 4> resarr;
		for (int i = 0; i < 4; i++)
			resarr[i] = (float)PyFloat_AsDouble(PySequence_GetItem(seqval, i));
		return resarr;
	}

	/** Setter: Animation data block has active action */
	void active_action(float values[4]) { /* not implemented */ }

	/** Getter: Animation data block doesn't have active action */
	std::array<float, 4> active_action_unset() {
		// TODO: MISSING DEREF! USE #DEFINE!
		PyObject *seqval = PyObject_GetAttrString(pyobjref, "active_action_unset");
		std::array<float, 4> resarr;
		for (int i = 0; i < 4; i++)
			resarr[i] = (float)PyFloat_AsDouble(PySequence_GetItem(seqval, i));
		return resarr;
	}

	/** Setter: Animation data block doesn't have active action */
	void active_action_unset(float values[4]) { /* not implemented */ }

	/** Getter: Action-Clip Strip - Unselected */
	std::array<float, 3> strips() {
		// TODO: MISSING DEREF! USE #DEFINE!
		PyObject *seqval = PyObject_GetAttrString(pyobjref, "strips");
		std::array<float, 3> resarr;
		for (int i = 0; i < 3; i++)
			resarr[i] = (float)PyFloat_AsDouble(PySequence_GetItem(seqval, i));
		return resarr;
	}

	/** Setter: Action-Clip Strip - Unselected */
	void strips(float values[3]) { /* not implemented */ }

	/** Getter: Action-Clip Strip - Selected */
	std::array<float, 3> strips_selected() {
		// TODO: MISSING DEREF! USE #DEFINE!
		PyObject *seqval = PyObject_GetAttrString(pyobjref, "strips_selected");
		std::array<float, 3> resarr;
		for (int i = 0; i < 3; i++)
			resarr[i] = (float)PyFloat_AsDouble(PySequence_GetItem(seqval, i));
		return resarr;
	}

	/** Setter: Action-Clip Strip - Selected */
	void strips_selected(float values[3]) { /* not implemented */ }

	/** Getter: Transition Strip - Unselected */
	std::array<float, 3> transition_strips() {
		// TODO: MISSING DEREF! USE #DEFINE!
		PyObject *seqval = PyObject_GetAttrString(pyobjref, "transition_strips");
		std::array<float, 3> resarr;
		for (int i = 0; i < 3; i++)
			resarr[i] = (float)PyFloat_AsDouble(PySequence_GetItem(seqval, i));
		return resarr;
	}

	/** Setter: Transition Strip - Unselected */
	void transition_strips(float values[3]) { /* not implemented */ }

	/** Getter: Transition Strip - Selected */
	std::array<float, 3> transition_strips_selected() {
		// TODO: MISSING DEREF! USE #DEFINE!
		PyObject *seqval = PyObject_GetAttrString(pyobjref, "transition_strips_selected");
		std::array<float, 3> resarr;
		for (int i = 0; i < 3; i++)
			resarr[i] = (float)PyFloat_AsDouble(PySequence_GetItem(seqval, i));
		return resarr;
	}

	/** Setter: Transition Strip - Selected */
	void transition_strips_selected(float values[3]) { /* not implemented */ }

	/** Getter: Meta Strip - Unselected (for grouping related strips) */
	std::array<float, 3> meta_strips() {
		// TODO: MISSING DEREF! USE #DEFINE!
		PyObject *seqval = PyObject_GetAttrString(pyobjref, "meta_strips");
		std::array<float, 3> resarr;
		for (int i = 0; i < 3; i++)
			resarr[i] = (float)PyFloat_AsDouble(PySequence_GetItem(seqval, i));
		return resarr;
	}

	/** Setter: Meta Strip - Unselected (for grouping related strips) */
	void meta_strips(float values[3]) { /* not implemented */ }

	/** Getter: Meta Strip - Selected (for grouping related strips) */
	std::array<float, 3> meta_strips_selected() {
		// TODO: MISSING DEREF! USE #DEFINE!
		PyObject *seqval = PyObject_GetAttrString(pyobjref, "meta_strips_selected");
		std::array<float, 3> resarr;
		for (int i = 0; i < 3; i++)
			resarr[i] = (float)PyFloat_AsDouble(PySequence_GetItem(seqval, i));
		return resarr;
	}

	/** Setter: Meta Strip - Selected (for grouping related strips) */
	void meta_strips_selected(float values[3]) { /* not implemented */ }

	/** Getter: Sound Strip - Unselected (for timing speaker sounds) */
	std::array<float, 3> sound_strips() {
		// TODO: MISSING DEREF! USE #DEFINE!
		PyObject *seqval = PyObject_GetAttrString(pyobjref, "sound_strips");
		std::array<float, 3> resarr;
		for (int i = 0; i < 3; i++)
			resarr[i] = (float)PyFloat_AsDouble(PySequence_GetItem(seqval, i));
		return resarr;
	}

	/** Setter: Sound Strip - Unselected (for timing speaker sounds) */
	void sound_strips(float values[3]) { /* not implemented */ }

	/** Getter: Sound Strip - Selected (for timing speaker sounds) */
	std::array<float, 3> sound_strips_selected() {
		// TODO: MISSING DEREF! USE #DEFINE!
		PyObject *seqval = PyObject_GetAttrString(pyobjref, "sound_strips_selected");
		std::array<float, 3> resarr;
		for (int i = 0; i < 3; i++)
			resarr[i] = (float)PyFloat_AsDouble(PySequence_GetItem(seqval, i));
		return resarr;
	}

	/** Setter: Sound Strip - Selected (for timing speaker sounds) */
	void sound_strips_selected(float values[3]) { /* not implemented */ }

	/** Getter: Color for strip/action being 'tweaked' or edited */
	std::array<float, 3> tweak() {
		// TODO: MISSING DEREF! USE #DEFINE!
		PyObject *seqval = PyObject_GetAttrString(pyobjref, "tweak");
		std::array<float, 3> resarr;
		for (int i = 0; i < 3; i++)
			resarr[i] = (float)PyFloat_AsDouble(PySequence_GetItem(seqval, i));
		return resarr;
	}

	/** Setter: Color for strip/action being 'tweaked' or edited */
	void tweak(float values[3]) { /* not implemented */ }

	/** Getter: Warning/error indicator color for strips referencing the strip being tweaked */
	std::array<float, 3> tweak_duplicate() {
		// TODO: MISSING DEREF! USE #DEFINE!
		PyObject *seqval = PyObject_GetAttrString(pyobjref, "tweak_duplicate");
		std::array<float, 3> resarr;
		for (int i = 0; i < 3; i++)
			resarr[i] = (float)PyFloat_AsDouble(PySequence_GetItem(seqval, i));
		return resarr;
	}

	/** Setter: Warning/error indicator color for strips referencing the strip being tweaked */
	void tweak_duplicate(float values[3]) { /* not implemented */ }

	/** Getter: Color of keyframe border */
	std::array<float, 4> keyframe_border() {
		// TODO: MISSING DEREF! USE #DEFINE!
		PyObject *seqval = PyObject_GetAttrString(pyobjref, "keyframe_border");
		std::array<float, 4> resarr;
		for (int i = 0; i < 4; i++)
			resarr[i] = (float)PyFloat_AsDouble(PySequence_GetItem(seqval, i));
		return resarr;
	}

	/** Setter: Color of keyframe border */
	void keyframe_border(float values[4]) { /* not implemented */ }

	/** Getter: Color of selected keyframe border */
	std::array<float, 4> keyframe_border_selected() {
		// TODO: MISSING DEREF! USE #DEFINE!
		PyObject *seqval = PyObject_GetAttrString(pyobjref, "keyframe_border_selected");
		std::array<float, 4> resarr;
		for (int i = 0; i < 4; i++)
			resarr[i] = (float)PyFloat_AsDouble(PySequence_GetItem(seqval, i));
		return resarr;
	}

	/** Setter: Color of selected keyframe border */
	void keyframe_border_selected(float values[4]) { /* not implemented */ }

	/** Getter:  */
	std::array<float, 3> frame_current() {
		// TODO: MISSING DEREF! USE #DEFINE!
		PyObject *seqval = PyObject_GetAttrString(pyobjref, "frame_current");
		std::array<float, 3> resarr;
		for (int i = 0; i < 3; i++)
			resarr[i] = (float)PyFloat_AsDouble(PySequence_GetItem(seqval, i));
		return resarr;
	}

	/** Setter:  */
	void frame_current(float values[3]) { /* not implemented */ }

};

/**************** Theme Dope Sheet ****************/

/**
 * Theme settings for the Dope Sheet
 */
class ThemeDopeSheet : public pyUniplug {
public:
	ThemeDopeSheet(PyObject* pyobj) : pyUniplug(pyobj) {}

	ThemeDopeSheet() : pyUniplug(0)
	{
		// not implemented
	}

	/** Getter: Settings for space */
	ThemeSpaceGeneric space() {
		/* not implemented */ throw NULL;
	}

	/** Getter: Settings for space list */
	ThemeSpaceListGeneric space_list() {
		/* not implemented */ throw NULL;
	}

	/** Getter:  */
	std::array<float, 3> grid() {
		// TODO: MISSING DEREF! USE #DEFINE!
		PyObject *seqval = PyObject_GetAttrString(pyobjref, "grid");
		std::array<float, 3> resarr;
		for (int i = 0; i < 3; i++)
			resarr[i] = (float)PyFloat_AsDouble(PySequence_GetItem(seqval, i));
		return resarr;
	}

	/** Setter:  */
	void grid(float values[3]) { /* not implemented */ }

	/** Getter:  */
	std::array<float, 3> frame_current() {
		// TODO: MISSING DEREF! USE #DEFINE!
		PyObject *seqval = PyObject_GetAttrString(pyobjref, "frame_current");
		std::array<float, 3> resarr;
		for (int i = 0; i < 3; i++)
			resarr[i] = (float)PyFloat_AsDouble(PySequence_GetItem(seqval, i));
		return resarr;
	}

	/** Setter:  */
	void frame_current(float values[3]) { /* not implemented */ }

	/** Getter:  */
	std::array<float, 3> value_sliders() {
		// TODO: MISSING DEREF! USE #DEFINE!
		PyObject *seqval = PyObject_GetAttrString(pyobjref, "value_sliders");
		std::array<float, 3> resarr;
		for (int i = 0; i < 3; i++)
			resarr[i] = (float)PyFloat_AsDouble(PySequence_GetItem(seqval, i));
		return resarr;
	}

	/** Setter:  */
	void value_sliders(float values[3]) { /* not implemented */ }

	/** Getter:  */
	std::array<float, 3> view_sliders() {
		// TODO: MISSING DEREF! USE #DEFINE!
		PyObject *seqval = PyObject_GetAttrString(pyobjref, "view_sliders");
		std::array<float, 3> resarr;
		for (int i = 0; i < 3; i++)
			resarr[i] = (float)PyFloat_AsDouble(PySequence_GetItem(seqval, i));
		return resarr;
	}

	/** Setter:  */
	void view_sliders(float values[3]) { /* not implemented */ }

	/** Getter:  */
	std::array<float, 3> dopesheet_channel() {
		// TODO: MISSING DEREF! USE #DEFINE!
		PyObject *seqval = PyObject_GetAttrString(pyobjref, "dopesheet_channel");
		std::array<float, 3> resarr;
		for (int i = 0; i < 3; i++)
			resarr[i] = (float)PyFloat_AsDouble(PySequence_GetItem(seqval, i));
		return resarr;
	}

	/** Setter:  */
	void dopesheet_channel(float values[3]) { /* not implemented */ }

	/** Getter:  */
	std::array<float, 3> dopesheet_subchannel() {
		// TODO: MISSING DEREF! USE #DEFINE!
		PyObject *seqval = PyObject_GetAttrString(pyobjref, "dopesheet_subchannel");
		std::array<float, 3> resarr;
		for (int i = 0; i < 3; i++)
			resarr[i] = (float)PyFloat_AsDouble(PySequence_GetItem(seqval, i));
		return resarr;
	}

	/** Setter:  */
	void dopesheet_subchannel(float values[3]) { /* not implemented */ }

	/** Getter:  */
	std::array<float, 3> channels() {
		// TODO: MISSING DEREF! USE #DEFINE!
		PyObject *seqval = PyObject_GetAttrString(pyobjref, "channels");
		std::array<float, 3> resarr;
		for (int i = 0; i < 3; i++)
			resarr[i] = (float)PyFloat_AsDouble(PySequence_GetItem(seqval, i));
		return resarr;
	}

	/** Setter:  */
	void channels(float values[3]) { /* not implemented */ }

	/** Getter:  */
	std::array<float, 3> channels_selected() {
		// TODO: MISSING DEREF! USE #DEFINE!
		PyObject *seqval = PyObject_GetAttrString(pyobjref, "channels_selected");
		std::array<float, 3> resarr;
		for (int i = 0; i < 3; i++)
			resarr[i] = (float)PyFloat_AsDouble(PySequence_GetItem(seqval, i));
		return resarr;
	}

	/** Setter:  */
	void channels_selected(float values[3]) { /* not implemented */ }

	/** Getter:  */
	std::array<float, 3> channel_group() {
		// TODO: MISSING DEREF! USE #DEFINE!
		PyObject *seqval = PyObject_GetAttrString(pyobjref, "channel_group");
		std::array<float, 3> resarr;
		for (int i = 0; i < 3; i++)
			resarr[i] = (float)PyFloat_AsDouble(PySequence_GetItem(seqval, i));
		return resarr;
	}

	/** Setter:  */
	void channel_group(float values[3]) { /* not implemented */ }

	/** Getter:  */
	std::array<float, 3> active_channels_group() {
		// TODO: MISSING DEREF! USE #DEFINE!
		PyObject *seqval = PyObject_GetAttrString(pyobjref, "active_channels_group");
		std::array<float, 3> resarr;
		for (int i = 0; i < 3; i++)
			resarr[i] = (float)PyFloat_AsDouble(PySequence_GetItem(seqval, i));
		return resarr;
	}

	/** Setter:  */
	void active_channels_group(float values[3]) { /* not implemented */ }

	/** Getter:  */
	std::array<float, 3> long_key() {
		// TODO: MISSING DEREF! USE #DEFINE!
		PyObject *seqval = PyObject_GetAttrString(pyobjref, "long_key");
		std::array<float, 3> resarr;
		for (int i = 0; i < 3; i++)
			resarr[i] = (float)PyFloat_AsDouble(PySequence_GetItem(seqval, i));
		return resarr;
	}

	/** Setter:  */
	void long_key(float values[3]) { /* not implemented */ }

	/** Getter:  */
	std::array<float, 3> long_key_selected() {
		// TODO: MISSING DEREF! USE #DEFINE!
		PyObject *seqval = PyObject_GetAttrString(pyobjref, "long_key_selected");
		std::array<float, 3> resarr;
		for (int i = 0; i < 3; i++)
			resarr[i] = (float)PyFloat_AsDouble(PySequence_GetItem(seqval, i));
		return resarr;
	}

	/** Setter:  */
	void long_key_selected(float values[3]) { /* not implemented */ }

	/** Getter: Color of Keyframe */
	std::array<float, 3> keyframe() {
		// TODO: MISSING DEREF! USE #DEFINE!
		PyObject *seqval = PyObject_GetAttrString(pyobjref, "keyframe");
		std::array<float, 3> resarr;
		for (int i = 0; i < 3; i++)
			resarr[i] = (float)PyFloat_AsDouble(PySequence_GetItem(seqval, i));
		return resarr;
	}

	/** Setter: Color of Keyframe */
	void keyframe(float values[3]) { /* not implemented */ }

	/** Getter: Color of selected keyframe */
	std::array<float, 3> keyframe_selected() {
		// TODO: MISSING DEREF! USE #DEFINE!
		PyObject *seqval = PyObject_GetAttrString(pyobjref, "keyframe_selected");
		std::array<float, 3> resarr;
		for (int i = 0; i < 3; i++)
			resarr[i] = (float)PyFloat_AsDouble(PySequence_GetItem(seqval, i));
		return resarr;
	}

	/** Setter: Color of selected keyframe */
	void keyframe_selected(float values[3]) { /* not implemented */ }

	/** Getter: Color of extreme keyframe */
	std::array<float, 3> keyframe_extreme() {
		// TODO: MISSING DEREF! USE #DEFINE!
		PyObject *seqval = PyObject_GetAttrString(pyobjref, "keyframe_extreme");
		std::array<float, 3> resarr;
		for (int i = 0; i < 3; i++)
			resarr[i] = (float)PyFloat_AsDouble(PySequence_GetItem(seqval, i));
		return resarr;
	}

	/** Setter: Color of extreme keyframe */
	void keyframe_extreme(float values[3]) { /* not implemented */ }

	/** Getter: Color of selected extreme keyframe */
	std::array<float, 3> keyframe_extreme_selected() {
		// TODO: MISSING DEREF! USE #DEFINE!
		PyObject *seqval = PyObject_GetAttrString(pyobjref, "keyframe_extreme_selected");
		std::array<float, 3> resarr;
		for (int i = 0; i < 3; i++)
			resarr[i] = (float)PyFloat_AsDouble(PySequence_GetItem(seqval, i));
		return resarr;
	}

	/** Setter: Color of selected extreme keyframe */
	void keyframe_extreme_selected(float values[3]) { /* not implemented */ }

	/** Getter: Color of breakdown keyframe */
	std::array<float, 3> keyframe_breakdown() {
		// TODO: MISSING DEREF! USE #DEFINE!
		PyObject *seqval = PyObject_GetAttrString(pyobjref, "keyframe_breakdown");
		std::array<float, 3> resarr;
		for (int i = 0; i < 3; i++)
			resarr[i] = (float)PyFloat_AsDouble(PySequence_GetItem(seqval, i));
		return resarr;
	}

	/** Setter: Color of breakdown keyframe */
	void keyframe_breakdown(float values[3]) { /* not implemented */ }

	/** Getter: Color of selected breakdown keyframe */
	std::array<float, 3> keyframe_breakdown_selected() {
		// TODO: MISSING DEREF! USE #DEFINE!
		PyObject *seqval = PyObject_GetAttrString(pyobjref, "keyframe_breakdown_selected");
		std::array<float, 3> resarr;
		for (int i = 0; i < 3; i++)
			resarr[i] = (float)PyFloat_AsDouble(PySequence_GetItem(seqval, i));
		return resarr;
	}

	/** Setter: Color of selected breakdown keyframe */
	void keyframe_breakdown_selected(float values[3]) { /* not implemented */ }

	/** Getter: Color of jitter keyframe */
	std::array<float, 3> keyframe_jitter() {
		// TODO: MISSING DEREF! USE #DEFINE!
		PyObject *seqval = PyObject_GetAttrString(pyobjref, "keyframe_jitter");
		std::array<float, 3> resarr;
		for (int i = 0; i < 3; i++)
			resarr[i] = (float)PyFloat_AsDouble(PySequence_GetItem(seqval, i));
		return resarr;
	}

	/** Setter: Color of jitter keyframe */
	void keyframe_jitter(float values[3]) { /* not implemented */ }

	/** Getter: Color of selected jitter keyframe */
	std::array<float, 3> keyframe_jitter_selected() {
		// TODO: MISSING DEREF! USE #DEFINE!
		PyObject *seqval = PyObject_GetAttrString(pyobjref, "keyframe_jitter_selected");
		std::array<float, 3> resarr;
		for (int i = 0; i < 3; i++)
			resarr[i] = (float)PyFloat_AsDouble(PySequence_GetItem(seqval, i));
		return resarr;
	}

	/** Setter: Color of selected jitter keyframe */
	void keyframe_jitter_selected(float values[3]) { /* not implemented */ }

	/** Getter: Color of keyframe border */
	std::array<float, 4> keyframe_border() {
		// TODO: MISSING DEREF! USE #DEFINE!
		PyObject *seqval = PyObject_GetAttrString(pyobjref, "keyframe_border");
		std::array<float, 4> resarr;
		for (int i = 0; i < 4; i++)
			resarr[i] = (float)PyFloat_AsDouble(PySequence_GetItem(seqval, i));
		return resarr;
	}

	/** Setter: Color of keyframe border */
	void keyframe_border(float values[4]) { /* not implemented */ }

	/** Getter: Color of selected keyframe border */
	std::array<float, 4> keyframe_border_selected() {
		// TODO: MISSING DEREF! USE #DEFINE!
		PyObject *seqval = PyObject_GetAttrString(pyobjref, "keyframe_border_selected");
		std::array<float, 4> resarr;
		for (int i = 0; i < 4; i++)
			resarr[i] = (float)PyFloat_AsDouble(PySequence_GetItem(seqval, i));
		return resarr;
	}

	/** Setter: Color of selected keyframe border */
	void keyframe_border_selected(float values[4]) { /* not implemented */ }

	/** Getter: Color of summary channel */
	std::array<float, 4> summary() {
		// TODO: MISSING DEREF! USE #DEFINE!
		PyObject *seqval = PyObject_GetAttrString(pyobjref, "summary");
		std::array<float, 4> resarr;
		for (int i = 0; i < 4; i++)
			resarr[i] = (float)PyFloat_AsDouble(PySequence_GetItem(seqval, i));
		return resarr;
	}

	/** Setter: Color of summary channel */
	void summary(float values[4]) { /* not implemented */ }

};

/**************** Theme Image Editor ****************/

/**
 * Theme settings for the Image Editor
 */
class ThemeImageEditor : public pyUniplug {
public:
	ThemeImageEditor(PyObject* pyobj) : pyUniplug(pyobj) {}

	ThemeImageEditor() : pyUniplug(0)
	{
		// not implemented
	}

	/** Getter: Settings for space */
	ThemeSpaceGeneric space() {
		/* not implemented */ throw NULL;
	}

	/** Getter:  */
	std::array<float, 3> gp_vertex() {
		// TODO: MISSING DEREF! USE #DEFINE!
		PyObject *seqval = PyObject_GetAttrString(pyobjref, "gp_vertex");
		std::array<float, 3> resarr;
		for (int i = 0; i < 3; i++)
			resarr[i] = (float)PyFloat_AsDouble(PySequence_GetItem(seqval, i));
		return resarr;
	}

	/** Setter:  */
	void gp_vertex(float values[3]) { /* not implemented */ }

	/** Getter:  */
	std::array<float, 3> gp_vertex_select() {
		// TODO: MISSING DEREF! USE #DEFINE!
		PyObject *seqval = PyObject_GetAttrString(pyobjref, "gp_vertex_select");
		std::array<float, 3> resarr;
		for (int i = 0; i < 3; i++)
			resarr[i] = (float)PyFloat_AsDouble(PySequence_GetItem(seqval, i));
		return resarr;
	}

	/** Setter:  */
	void gp_vertex_select(float values[3]) { /* not implemented */ }

	/** Getter:  */
	int gp_vertex_size() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "gp_vertex_size"));
	}

	/** Setter:  */
	void gp_vertex_size(int value) {
		PyObject_SetAttrString(pyobjref, "gp_vertex_size", Py_BuildValue("i", value));
	}

	/** Getter:  */
	std::array<float, 3> vertex() {
		// TODO: MISSING DEREF! USE #DEFINE!
		PyObject *seqval = PyObject_GetAttrString(pyobjref, "vertex");
		std::array<float, 3> resarr;
		for (int i = 0; i < 3; i++)
			resarr[i] = (float)PyFloat_AsDouble(PySequence_GetItem(seqval, i));
		return resarr;
	}

	/** Setter:  */
	void vertex(float values[3]) { /* not implemented */ }

	/** Getter:  */
	std::array<float, 3> vertex_select() {
		// TODO: MISSING DEREF! USE #DEFINE!
		PyObject *seqval = PyObject_GetAttrString(pyobjref, "vertex_select");
		std::array<float, 3> resarr;
		for (int i = 0; i < 3; i++)
			resarr[i] = (float)PyFloat_AsDouble(PySequence_GetItem(seqval, i));
		return resarr;
	}

	/** Setter:  */
	void vertex_select(float values[3]) { /* not implemented */ }

	/** Getter:  */
	int vertex_size() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "vertex_size"));
	}

	/** Setter:  */
	void vertex_size(int value) {
		PyObject_SetAttrString(pyobjref, "vertex_size", Py_BuildValue("i", value));
	}

	/** Getter:  */
	std::array<float, 3> vertex_unreferenced() {
		// TODO: MISSING DEREF! USE #DEFINE!
		PyObject *seqval = PyObject_GetAttrString(pyobjref, "vertex_unreferenced");
		std::array<float, 3> resarr;
		for (int i = 0; i < 3; i++)
			resarr[i] = (float)PyFloat_AsDouble(PySequence_GetItem(seqval, i));
		return resarr;
	}

	/** Setter:  */
	void vertex_unreferenced(float values[3]) { /* not implemented */ }

	/** Getter:  */
	std::array<float, 4> face() {
		// TODO: MISSING DEREF! USE #DEFINE!
		PyObject *seqval = PyObject_GetAttrString(pyobjref, "face");
		std::array<float, 4> resarr;
		for (int i = 0; i < 4; i++)
			resarr[i] = (float)PyFloat_AsDouble(PySequence_GetItem(seqval, i));
		return resarr;
	}

	/** Setter:  */
	void face(float values[4]) { /* not implemented */ }

	/** Getter:  */
	std::array<float, 4> face_select() {
		// TODO: MISSING DEREF! USE #DEFINE!
		PyObject *seqval = PyObject_GetAttrString(pyobjref, "face_select");
		std::array<float, 4> resarr;
		for (int i = 0; i < 4; i++)
			resarr[i] = (float)PyFloat_AsDouble(PySequence_GetItem(seqval, i));
		return resarr;
	}

	/** Setter:  */
	void face_select(float values[4]) { /* not implemented */ }

	/** Getter:  */
	std::array<float, 3> face_dot() {
		// TODO: MISSING DEREF! USE #DEFINE!
		PyObject *seqval = PyObject_GetAttrString(pyobjref, "face_dot");
		std::array<float, 3> resarr;
		for (int i = 0; i < 3; i++)
			resarr[i] = (float)PyFloat_AsDouble(PySequence_GetItem(seqval, i));
		return resarr;
	}

	/** Setter:  */
	void face_dot(float values[3]) { /* not implemented */ }

	/** Getter:  */
	int facedot_size() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "facedot_size"));
	}

	/** Setter:  */
	void facedot_size(int value) {
		PyObject_SetAttrString(pyobjref, "facedot_size", Py_BuildValue("i", value));
	}

	/** Getter:  */
	std::array<float, 4> freestyle_face_mark() {
		// TODO: MISSING DEREF! USE #DEFINE!
		PyObject *seqval = PyObject_GetAttrString(pyobjref, "freestyle_face_mark");
		std::array<float, 4> resarr;
		for (int i = 0; i < 4; i++)
			resarr[i] = (float)PyFloat_AsDouble(PySequence_GetItem(seqval, i));
		return resarr;
	}

	/** Setter:  */
	void freestyle_face_mark(float values[4]) { /* not implemented */ }

	/** Getter:  */
	std::array<float, 4> editmesh_active() {
		// TODO: MISSING DEREF! USE #DEFINE!
		PyObject *seqval = PyObject_GetAttrString(pyobjref, "editmesh_active");
		std::array<float, 4> resarr;
		for (int i = 0; i < 4; i++)
			resarr[i] = (float)PyFloat_AsDouble(PySequence_GetItem(seqval, i));
		return resarr;
	}

	/** Setter:  */
	void editmesh_active(float values[4]) { /* not implemented */ }

	/** Getter:  */
	std::array<float, 3> wire_edit() {
		// TODO: MISSING DEREF! USE #DEFINE!
		PyObject *seqval = PyObject_GetAttrString(pyobjref, "wire_edit");
		std::array<float, 3> resarr;
		for (int i = 0; i < 3; i++)
			resarr[i] = (float)PyFloat_AsDouble(PySequence_GetItem(seqval, i));
		return resarr;
	}

	/** Setter:  */
	void wire_edit(float values[3]) { /* not implemented */ }

	/** Getter:  */
	std::array<float, 3> edge_select() {
		// TODO: MISSING DEREF! USE #DEFINE!
		PyObject *seqval = PyObject_GetAttrString(pyobjref, "edge_select");
		std::array<float, 3> resarr;
		for (int i = 0; i < 3; i++)
			resarr[i] = (float)PyFloat_AsDouble(PySequence_GetItem(seqval, i));
		return resarr;
	}

	/** Setter:  */
	void edge_select(float values[3]) { /* not implemented */ }

	/** Getter:  */
	std::array<float, 4> scope_back() {
		// TODO: MISSING DEREF! USE #DEFINE!
		PyObject *seqval = PyObject_GetAttrString(pyobjref, "scope_back");
		std::array<float, 4> resarr;
		for (int i = 0; i < 4; i++)
			resarr[i] = (float)PyFloat_AsDouble(PySequence_GetItem(seqval, i));
		return resarr;
	}

	/** Setter:  */
	void scope_back(float values[4]) { /* not implemented */ }

	/** Getter:  */
	std::array<float, 4> preview_stitch_face() {
		// TODO: MISSING DEREF! USE #DEFINE!
		PyObject *seqval = PyObject_GetAttrString(pyobjref, "preview_stitch_face");
		std::array<float, 4> resarr;
		for (int i = 0; i < 4; i++)
			resarr[i] = (float)PyFloat_AsDouble(PySequence_GetItem(seqval, i));
		return resarr;
	}

	/** Setter:  */
	void preview_stitch_face(float values[4]) { /* not implemented */ }

	/** Getter:  */
	std::array<float, 4> preview_stitch_edge() {
		// TODO: MISSING DEREF! USE #DEFINE!
		PyObject *seqval = PyObject_GetAttrString(pyobjref, "preview_stitch_edge");
		std::array<float, 4> resarr;
		for (int i = 0; i < 4; i++)
			resarr[i] = (float)PyFloat_AsDouble(PySequence_GetItem(seqval, i));
		return resarr;
	}

	/** Setter:  */
	void preview_stitch_edge(float values[4]) { /* not implemented */ }

	/** Getter:  */
	std::array<float, 4> preview_stitch_vert() {
		// TODO: MISSING DEREF! USE #DEFINE!
		PyObject *seqval = PyObject_GetAttrString(pyobjref, "preview_stitch_vert");
		std::array<float, 4> resarr;
		for (int i = 0; i < 4; i++)
			resarr[i] = (float)PyFloat_AsDouble(PySequence_GetItem(seqval, i));
		return resarr;
	}

	/** Setter:  */
	void preview_stitch_vert(float values[4]) { /* not implemented */ }

	/** Getter:  */
	std::array<float, 4> preview_stitch_stitchable() {
		// TODO: MISSING DEREF! USE #DEFINE!
		PyObject *seqval = PyObject_GetAttrString(pyobjref, "preview_stitch_stitchable");
		std::array<float, 4> resarr;
		for (int i = 0; i < 4; i++)
			resarr[i] = (float)PyFloat_AsDouble(PySequence_GetItem(seqval, i));
		return resarr;
	}

	/** Setter:  */
	void preview_stitch_stitchable(float values[4]) { /* not implemented */ }

	/** Getter:  */
	std::array<float, 4> preview_stitch_unstitchable() {
		// TODO: MISSING DEREF! USE #DEFINE!
		PyObject *seqval = PyObject_GetAttrString(pyobjref, "preview_stitch_unstitchable");
		std::array<float, 4> resarr;
		for (int i = 0; i < 4; i++)
			resarr[i] = (float)PyFloat_AsDouble(PySequence_GetItem(seqval, i));
		return resarr;
	}

	/** Setter:  */
	void preview_stitch_unstitchable(float values[4]) { /* not implemented */ }

	/** Getter:  */
	std::array<float, 4> preview_stitch_active() {
		// TODO: MISSING DEREF! USE #DEFINE!
		PyObject *seqval = PyObject_GetAttrString(pyobjref, "preview_stitch_active");
		std::array<float, 4> resarr;
		for (int i = 0; i < 4; i++)
			resarr[i] = (float)PyFloat_AsDouble(PySequence_GetItem(seqval, i));
		return resarr;
	}

	/** Setter:  */
	void preview_stitch_active(float values[4]) { /* not implemented */ }

	/** Getter:  */
	std::array<float, 4> uv_shadow() {
		// TODO: MISSING DEREF! USE #DEFINE!
		PyObject *seqval = PyObject_GetAttrString(pyobjref, "uv_shadow");
		std::array<float, 4> resarr;
		for (int i = 0; i < 4; i++)
			resarr[i] = (float)PyFloat_AsDouble(PySequence_GetItem(seqval, i));
		return resarr;
	}

	/** Setter:  */
	void uv_shadow(float values[4]) { /* not implemented */ }

	/** Getter:  */
	std::array<float, 4> uv_others() {
		// TODO: MISSING DEREF! USE #DEFINE!
		PyObject *seqval = PyObject_GetAttrString(pyobjref, "uv_others");
		std::array<float, 4> resarr;
		for (int i = 0; i < 4; i++)
			resarr[i] = (float)PyFloat_AsDouble(PySequence_GetItem(seqval, i));
		return resarr;
	}

	/** Setter:  */
	void uv_others(float values[4]) { /* not implemented */ }

	/** Getter:  */
	std::array<float, 3> frame_current() {
		// TODO: MISSING DEREF! USE #DEFINE!
		PyObject *seqval = PyObject_GetAttrString(pyobjref, "frame_current");
		std::array<float, 3> resarr;
		for (int i = 0; i < 3; i++)
			resarr[i] = (float)PyFloat_AsDouble(PySequence_GetItem(seqval, i));
		return resarr;
	}

	/** Setter:  */
	void frame_current(float values[3]) { /* not implemented */ }

	/** Getter:  */
	std::array<float, 3> metadatabg() {
		// TODO: MISSING DEREF! USE #DEFINE!
		PyObject *seqval = PyObject_GetAttrString(pyobjref, "metadatabg");
		std::array<float, 3> resarr;
		for (int i = 0; i < 3; i++)
			resarr[i] = (float)PyFloat_AsDouble(PySequence_GetItem(seqval, i));
		return resarr;
	}

	/** Setter:  */
	void metadatabg(float values[3]) { /* not implemented */ }

	/** Getter:  */
	std::array<float, 3> metadatatext() {
		// TODO: MISSING DEREF! USE #DEFINE!
		PyObject *seqval = PyObject_GetAttrString(pyobjref, "metadatatext");
		std::array<float, 3> resarr;
		for (int i = 0; i < 3; i++)
			resarr[i] = (float)PyFloat_AsDouble(PySequence_GetItem(seqval, i));
		return resarr;
	}

	/** Setter:  */
	void metadatatext(float values[3]) { /* not implemented */ }

	/** Getter:  */
	std::array<float, 3> handle_free() {
		// TODO: MISSING DEREF! USE #DEFINE!
		PyObject *seqval = PyObject_GetAttrString(pyobjref, "handle_free");
		std::array<float, 3> resarr;
		for (int i = 0; i < 3; i++)
			resarr[i] = (float)PyFloat_AsDouble(PySequence_GetItem(seqval, i));
		return resarr;
	}

	/** Setter:  */
	void handle_free(float values[3]) { /* not implemented */ }

	/** Getter:  */
	std::array<float, 3> handle_auto() {
		// TODO: MISSING DEREF! USE #DEFINE!
		PyObject *seqval = PyObject_GetAttrString(pyobjref, "handle_auto");
		std::array<float, 3> resarr;
		for (int i = 0; i < 3; i++)
			resarr[i] = (float)PyFloat_AsDouble(PySequence_GetItem(seqval, i));
		return resarr;
	}

	/** Setter:  */
	void handle_auto(float values[3]) { /* not implemented */ }

	/** Getter:  */
	std::array<float, 3> handle_align() {
		// TODO: MISSING DEREF! USE #DEFINE!
		PyObject *seqval = PyObject_GetAttrString(pyobjref, "handle_align");
		std::array<float, 3> resarr;
		for (int i = 0; i < 3; i++)
			resarr[i] = (float)PyFloat_AsDouble(PySequence_GetItem(seqval, i));
		return resarr;
	}

	/** Setter:  */
	void handle_align(float values[3]) { /* not implemented */ }

	/** Getter:  */
	std::array<float, 3> handle_sel_free() {
		// TODO: MISSING DEREF! USE #DEFINE!
		PyObject *seqval = PyObject_GetAttrString(pyobjref, "handle_sel_free");
		std::array<float, 3> resarr;
		for (int i = 0; i < 3; i++)
			resarr[i] = (float)PyFloat_AsDouble(PySequence_GetItem(seqval, i));
		return resarr;
	}

	/** Setter:  */
	void handle_sel_free(float values[3]) { /* not implemented */ }

	/** Getter:  */
	std::array<float, 3> handle_sel_auto() {
		// TODO: MISSING DEREF! USE #DEFINE!
		PyObject *seqval = PyObject_GetAttrString(pyobjref, "handle_sel_auto");
		std::array<float, 3> resarr;
		for (int i = 0; i < 3; i++)
			resarr[i] = (float)PyFloat_AsDouble(PySequence_GetItem(seqval, i));
		return resarr;
	}

	/** Setter:  */
	void handle_sel_auto(float values[3]) { /* not implemented */ }

	/** Getter:  */
	std::array<float, 3> handle_sel_align() {
		// TODO: MISSING DEREF! USE #DEFINE!
		PyObject *seqval = PyObject_GetAttrString(pyobjref, "handle_sel_align");
		std::array<float, 3> resarr;
		for (int i = 0; i < 3; i++)
			resarr[i] = (float)PyFloat_AsDouble(PySequence_GetItem(seqval, i));
		return resarr;
	}

	/** Setter:  */
	void handle_sel_align(float values[3]) { /* not implemented */ }

	/** Getter:  */
	std::array<float, 3> handle_auto_clamped() {
		// TODO: MISSING DEREF! USE #DEFINE!
		PyObject *seqval = PyObject_GetAttrString(pyobjref, "handle_auto_clamped");
		std::array<float, 3> resarr;
		for (int i = 0; i < 3; i++)
			resarr[i] = (float)PyFloat_AsDouble(PySequence_GetItem(seqval, i));
		return resarr;
	}

	/** Setter:  */
	void handle_auto_clamped(float values[3]) { /* not implemented */ }

	/** Getter:  */
	std::array<float, 3> handle_sel_auto_clamped() {
		// TODO: MISSING DEREF! USE #DEFINE!
		PyObject *seqval = PyObject_GetAttrString(pyobjref, "handle_sel_auto_clamped");
		std::array<float, 3> resarr;
		for (int i = 0; i < 3; i++)
			resarr[i] = (float)PyFloat_AsDouble(PySequence_GetItem(seqval, i));
		return resarr;
	}

	/** Setter:  */
	void handle_sel_auto_clamped(float values[3]) { /* not implemented */ }

	/** Getter:  */
	std::array<float, 3> handle_vertex() {
		// TODO: MISSING DEREF! USE #DEFINE!
		PyObject *seqval = PyObject_GetAttrString(pyobjref, "handle_vertex");
		std::array<float, 3> resarr;
		for (int i = 0; i < 3; i++)
			resarr[i] = (float)PyFloat_AsDouble(PySequence_GetItem(seqval, i));
		return resarr;
	}

	/** Setter:  */
	void handle_vertex(float values[3]) { /* not implemented */ }

	/** Getter:  */
	std::array<float, 3> handle_vertex_select() {
		// TODO: MISSING DEREF! USE #DEFINE!
		PyObject *seqval = PyObject_GetAttrString(pyobjref, "handle_vertex_select");
		std::array<float, 3> resarr;
		for (int i = 0; i < 3; i++)
			resarr[i] = (float)PyFloat_AsDouble(PySequence_GetItem(seqval, i));
		return resarr;
	}

	/** Setter:  */
	void handle_vertex_select(float values[3]) { /* not implemented */ }

	/** Getter:  */
	int handle_vertex_size() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "handle_vertex_size"));
	}

	/** Setter:  */
	void handle_vertex_size(int value) {
		PyObject_SetAttrString(pyobjref, "handle_vertex_size", Py_BuildValue("i", value));
	}

	/** Getter:  */
	std::array<float, 4> paint_curve_handle() {
		// TODO: MISSING DEREF! USE #DEFINE!
		PyObject *seqval = PyObject_GetAttrString(pyobjref, "paint_curve_handle");
		std::array<float, 4> resarr;
		for (int i = 0; i < 4; i++)
			resarr[i] = (float)PyFloat_AsDouble(PySequence_GetItem(seqval, i));
		return resarr;
	}

	/** Setter:  */
	void paint_curve_handle(float values[4]) { /* not implemented */ }

	/** Getter:  */
	std::array<float, 4> paint_curve_pivot() {
		// TODO: MISSING DEREF! USE #DEFINE!
		PyObject *seqval = PyObject_GetAttrString(pyobjref, "paint_curve_pivot");
		std::array<float, 4> resarr;
		for (int i = 0; i < 4; i++)
			resarr[i] = (float)PyFloat_AsDouble(PySequence_GetItem(seqval, i));
		return resarr;
	}

	/** Setter:  */
	void paint_curve_pivot(float values[4]) { /* not implemented */ }

};

/**************** Theme Sequence Editor ****************/

/**
 * Theme settings for the Sequence Editor
 */
class ThemeSequenceEditor : public pyUniplug {
public:
	ThemeSequenceEditor(PyObject* pyobj) : pyUniplug(pyobj) {}

	ThemeSequenceEditor() : pyUniplug(0)
	{
		// not implemented
	}

	/** Getter: Settings for space */
	ThemeSpaceGeneric space() {
		/* not implemented */ throw NULL;
	}

	/** Getter:  */
	std::array<float, 3> gp_vertex() {
		// TODO: MISSING DEREF! USE #DEFINE!
		PyObject *seqval = PyObject_GetAttrString(pyobjref, "gp_vertex");
		std::array<float, 3> resarr;
		for (int i = 0; i < 3; i++)
			resarr[i] = (float)PyFloat_AsDouble(PySequence_GetItem(seqval, i));
		return resarr;
	}

	/** Setter:  */
	void gp_vertex(float values[3]) { /* not implemented */ }

	/** Getter:  */
	std::array<float, 3> gp_vertex_select() {
		// TODO: MISSING DEREF! USE #DEFINE!
		PyObject *seqval = PyObject_GetAttrString(pyobjref, "gp_vertex_select");
		std::array<float, 3> resarr;
		for (int i = 0; i < 3; i++)
			resarr[i] = (float)PyFloat_AsDouble(PySequence_GetItem(seqval, i));
		return resarr;
	}

	/** Setter:  */
	void gp_vertex_select(float values[3]) { /* not implemented */ }

	/** Getter:  */
	int gp_vertex_size() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "gp_vertex_size"));
	}

	/** Setter:  */
	void gp_vertex_size(int value) {
		PyObject_SetAttrString(pyobjref, "gp_vertex_size", Py_BuildValue("i", value));
	}

	/** Getter:  */
	std::array<float, 3> grid() {
		// TODO: MISSING DEREF! USE #DEFINE!
		PyObject *seqval = PyObject_GetAttrString(pyobjref, "grid");
		std::array<float, 3> resarr;
		for (int i = 0; i < 3; i++)
			resarr[i] = (float)PyFloat_AsDouble(PySequence_GetItem(seqval, i));
		return resarr;
	}

	/** Setter:  */
	void grid(float values[3]) { /* not implemented */ }

	/** Getter:  */
	std::array<float, 3> window_sliders() {
		// TODO: MISSING DEREF! USE #DEFINE!
		PyObject *seqval = PyObject_GetAttrString(pyobjref, "window_sliders");
		std::array<float, 3> resarr;
		for (int i = 0; i < 3; i++)
			resarr[i] = (float)PyFloat_AsDouble(PySequence_GetItem(seqval, i));
		return resarr;
	}

	/** Setter:  */
	void window_sliders(float values[3]) { /* not implemented */ }

	/** Getter:  */
	std::array<float, 3> movie_strip() {
		// TODO: MISSING DEREF! USE #DEFINE!
		PyObject *seqval = PyObject_GetAttrString(pyobjref, "movie_strip");
		std::array<float, 3> resarr;
		for (int i = 0; i < 3; i++)
			resarr[i] = (float)PyFloat_AsDouble(PySequence_GetItem(seqval, i));
		return resarr;
	}

	/** Setter:  */
	void movie_strip(float values[3]) { /* not implemented */ }

	/** Getter:  */
	std::array<float, 3> movieclip_strip() {
		// TODO: MISSING DEREF! USE #DEFINE!
		PyObject *seqval = PyObject_GetAttrString(pyobjref, "movieclip_strip");
		std::array<float, 3> resarr;
		for (int i = 0; i < 3; i++)
			resarr[i] = (float)PyFloat_AsDouble(PySequence_GetItem(seqval, i));
		return resarr;
	}

	/** Setter:  */
	void movieclip_strip(float values[3]) { /* not implemented */ }

	/** Getter:  */
	std::array<float, 3> image_strip() {
		// TODO: MISSING DEREF! USE #DEFINE!
		PyObject *seqval = PyObject_GetAttrString(pyobjref, "image_strip");
		std::array<float, 3> resarr;
		for (int i = 0; i < 3; i++)
			resarr[i] = (float)PyFloat_AsDouble(PySequence_GetItem(seqval, i));
		return resarr;
	}

	/** Setter:  */
	void image_strip(float values[3]) { /* not implemented */ }

	/** Getter:  */
	std::array<float, 3> scene_strip() {
		// TODO: MISSING DEREF! USE #DEFINE!
		PyObject *seqval = PyObject_GetAttrString(pyobjref, "scene_strip");
		std::array<float, 3> resarr;
		for (int i = 0; i < 3; i++)
			resarr[i] = (float)PyFloat_AsDouble(PySequence_GetItem(seqval, i));
		return resarr;
	}

	/** Setter:  */
	void scene_strip(float values[3]) { /* not implemented */ }

	/** Getter:  */
	std::array<float, 3> audio_strip() {
		// TODO: MISSING DEREF! USE #DEFINE!
		PyObject *seqval = PyObject_GetAttrString(pyobjref, "audio_strip");
		std::array<float, 3> resarr;
		for (int i = 0; i < 3; i++)
			resarr[i] = (float)PyFloat_AsDouble(PySequence_GetItem(seqval, i));
		return resarr;
	}

	/** Setter:  */
	void audio_strip(float values[3]) { /* not implemented */ }

	/** Getter:  */
	std::array<float, 3> effect_strip() {
		// TODO: MISSING DEREF! USE #DEFINE!
		PyObject *seqval = PyObject_GetAttrString(pyobjref, "effect_strip");
		std::array<float, 3> resarr;
		for (int i = 0; i < 3; i++)
			resarr[i] = (float)PyFloat_AsDouble(PySequence_GetItem(seqval, i));
		return resarr;
	}

	/** Setter:  */
	void effect_strip(float values[3]) { /* not implemented */ }

	/** Getter:  */
	std::array<float, 3> transition_strip() {
		// TODO: MISSING DEREF! USE #DEFINE!
		PyObject *seqval = PyObject_GetAttrString(pyobjref, "transition_strip");
		std::array<float, 3> resarr;
		for (int i = 0; i < 3; i++)
			resarr[i] = (float)PyFloat_AsDouble(PySequence_GetItem(seqval, i));
		return resarr;
	}

	/** Setter:  */
	void transition_strip(float values[3]) { /* not implemented */ }

	/** Getter:  */
	std::array<float, 3> meta_strip() {
		// TODO: MISSING DEREF! USE #DEFINE!
		PyObject *seqval = PyObject_GetAttrString(pyobjref, "meta_strip");
		std::array<float, 3> resarr;
		for (int i = 0; i < 3; i++)
			resarr[i] = (float)PyFloat_AsDouble(PySequence_GetItem(seqval, i));
		return resarr;
	}

	/** Setter:  */
	void meta_strip(float values[3]) { /* not implemented */ }

	/** Getter:  */
	std::array<float, 3> frame_current() {
		// TODO: MISSING DEREF! USE #DEFINE!
		PyObject *seqval = PyObject_GetAttrString(pyobjref, "frame_current");
		std::array<float, 3> resarr;
		for (int i = 0; i < 3; i++)
			resarr[i] = (float)PyFloat_AsDouble(PySequence_GetItem(seqval, i));
		return resarr;
	}

	/** Setter:  */
	void frame_current(float values[3]) { /* not implemented */ }

	/** Getter:  */
	std::array<float, 3> keyframe() {
		// TODO: MISSING DEREF! USE #DEFINE!
		PyObject *seqval = PyObject_GetAttrString(pyobjref, "keyframe");
		std::array<float, 3> resarr;
		for (int i = 0; i < 3; i++)
			resarr[i] = (float)PyFloat_AsDouble(PySequence_GetItem(seqval, i));
		return resarr;
	}

	/** Setter:  */
	void keyframe(float values[3]) { /* not implemented */ }

	/** Getter:  */
	std::array<float, 3> draw_action() {
		// TODO: MISSING DEREF! USE #DEFINE!
		PyObject *seqval = PyObject_GetAttrString(pyobjref, "draw_action");
		std::array<float, 3> resarr;
		for (int i = 0; i < 3; i++)
			resarr[i] = (float)PyFloat_AsDouble(PySequence_GetItem(seqval, i));
		return resarr;
	}

	/** Setter:  */
	void draw_action(float values[3]) { /* not implemented */ }

	/** Getter:  */
	std::array<float, 3> preview_back() {
		// TODO: MISSING DEREF! USE #DEFINE!
		PyObject *seqval = PyObject_GetAttrString(pyobjref, "preview_back");
		std::array<float, 3> resarr;
		for (int i = 0; i < 3; i++)
			resarr[i] = (float)PyFloat_AsDouble(PySequence_GetItem(seqval, i));
		return resarr;
	}

	/** Setter:  */
	void preview_back(float values[3]) { /* not implemented */ }

	/** Getter:  */
	std::array<float, 3> metadatabg() {
		// TODO: MISSING DEREF! USE #DEFINE!
		PyObject *seqval = PyObject_GetAttrString(pyobjref, "metadatabg");
		std::array<float, 3> resarr;
		for (int i = 0; i < 3; i++)
			resarr[i] = (float)PyFloat_AsDouble(PySequence_GetItem(seqval, i));
		return resarr;
	}

	/** Setter:  */
	void metadatabg(float values[3]) { /* not implemented */ }

	/** Getter:  */
	std::array<float, 3> metadatatext() {
		// TODO: MISSING DEREF! USE #DEFINE!
		PyObject *seqval = PyObject_GetAttrString(pyobjref, "metadatatext");
		std::array<float, 3> resarr;
		for (int i = 0; i < 3; i++)
			resarr[i] = (float)PyFloat_AsDouble(PySequence_GetItem(seqval, i));
		return resarr;
	}

	/** Setter:  */
	void metadatatext(float values[3]) { /* not implemented */ }

};

/**************** Theme Properties ****************/

/**
 * Theme settings for the Properties
 */
class ThemeProperties : public pyUniplug {
public:
	ThemeProperties(PyObject* pyobj) : pyUniplug(pyobj) {}

	ThemeProperties() : pyUniplug(0)
	{
		// not implemented
	}

	/** Getter: Settings for space */
	ThemeSpaceGeneric space() {
		/* not implemented */ throw NULL;
	}

};

/**************** Theme Text Editor ****************/

/**
 * Theme settings for the Text Editor
 */
class ThemeTextEditor : public pyUniplug {
public:
	ThemeTextEditor(PyObject* pyobj) : pyUniplug(pyobj) {}

	ThemeTextEditor() : pyUniplug(0)
	{
		// not implemented
	}

	/** Getter: Settings for space */
	ThemeSpaceGeneric space() {
		/* not implemented */ throw NULL;
	}

	/** Getter:  */
	std::array<float, 3> line_numbers_background() {
		// TODO: MISSING DEREF! USE #DEFINE!
		PyObject *seqval = PyObject_GetAttrString(pyobjref, "line_numbers_background");
		std::array<float, 3> resarr;
		for (int i = 0; i < 3; i++)
			resarr[i] = (float)PyFloat_AsDouble(PySequence_GetItem(seqval, i));
		return resarr;
	}

	/** Setter:  */
	void line_numbers_background(float values[3]) { /* not implemented */ }

	/** Getter:  */
	std::array<float, 3> selected_text() {
		// TODO: MISSING DEREF! USE #DEFINE!
		PyObject *seqval = PyObject_GetAttrString(pyobjref, "selected_text");
		std::array<float, 3> resarr;
		for (int i = 0; i < 3; i++)
			resarr[i] = (float)PyFloat_AsDouble(PySequence_GetItem(seqval, i));
		return resarr;
	}

	/** Setter:  */
	void selected_text(float values[3]) { /* not implemented */ }

	/** Getter:  */
	std::array<float, 3> cursor() {
		// TODO: MISSING DEREF! USE #DEFINE!
		PyObject *seqval = PyObject_GetAttrString(pyobjref, "cursor");
		std::array<float, 3> resarr;
		for (int i = 0; i < 3; i++)
			resarr[i] = (float)PyFloat_AsDouble(PySequence_GetItem(seqval, i));
		return resarr;
	}

	/** Setter:  */
	void cursor(float values[3]) { /* not implemented */ }

	/** Getter:  */
	std::array<float, 3> syntax_builtin() {
		// TODO: MISSING DEREF! USE #DEFINE!
		PyObject *seqval = PyObject_GetAttrString(pyobjref, "syntax_builtin");
		std::array<float, 3> resarr;
		for (int i = 0; i < 3; i++)
			resarr[i] = (float)PyFloat_AsDouble(PySequence_GetItem(seqval, i));
		return resarr;
	}

	/** Setter:  */
	void syntax_builtin(float values[3]) { /* not implemented */ }

	/** Getter:  */
	std::array<float, 3> syntax_symbols() {
		// TODO: MISSING DEREF! USE #DEFINE!
		PyObject *seqval = PyObject_GetAttrString(pyobjref, "syntax_symbols");
		std::array<float, 3> resarr;
		for (int i = 0; i < 3; i++)
			resarr[i] = (float)PyFloat_AsDouble(PySequence_GetItem(seqval, i));
		return resarr;
	}

	/** Setter:  */
	void syntax_symbols(float values[3]) { /* not implemented */ }

	/** Getter:  */
	std::array<float, 3> syntax_special() {
		// TODO: MISSING DEREF! USE #DEFINE!
		PyObject *seqval = PyObject_GetAttrString(pyobjref, "syntax_special");
		std::array<float, 3> resarr;
		for (int i = 0; i < 3; i++)
			resarr[i] = (float)PyFloat_AsDouble(PySequence_GetItem(seqval, i));
		return resarr;
	}

	/** Setter:  */
	void syntax_special(float values[3]) { /* not implemented */ }

	/** Getter:  */
	std::array<float, 3> syntax_preprocessor() {
		// TODO: MISSING DEREF! USE #DEFINE!
		PyObject *seqval = PyObject_GetAttrString(pyobjref, "syntax_preprocessor");
		std::array<float, 3> resarr;
		for (int i = 0; i < 3; i++)
			resarr[i] = (float)PyFloat_AsDouble(PySequence_GetItem(seqval, i));
		return resarr;
	}

	/** Setter:  */
	void syntax_preprocessor(float values[3]) { /* not implemented */ }

	/** Getter:  */
	std::array<float, 3> syntax_reserved() {
		// TODO: MISSING DEREF! USE #DEFINE!
		PyObject *seqval = PyObject_GetAttrString(pyobjref, "syntax_reserved");
		std::array<float, 3> resarr;
		for (int i = 0; i < 3; i++)
			resarr[i] = (float)PyFloat_AsDouble(PySequence_GetItem(seqval, i));
		return resarr;
	}

	/** Setter:  */
	void syntax_reserved(float values[3]) { /* not implemented */ }

	/** Getter:  */
	std::array<float, 3> syntax_comment() {
		// TODO: MISSING DEREF! USE #DEFINE!
		PyObject *seqval = PyObject_GetAttrString(pyobjref, "syntax_comment");
		std::array<float, 3> resarr;
		for (int i = 0; i < 3; i++)
			resarr[i] = (float)PyFloat_AsDouble(PySequence_GetItem(seqval, i));
		return resarr;
	}

	/** Setter:  */
	void syntax_comment(float values[3]) { /* not implemented */ }

	/** Getter:  */
	std::array<float, 3> syntax_string() {
		// TODO: MISSING DEREF! USE #DEFINE!
		PyObject *seqval = PyObject_GetAttrString(pyobjref, "syntax_string");
		std::array<float, 3> resarr;
		for (int i = 0; i < 3; i++)
			resarr[i] = (float)PyFloat_AsDouble(PySequence_GetItem(seqval, i));
		return resarr;
	}

	/** Setter:  */
	void syntax_string(float values[3]) { /* not implemented */ }

	/** Getter:  */
	std::array<float, 3> syntax_numbers() {
		// TODO: MISSING DEREF! USE #DEFINE!
		PyObject *seqval = PyObject_GetAttrString(pyobjref, "syntax_numbers");
		std::array<float, 3> resarr;
		for (int i = 0; i < 3; i++)
			resarr[i] = (float)PyFloat_AsDouble(PySequence_GetItem(seqval, i));
		return resarr;
	}

	/** Setter:  */
	void syntax_numbers(float values[3]) { /* not implemented */ }

};

/**************** Theme Timeline ****************/

/**
 * Theme settings for the Timeline
 */
class ThemeTimeline : public pyUniplug {
public:
	ThemeTimeline(PyObject* pyobj) : pyUniplug(pyobj) {}

	ThemeTimeline() : pyUniplug(0)
	{
		// not implemented
	}

	/** Getter: Settings for space */
	ThemeSpaceGeneric space() {
		/* not implemented */ throw NULL;
	}

	/** Getter:  */
	std::array<float, 3> grid() {
		// TODO: MISSING DEREF! USE #DEFINE!
		PyObject *seqval = PyObject_GetAttrString(pyobjref, "grid");
		std::array<float, 3> resarr;
		for (int i = 0; i < 3; i++)
			resarr[i] = (float)PyFloat_AsDouble(PySequence_GetItem(seqval, i));
		return resarr;
	}

	/** Setter:  */
	void grid(float values[3]) { /* not implemented */ }

	/** Getter:  */
	std::array<float, 3> frame_current() {
		// TODO: MISSING DEREF! USE #DEFINE!
		PyObject *seqval = PyObject_GetAttrString(pyobjref, "frame_current");
		std::array<float, 3> resarr;
		for (int i = 0; i < 3; i++)
			resarr[i] = (float)PyFloat_AsDouble(PySequence_GetItem(seqval, i));
		return resarr;
	}

	/** Setter:  */
	void frame_current(float values[3]) { /* not implemented */ }

	/** Getter: Base color for keyframe indicator lines */
	std::array<float, 3> time_keyframe() {
		// TODO: MISSING DEREF! USE #DEFINE!
		PyObject *seqval = PyObject_GetAttrString(pyobjref, "time_keyframe");
		std::array<float, 3> resarr;
		for (int i = 0; i < 3; i++)
			resarr[i] = (float)PyFloat_AsDouble(PySequence_GetItem(seqval, i));
		return resarr;
	}

	/** Setter: Base color for keyframe indicator lines */
	void time_keyframe(float values[3]) { /* not implemented */ }

	/** Getter: Color of Grease Pencil keyframes */
	std::array<float, 3> time_grease_pencil() {
		// TODO: MISSING DEREF! USE #DEFINE!
		PyObject *seqval = PyObject_GetAttrString(pyobjref, "time_grease_pencil");
		std::array<float, 3> resarr;
		for (int i = 0; i < 3; i++)
			resarr[i] = (float)PyFloat_AsDouble(PySequence_GetItem(seqval, i));
		return resarr;
	}

	/** Setter: Color of Grease Pencil keyframes */
	void time_grease_pencil(float values[3]) { /* not implemented */ }

};

/**************** Theme Node Editor ****************/

/**
 * Theme settings for the Node Editor
 */
class ThemeNodeEditor : public pyUniplug {
public:
	ThemeNodeEditor(PyObject* pyobj) : pyUniplug(pyobj) {}

	ThemeNodeEditor() : pyUniplug(0)
	{
		// not implemented
	}

	/** Getter: Settings for space */
	ThemeSpaceGeneric space() {
		/* not implemented */ throw NULL;
	}

	/** Getter: Settings for space list */
	ThemeSpaceListGeneric space_list() {
		/* not implemented */ throw NULL;
	}

	/** Getter:  */
	std::array<float, 3> gp_vertex() {
		// TODO: MISSING DEREF! USE #DEFINE!
		PyObject *seqval = PyObject_GetAttrString(pyobjref, "gp_vertex");
		std::array<float, 3> resarr;
		for (int i = 0; i < 3; i++)
			resarr[i] = (float)PyFloat_AsDouble(PySequence_GetItem(seqval, i));
		return resarr;
	}

	/** Setter:  */
	void gp_vertex(float values[3]) { /* not implemented */ }

	/** Getter:  */
	std::array<float, 3> gp_vertex_select() {
		// TODO: MISSING DEREF! USE #DEFINE!
		PyObject *seqval = PyObject_GetAttrString(pyobjref, "gp_vertex_select");
		std::array<float, 3> resarr;
		for (int i = 0; i < 3; i++)
			resarr[i] = (float)PyFloat_AsDouble(PySequence_GetItem(seqval, i));
		return resarr;
	}

	/** Setter:  */
	void gp_vertex_select(float values[3]) { /* not implemented */ }

	/** Getter:  */
	int gp_vertex_size() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "gp_vertex_size"));
	}

	/** Setter:  */
	void gp_vertex_size(int value) {
		PyObject_SetAttrString(pyobjref, "gp_vertex_size", Py_BuildValue("i", value));
	}

	/** Getter:  */
	std::array<float, 3> node_selected() {
		// TODO: MISSING DEREF! USE #DEFINE!
		PyObject *seqval = PyObject_GetAttrString(pyobjref, "node_selected");
		std::array<float, 3> resarr;
		for (int i = 0; i < 3; i++)
			resarr[i] = (float)PyFloat_AsDouble(PySequence_GetItem(seqval, i));
		return resarr;
	}

	/** Setter:  */
	void node_selected(float values[3]) { /* not implemented */ }

	/** Getter:  */
	std::array<float, 3> node_active() {
		// TODO: MISSING DEREF! USE #DEFINE!
		PyObject *seqval = PyObject_GetAttrString(pyobjref, "node_active");
		std::array<float, 3> resarr;
		for (int i = 0; i < 3; i++)
			resarr[i] = (float)PyFloat_AsDouble(PySequence_GetItem(seqval, i));
		return resarr;
	}

	/** Setter:  */
	void node_active(float values[3]) { /* not implemented */ }

	/** Getter:  */
	std::array<float, 3> wire() {
		// TODO: MISSING DEREF! USE #DEFINE!
		PyObject *seqval = PyObject_GetAttrString(pyobjref, "wire");
		std::array<float, 3> resarr;
		for (int i = 0; i < 3; i++)
			resarr[i] = (float)PyFloat_AsDouble(PySequence_GetItem(seqval, i));
		return resarr;
	}

	/** Setter:  */
	void wire(float values[3]) { /* not implemented */ }

	/** Getter:  */
	std::array<float, 3> wire_inner() {
		// TODO: MISSING DEREF! USE #DEFINE!
		PyObject *seqval = PyObject_GetAttrString(pyobjref, "wire_inner");
		std::array<float, 3> resarr;
		for (int i = 0; i < 3; i++)
			resarr[i] = (float)PyFloat_AsDouble(PySequence_GetItem(seqval, i));
		return resarr;
	}

	/** Setter:  */
	void wire_inner(float values[3]) { /* not implemented */ }

	/** Getter:  */
	std::array<float, 3> wire_select() {
		// TODO: MISSING DEREF! USE #DEFINE!
		PyObject *seqval = PyObject_GetAttrString(pyobjref, "wire_select");
		std::array<float, 3> resarr;
		for (int i = 0; i < 3; i++)
			resarr[i] = (float)PyFloat_AsDouble(PySequence_GetItem(seqval, i));
		return resarr;
	}

	/** Setter:  */
	void wire_select(float values[3]) { /* not implemented */ }

	/** Getter:  */
	std::array<float, 3> selected_text() {
		// TODO: MISSING DEREF! USE #DEFINE!
		PyObject *seqval = PyObject_GetAttrString(pyobjref, "selected_text");
		std::array<float, 3> resarr;
		for (int i = 0; i < 3; i++)
			resarr[i] = (float)PyFloat_AsDouble(PySequence_GetItem(seqval, i));
		return resarr;
	}

	/** Setter:  */
	void selected_text(float values[3]) { /* not implemented */ }

	/** Getter:  */
	std::array<float, 4> node_backdrop() {
		// TODO: MISSING DEREF! USE #DEFINE!
		PyObject *seqval = PyObject_GetAttrString(pyobjref, "node_backdrop");
		std::array<float, 4> resarr;
		for (int i = 0; i < 4; i++)
			resarr[i] = (float)PyFloat_AsDouble(PySequence_GetItem(seqval, i));
		return resarr;
	}

	/** Setter:  */
	void node_backdrop(float values[4]) { /* not implemented */ }

	/** Getter:  */
	std::array<float, 3> converter_node() {
		// TODO: MISSING DEREF! USE #DEFINE!
		PyObject *seqval = PyObject_GetAttrString(pyobjref, "converter_node");
		std::array<float, 3> resarr;
		for (int i = 0; i < 3; i++)
			resarr[i] = (float)PyFloat_AsDouble(PySequence_GetItem(seqval, i));
		return resarr;
	}

	/** Setter:  */
	void converter_node(float values[3]) { /* not implemented */ }

	/** Getter:  */
	std::array<float, 3> color_node() {
		// TODO: MISSING DEREF! USE #DEFINE!
		PyObject *seqval = PyObject_GetAttrString(pyobjref, "color_node");
		std::array<float, 3> resarr;
		for (int i = 0; i < 3; i++)
			resarr[i] = (float)PyFloat_AsDouble(PySequence_GetItem(seqval, i));
		return resarr;
	}

	/** Setter:  */
	void color_node(float values[3]) { /* not implemented */ }

	/** Getter:  */
	std::array<float, 3> group_node() {
		// TODO: MISSING DEREF! USE #DEFINE!
		PyObject *seqval = PyObject_GetAttrString(pyobjref, "group_node");
		std::array<float, 3> resarr;
		for (int i = 0; i < 3; i++)
			resarr[i] = (float)PyFloat_AsDouble(PySequence_GetItem(seqval, i));
		return resarr;
	}

	/** Setter:  */
	void group_node(float values[3]) { /* not implemented */ }

	/** Getter:  */
	std::array<float, 3> group_socket_node() {
		// TODO: MISSING DEREF! USE #DEFINE!
		PyObject *seqval = PyObject_GetAttrString(pyobjref, "group_socket_node");
		std::array<float, 3> resarr;
		for (int i = 0; i < 3; i++)
			resarr[i] = (float)PyFloat_AsDouble(PySequence_GetItem(seqval, i));
		return resarr;
	}

	/** Setter:  */
	void group_socket_node(float values[3]) { /* not implemented */ }

	/** Getter:  */
	std::array<float, 4> frame_node() {
		// TODO: MISSING DEREF! USE #DEFINE!
		PyObject *seqval = PyObject_GetAttrString(pyobjref, "frame_node");
		std::array<float, 4> resarr;
		for (int i = 0; i < 4; i++)
			resarr[i] = (float)PyFloat_AsDouble(PySequence_GetItem(seqval, i));
		return resarr;
	}

	/** Setter:  */
	void frame_node(float values[4]) { /* not implemented */ }

	/** Getter:  */
	std::array<float, 3> matte_node() {
		// TODO: MISSING DEREF! USE #DEFINE!
		PyObject *seqval = PyObject_GetAttrString(pyobjref, "matte_node");
		std::array<float, 3> resarr;
		for (int i = 0; i < 3; i++)
			resarr[i] = (float)PyFloat_AsDouble(PySequence_GetItem(seqval, i));
		return resarr;
	}

	/** Setter:  */
	void matte_node(float values[3]) { /* not implemented */ }

	/** Getter:  */
	std::array<float, 3> distor_node() {
		// TODO: MISSING DEREF! USE #DEFINE!
		PyObject *seqval = PyObject_GetAttrString(pyobjref, "distor_node");
		std::array<float, 3> resarr;
		for (int i = 0; i < 3; i++)
			resarr[i] = (float)PyFloat_AsDouble(PySequence_GetItem(seqval, i));
		return resarr;
	}

	/** Setter:  */
	void distor_node(float values[3]) { /* not implemented */ }

	/** Getter: Curving of the noodle */
	int noodle_curving() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "noodle_curving"));
	}

	/** Setter: Curving of the noodle */
	void noodle_curving(int value) {
		PyObject_SetAttrString(pyobjref, "noodle_curving", Py_BuildValue("i", value));
	}

	/** Getter:  */
	std::array<float, 3> input_node() {
		// TODO: MISSING DEREF! USE #DEFINE!
		PyObject *seqval = PyObject_GetAttrString(pyobjref, "input_node");
		std::array<float, 3> resarr;
		for (int i = 0; i < 3; i++)
			resarr[i] = (float)PyFloat_AsDouble(PySequence_GetItem(seqval, i));
		return resarr;
	}

	/** Setter:  */
	void input_node(float values[3]) { /* not implemented */ }

	/** Getter:  */
	std::array<float, 3> output_node() {
		// TODO: MISSING DEREF! USE #DEFINE!
		PyObject *seqval = PyObject_GetAttrString(pyobjref, "output_node");
		std::array<float, 3> resarr;
		for (int i = 0; i < 3; i++)
			resarr[i] = (float)PyFloat_AsDouble(PySequence_GetItem(seqval, i));
		return resarr;
	}

	/** Setter:  */
	void output_node(float values[3]) { /* not implemented */ }

	/** Getter:  */
	std::array<float, 3> filter_node() {
		// TODO: MISSING DEREF! USE #DEFINE!
		PyObject *seqval = PyObject_GetAttrString(pyobjref, "filter_node");
		std::array<float, 3> resarr;
		for (int i = 0; i < 3; i++)
			resarr[i] = (float)PyFloat_AsDouble(PySequence_GetItem(seqval, i));
		return resarr;
	}

	/** Setter:  */
	void filter_node(float values[3]) { /* not implemented */ }

	/** Getter:  */
	std::array<float, 3> vector_node() {
		// TODO: MISSING DEREF! USE #DEFINE!
		PyObject *seqval = PyObject_GetAttrString(pyobjref, "vector_node");
		std::array<float, 3> resarr;
		for (int i = 0; i < 3; i++)
			resarr[i] = (float)PyFloat_AsDouble(PySequence_GetItem(seqval, i));
		return resarr;
	}

	/** Setter:  */
	void vector_node(float values[3]) { /* not implemented */ }

	/** Getter:  */
	std::array<float, 3> texture_node() {
		// TODO: MISSING DEREF! USE #DEFINE!
		PyObject *seqval = PyObject_GetAttrString(pyobjref, "texture_node");
		std::array<float, 3> resarr;
		for (int i = 0; i < 3; i++)
			resarr[i] = (float)PyFloat_AsDouble(PySequence_GetItem(seqval, i));
		return resarr;
	}

	/** Setter:  */
	void texture_node(float values[3]) { /* not implemented */ }

	/** Getter:  */
	std::array<float, 3> shader_node() {
		// TODO: MISSING DEREF! USE #DEFINE!
		PyObject *seqval = PyObject_GetAttrString(pyobjref, "shader_node");
		std::array<float, 3> resarr;
		for (int i = 0; i < 3; i++)
			resarr[i] = (float)PyFloat_AsDouble(PySequence_GetItem(seqval, i));
		return resarr;
	}

	/** Setter:  */
	void shader_node(float values[3]) { /* not implemented */ }

	/** Getter:  */
	std::array<float, 3> script_node() {
		// TODO: MISSING DEREF! USE #DEFINE!
		PyObject *seqval = PyObject_GetAttrString(pyobjref, "script_node");
		std::array<float, 3> resarr;
		for (int i = 0; i < 3; i++)
			resarr[i] = (float)PyFloat_AsDouble(PySequence_GetItem(seqval, i));
		return resarr;
	}

	/** Setter:  */
	void script_node(float values[3]) { /* not implemented */ }

	/** Getter:  */
	std::array<float, 3> pattern_node() {
		// TODO: MISSING DEREF! USE #DEFINE!
		PyObject *seqval = PyObject_GetAttrString(pyobjref, "pattern_node");
		std::array<float, 3> resarr;
		for (int i = 0; i < 3; i++)
			resarr[i] = (float)PyFloat_AsDouble(PySequence_GetItem(seqval, i));
		return resarr;
	}

	/** Setter:  */
	void pattern_node(float values[3]) { /* not implemented */ }

	/** Getter:  */
	std::array<float, 3> layout_node() {
		// TODO: MISSING DEREF! USE #DEFINE!
		PyObject *seqval = PyObject_GetAttrString(pyobjref, "layout_node");
		std::array<float, 3> resarr;
		for (int i = 0; i < 3; i++)
			resarr[i] = (float)PyFloat_AsDouble(PySequence_GetItem(seqval, i));
		return resarr;
	}

	/** Setter:  */
	void layout_node(float values[3]) { /* not implemented */ }

};

/**************** Theme Outliner ****************/

/**
 * Theme settings for the Outliner
 */
class ThemeOutliner : public pyUniplug {
public:
	ThemeOutliner(PyObject* pyobj) : pyUniplug(pyobj) {}

	ThemeOutliner() : pyUniplug(0)
	{
		// not implemented
	}

	/** Getter: Settings for space */
	ThemeSpaceGeneric space() {
		/* not implemented */ throw NULL;
	}

	/** Getter:  */
	std::array<float, 3> match() {
		// TODO: MISSING DEREF! USE #DEFINE!
		PyObject *seqval = PyObject_GetAttrString(pyobjref, "match");
		std::array<float, 3> resarr;
		for (int i = 0; i < 3; i++)
			resarr[i] = (float)PyFloat_AsDouble(PySequence_GetItem(seqval, i));
		return resarr;
	}

	/** Setter:  */
	void match(float values[3]) { /* not implemented */ }

	/** Getter:  */
	std::array<float, 3> selected_highlight() {
		// TODO: MISSING DEREF! USE #DEFINE!
		PyObject *seqval = PyObject_GetAttrString(pyobjref, "selected_highlight");
		std::array<float, 3> resarr;
		for (int i = 0; i < 3; i++)
			resarr[i] = (float)PyFloat_AsDouble(PySequence_GetItem(seqval, i));
		return resarr;
	}

	/** Setter:  */
	void selected_highlight(float values[3]) { /* not implemented */ }

};

/**************** Theme Info ****************/

/**
 * Theme settings for Info
 */
class ThemeInfo : public pyUniplug {
public:
	ThemeInfo(PyObject* pyobj) : pyUniplug(pyobj) {}

	ThemeInfo() : pyUniplug(0)
	{
		// not implemented
	}

	/** Getter: Settings for space */
	ThemeSpaceGeneric space() {
		/* not implemented */ throw NULL;
	}

	/** Getter:  */
	std::array<float, 3> info_selected() {
		// TODO: MISSING DEREF! USE #DEFINE!
		PyObject *seqval = PyObject_GetAttrString(pyobjref, "info_selected");
		std::array<float, 3> resarr;
		for (int i = 0; i < 3; i++)
			resarr[i] = (float)PyFloat_AsDouble(PySequence_GetItem(seqval, i));
		return resarr;
	}

	/** Setter:  */
	void info_selected(float values[3]) { /* not implemented */ }

	/** Getter:  */
	std::array<float, 3> info_selected_text() {
		// TODO: MISSING DEREF! USE #DEFINE!
		PyObject *seqval = PyObject_GetAttrString(pyobjref, "info_selected_text");
		std::array<float, 3> resarr;
		for (int i = 0; i < 3; i++)
			resarr[i] = (float)PyFloat_AsDouble(PySequence_GetItem(seqval, i));
		return resarr;
	}

	/** Setter:  */
	void info_selected_text(float values[3]) { /* not implemented */ }

	/** Getter:  */
	std::array<float, 3> info_error() {
		// TODO: MISSING DEREF! USE #DEFINE!
		PyObject *seqval = PyObject_GetAttrString(pyobjref, "info_error");
		std::array<float, 3> resarr;
		for (int i = 0; i < 3; i++)
			resarr[i] = (float)PyFloat_AsDouble(PySequence_GetItem(seqval, i));
		return resarr;
	}

	/** Setter:  */
	void info_error(float values[3]) { /* not implemented */ }

	/** Getter:  */
	std::array<float, 3> info_error_text() {
		// TODO: MISSING DEREF! USE #DEFINE!
		PyObject *seqval = PyObject_GetAttrString(pyobjref, "info_error_text");
		std::array<float, 3> resarr;
		for (int i = 0; i < 3; i++)
			resarr[i] = (float)PyFloat_AsDouble(PySequence_GetItem(seqval, i));
		return resarr;
	}

	/** Setter:  */
	void info_error_text(float values[3]) { /* not implemented */ }

	/** Getter:  */
	std::array<float, 3> info_warning() {
		// TODO: MISSING DEREF! USE #DEFINE!
		PyObject *seqval = PyObject_GetAttrString(pyobjref, "info_warning");
		std::array<float, 3> resarr;
		for (int i = 0; i < 3; i++)
			resarr[i] = (float)PyFloat_AsDouble(PySequence_GetItem(seqval, i));
		return resarr;
	}

	/** Setter:  */
	void info_warning(float values[3]) { /* not implemented */ }

	/** Getter:  */
	std::array<float, 3> info_warning_text() {
		// TODO: MISSING DEREF! USE #DEFINE!
		PyObject *seqval = PyObject_GetAttrString(pyobjref, "info_warning_text");
		std::array<float, 3> resarr;
		for (int i = 0; i < 3; i++)
			resarr[i] = (float)PyFloat_AsDouble(PySequence_GetItem(seqval, i));
		return resarr;
	}

	/** Setter:  */
	void info_warning_text(float values[3]) { /* not implemented */ }

	/** Getter:  */
	std::array<float, 3> info_info() {
		// TODO: MISSING DEREF! USE #DEFINE!
		PyObject *seqval = PyObject_GetAttrString(pyobjref, "info_info");
		std::array<float, 3> resarr;
		for (int i = 0; i < 3; i++)
			resarr[i] = (float)PyFloat_AsDouble(PySequence_GetItem(seqval, i));
		return resarr;
	}

	/** Setter:  */
	void info_info(float values[3]) { /* not implemented */ }

	/** Getter:  */
	std::array<float, 3> info_info_text() {
		// TODO: MISSING DEREF! USE #DEFINE!
		PyObject *seqval = PyObject_GetAttrString(pyobjref, "info_info_text");
		std::array<float, 3> resarr;
		for (int i = 0; i < 3; i++)
			resarr[i] = (float)PyFloat_AsDouble(PySequence_GetItem(seqval, i));
		return resarr;
	}

	/** Setter:  */
	void info_info_text(float values[3]) { /* not implemented */ }

	/** Getter:  */
	std::array<float, 3> info_debug() {
		// TODO: MISSING DEREF! USE #DEFINE!
		PyObject *seqval = PyObject_GetAttrString(pyobjref, "info_debug");
		std::array<float, 3> resarr;
		for (int i = 0; i < 3; i++)
			resarr[i] = (float)PyFloat_AsDouble(PySequence_GetItem(seqval, i));
		return resarr;
	}

	/** Setter:  */
	void info_debug(float values[3]) { /* not implemented */ }

	/** Getter:  */
	std::array<float, 3> info_debug_text() {
		// TODO: MISSING DEREF! USE #DEFINE!
		PyObject *seqval = PyObject_GetAttrString(pyobjref, "info_debug_text");
		std::array<float, 3> resarr;
		for (int i = 0; i < 3; i++)
			resarr[i] = (float)PyFloat_AsDouble(PySequence_GetItem(seqval, i));
		return resarr;
	}

	/** Setter:  */
	void info_debug_text(float values[3]) { /* not implemented */ }

};

/**************** Theme User Preferences ****************/

/**
 * Theme settings for the User Preferences
 */
class ThemeUserPreferences : public pyUniplug {
public:
	ThemeUserPreferences(PyObject* pyobj) : pyUniplug(pyobj) {}

	ThemeUserPreferences() : pyUniplug(0)
	{
		// not implemented
	}

	/** Getter: Settings for space */
	ThemeSpaceGeneric space() {
		/* not implemented */ throw NULL;
	}

};

/**************** Theme Console ****************/

/**
 * Theme settings for the Console
 */
class ThemeConsole : public pyUniplug {
public:
	ThemeConsole(PyObject* pyobj) : pyUniplug(pyobj) {}

	ThemeConsole() : pyUniplug(0)
	{
		// not implemented
	}

	/** Getter: Settings for space */
	ThemeSpaceGeneric space() {
		/* not implemented */ throw NULL;
	}

	/** Getter:  */
	std::array<float, 3> line_output() {
		// TODO: MISSING DEREF! USE #DEFINE!
		PyObject *seqval = PyObject_GetAttrString(pyobjref, "line_output");
		std::array<float, 3> resarr;
		for (int i = 0; i < 3; i++)
			resarr[i] = (float)PyFloat_AsDouble(PySequence_GetItem(seqval, i));
		return resarr;
	}

	/** Setter:  */
	void line_output(float values[3]) { /* not implemented */ }

	/** Getter:  */
	std::array<float, 3> line_input() {
		// TODO: MISSING DEREF! USE #DEFINE!
		PyObject *seqval = PyObject_GetAttrString(pyobjref, "line_input");
		std::array<float, 3> resarr;
		for (int i = 0; i < 3; i++)
			resarr[i] = (float)PyFloat_AsDouble(PySequence_GetItem(seqval, i));
		return resarr;
	}

	/** Setter:  */
	void line_input(float values[3]) { /* not implemented */ }

	/** Getter:  */
	std::array<float, 3> line_info() {
		// TODO: MISSING DEREF! USE #DEFINE!
		PyObject *seqval = PyObject_GetAttrString(pyobjref, "line_info");
		std::array<float, 3> resarr;
		for (int i = 0; i < 3; i++)
			resarr[i] = (float)PyFloat_AsDouble(PySequence_GetItem(seqval, i));
		return resarr;
	}

	/** Setter:  */
	void line_info(float values[3]) { /* not implemented */ }

	/** Getter:  */
	std::array<float, 3> line_error() {
		// TODO: MISSING DEREF! USE #DEFINE!
		PyObject *seqval = PyObject_GetAttrString(pyobjref, "line_error");
		std::array<float, 3> resarr;
		for (int i = 0; i < 3; i++)
			resarr[i] = (float)PyFloat_AsDouble(PySequence_GetItem(seqval, i));
		return resarr;
	}

	/** Setter:  */
	void line_error(float values[3]) { /* not implemented */ }

	/** Getter:  */
	std::array<float, 3> cursor() {
		// TODO: MISSING DEREF! USE #DEFINE!
		PyObject *seqval = PyObject_GetAttrString(pyobjref, "cursor");
		std::array<float, 3> resarr;
		for (int i = 0; i < 3; i++)
			resarr[i] = (float)PyFloat_AsDouble(PySequence_GetItem(seqval, i));
		return resarr;
	}

	/** Setter:  */
	void cursor(float values[3]) { /* not implemented */ }

	/** Getter:  */
	std::array<float, 4> select() {
		// TODO: MISSING DEREF! USE #DEFINE!
		PyObject *seqval = PyObject_GetAttrString(pyobjref, "select");
		std::array<float, 4> resarr;
		for (int i = 0; i < 4; i++)
			resarr[i] = (float)PyFloat_AsDouble(PySequence_GetItem(seqval, i));
		return resarr;
	}

	/** Setter:  */
	void select(float values[4]) { /* not implemented */ }

};

/**************** Theme Logic Editor ****************/

/**
 * Theme settings for the Logic Editor
 */
class ThemeLogicEditor : public pyUniplug {
public:
	ThemeLogicEditor(PyObject* pyobj) : pyUniplug(pyobj) {}

	ThemeLogicEditor() : pyUniplug(0)
	{
		// not implemented
	}

	/** Getter: Settings for space */
	ThemeSpaceGeneric space() {
		/* not implemented */ throw NULL;
	}

};

/**************** Theme Clip Editor ****************/

/**
 * Theme settings for the Movie Clip Editor
 */
class ThemeClipEditor : public pyUniplug {
public:
	ThemeClipEditor(PyObject* pyobj) : pyUniplug(pyobj) {}

	ThemeClipEditor() : pyUniplug(0)
	{
		// not implemented
	}

	/** Getter: Settings for space */
	ThemeSpaceGeneric space() {
		/* not implemented */ throw NULL;
	}

	/** Getter: Settings for space list */
	ThemeSpaceListGeneric space_list() {
		/* not implemented */ throw NULL;
	}

	/** Getter:  */
	std::array<float, 3> gp_vertex() {
		// TODO: MISSING DEREF! USE #DEFINE!
		PyObject *seqval = PyObject_GetAttrString(pyobjref, "gp_vertex");
		std::array<float, 3> resarr;
		for (int i = 0; i < 3; i++)
			resarr[i] = (float)PyFloat_AsDouble(PySequence_GetItem(seqval, i));
		return resarr;
	}

	/** Setter:  */
	void gp_vertex(float values[3]) { /* not implemented */ }

	/** Getter:  */
	std::array<float, 3> gp_vertex_select() {
		// TODO: MISSING DEREF! USE #DEFINE!
		PyObject *seqval = PyObject_GetAttrString(pyobjref, "gp_vertex_select");
		std::array<float, 3> resarr;
		for (int i = 0; i < 3; i++)
			resarr[i] = (float)PyFloat_AsDouble(PySequence_GetItem(seqval, i));
		return resarr;
	}

	/** Setter:  */
	void gp_vertex_select(float values[3]) { /* not implemented */ }

	/** Getter:  */
	int gp_vertex_size() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "gp_vertex_size"));
	}

	/** Setter:  */
	void gp_vertex_size(int value) {
		PyObject_SetAttrString(pyobjref, "gp_vertex_size", Py_BuildValue("i", value));
	}

	/** Getter: Color of marker's outline */
	std::array<float, 3> marker_outline() {
		// TODO: MISSING DEREF! USE #DEFINE!
		PyObject *seqval = PyObject_GetAttrString(pyobjref, "marker_outline");
		std::array<float, 3> resarr;
		for (int i = 0; i < 3; i++)
			resarr[i] = (float)PyFloat_AsDouble(PySequence_GetItem(seqval, i));
		return resarr;
	}

	/** Setter: Color of marker's outline */
	void marker_outline(float values[3]) { /* not implemented */ }

	/** Getter: Color of marker */
	std::array<float, 3> marker() {
		// TODO: MISSING DEREF! USE #DEFINE!
		PyObject *seqval = PyObject_GetAttrString(pyobjref, "marker");
		std::array<float, 3> resarr;
		for (int i = 0; i < 3; i++)
			resarr[i] = (float)PyFloat_AsDouble(PySequence_GetItem(seqval, i));
		return resarr;
	}

	/** Setter: Color of marker */
	void marker(float values[3]) { /* not implemented */ }

	/** Getter: Color of active marker */
	std::array<float, 3> active_marker() {
		// TODO: MISSING DEREF! USE #DEFINE!
		PyObject *seqval = PyObject_GetAttrString(pyobjref, "active_marker");
		std::array<float, 3> resarr;
		for (int i = 0; i < 3; i++)
			resarr[i] = (float)PyFloat_AsDouble(PySequence_GetItem(seqval, i));
		return resarr;
	}

	/** Setter: Color of active marker */
	void active_marker(float values[3]) { /* not implemented */ }

	/** Getter: Color of selected marker */
	std::array<float, 3> selected_marker() {
		// TODO: MISSING DEREF! USE #DEFINE!
		PyObject *seqval = PyObject_GetAttrString(pyobjref, "selected_marker");
		std::array<float, 3> resarr;
		for (int i = 0; i < 3; i++)
			resarr[i] = (float)PyFloat_AsDouble(PySequence_GetItem(seqval, i));
		return resarr;
	}

	/** Setter: Color of selected marker */
	void selected_marker(float values[3]) { /* not implemented */ }

	/** Getter: Color of disabled marker */
	std::array<float, 3> disabled_marker() {
		// TODO: MISSING DEREF! USE #DEFINE!
		PyObject *seqval = PyObject_GetAttrString(pyobjref, "disabled_marker");
		std::array<float, 3> resarr;
		for (int i = 0; i < 3; i++)
			resarr[i] = (float)PyFloat_AsDouble(PySequence_GetItem(seqval, i));
		return resarr;
	}

	/** Setter: Color of disabled marker */
	void disabled_marker(float values[3]) { /* not implemented */ }

	/** Getter: Color of locked marker */
	std::array<float, 3> locked_marker() {
		// TODO: MISSING DEREF! USE #DEFINE!
		PyObject *seqval = PyObject_GetAttrString(pyobjref, "locked_marker");
		std::array<float, 3> resarr;
		for (int i = 0; i < 3; i++)
			resarr[i] = (float)PyFloat_AsDouble(PySequence_GetItem(seqval, i));
		return resarr;
	}

	/** Setter: Color of locked marker */
	void locked_marker(float values[3]) { /* not implemented */ }

	/** Getter: Color of path before current frame */
	std::array<float, 3> path_before() {
		// TODO: MISSING DEREF! USE #DEFINE!
		PyObject *seqval = PyObject_GetAttrString(pyobjref, "path_before");
		std::array<float, 3> resarr;
		for (int i = 0; i < 3; i++)
			resarr[i] = (float)PyFloat_AsDouble(PySequence_GetItem(seqval, i));
		return resarr;
	}

	/** Setter: Color of path before current frame */
	void path_before(float values[3]) { /* not implemented */ }

	/** Getter: Color of path after current frame */
	std::array<float, 3> path_after() {
		// TODO: MISSING DEREF! USE #DEFINE!
		PyObject *seqval = PyObject_GetAttrString(pyobjref, "path_after");
		std::array<float, 3> resarr;
		for (int i = 0; i < 3; i++)
			resarr[i] = (float)PyFloat_AsDouble(PySequence_GetItem(seqval, i));
		return resarr;
	}

	/** Setter: Color of path after current frame */
	void path_after(float values[3]) { /* not implemented */ }

	/** Getter:  */
	std::array<float, 3> frame_current() {
		// TODO: MISSING DEREF! USE #DEFINE!
		PyObject *seqval = PyObject_GetAttrString(pyobjref, "frame_current");
		std::array<float, 3> resarr;
		for (int i = 0; i < 3; i++)
			resarr[i] = (float)PyFloat_AsDouble(PySequence_GetItem(seqval, i));
		return resarr;
	}

	/** Setter:  */
	void frame_current(float values[3]) { /* not implemented */ }

	/** Getter:  */
	std::array<float, 3> strips() {
		// TODO: MISSING DEREF! USE #DEFINE!
		PyObject *seqval = PyObject_GetAttrString(pyobjref, "strips");
		std::array<float, 3> resarr;
		for (int i = 0; i < 3; i++)
			resarr[i] = (float)PyFloat_AsDouble(PySequence_GetItem(seqval, i));
		return resarr;
	}

	/** Setter:  */
	void strips(float values[3]) { /* not implemented */ }

	/** Getter:  */
	std::array<float, 3> strips_selected() {
		// TODO: MISSING DEREF! USE #DEFINE!
		PyObject *seqval = PyObject_GetAttrString(pyobjref, "strips_selected");
		std::array<float, 3> resarr;
		for (int i = 0; i < 3; i++)
			resarr[i] = (float)PyFloat_AsDouble(PySequence_GetItem(seqval, i));
		return resarr;
	}

	/** Setter:  */
	void strips_selected(float values[3]) { /* not implemented */ }

	/** Getter:  */
	std::array<float, 3> handle_free() {
		// TODO: MISSING DEREF! USE #DEFINE!
		PyObject *seqval = PyObject_GetAttrString(pyobjref, "handle_free");
		std::array<float, 3> resarr;
		for (int i = 0; i < 3; i++)
			resarr[i] = (float)PyFloat_AsDouble(PySequence_GetItem(seqval, i));
		return resarr;
	}

	/** Setter:  */
	void handle_free(float values[3]) { /* not implemented */ }

	/** Getter:  */
	std::array<float, 3> handle_auto() {
		// TODO: MISSING DEREF! USE #DEFINE!
		PyObject *seqval = PyObject_GetAttrString(pyobjref, "handle_auto");
		std::array<float, 3> resarr;
		for (int i = 0; i < 3; i++)
			resarr[i] = (float)PyFloat_AsDouble(PySequence_GetItem(seqval, i));
		return resarr;
	}

	/** Setter:  */
	void handle_auto(float values[3]) { /* not implemented */ }

	/** Getter:  */
	std::array<float, 3> handle_align() {
		// TODO: MISSING DEREF! USE #DEFINE!
		PyObject *seqval = PyObject_GetAttrString(pyobjref, "handle_align");
		std::array<float, 3> resarr;
		for (int i = 0; i < 3; i++)
			resarr[i] = (float)PyFloat_AsDouble(PySequence_GetItem(seqval, i));
		return resarr;
	}

	/** Setter:  */
	void handle_align(float values[3]) { /* not implemented */ }

	/** Getter:  */
	std::array<float, 3> handle_sel_free() {
		// TODO: MISSING DEREF! USE #DEFINE!
		PyObject *seqval = PyObject_GetAttrString(pyobjref, "handle_sel_free");
		std::array<float, 3> resarr;
		for (int i = 0; i < 3; i++)
			resarr[i] = (float)PyFloat_AsDouble(PySequence_GetItem(seqval, i));
		return resarr;
	}

	/** Setter:  */
	void handle_sel_free(float values[3]) { /* not implemented */ }

	/** Getter:  */
	std::array<float, 3> handle_sel_auto() {
		// TODO: MISSING DEREF! USE #DEFINE!
		PyObject *seqval = PyObject_GetAttrString(pyobjref, "handle_sel_auto");
		std::array<float, 3> resarr;
		for (int i = 0; i < 3; i++)
			resarr[i] = (float)PyFloat_AsDouble(PySequence_GetItem(seqval, i));
		return resarr;
	}

	/** Setter:  */
	void handle_sel_auto(float values[3]) { /* not implemented */ }

	/** Getter:  */
	std::array<float, 3> handle_sel_align() {
		// TODO: MISSING DEREF! USE #DEFINE!
		PyObject *seqval = PyObject_GetAttrString(pyobjref, "handle_sel_align");
		std::array<float, 3> resarr;
		for (int i = 0; i < 3; i++)
			resarr[i] = (float)PyFloat_AsDouble(PySequence_GetItem(seqval, i));
		return resarr;
	}

	/** Setter:  */
	void handle_sel_align(float values[3]) { /* not implemented */ }

	/** Getter:  */
	std::array<float, 3> handle_auto_clamped() {
		// TODO: MISSING DEREF! USE #DEFINE!
		PyObject *seqval = PyObject_GetAttrString(pyobjref, "handle_auto_clamped");
		std::array<float, 3> resarr;
		for (int i = 0; i < 3; i++)
			resarr[i] = (float)PyFloat_AsDouble(PySequence_GetItem(seqval, i));
		return resarr;
	}

	/** Setter:  */
	void handle_auto_clamped(float values[3]) { /* not implemented */ }

	/** Getter:  */
	std::array<float, 3> handle_sel_auto_clamped() {
		// TODO: MISSING DEREF! USE #DEFINE!
		PyObject *seqval = PyObject_GetAttrString(pyobjref, "handle_sel_auto_clamped");
		std::array<float, 3> resarr;
		for (int i = 0; i < 3; i++)
			resarr[i] = (float)PyFloat_AsDouble(PySequence_GetItem(seqval, i));
		return resarr;
	}

	/** Setter:  */
	void handle_sel_auto_clamped(float values[3]) { /* not implemented */ }

	/** Getter:  */
	std::array<float, 3> handle_vertex() {
		// TODO: MISSING DEREF! USE #DEFINE!
		PyObject *seqval = PyObject_GetAttrString(pyobjref, "handle_vertex");
		std::array<float, 3> resarr;
		for (int i = 0; i < 3; i++)
			resarr[i] = (float)PyFloat_AsDouble(PySequence_GetItem(seqval, i));
		return resarr;
	}

	/** Setter:  */
	void handle_vertex(float values[3]) { /* not implemented */ }

	/** Getter:  */
	std::array<float, 3> handle_vertex_select() {
		// TODO: MISSING DEREF! USE #DEFINE!
		PyObject *seqval = PyObject_GetAttrString(pyobjref, "handle_vertex_select");
		std::array<float, 3> resarr;
		for (int i = 0; i < 3; i++)
			resarr[i] = (float)PyFloat_AsDouble(PySequence_GetItem(seqval, i));
		return resarr;
	}

	/** Setter:  */
	void handle_vertex_select(float values[3]) { /* not implemented */ }

	/** Getter:  */
	int handle_vertex_size() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "handle_vertex_size"));
	}

	/** Setter:  */
	void handle_vertex_size(int value) {
		PyObject_SetAttrString(pyobjref, "handle_vertex_size", Py_BuildValue("i", value));
	}

};

/**************** Theme Bone Color Set ****************/

/**
 * Theme settings for bone color sets
 */
class ThemeBoneColorSet : public pyUniplug {
public:
	ThemeBoneColorSet(PyObject* pyobj) : pyUniplug(pyobj) {}

	ThemeBoneColorSet() : pyUniplug(0)
	{
		// not implemented
	}

	/** Getter: Color used for the surface of bones */
	std::array<float, 3> normal() {
		// TODO: MISSING DEREF! USE #DEFINE!
		PyObject *seqval = PyObject_GetAttrString(pyobjref, "normal");
		std::array<float, 3> resarr;
		for (int i = 0; i < 3; i++)
			resarr[i] = (float)PyFloat_AsDouble(PySequence_GetItem(seqval, i));
		return resarr;
	}

	/** Setter: Color used for the surface of bones */
	void normal(float values[3]) { /* not implemented */ }

	/** Getter: Color used for selected bones */
	std::array<float, 3> select() {
		// TODO: MISSING DEREF! USE #DEFINE!
		PyObject *seqval = PyObject_GetAttrString(pyobjref, "select");
		std::array<float, 3> resarr;
		for (int i = 0; i < 3; i++)
			resarr[i] = (float)PyFloat_AsDouble(PySequence_GetItem(seqval, i));
		return resarr;
	}

	/** Setter: Color used for selected bones */
	void select(float values[3]) { /* not implemented */ }

	/** Getter: Color used for active bones */
	std::array<float, 3> active() {
		// TODO: MISSING DEREF! USE #DEFINE!
		PyObject *seqval = PyObject_GetAttrString(pyobjref, "active");
		std::array<float, 3> resarr;
		for (int i = 0; i < 3; i++)
			resarr[i] = (float)PyFloat_AsDouble(PySequence_GetItem(seqval, i));
		return resarr;
	}

	/** Setter: Color used for active bones */
	void active(float values[3]) { /* not implemented */ }

	/** Getter: Allow the use of colors indicating constraints/keyed status */
	bool show_colored_constraints() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "show_colored_constraints")) == 1;
	}

	/** Setter: Allow the use of colors indicating constraints/keyed status */
	void show_colored_constraints(bool value) {
		PyObject_SetAttrString(pyobjref, "show_colored_constraints", Py_BuildValue("i", value));
	}

};

/**************** Theme ****************/

/**
 * Theme settings defining draw style and colors in the user interface
 */
class Theme : public pyUniplug {
public:
	Theme(PyObject* pyobj) : pyUniplug(pyobj) {}

	Theme() : pyUniplug(0)
	{
		// not implemented
	}

	/** Getter: Name of the theme */
	std::string name() { /* not implemented */ throw NULL; }
	/** Setter: Name of the theme */
	void name(const std::string& value) { /* not implemented */ }

	enum theme_area_enum {
		theme_area_USER_INTERFACE = 0,
		theme_area_STYLE = 19,
		theme_area_BONE_COLOR_SETS = 18,
		theme_area_VIEW_3D = 1,
		theme_area_TIMELINE = 2,
		theme_area_GRAPH_EDITOR = 3,
		theme_area_DOPESHEET_EDITOR = 4,
		theme_area_NLA_EDITOR = 5,
		theme_area_IMAGE_EDITOR = 6,
		theme_area_SEQUENCE_EDITOR = 7,
		theme_area_TEXT_EDITOR = 8,
		theme_area_NODE_EDITOR = 9,
		theme_area_LOGIC_EDITOR = 10,
		theme_area_PROPERTIES = 11,
		theme_area_OUTLINER = 12,
		theme_area_USER_PREFERENCES = 14,
		theme_area_INFO = 15,
		theme_area_FILE_BROWSER = 16,
		theme_area_CONSOLE = 17,
		theme_area_CLIP_EDITOR = 20,
	};

	/** Getter:  */
	theme_area_enum theme_area() { /* not implemented */ throw NULL; }
	/** Setter:  */
	void theme_area(theme_area_enum value) { /* not implemented */ }

	/** Getter:  */
	ThemeUserInterface user_interface() {
		/* not implemented */ throw NULL;
	}

	/** Getter:  */
	ThemeView3D view_3d() {
		/* not implemented */ throw NULL;
	}

	/** Getter:  */
	ThemeGraphEditor graph_editor() {
		/* not implemented */ throw NULL;
	}

	/** Getter:  */
	ThemeFileBrowser file_browser() {
		/* not implemented */ throw NULL;
	}

	/** Getter:  */
	ThemeNLAEditor nla_editor() {
		/* not implemented */ throw NULL;
	}

	/** Getter:  */
	ThemeDopeSheet dopesheet_editor() {
		/* not implemented */ throw NULL;
	}

	/** Getter:  */
	ThemeImageEditor image_editor() {
		/* not implemented */ throw NULL;
	}

	/** Getter:  */
	ThemeSequenceEditor sequence_editor() {
		/* not implemented */ throw NULL;
	}

	/** Getter:  */
	ThemeProperties properties() {
		/* not implemented */ throw NULL;
	}

	/** Getter:  */
	ThemeTextEditor text_editor() {
		/* not implemented */ throw NULL;
	}

	/** Getter:  */
	ThemeTimeline timeline() {
		/* not implemented */ throw NULL;
	}

	/** Getter:  */
	ThemeNodeEditor node_editor() {
		/* not implemented */ throw NULL;
	}

	/** Getter:  */
	ThemeLogicEditor logic_editor() {
		/* not implemented */ throw NULL;
	}

	/** Getter:  */
	ThemeOutliner outliner() {
		/* not implemented */ throw NULL;
	}

	/** Getter:  */
	ThemeInfo info() {
		/* not implemented */ throw NULL;
	}

	/** Getter:  */
	ThemeUserPreferences user_preferences() {
		/* not implemented */ throw NULL;
	}

	/** Getter:  */
	ThemeConsole console() {
		/* not implemented */ throw NULL;
	}

	/** Getter:  */
	std::map<std::string, ThemeBoneColorSet> bone_color_sets() {
		// TODO: MISSING DEREF! USE #DEFINE!
		PyObject *seqval = PyObject_GetAttrString(pyobjref, "bone_color_sets");
		PyObject *seqkeys = PyObject_CallMethod(seqval, "keys", NULL);
		std::map<std::string, ThemeBoneColorSet> resmap;
		for (int i = 0; i < PySequence_Length(seqval); i++) {
			PyObject *keyobj = PySequence_GetItem(seqkeys, i);
			std::string key = PyBytes_AsString(PyUnicode_AsASCIIString(keyobj));
			ThemeBoneColorSet value = ThemeBoneColorSet(PySequence_GetItem(seqval, i));
			resmap.insert(std::pair<std::string,ThemeBoneColorSet>(key, value));
		}
		return resmap;
	}

	/** Setter:  */
	void bone_color_sets(std::map<std::string, ThemeBoneColorSet> value) { /* not implemented */ }

	/** Getter:  */
	ThemeClipEditor clip_editor() {
		/* not implemented */ throw NULL;
	}

};

/**************** Solid Light ****************/

/**
 * Light used for OpenGL lighting in solid draw mode
 */
class UserSolidLight : public pyUniplug {
public:
	UserSolidLight(PyObject* pyobj) : pyUniplug(pyobj) {}

	UserSolidLight() : pyUniplug(0)
	{
		// not implemented
	}

	/** Getter: Enable this OpenGL light in solid draw mode */
	bool use() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use")) == 1;
	}

	/** Setter: Enable this OpenGL light in solid draw mode */
	void use(bool value) {
		PyObject_SetAttrString(pyobjref, "use", Py_BuildValue("i", value));
	}

	/** Getter: Direction that the OpenGL light is shining */
	std::array<float, 3> direction() {
		// TODO: MISSING DEREF! USE #DEFINE!
		PyObject *seqval = PyObject_GetAttrString(pyobjref, "direction");
		std::array<float, 3> resarr;
		for (int i = 0; i < 3; i++)
			resarr[i] = (float)PyFloat_AsDouble(PySequence_GetItem(seqval, i));
		return resarr;
	}

	/** Setter: Direction that the OpenGL light is shining */
	void direction(float values[3]) { /* not implemented */ }

	/** Getter: Diffuse color of the OpenGL light */
	std::array<float, 3> diffuse_color() {
		// TODO: MISSING DEREF! USE #DEFINE!
		PyObject *seqval = PyObject_GetAttrString(pyobjref, "diffuse_color");
		std::array<float, 3> resarr;
		for (int i = 0; i < 3; i++)
			resarr[i] = (float)PyFloat_AsDouble(PySequence_GetItem(seqval, i));
		return resarr;
	}

	/** Setter: Diffuse color of the OpenGL light */
	void diffuse_color(float values[3]) { /* not implemented */ }

	/** Getter: Color of the light's specular highlight */
	std::array<float, 3> specular_color() {
		// TODO: MISSING DEREF! USE #DEFINE!
		PyObject *seqval = PyObject_GetAttrString(pyobjref, "specular_color");
		std::array<float, 3> resarr;
		for (int i = 0; i < 3; i++)
			resarr[i] = (float)PyFloat_AsDouble(PySequence_GetItem(seqval, i));
		return resarr;
	}

	/** Setter: Color of the light's specular highlight */
	void specular_color(float values[3]) { /* not implemented */ }

};

/**************** Walk Navigation ****************/

/**
 * Walk navigation settings
 */
class WalkNavigation : public pyUniplug {
public:
	WalkNavigation(PyObject* pyobj) : pyUniplug(pyobj) {}

	WalkNavigation() : pyUniplug(0)
	{
		// not implemented
	}

	/** Getter: Speed factor for when looking around, high values mean faster mouse movement */
	float mouse_speed() { /* not implemented */ throw NULL; }
	/** Setter: Speed factor for when looking around, high values mean faster mouse movement */
	void mouse_speed(float value) {
		PyObject_SetAttrString(pyobjref, "mouse_speed", Py_BuildValue("f", value));
	}

	/** Getter: Base speed for walking and flying */
	float walk_speed() { /* not implemented */ throw NULL; }
	/** Setter: Base speed for walking and flying */
	void walk_speed(float value) {
		PyObject_SetAttrString(pyobjref, "walk_speed", Py_BuildValue("f", value));
	}

	/** Getter: Multiplication factor when using the fast or slow modifiers */
	float walk_speed_factor() { /* not implemented */ throw NULL; }
	/** Setter: Multiplication factor when using the fast or slow modifiers */
	void walk_speed_factor(float value) {
		PyObject_SetAttrString(pyobjref, "walk_speed_factor", Py_BuildValue("f", value));
	}

	/** Getter: View distance from the floor when walking */
	float view_height() { /* not implemented */ throw NULL; }
	/** Setter: View distance from the floor when walking */
	void view_height(float value) {
		PyObject_SetAttrString(pyobjref, "view_height", Py_BuildValue("f", value));
	}

	/** Getter: Maximum height of a jump */
	float jump_height() { /* not implemented */ throw NULL; }
	/** Setter: Maximum height of a jump */
	void jump_height(float value) {
		PyObject_SetAttrString(pyobjref, "jump_height", Py_BuildValue("f", value));
	}

	/** Getter: Interval of time warp when teleporting in navigation mode */
	float teleport_time() { /* not implemented */ throw NULL; }
	/** Setter: Interval of time warp when teleporting in navigation mode */
	void teleport_time(float value) {
		PyObject_SetAttrString(pyobjref, "teleport_time", Py_BuildValue("f", value));
	}

	/** Getter: Walk with gravity, or free navigate */
	bool use_gravity() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_gravity")) == 1;
	}

	/** Setter: Walk with gravity, or free navigate */
	void use_gravity(bool value) {
		PyObject_SetAttrString(pyobjref, "use_gravity", Py_BuildValue("i", value));
	}

	/** Getter: Reverse the mouse look */
	bool use_mouse_reverse() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_mouse_reverse")) == 1;
	}

	/** Setter: Reverse the mouse look */
	void use_mouse_reverse(bool value) {
		PyObject_SetAttrString(pyobjref, "use_mouse_reverse", Py_BuildValue("i", value));
	}

};

/**************** User Preferences ****************/

/**
 * Global user preferences
 */
class UserPreferences : public pyUniplug {
public:
	UserPreferences(PyObject* pyobj) : pyUniplug(pyobj) {}

	UserPreferences() : pyUniplug(0)
	{
		// not implemented
	}

	enum active_section_enum {
		active_section_INTERFACE = 0,
		active_section_EDITING = 1,
		active_section_INPUT = 5,
		active_section_ADDONS = 6,
		active_section_THEMES = 4,
		active_section_FILES = 2,
		active_section_SYSTEM = 3,
	};

	/** Getter: Active section of the user preferences shown in the user interface */
	active_section_enum active_section() { /* not implemented */ throw NULL; }
	/** Setter: Active section of the user preferences shown in the user interface */
	void active_section(active_section_enum value) { /* not implemented */ }

	/** Getter:  */
	std::map<std::string, Theme> themes() {
		// TODO: MISSING DEREF! USE #DEFINE!
		PyObject *seqval = PyObject_GetAttrString(pyobjref, "themes");
		PyObject *seqkeys = PyObject_CallMethod(seqval, "keys", NULL);
		std::map<std::string, Theme> resmap;
		for (int i = 0; i < PySequence_Length(seqval); i++) {
			PyObject *keyobj = PySequence_GetItem(seqkeys, i);
			std::string key = PyBytes_AsString(PyUnicode_AsASCIIString(keyobj));
			Theme value = Theme(PySequence_GetItem(seqval, i));
			resmap.insert(std::pair<std::string,Theme>(key, value));
		}
		return resmap;
	}

	/** Setter:  */
	void themes(std::map<std::string, Theme> value) { /* not implemented */ }

	/** Getter:  */
	std::map<std::string, ThemeStyle> ui_styles() {
		// TODO: MISSING DEREF! USE #DEFINE!
		PyObject *seqval = PyObject_GetAttrString(pyobjref, "ui_styles");
		PyObject *seqkeys = PyObject_CallMethod(seqval, "keys", NULL);
		std::map<std::string, ThemeStyle> resmap;
		for (int i = 0; i < PySequence_Length(seqval); i++) {
			PyObject *keyobj = PySequence_GetItem(seqkeys, i);
			std::string key = PyBytes_AsString(PyUnicode_AsASCIIString(keyobj));
			ThemeStyle value = ThemeStyle(PySequence_GetItem(seqval, i));
			resmap.insert(std::pair<std::string,ThemeStyle>(key, value));
		}
		return resmap;
	}

	/** Setter:  */
	void ui_styles(std::map<std::string, ThemeStyle> value) { /* not implemented */ }

	/** Getter:  */
	std::map<std::string, Addon> addons();
	/** Setter:  */
	void addons(std::map<std::string, Addon> value);

	/** Getter:  */
	std::map<std::string, PathCompare> autoexec_paths();
	/** Setter:  */
	void autoexec_paths(std::map<std::string, PathCompare> value);

	/** Getter: Preferences related to viewing data */
	UserPreferencesView view();

	/** Getter: Settings for interacting with Blender data */
	UserPreferencesEdit edit();

	/** Getter: Settings for input devices */
	UserPreferencesInput inputs();

	/** Getter: Default paths for external files */
	UserPreferencesFilePaths filepaths();

	/** Getter: Graphics driver and operating system settings */
	UserPreferencesSystem system();

};

/**************** View & Controls ****************/

/**
 * Preferences related to viewing data
 */
class UserPreferencesView : public pyUniplug {
public:
	UserPreferencesView(PyObject* pyobj) : pyUniplug(pyobj) {}

	UserPreferencesView() : pyUniplug(0)
	{
		// not implemented
	}

	/** Getter: Display tooltips (when off hold Alt to force display) */
	bool show_tooltips() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "show_tooltips")) == 1;
	}

	/** Setter: Display tooltips (when off hold Alt to force display) */
	void show_tooltips(bool value) {
		PyObject_SetAttrString(pyobjref, "show_tooltips", Py_BuildValue("i", value));
	}

	/** Getter: Show Python references in tooltips */
	bool show_tooltips_python() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "show_tooltips_python")) == 1;
	}

	/** Setter: Show Python references in tooltips */
	void show_tooltips_python(bool value) {
		PyObject_SetAttrString(pyobjref, "show_tooltips_python", Py_BuildValue("i", value));
	}

	/** Getter: Display objects name and frame number in 3D view */
	bool show_object_info() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "show_object_info")) == 1;
	}

	/** Setter: Display objects name and frame number in 3D view */
	void show_object_info(bool value) {
		PyObject_SetAttrString(pyobjref, "show_object_info", Py_BuildValue("i", value));
	}

	/** Getter: Force the current Scene to be displayed in all Screens */
	bool use_global_scene() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_global_scene")) == 1;
	}

	/** Setter: Force the current Scene to be displayed in all Screens */
	void use_global_scene(bool value) {
		PyObject_SetAttrString(pyobjref, "use_global_scene", Py_BuildValue("i", value));
	}

	/** Getter: Use large mouse cursors when available */
	bool show_large_cursors() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "show_large_cursors")) == 1;
	}

	/** Setter: Use large mouse cursors when available */
	void show_large_cursors(bool value) {
		PyObject_SetAttrString(pyobjref, "show_large_cursors", Py_BuildValue("i", value));
	}

	/** Getter: Show the name of the view's direction in each 3D View */
	bool show_view_name() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "show_view_name")) == 1;
	}

	/** Setter: Show the name of the view's direction in each 3D View */
	void show_view_name(bool value) {
		PyObject_SetAttrString(pyobjref, "show_view_name", Py_BuildValue("i", value));
	}

	/** Getter: Display splash screen on startup */
	bool show_splash() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "show_splash")) == 1;
	}

	/** Setter: Display splash screen on startup */
	void show_splash(bool value) {
		PyObject_SetAttrString(pyobjref, "show_splash", Py_BuildValue("i", value));
	}

	/** Getter: Show the frames per second screen refresh rate, while animation is played back */
	bool show_playback_fps() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "show_playback_fps")) == 1;
	}

	/** Setter: Show the frames per second screen refresh rate, while animation is played back */
	void show_playback_fps(bool value) {
		PyObject_SetAttrString(pyobjref, "show_playback_fps", Py_BuildValue("i", value));
	}

	/** Getter: Open menu buttons and pulldowns automatically when the mouse is hovering */
	bool use_mouse_over_open() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_mouse_over_open")) == 1;
	}

	/** Setter: Open menu buttons and pulldowns automatically when the mouse is hovering */
	void use_mouse_over_open(bool value) {
		PyObject_SetAttrString(pyobjref, "use_mouse_over_open", Py_BuildValue("i", value));
	}

	/** Getter: Time delay in 1/10 seconds before automatically opening top level menus */
	int open_toplevel_delay() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "open_toplevel_delay"));
	}

	/** Setter: Time delay in 1/10 seconds before automatically opening top level menus */
	void open_toplevel_delay(int value) {
		PyObject_SetAttrString(pyobjref, "open_toplevel_delay", Py_BuildValue("i", value));
	}

	/** Getter: Time delay in 1/10 seconds before automatically opening sub level menus */
	int open_sublevel_delay() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "open_sublevel_delay"));
	}

	/** Setter: Time delay in 1/10 seconds before automatically opening sub level menus */
	void open_sublevel_delay(int value) {
		PyObject_SetAttrString(pyobjref, "open_sublevel_delay", Py_BuildValue("i", value));
	}

	/** Getter: Pie menus will use the initial mouse position as center for this amount of time (in 1/100ths of sec) */
	int pie_initial_timeout() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "pie_initial_timeout"));
	}

	/** Setter: Pie menus will use the initial mouse position as center for this amount of time (in 1/100ths of sec) */
	void pie_initial_timeout(int value) {
		PyObject_SetAttrString(pyobjref, "pie_initial_timeout", Py_BuildValue("i", value));
	}

	/** Getter: Time needed to fully animate the pie to unfolded state (in 1/100ths of sec) */
	int pie_animation_timeout() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "pie_animation_timeout"));
	}

	/** Setter: Time needed to fully animate the pie to unfolded state (in 1/100ths of sec) */
	void pie_animation_timeout(int value) {
		PyObject_SetAttrString(pyobjref, "pie_animation_timeout", Py_BuildValue("i", value));
	}

	/** Getter: Pie menu size in pixels */
	int pie_menu_radius() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "pie_menu_radius"));
	}

	/** Setter: Pie menu size in pixels */
	void pie_menu_radius(int value) {
		PyObject_SetAttrString(pyobjref, "pie_menu_radius", Py_BuildValue("i", value));
	}

	/** Getter: Distance from center needed before a selection can be made */
	int pie_menu_threshold() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "pie_menu_threshold"));
	}

	/** Setter: Distance from center needed before a selection can be made */
	void pie_menu_threshold(int value) {
		PyObject_SetAttrString(pyobjref, "pie_menu_threshold", Py_BuildValue("i", value));
	}

	/** Getter: Distance threshold after which selection is made (zero to disable) */
	int pie_menu_confirm() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "pie_menu_confirm"));
	}

	/** Setter: Distance threshold after which selection is made (zero to disable) */
	void pie_menu_confirm(int value) {
		PyObject_SetAttrString(pyobjref, "pie_menu_confirm", Py_BuildValue("i", value));
	}

	/** Getter: Ask for confirmation when quitting through the window close button */
	bool use_quit_dialog() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_quit_dialog")) == 1;
	}

	/** Setter: Ask for confirmation when quitting through the window close button */
	void use_quit_dialog(bool value) {
		PyObject_SetAttrString(pyobjref, "use_quit_dialog", Py_BuildValue("i", value));
	}

	/** Getter: Pop up a warning when an old OpenGL version is detected */
	bool use_gl_warn_support() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_gl_warn_support")) == 1;
	}

	/** Setter: Pop up a warning when an old OpenGL version is detected */
	void use_gl_warn_support(bool value) {
		PyObject_SetAttrString(pyobjref, "use_gl_warn_support", Py_BuildValue("i", value));
	}

	/** Getter: Time in 1/10 seconds to hold the Left Mouse Button before opening the toolbox */
	int open_left_mouse_delay() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "open_left_mouse_delay"));
	}

	/** Setter: Time in 1/10 seconds to hold the Left Mouse Button before opening the toolbox */
	void open_left_mouse_delay(int value) {
		PyObject_SetAttrString(pyobjref, "open_left_mouse_delay", Py_BuildValue("i", value));
	}

	/** Getter: Time in 1/10 seconds to hold the Right Mouse Button before opening the toolbox */
	int open_right_mouse_delay() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "open_right_mouse_delay"));
	}

	/** Setter: Time in 1/10 seconds to hold the Right Mouse Button before opening the toolbox */
	void open_right_mouse_delay(int value) {
		PyObject_SetAttrString(pyobjref, "open_right_mouse_delay", Py_BuildValue("i", value));
	}

	/** Getter: Use a column layout for toolbox */
	bool show_column_layout() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "show_column_layout")) == 1;
	}

	/** Setter: Use a column layout for toolbox */
	void show_column_layout(bool value) {
		PyObject_SetAttrString(pyobjref, "show_column_layout", Py_BuildValue("i", value));
	}

	/** Getter: Otherwise menus, etc will always be top to bottom, left to right, no matter opening direction */
	bool use_directional_menus() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_directional_menus")) == 1;
	}

	/** Setter: Otherwise menus, etc will always be top to bottom, left to right, no matter opening direction */
	void use_directional_menus(bool value) {
		PyObject_SetAttrString(pyobjref, "use_directional_menus", Py_BuildValue("i", value));
	}

	/** Getter: Lock the same rotation/scaling pivot in all 3D Views */
	bool use_global_pivot() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_global_pivot")) == 1;
	}

	/** Setter: Lock the same rotation/scaling pivot in all 3D Views */
	void use_global_pivot(bool value) {
		PyObject_SetAttrString(pyobjref, "use_global_pivot", Py_BuildValue("i", value));
	}

	/** Getter: Use the depth under the mouse to improve view pan/rotate/zoom functionality */
	bool use_mouse_depth_navigate() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_mouse_depth_navigate")) == 1;
	}

	/** Setter: Use the depth under the mouse to improve view pan/rotate/zoom functionality */
	void use_mouse_depth_navigate(bool value) {
		PyObject_SetAttrString(pyobjref, "use_mouse_depth_navigate", Py_BuildValue("i", value));
	}

	/** Getter: Use the depth under the mouse when placing the cursor */
	bool use_mouse_depth_cursor() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_mouse_depth_cursor")) == 1;
	}

	/** Setter: Use the depth under the mouse when placing the cursor */
	void use_mouse_depth_cursor(bool value) {
		PyObject_SetAttrString(pyobjref, "use_mouse_depth_cursor", Py_BuildValue("i", value));
	}

	/** Getter: When the camera is locked to the view and in fly mode, transform the parent rather than the camera */
	bool use_camera_lock_parent() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_camera_lock_parent")) == 1;
	}

	/** Setter: When the camera is locked to the view and in fly mode, transform the parent rather than the camera */
	void use_camera_lock_parent(bool value) {
		PyObject_SetAttrString(pyobjref, "use_camera_lock_parent", Py_BuildValue("i", value));
	}

	/** Getter: Zoom in towards the mouse pointer's position in the 3D view, rather than the 2D window center */
	bool use_zoom_to_mouse() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_zoom_to_mouse")) == 1;
	}

	/** Setter: Zoom in towards the mouse pointer's position in the 3D view, rather than the 2D window center */
	void use_zoom_to_mouse(bool value) {
		PyObject_SetAttrString(pyobjref, "use_zoom_to_mouse", Py_BuildValue("i", value));
	}

	/** Getter: Automatically switch between orthographic and perspective when changing from top/front/side views */
	bool use_auto_perspective() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_auto_perspective")) == 1;
	}

	/** Setter: Automatically switch between orthographic and perspective when changing from top/front/side views */
	void use_auto_perspective(bool value) {
		PyObject_SetAttrString(pyobjref, "use_auto_perspective", Py_BuildValue("i", value));
	}

	/** Getter: Use selection as the pivot point */
	bool use_rotate_around_active() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_rotate_around_active")) == 1;
	}

	/** Setter: Use selection as the pivot point */
	void use_rotate_around_active(bool value) {
		PyObject_SetAttrString(pyobjref, "use_rotate_around_active", Py_BuildValue("i", value));
	}

	/** Getter: Show a small rotating 3D axes in the bottom left corner of the 3D View */
	bool show_mini_axis() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "show_mini_axis")) == 1;
	}

	/** Setter: Show a small rotating 3D axes in the bottom left corner of the 3D View */
	void show_mini_axis(bool value) {
		PyObject_SetAttrString(pyobjref, "show_mini_axis", Py_BuildValue("i", value));
	}

	/** Getter: The axes icon's size */
	int mini_axis_size() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "mini_axis_size"));
	}

	/** Setter: The axes icon's size */
	void mini_axis_size(int value) {
		PyObject_SetAttrString(pyobjref, "mini_axis_size", Py_BuildValue("i", value));
	}

	/** Getter: Brightness of the icon */
	int mini_axis_brightness() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "mini_axis_brightness"));
	}

	/** Setter: Brightness of the icon */
	void mini_axis_brightness(int value) {
		PyObject_SetAttrString(pyobjref, "mini_axis_brightness", Py_BuildValue("i", value));
	}

	/** Getter: Time to animate the view in milliseconds, zero to disable */
	int smooth_view() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "smooth_view"));
	}

	/** Setter: Time to animate the view in milliseconds, zero to disable */
	void smooth_view(int value) {
		PyObject_SetAttrString(pyobjref, "smooth_view", Py_BuildValue("i", value));
	}

	/** Getter: Rotation step for numerical pad keys (2 4 6 8) */
	int rotation_angle() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "rotation_angle"));
	}

	/** Setter: Rotation step for numerical pad keys (2 4 6 8) */
	void rotation_angle(int value) {
		PyObject_SetAttrString(pyobjref, "rotation_angle", Py_BuildValue("i", value));
	}

	/** Getter: Use 3D transform manipulator */
	bool show_manipulator() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "show_manipulator")) == 1;
	}

	/** Setter: Use 3D transform manipulator */
	void show_manipulator(bool value) {
		PyObject_SetAttrString(pyobjref, "show_manipulator", Py_BuildValue("i", value));
	}

	/** Getter: Diameter of the manipulator */
	int manipulator_size() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "manipulator_size"));
	}

	/** Setter: Diameter of the manipulator */
	void manipulator_size(int value) {
		PyObject_SetAttrString(pyobjref, "manipulator_size", Py_BuildValue("i", value));
	}

	/** Getter: Size of manipulator handles as percentage of the radius */
	int manipulator_handle_size() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "manipulator_handle_size"));
	}

	/** Setter: Size of manipulator handles as percentage of the radius */
	void manipulator_handle_size(int value) {
		PyObject_SetAttrString(pyobjref, "manipulator_handle_size", Py_BuildValue("i", value));
	}

	/** Getter: Distance around the handles to accept mouse clicks */
	int manipulator_hotspot() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "manipulator_hotspot"));
	}

	/** Setter: Distance around the handles to accept mouse clicks */
	void manipulator_hotspot(int value) {
		PyObject_SetAttrString(pyobjref, "manipulator_hotspot", Py_BuildValue("i", value));
	}

	/** Getter: Diameter in Pixels for Object/Lamp origin display */
	int object_origin_size() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "object_origin_size"));
	}

	/** Setter: Diameter in Pixels for Object/Lamp origin display */
	void object_origin_size(int value) {
		PyObject_SetAttrString(pyobjref, "object_origin_size", Py_BuildValue("i", value));
	}

	/** Getter: Minimum number of pixels between each gridline in 2D Viewports */
	int view2d_grid_spacing_min() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "view2d_grid_spacing_min"));
	}

	/** Setter: Minimum number of pixels between each gridline in 2D Viewports */
	void view2d_grid_spacing_min(int value) {
		PyObject_SetAttrString(pyobjref, "view2d_grid_spacing_min", Py_BuildValue("i", value));
	}

	enum timecode_style_enum {
		timecode_style_MINIMAL = 0,
		timecode_style_SMPTE = 2,
		timecode_style_SMPTE_COMPACT = 1,
		timecode_style_MILLISECONDS = 3,
		timecode_style_SECONDS_ONLY = 4,
	};

	/** Getter: Format of Time Codes displayed when not displaying timing in terms of frames */
	timecode_style_enum timecode_style() { /* not implemented */ throw NULL; }
	/** Setter: Format of Time Codes displayed when not displaying timing in terms of frames */
	void timecode_style(timecode_style_enum value) { /* not implemented */ }

	enum view_frame_type_enum {
		view_frame_type_KEEP_RANGE = 0,
		view_frame_type_SECONDS = 1,
		view_frame_type_KEYFRAMES = 2,
	};

	/** Getter: How zooming to frame focuses around current frame */
	view_frame_type_enum view_frame_type() { /* not implemented */ throw NULL; }
	/** Setter: How zooming to frame focuses around current frame */
	void view_frame_type(view_frame_type_enum value) { /* not implemented */ }

	/** Getter: Keyframes around cursor that we zoom around */
	int view_frame_keyframes() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "view_frame_keyframes"));
	}

	/** Setter: Keyframes around cursor that we zoom around */
	void view_frame_keyframes(int value) {
		PyObject_SetAttrString(pyobjref, "view_frame_keyframes", Py_BuildValue("i", value));
	}

	/** Getter: Seconds around cursor that we zoom around */
	float view_frame_seconds() { /* not implemented */ throw NULL; }
	/** Setter: Seconds around cursor that we zoom around */
	void view_frame_seconds(float value) {
		PyObject_SetAttrString(pyobjref, "view_frame_seconds", Py_BuildValue("f", value));
	}

};

/**************** Edit Methods ****************/

/**
 * Settings for interacting with Blender data
 */
class UserPreferencesEdit : public pyUniplug {
public:
	UserPreferencesEdit(PyObject* pyobj) : pyUniplug(pyobj) {}

	UserPreferencesEdit() : pyUniplug(0)
	{
		// not implemented
	}

	enum material_link_enum {
		material_link_OBDATA = 0,
		material_link_OBJECT = 256,
	};

	/** Getter: Toggle whether the material is linked to object data or the object block */
	material_link_enum material_link() { /* not implemented */ throw NULL; }
	/** Setter: Toggle whether the material is linked to object data or the object block */
	void material_link(material_link_enum value) { /* not implemented */ }

	enum object_align_enum {
		object_align_WORLD = 0,
		object_align_VIEW = 524288,
	};

	/** Getter: When adding objects from a 3D View menu, either align them with that view or with the world */
	object_align_enum object_align() { /* not implemented */ throw NULL; }
	/** Setter: When adding objects from a 3D View menu, either align them with that view or with the world */
	void object_align(object_align_enum value) { /* not implemented */ }

	/** Getter: Enter Edit Mode automatically after adding a new object */
	bool use_enter_edit_mode() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_enter_edit_mode")) == 1;
	}

	/** Setter: Enter Edit Mode automatically after adding a new object */
	void use_enter_edit_mode(bool value) {
		PyObject_SetAttrString(pyobjref, "use_enter_edit_mode", Py_BuildValue("i", value));
	}

	/** Getter: Moving things with a mouse drag confirms when releasing the button */
	bool use_drag_immediately() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_drag_immediately")) == 1;
	}

	/** Setter: Moving things with a mouse drag confirms when releasing the button */
	void use_drag_immediately(bool value) {
		PyObject_SetAttrString(pyobjref, "use_drag_immediately", Py_BuildValue("i", value));
	}

	/** Getter: Number of undo steps available (smaller values conserve memory) */
	int undo_steps() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "undo_steps"));
	}

	/** Setter: Number of undo steps available (smaller values conserve memory) */
	void undo_steps(int value) {
		PyObject_SetAttrString(pyobjref, "undo_steps", Py_BuildValue("i", value));
	}

	/** Getter: Maximum memory usage in megabytes (0 means unlimited) */
	int undo_memory_limit() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "undo_memory_limit"));
	}

	/** Setter: Maximum memory usage in megabytes (0 means unlimited) */
	void undo_memory_limit(int value) {
		PyObject_SetAttrString(pyobjref, "undo_memory_limit", Py_BuildValue("i", value));
	}

	/** Getter: Global undo works by keeping a full copy of the file itself in memory, so takes extra memory */
	bool use_global_undo() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_global_undo")) == 1;
	}

	/** Setter: Global undo works by keeping a full copy of the file itself in memory, so takes extra memory */
	void use_global_undo(bool value) {
		PyObject_SetAttrString(pyobjref, "use_global_undo", Py_BuildValue("i", value));
	}

	/** Getter: Automatic keyframe insertion for Objects and Bones (default setting used for new Scenes) */
	bool use_auto_keying() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_auto_keying")) == 1;
	}

	/** Setter: Automatic keyframe insertion for Objects and Bones (default setting used for new Scenes) */
	void use_auto_keying(bool value) {
		PyObject_SetAttrString(pyobjref, "use_auto_keying", Py_BuildValue("i", value));
	}

	enum auto_keying_mode_enum {
		auto_keying_mode_ADD_REPLACE_KEYS = 3,
		auto_keying_mode_REPLACE_KEYS = 5,
	};

	/** Getter: Mode of automatic keyframe insertion for Objects and Bones (default setting used for new Scenes) */
	auto_keying_mode_enum auto_keying_mode() { /* not implemented */ throw NULL; }
	/** Setter: Mode of automatic keyframe insertion for Objects and Bones (default setting used for new Scenes) */
	void auto_keying_mode(auto_keying_mode_enum value) { /* not implemented */ }

	/** Getter: Automatic keyframe insertion in available F-Curves */
	bool use_keyframe_insert_available() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_keyframe_insert_available")) == 1;
	}

	/** Setter: Automatic keyframe insertion in available F-Curves */
	void use_keyframe_insert_available(bool value) {
		PyObject_SetAttrString(pyobjref, "use_keyframe_insert_available", Py_BuildValue("i", value));
	}

	/** Getter: Show warning indicators when transforming objects and bones if auto keying is enabled */
	bool use_auto_keying_warning() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_auto_keying_warning")) == 1;
	}

	/** Setter: Show warning indicators when transforming objects and bones if auto keying is enabled */
	void use_auto_keying_warning(bool value) {
		PyObject_SetAttrString(pyobjref, "use_auto_keying_warning", Py_BuildValue("i", value));
	}

	/** Getter: Keyframe insertion only when keyframe needed */
	bool use_keyframe_insert_needed() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_keyframe_insert_needed")) == 1;
	}

	/** Setter: Keyframe insertion only when keyframe needed */
	void use_keyframe_insert_needed(bool value) {
		PyObject_SetAttrString(pyobjref, "use_keyframe_insert_needed", Py_BuildValue("i", value));
	}

	/** Getter: Use Visual keying automatically for constrained objects */
	bool use_visual_keying() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_visual_keying")) == 1;
	}

	/** Setter: Use Visual keying automatically for constrained objects */
	void use_visual_keying(bool value) {
		PyObject_SetAttrString(pyobjref, "use_visual_keying", Py_BuildValue("i", value));
	}

	/** Getter: Color for newly added transformation F-Curves (Location, Rotation, Scale) and also Color is based on the transform axis */
	bool use_insertkey_xyz_to_rgb() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_insertkey_xyz_to_rgb")) == 1;
	}

	/** Setter: Color for newly added transformation F-Curves (Location, Rotation, Scale) and also Color is based on the transform axis */
	void use_insertkey_xyz_to_rgb(bool value) {
		PyObject_SetAttrString(pyobjref, "use_insertkey_xyz_to_rgb", Py_BuildValue("i", value));
	}

	enum keyframe_new_interpolation_type_enum {
		keyframe_new_interpolation_type_CONSTANT = 0,
		keyframe_new_interpolation_type_LINEAR = 1,
		keyframe_new_interpolation_type_BEZIER = 2,
		keyframe_new_interpolation_type_SINE = 12,
		keyframe_new_interpolation_type_QUAD = 9,
		keyframe_new_interpolation_type_CUBIC = 6,
		keyframe_new_interpolation_type_QUART = 10,
		keyframe_new_interpolation_type_QUINT = 11,
		keyframe_new_interpolation_type_EXPO = 8,
		keyframe_new_interpolation_type_CIRC = 5,
		keyframe_new_interpolation_type_BACK = 3,
		keyframe_new_interpolation_type_BOUNCE = 4,
		keyframe_new_interpolation_type_ELASTIC = 7,
	};

	/** Getter: Interpolation mode used for first keyframe on newly added F-Curves (subsequent keyframes take interpolation from preceding keyframe) */
	keyframe_new_interpolation_type_enum keyframe_new_interpolation_type() { /* not implemented */ throw NULL; }
	/** Setter: Interpolation mode used for first keyframe on newly added F-Curves (subsequent keyframes take interpolation from preceding keyframe) */
	void keyframe_new_interpolation_type(keyframe_new_interpolation_type_enum value) { /* not implemented */ }

	enum keyframe_new_handle_type_enum {
		keyframe_new_handle_type_FREE = 0,
		keyframe_new_handle_type_VECTOR = 2,
		keyframe_new_handle_type_ALIGNED = 3,
		keyframe_new_handle_type_AUTO = 1,
		keyframe_new_handle_type_AUTO_CLAMPED = 4,
	};

	/** Getter: Handle type for handles of new keyframes */
	keyframe_new_handle_type_enum keyframe_new_handle_type() { /* not implemented */ throw NULL; }
	/** Setter: Handle type for handles of new keyframes */
	void keyframe_new_handle_type(keyframe_new_handle_type_enum value) { /* not implemented */ }

	/** Getter: Current frame number can be manually set to a negative value */
	bool use_negative_frames() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_negative_frames")) == 1;
	}

	/** Setter: Current frame number can be manually set to a negative value */
	void use_negative_frames(bool value) {
		PyObject_SetAttrString(pyobjref, "use_negative_frames", Py_BuildValue("i", value));
	}

	/** Getter: Amount that unselected F-Curves stand out from the background (Graph Editor) */
	float fcurve_unselected_alpha() { /* not implemented */ throw NULL; }
	/** Setter: Amount that unselected F-Curves stand out from the background (Graph Editor) */
	void fcurve_unselected_alpha(float value) {
		PyObject_SetAttrString(pyobjref, "fcurve_unselected_alpha", Py_BuildValue("f", value));
	}

	/** Getter: Pixels moved by mouse per axis when drawing stroke */
	int grease_pencil_manhattan_distance() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "grease_pencil_manhattan_distance"));
	}

	/** Setter: Pixels moved by mouse per axis when drawing stroke */
	void grease_pencil_manhattan_distance(int value) {
		PyObject_SetAttrString(pyobjref, "grease_pencil_manhattan_distance", Py_BuildValue("i", value));
	}

	/** Getter: Distance moved by mouse when drawing stroke to include */
	int grease_pencil_euclidean_distance() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "grease_pencil_euclidean_distance"));
	}

	/** Setter: Distance moved by mouse when drawing stroke to include */
	void grease_pencil_euclidean_distance(int value) {
		PyObject_SetAttrString(pyobjref, "grease_pencil_euclidean_distance", Py_BuildValue("i", value));
	}

	/** Getter: Smooth the final stroke */
	bool use_grease_pencil_smooth_stroke() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_grease_pencil_smooth_stroke")) == 1;
	}

	/** Setter: Smooth the final stroke */
	void use_grease_pencil_smooth_stroke(bool value) {
		PyObject_SetAttrString(pyobjref, "use_grease_pencil_smooth_stroke", Py_BuildValue("i", value));
	}

	/** Getter: Simplify the final stroke */
	bool use_grease_pencil_simplify_stroke() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_grease_pencil_simplify_stroke")) == 1;
	}

	/** Setter: Simplify the final stroke */
	void use_grease_pencil_simplify_stroke(bool value) {
		PyObject_SetAttrString(pyobjref, "use_grease_pencil_simplify_stroke", Py_BuildValue("i", value));
	}

	/** Getter: Radius of eraser 'brush' */
	int grease_pencil_eraser_radius() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "grease_pencil_eraser_radius"));
	}

	/** Setter: Radius of eraser 'brush' */
	void grease_pencil_eraser_radius(int value) {
		PyObject_SetAttrString(pyobjref, "grease_pencil_eraser_radius", Py_BuildValue("i", value));
	}

	/** Getter: Color of new Grease Pencil layers */
	std::array<float, 4> grease_pencil_default_color() {
		// TODO: MISSING DEREF! USE #DEFINE!
		PyObject *seqval = PyObject_GetAttrString(pyobjref, "grease_pencil_default_color");
		std::array<float, 4> resarr;
		for (int i = 0; i < 4; i++)
			resarr[i] = (float)PyFloat_AsDouble(PySequence_GetItem(seqval, i));
		return resarr;
	}

	/** Setter: Color of new Grease Pencil layers */
	void grease_pencil_default_color(float values[4]) { /* not implemented */ }

	/** Getter: Color of texture overlay */
	std::array<float, 3> sculpt_paint_overlay_color() {
		// TODO: MISSING DEREF! USE #DEFINE!
		PyObject *seqval = PyObject_GetAttrString(pyobjref, "sculpt_paint_overlay_color");
		std::array<float, 3> resarr;
		for (int i = 0; i < 3; i++)
			resarr[i] = (float)PyFloat_AsDouble(PySequence_GetItem(seqval, i));
		return resarr;
	}

	/** Setter: Color of texture overlay */
	void sculpt_paint_overlay_color(float values[3]) { /* not implemented */ }

	/** Getter: Causes mesh data to be duplicated with the object */
	bool use_duplicate_mesh() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_duplicate_mesh")) == 1;
	}

	/** Setter: Causes mesh data to be duplicated with the object */
	void use_duplicate_mesh(bool value) {
		PyObject_SetAttrString(pyobjref, "use_duplicate_mesh", Py_BuildValue("i", value));
	}

	/** Getter: Causes surface data to be duplicated with the object */
	bool use_duplicate_surface() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_duplicate_surface")) == 1;
	}

	/** Setter: Causes surface data to be duplicated with the object */
	void use_duplicate_surface(bool value) {
		PyObject_SetAttrString(pyobjref, "use_duplicate_surface", Py_BuildValue("i", value));
	}

	/** Getter: Causes curve data to be duplicated with the object */
	bool use_duplicate_curve() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_duplicate_curve")) == 1;
	}

	/** Setter: Causes curve data to be duplicated with the object */
	void use_duplicate_curve(bool value) {
		PyObject_SetAttrString(pyobjref, "use_duplicate_curve", Py_BuildValue("i", value));
	}

	/** Getter: Causes text data to be duplicated with the object */
	bool use_duplicate_text() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_duplicate_text")) == 1;
	}

	/** Setter: Causes text data to be duplicated with the object */
	void use_duplicate_text(bool value) {
		PyObject_SetAttrString(pyobjref, "use_duplicate_text", Py_BuildValue("i", value));
	}

	/** Getter: Causes metaball data to be duplicated with the object */
	bool use_duplicate_metaball() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_duplicate_metaball")) == 1;
	}

	/** Setter: Causes metaball data to be duplicated with the object */
	void use_duplicate_metaball(bool value) {
		PyObject_SetAttrString(pyobjref, "use_duplicate_metaball", Py_BuildValue("i", value));
	}

	/** Getter: Causes armature data to be duplicated with the object */
	bool use_duplicate_armature() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_duplicate_armature")) == 1;
	}

	/** Setter: Causes armature data to be duplicated with the object */
	void use_duplicate_armature(bool value) {
		PyObject_SetAttrString(pyobjref, "use_duplicate_armature", Py_BuildValue("i", value));
	}

	/** Getter: Causes lamp data to be duplicated with the object */
	bool use_duplicate_lamp() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_duplicate_lamp")) == 1;
	}

	/** Setter: Causes lamp data to be duplicated with the object */
	void use_duplicate_lamp(bool value) {
		PyObject_SetAttrString(pyobjref, "use_duplicate_lamp", Py_BuildValue("i", value));
	}

	/** Getter: Causes material data to be duplicated with the object */
	bool use_duplicate_material() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_duplicate_material")) == 1;
	}

	/** Setter: Causes material data to be duplicated with the object */
	void use_duplicate_material(bool value) {
		PyObject_SetAttrString(pyobjref, "use_duplicate_material", Py_BuildValue("i", value));
	}

	/** Getter: Causes texture data to be duplicated with the object */
	bool use_duplicate_texture() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_duplicate_texture")) == 1;
	}

	/** Setter: Causes texture data to be duplicated with the object */
	void use_duplicate_texture(bool value) {
		PyObject_SetAttrString(pyobjref, "use_duplicate_texture", Py_BuildValue("i", value));
	}

	/** Getter: Causes F-curve data to be duplicated with the object */
	bool use_duplicate_fcurve() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_duplicate_fcurve")) == 1;
	}

	/** Setter: Causes F-curve data to be duplicated with the object */
	void use_duplicate_fcurve(bool value) {
		PyObject_SetAttrString(pyobjref, "use_duplicate_fcurve", Py_BuildValue("i", value));
	}

	/** Getter: Causes actions to be duplicated with the object */
	bool use_duplicate_action() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_duplicate_action")) == 1;
	}

	/** Setter: Causes actions to be duplicated with the object */
	void use_duplicate_action(bool value) {
		PyObject_SetAttrString(pyobjref, "use_duplicate_action", Py_BuildValue("i", value));
	}

	/** Getter: Causes particle systems to be duplicated with the object */
	bool use_duplicate_particle() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_duplicate_particle")) == 1;
	}

	/** Setter: Causes particle systems to be duplicated with the object */
	void use_duplicate_particle(bool value) {
		PyObject_SetAttrString(pyobjref, "use_duplicate_particle", Py_BuildValue("i", value));
	}

};

/**************** Input ****************/

/**
 * Settings for input devices
 */
class UserPreferencesInput : public pyUniplug {
public:
	UserPreferencesInput(PyObject* pyobj) : pyUniplug(pyobj) {}

	UserPreferencesInput() : pyUniplug(0)
	{
		// not implemented
	}

	enum select_mouse_enum {
		select_mouse_LEFT = 16384,
		select_mouse_RIGHT = 0,
	};

	/** Getter: Mouse button used for selection */
	select_mouse_enum select_mouse() { /* not implemented */ throw NULL; }
	/** Setter: Mouse button used for selection */
	void select_mouse(select_mouse_enum value) { /* not implemented */ }

	enum view_zoom_method_enum {
		view_zoom_method_CONTINUE = 0,
		view_zoom_method_DOLLY = 2,
		view_zoom_method_SCALE = 1,
	};

	/** Getter: Which style to use for viewport scaling */
	view_zoom_method_enum view_zoom_method() { /* not implemented */ throw NULL; }
	/** Setter: Which style to use for viewport scaling */
	void view_zoom_method(view_zoom_method_enum value) { /* not implemented */ }

	enum view_zoom_axis_enum {
		view_zoom_axis_VERTICAL = 0,
		view_zoom_axis_HORIZONTAL = 67108864,
	};

	/** Getter: Axis of mouse movement to zoom in or out on */
	view_zoom_axis_enum view_zoom_axis() { /* not implemented */ throw NULL; }
	/** Setter: Axis of mouse movement to zoom in or out on */
	void view_zoom_axis(view_zoom_axis_enum value) { /* not implemented */ }

	/** Getter: Invert the axis of mouse movement for zooming */
	bool invert_mouse_zoom() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "invert_mouse_zoom")) == 1;
	}

	/** Setter: Invert the axis of mouse movement for zooming */
	void invert_mouse_zoom(bool value) {
		PyObject_SetAttrString(pyobjref, "invert_mouse_zoom", Py_BuildValue("i", value));
	}

	enum view_rotate_method_enum {
		view_rotate_method_TURNTABLE = 0,
		view_rotate_method_TRACKBALL = 32,
	};

	/** Getter: Rotation style in the viewport */
	view_rotate_method_enum view_rotate_method() { /* not implemented */ throw NULL; }
	/** Setter: Rotation style in the viewport */
	void view_rotate_method(view_rotate_method_enum value) { /* not implemented */ }

	/** Getter: Allow moving the mouse outside the view on some manipulations (transform, ui control drag) */
	bool use_mouse_continuous() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_mouse_continuous")) == 1;
	}

	/** Setter: Allow moving the mouse outside the view on some manipulations (transform, ui control drag) */
	void use_mouse_continuous(bool value) {
		PyObject_SetAttrString(pyobjref, "use_mouse_continuous", Py_BuildValue("i", value));
	}

	enum navigation_mode_enum {
		navigation_mode_WALK = 0,
		navigation_mode_FLY = 1,
	};

	/** Getter: Which method to use for viewport navigation */
	navigation_mode_enum navigation_mode() { /* not implemented */ throw NULL; }
	/** Setter: Which method to use for viewport navigation */
	void navigation_mode(navigation_mode_enum value) { /* not implemented */ }

	/** Getter: Settings for walk navigation mode */
	WalkNavigation walk_navigation() {
		/* not implemented */ throw NULL;
	}

	/** Getter: Amount of pixels you have to drag before dragging UI items happens */
	int drag_threshold() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "drag_threshold"));
	}

	/** Setter: Amount of pixels you have to drag before dragging UI items happens */
	void drag_threshold(int value) {
		PyObject_SetAttrString(pyobjref, "drag_threshold", Py_BuildValue("i", value));
	}

	/** Getter: Number of pixels you have to drag before tweak event is triggered */
	int tweak_threshold() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "tweak_threshold"));
	}

	/** Setter: Number of pixels you have to drag before tweak event is triggered */
	void tweak_threshold(int value) {
		PyObject_SetAttrString(pyobjref, "tweak_threshold", Py_BuildValue("i", value));
	}

	/** Getter: Overall sensitivity of the 3D Mouse for panning */
	float ndof_sensitivity() { /* not implemented */ throw NULL; }
	/** Setter: Overall sensitivity of the 3D Mouse for panning */
	void ndof_sensitivity(float value) {
		PyObject_SetAttrString(pyobjref, "ndof_sensitivity", Py_BuildValue("f", value));
	}

	/** Getter: Overall sensitivity of the 3D Mouse for orbiting */
	float ndof_orbit_sensitivity() { /* not implemented */ throw NULL; }
	/** Setter: Overall sensitivity of the 3D Mouse for orbiting */
	void ndof_orbit_sensitivity(float value) {
		PyObject_SetAttrString(pyobjref, "ndof_orbit_sensitivity", Py_BuildValue("f", value));
	}

	/** Getter: Pan using up/down on the device (otherwise forward/backward) */
	bool ndof_pan_yz_swap_axis() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "ndof_pan_yz_swap_axis")) == 1;
	}

	/** Setter: Pan using up/down on the device (otherwise forward/backward) */
	void ndof_pan_yz_swap_axis(bool value) {
		PyObject_SetAttrString(pyobjref, "ndof_pan_yz_swap_axis", Py_BuildValue("i", value));
	}

	/** Getter: Zoom using opposite direction */
	bool ndof_zoom_invert() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "ndof_zoom_invert")) == 1;
	}

	/** Setter: Zoom using opposite direction */
	void ndof_zoom_invert(bool value) {
		PyObject_SetAttrString(pyobjref, "ndof_zoom_invert", Py_BuildValue("i", value));
	}

	/** Getter: Display the center and axis during rotation */
	bool ndof_show_guide() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "ndof_show_guide")) == 1;
	}

	/** Setter: Display the center and axis during rotation */
	void ndof_show_guide(bool value) {
		PyObject_SetAttrString(pyobjref, "ndof_show_guide", Py_BuildValue("i", value));
	}

	enum ndof_view_navigate_method_enum {
		ndof_view_navigate_method_FREE = 0,
		ndof_view_navigate_method_ORBIT = 64,
	};

	/** Getter: Navigation style in the viewport */
	ndof_view_navigate_method_enum ndof_view_navigate_method() { /* not implemented */ throw NULL; }
	/** Setter: Navigation style in the viewport */
	void ndof_view_navigate_method(ndof_view_navigate_method_enum value) { /* not implemented */ }

	enum ndof_view_rotate_method_enum {
		ndof_view_rotate_method_TURNTABLE = 32768,
		ndof_view_rotate_method_TRACKBALL = 0,
	};

	/** Getter: Rotation style in the viewport */
	ndof_view_rotate_method_enum ndof_view_rotate_method() { /* not implemented */ throw NULL; }
	/** Setter: Rotation style in the viewport */
	void ndof_view_rotate_method(ndof_view_rotate_method_enum value) { /* not implemented */ }

	/** Getter:  */
	bool ndof_rotx_invert_axis() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "ndof_rotx_invert_axis")) == 1;
	}

	/** Setter:  */
	void ndof_rotx_invert_axis(bool value) {
		PyObject_SetAttrString(pyobjref, "ndof_rotx_invert_axis", Py_BuildValue("i", value));
	}

	/** Getter:  */
	bool ndof_roty_invert_axis() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "ndof_roty_invert_axis")) == 1;
	}

	/** Setter:  */
	void ndof_roty_invert_axis(bool value) {
		PyObject_SetAttrString(pyobjref, "ndof_roty_invert_axis", Py_BuildValue("i", value));
	}

	/** Getter:  */
	bool ndof_rotz_invert_axis() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "ndof_rotz_invert_axis")) == 1;
	}

	/** Setter:  */
	void ndof_rotz_invert_axis(bool value) {
		PyObject_SetAttrString(pyobjref, "ndof_rotz_invert_axis", Py_BuildValue("i", value));
	}

	/** Getter:  */
	bool ndof_panx_invert_axis() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "ndof_panx_invert_axis")) == 1;
	}

	/** Setter:  */
	void ndof_panx_invert_axis(bool value) {
		PyObject_SetAttrString(pyobjref, "ndof_panx_invert_axis", Py_BuildValue("i", value));
	}

	/** Getter:  */
	bool ndof_pany_invert_axis() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "ndof_pany_invert_axis")) == 1;
	}

	/** Setter:  */
	void ndof_pany_invert_axis(bool value) {
		PyObject_SetAttrString(pyobjref, "ndof_pany_invert_axis", Py_BuildValue("i", value));
	}

	/** Getter:  */
	bool ndof_panz_invert_axis() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "ndof_panz_invert_axis")) == 1;
	}

	/** Setter:  */
	void ndof_panz_invert_axis(bool value) {
		PyObject_SetAttrString(pyobjref, "ndof_panz_invert_axis", Py_BuildValue("i", value));
	}

	/** Getter: Keep horizon level while flying with 3D Mouse */
	bool ndof_lock_horizon() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "ndof_lock_horizon")) == 1;
	}

	/** Setter: Keep horizon level while flying with 3D Mouse */
	void ndof_lock_horizon(bool value) {
		PyObject_SetAttrString(pyobjref, "ndof_lock_horizon", Py_BuildValue("i", value));
	}

	/** Getter: Device up/down directly controls your Z position */
	bool ndof_fly_helicopter() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "ndof_fly_helicopter")) == 1;
	}

	/** Setter: Device up/down directly controls your Z position */
	void ndof_fly_helicopter(bool value) {
		PyObject_SetAttrString(pyobjref, "ndof_fly_helicopter", Py_BuildValue("i", value));
	}

	/** Getter: Time/delay (in ms) for a double click */
	int mouse_double_click_time() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "mouse_double_click_time"));
	}

	/** Setter: Time/delay (in ms) for a double click */
	void mouse_double_click_time(int value) {
		PyObject_SetAttrString(pyobjref, "mouse_double_click_time", Py_BuildValue("i", value));
	}

	/** Getter: Emulate Middle Mouse with Alt+Left Mouse (doesn't work with Left Mouse Select option) */
	bool use_mouse_emulate_3_button() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_mouse_emulate_3_button")) == 1;
	}

	/** Setter: Emulate Middle Mouse with Alt+Left Mouse (doesn't work with Left Mouse Select option) */
	void use_mouse_emulate_3_button(bool value) {
		PyObject_SetAttrString(pyobjref, "use_mouse_emulate_3_button", Py_BuildValue("i", value));
	}

	/** Getter: Main 1 to 0 keys act as the numpad ones (useful for laptops) */
	bool use_emulate_numpad() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_emulate_numpad")) == 1;
	}

	/** Setter: Main 1 to 0 keys act as the numpad ones (useful for laptops) */
	void use_emulate_numpad(bool value) {
		PyObject_SetAttrString(pyobjref, "use_emulate_numpad", Py_BuildValue("i", value));
	}

	/** Getter: In text window, paste with middle mouse button instead of panning */
	bool use_mouse_mmb_paste() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_mouse_mmb_paste")) == 1;
	}

	/** Setter: In text window, paste with middle mouse button instead of panning */
	void use_mouse_mmb_paste(bool value) {
		PyObject_SetAttrString(pyobjref, "use_mouse_mmb_paste", Py_BuildValue("i", value));
	}

	/** Getter: Swap the Mouse Wheel zoom direction */
	bool invert_zoom_wheel() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "invert_zoom_wheel")) == 1;
	}

	/** Setter: Swap the Mouse Wheel zoom direction */
	void invert_zoom_wheel(bool value) {
		PyObject_SetAttrString(pyobjref, "invert_zoom_wheel", Py_BuildValue("i", value));
	}

	/** Getter: Number of lines scrolled at a time with the mouse wheel */
	int wheel_scroll_lines() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "wheel_scroll_lines"));
	}

	/** Setter: Number of lines scrolled at a time with the mouse wheel */
	void wheel_scroll_lines(int value) {
		PyObject_SetAttrString(pyobjref, "wheel_scroll_lines", Py_BuildValue("i", value));
	}

	/** Getter: If your system uses 'natural' scrolling, this option keeps consistent trackpad usage throughout the UI */
	bool use_trackpad_natural() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_trackpad_natural")) == 1;
	}

	/** Setter: If your system uses 'natural' scrolling, this option keeps consistent trackpad usage throughout the UI */
	void use_trackpad_natural(bool value) {
		PyObject_SetAttrString(pyobjref, "use_trackpad_natural", Py_BuildValue("i", value));
	}

	/** Getter: The name of the active key configuration */
	std::string active_keyconfig() { /* not implemented */ throw NULL; }
	/** Setter: The name of the active key configuration */
	void active_keyconfig(const std::string& value) { /* not implemented */ }

};

/**************** File Paths ****************/

/**
 * Default paths for external files
 */
class UserPreferencesFilePaths : public pyUniplug {
public:
	UserPreferencesFilePaths(PyObject* pyobj) : pyUniplug(pyobj) {}

	UserPreferencesFilePaths() : pyUniplug(0)
	{
		// not implemented
	}

	/** Getter: Hide files/datablocks that start with a dot (.*) */
	bool show_hidden_files_datablocks() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "show_hidden_files_datablocks")) == 1;
	}

	/** Setter: Hide files/datablocks that start with a dot (.*) */
	void show_hidden_files_datablocks(bool value) {
		PyObject_SetAttrString(pyobjref, "show_hidden_files_datablocks", Py_BuildValue("i", value));
	}

	/** Getter: Display only files with extensions in the image select window */
	bool use_filter_files() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_filter_files")) == 1;
	}

	/** Setter: Display only files with extensions in the image select window */
	void use_filter_files(bool value) {
		PyObject_SetAttrString(pyobjref, "use_filter_files", Py_BuildValue("i", value));
	}

	/** Getter: Hide recent locations in the file selector */
	bool hide_recent_locations() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "hide_recent_locations")) == 1;
	}

	/** Setter: Hide recent locations in the file selector */
	void hide_recent_locations(bool value) {
		PyObject_SetAttrString(pyobjref, "hide_recent_locations", Py_BuildValue("i", value));
	}

	/** Getter: Hide system bookmarks in the file selector */
	bool hide_system_bookmarks() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "hide_system_bookmarks")) == 1;
	}

	/** Setter: Hide system bookmarks in the file selector */
	void hide_system_bookmarks(bool value) {
		PyObject_SetAttrString(pyobjref, "hide_system_bookmarks", Py_BuildValue("i", value));
	}

	/** Getter: Open in thumbnail view for images and movies */
	bool show_thumbnails() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "show_thumbnails")) == 1;
	}

	/** Setter: Open in thumbnail view for images and movies */
	void show_thumbnails(bool value) {
		PyObject_SetAttrString(pyobjref, "show_thumbnails", Py_BuildValue("i", value));
	}

	/** Getter: Default relative path option for the file selector */
	bool use_relative_paths() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_relative_paths")) == 1;
	}

	/** Setter: Default relative path option for the file selector */
	void use_relative_paths(bool value) {
		PyObject_SetAttrString(pyobjref, "use_relative_paths", Py_BuildValue("i", value));
	}

	/** Getter: Enable file compression when saving .blend files */
	bool use_file_compression() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_file_compression")) == 1;
	}

	/** Setter: Enable file compression when saving .blend files */
	void use_file_compression(bool value) {
		PyObject_SetAttrString(pyobjref, "use_file_compression", Py_BuildValue("i", value));
	}

	/** Getter: Load user interface setup when loading .blend files */
	bool use_load_ui() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_load_ui")) == 1;
	}

	/** Setter: Load user interface setup when loading .blend files */
	void use_load_ui(bool value) {
		PyObject_SetAttrString(pyobjref, "use_load_ui", Py_BuildValue("i", value));
	}

	/** Getter: The default directory to search for loading fonts */
	std::string font_directory() { /* not implemented */ throw NULL; }
	/** Setter: The default directory to search for loading fonts */
	void font_directory(const std::string& value) { /* not implemented */ }

	/** Getter: The default directory to search for textures */
	std::string texture_directory() { /* not implemented */ throw NULL; }
	/** Setter: The default directory to search for textures */
	void texture_directory(const std::string& value) { /* not implemented */ }

	/** Getter: The default directory for rendering output, for new scenes */
	std::string render_output_directory() { /* not implemented */ throw NULL; }
	/** Setter: The default directory for rendering output, for new scenes */
	void render_output_directory(const std::string& value) { /* not implemented */ }

	/** Getter: Alternate script path, matching the default layout with subdirs: startup, addons & modules (requires restart) */
	std::string script_directory() { /* not implemented */ throw NULL; }
	/** Setter: Alternate script path, matching the default layout with subdirs: startup, addons & modules (requires restart) */
	void script_directory(const std::string& value) { /* not implemented */ }

	/** Getter: The path to the '/branches' directory of your local svn-translation copy, to allow translating from the UI */
	std::string i18n_branches_directory() { /* not implemented */ throw NULL; }
	/** Setter: The path to the '/branches' directory of your local svn-translation copy, to allow translating from the UI */
	void i18n_branches_directory(const std::string& value) { /* not implemented */ }

	/** Getter: The default directory to search for sounds */
	std::string sound_directory() { /* not implemented */ throw NULL; }
	/** Setter: The default directory to search for sounds */
	void sound_directory(const std::string& value) { /* not implemented */ }

	/** Getter: The directory for storing temporary save files */
	std::string temporary_directory() { /* not implemented */ throw NULL; }
	/** Setter: The directory for storing temporary save files */
	void temporary_directory(const std::string& value) { /* not implemented */ }

	/** Getter: Where to cache raw render results */
	std::string render_cache_directory() { /* not implemented */ throw NULL; }
	/** Setter: Where to cache raw render results */
	void render_cache_directory(const std::string& value) { /* not implemented */ }

	/** Getter: Path to an image editor */
	std::string image_editor() { /* not implemented */ throw NULL; }
	/** Setter: Path to an image editor */
	void image_editor(const std::string& value) { /* not implemented */ }

	/** Getter: Path to a custom animation/frame sequence player */
	std::string animation_player() { /* not implemented */ throw NULL; }
	/** Setter: Path to a custom animation/frame sequence player */
	void animation_player(const std::string& value) { /* not implemented */ }

	enum animation_player_preset_enum {
		animation_player_preset_INTERNAL = 0,
		animation_player_preset_DJV = 2,
		animation_player_preset_FRAMECYCLER = 3,
		animation_player_preset_RV = 4,
		animation_player_preset_MPLAYER = 5,
		animation_player_preset_CUSTOM = 50,
	};

	/** Getter: Preset configs for external animation players */
	animation_player_preset_enum animation_player_preset() { /* not implemented */ throw NULL; }
	/** Setter: Preset configs for external animation players */
	void animation_player_preset(animation_player_preset_enum value) { /* not implemented */ }

	/** Getter: The number of old versions to maintain in the current directory, when manually saving */
	int save_version() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "save_version"));
	}

	/** Setter: The number of old versions to maintain in the current directory, when manually saving */
	void save_version(int value) {
		PyObject_SetAttrString(pyobjref, "save_version", Py_BuildValue("i", value));
	}

	/** Getter: Automatic saving of temporary files in temp directory, uses process ID (Sculpt or edit mode data won't be saved!') */
	bool use_auto_save_temporary_files() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_auto_save_temporary_files")) == 1;
	}

	/** Setter: Automatic saving of temporary files in temp directory, uses process ID (Sculpt or edit mode data won't be saved!') */
	void use_auto_save_temporary_files(bool value) {
		PyObject_SetAttrString(pyobjref, "use_auto_save_temporary_files", Py_BuildValue("i", value));
	}

	/** Getter: The time (in minutes) to wait between automatic temporary saves */
	int auto_save_time() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "auto_save_time"));
	}

	/** Setter: The time (in minutes) to wait between automatic temporary saves */
	void auto_save_time(int value) {
		PyObject_SetAttrString(pyobjref, "auto_save_time", Py_BuildValue("i", value));
	}

	/** Getter: Always load session recovery and save it after quitting Blender */
	bool use_keep_session() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_keep_session")) == 1;
	}

	/** Setter: Always load session recovery and save it after quitting Blender */
	void use_keep_session(bool value) {
		PyObject_SetAttrString(pyobjref, "use_keep_session", Py_BuildValue("i", value));
	}

	/** Getter: Maximum number of recently opened files to remember */
	int recent_files() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "recent_files"));
	}

	/** Setter: Maximum number of recently opened files to remember */
	void recent_files(int value) {
		PyObject_SetAttrString(pyobjref, "recent_files", Py_BuildValue("i", value));
	}

	/** Getter: Enables automatic saving of preview images in the .blend file */
	bool use_save_preview_images() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_save_preview_images")) == 1;
	}

	/** Setter: Enables automatic saving of preview images in the .blend file */
	void use_save_preview_images(bool value) {
		PyObject_SetAttrString(pyobjref, "use_save_preview_images", Py_BuildValue("i", value));
	}

};

/**************** System & OpenGL ****************/

/**
 * Graphics driver and operating system settings
 */
class UserPreferencesSystem : public pyUniplug {
public:
	UserPreferencesSystem(PyObject* pyobj) : pyUniplug(pyobj) {}

	UserPreferencesSystem() : pyUniplug(0)
	{
		// not implemented
	}

	/** Getter: Use international fonts */
	bool use_international_fonts() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_international_fonts")) == 1;
	}

	/** Setter: Use international fonts */
	void use_international_fonts(bool value) {
		PyObject_SetAttrString(pyobjref, "use_international_fonts", Py_BuildValue("i", value));
	}

	/** Getter: Font size and resolution for display */
	int dpi() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "dpi"));
	}

	/** Setter: Font size and resolution for display */
	void dpi(int value) {
		PyObject_SetAttrString(pyobjref, "dpi", Py_BuildValue("i", value));
	}

	enum virtual_pixel_mode_enum {
		virtual_pixel_mode_NATIVE = 0,
		virtual_pixel_mode_DOUBLE = 1,
	};

	/** Getter: Modify the pixel size for hi-res devices */
	virtual_pixel_mode_enum virtual_pixel_mode() { /* not implemented */ throw NULL; }
	/** Setter: Modify the pixel size for hi-res devices */
	void virtual_pixel_mode(virtual_pixel_mode_enum value) { /* not implemented */ }

	/** Getter:  */
	float pixel_size() { /* not implemented */ throw NULL; }
	/** Setter:  */
	void pixel_size(float value) {
		PyObject_SetAttrString(pyobjref, "pixel_size", Py_BuildValue("f", value));
	}

	/** Getter: Path to interface font */
	std::string font_path_ui() { /* not implemented */ throw NULL; }
	/** Setter: Path to interface font */
	void font_path_ui(const std::string& value) { /* not implemented */ }

	/** Getter: Maximum number of lines to store for the console buffer */
	int scrollback() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "scrollback"));
	}

	/** Setter: Maximum number of lines to store for the console buffer */
	void scrollback(int value) {
		PyObject_SetAttrString(pyobjref, "scrollback", Py_BuildValue("i", value));
	}

	/** Getter: Name that will be used in exported files when format supports such feature */
	std::string author() { /* not implemented */ throw NULL; }
	/** Setter: Name that will be used in exported files when format supports such feature */
	void author(const std::string& value) { /* not implemented */ }

	enum language_enum {
		language_DEFAULT = 0,
	};

	/** Getter: Language used for translation */
	language_enum language() { /* not implemented */ throw NULL; }
	/** Setter: Language used for translation */
	void language(language_enum value) { /* not implemented */ }

	/** Getter: Translate tooltips */
	bool use_translate_tooltips() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_translate_tooltips")) == 1;
	}

	/** Setter: Translate tooltips */
	void use_translate_tooltips(bool value) {
		PyObject_SetAttrString(pyobjref, "use_translate_tooltips", Py_BuildValue("i", value));
	}

	/** Getter: Translate interface */
	bool use_translate_interface() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_translate_interface")) == 1;
	}

	/** Setter: Translate interface */
	void use_translate_interface(bool value) {
		PyObject_SetAttrString(pyobjref, "use_translate_interface", Py_BuildValue("i", value));
	}

	/** Getter: Translate new data names (when adding/creating some) */
	bool use_translate_new_dataname() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_translate_new_dataname")) == 1;
	}

	/** Setter: Translate new data names (when adding/creating some) */
	void use_translate_new_dataname(bool value) {
		PyObject_SetAttrString(pyobjref, "use_translate_new_dataname", Py_BuildValue("i", value));
	}

	/** Getter: Use textures for drawing international fonts */
	bool use_textured_fonts() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_textured_fonts")) == 1;
	}

	/** Setter: Use textures for drawing international fonts */
	void use_textured_fonts(bool value) {
		PyObject_SetAttrString(pyobjref, "use_textured_fonts", Py_BuildValue("i", value));
	}

	/** Getter: Lights user to display objects in solid draw mode */
	std::map<std::string, UserSolidLight> solid_lights() {
		// TODO: MISSING DEREF! USE #DEFINE!
		PyObject *seqval = PyObject_GetAttrString(pyobjref, "solid_lights");
		PyObject *seqkeys = PyObject_CallMethod(seqval, "keys", NULL);
		std::map<std::string, UserSolidLight> resmap;
		for (int i = 0; i < PySequence_Length(seqval); i++) {
			PyObject *keyobj = PySequence_GetItem(seqkeys, i);
			std::string key = PyBytes_AsString(PyUnicode_AsASCIIString(keyobj));
			UserSolidLight value = UserSolidLight(PySequence_GetItem(seqval, i));
			resmap.insert(std::pair<std::string,UserSolidLight>(key, value));
		}
		return resmap;
	}

	/** Setter: Lights user to display objects in solid draw mode */
	void solid_lights(std::map<std::string, UserSolidLight> value) { /* not implemented */ }

	/** Getter: Enable color range used for weight visualization in weight painting mode */
	bool use_weight_color_range() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_weight_color_range")) == 1;
	}

	/** Setter: Enable color range used for weight visualization in weight painting mode */
	void use_weight_color_range(bool value) {
		PyObject_SetAttrString(pyobjref, "use_weight_color_range", Py_BuildValue("i", value));
	}

	/** Getter: Color range used for weight visualization in weight painting mode */
	ColorRamp weight_color_range() {
		/* not implemented */ throw NULL;
	}

	enum color_picker_type_enum {
		color_picker_type_CIRCLE_HSV = 0,
		color_picker_type_CIRCLE_HSL = 4,
		color_picker_type_SQUARE_SV = 1,
		color_picker_type_SQUARE_HS = 2,
		color_picker_type_SQUARE_HV = 3,
	};

	/** Getter: Different styles of displaying the color picker widget */
	color_picker_type_enum color_picker_type() { /* not implemented */ throw NULL; }
	/** Setter: Different styles of displaying the color picker widget */
	void color_picker_type(color_picker_type_enum value) { /* not implemented */ }

	/** Getter: Allow user to choose any codec (Windows only, might generate instability) */
	bool use_preview_images() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_preview_images")) == 1;
	}

	/** Setter: Allow user to choose any codec (Windows only, might generate instability) */
	void use_preview_images(bool value) {
		PyObject_SetAttrString(pyobjref, "use_preview_images", Py_BuildValue("i", value));
	}

	/** Getter: Allow any .blend file to run scripts automatically (unsafe with blend files from an untrusted source) */
	bool use_scripts_auto_execute() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_scripts_auto_execute")) == 1;
	}

	/** Setter: Allow any .blend file to run scripts automatically (unsafe with blend files from an untrusted source) */
	void use_scripts_auto_execute(bool value) {
		PyObject_SetAttrString(pyobjref, "use_scripts_auto_execute", Py_BuildValue("i", value));
	}

	/** Getter: Automatically convert all new tabs into spaces for new and loaded text files */
	bool use_tabs_as_spaces() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_tabs_as_spaces")) == 1;
	}

	/** Setter: Automatically convert all new tabs into spaces for new and loaded text files */
	void use_tabs_as_spaces(bool value) {
		PyObject_SetAttrString(pyobjref, "use_tabs_as_spaces", Py_BuildValue("i", value));
	}

	/** Getter: Number of frames to render ahead during playback (sequencer only) */
	int prefetch_frames() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "prefetch_frames"));
	}

	/** Setter: Number of frames to render ahead during playback (sequencer only) */
	void prefetch_frames(int value) {
		PyObject_SetAttrString(pyobjref, "prefetch_frames", Py_BuildValue("i", value));
	}

	/** Getter: Memory cache limit (in megabytes) */
	int memory_cache_limit() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "memory_cache_limit"));
	}

	/** Setter: Memory cache limit (in megabytes) */
	void memory_cache_limit(int value) {
		PyObject_SetAttrString(pyobjref, "memory_cache_limit", Py_BuildValue("i", value));
	}

	/** Getter: Frameserver Port for Frameserver Rendering */
	int frame_server_port() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "frame_server_port"));
	}

	/** Setter: Frameserver Port for Frameserver Rendering */
	void frame_server_port(int value) {
		PyObject_SetAttrString(pyobjref, "frame_server_port", Py_BuildValue("i", value));
	}

	/** Getter: Clip alpha below this threshold in the 3D textured view */
	float gl_clip_alpha() { /* not implemented */ throw NULL; }
	/** Setter: Clip alpha below this threshold in the 3D textured view */
	void gl_clip_alpha(float value) {
		PyObject_SetAttrString(pyobjref, "gl_clip_alpha", Py_BuildValue("f", value));
	}

	/** Getter: Scale textures for the 3D View (looks nicer but uses more memory and slows image reloading) */
	bool use_mipmaps() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_mipmaps")) == 1;
	}

	/** Setter: Scale textures for the 3D View (looks nicer but uses more memory and slows image reloading) */
	void use_mipmaps(bool value) {
		PyObject_SetAttrString(pyobjref, "use_mipmaps", Py_BuildValue("i", value));
	}

	/** Getter: Use 16 bit per component texture for float images */
	bool use_16bit_textures() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_16bit_textures")) == 1;
	}

	/** Setter: Use 16 bit per component texture for float images */
	void use_16bit_textures(bool value) {
		PyObject_SetAttrString(pyobjref, "use_16bit_textures", Py_BuildValue("i", value));
	}

	/** Getter: Generate Image Mipmaps on the GPU */
	bool use_gpu_mipmap() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_gpu_mipmap")) == 1;
	}

	/** Setter: Generate Image Mipmaps on the GPU */
	void use_gpu_mipmap(bool value) {
		PyObject_SetAttrString(pyobjref, "use_gpu_mipmap", Py_BuildValue("i", value));
	}

	enum image_draw_method_enum {
		image_draw_method_2DTEXTURE = 2,
		image_draw_method_GLSL = 1,
		image_draw_method_DRAWPIXELS = 3,
	};

	/** Getter: Method used for displaying images on the screen */
	image_draw_method_enum image_draw_method() { /* not implemented */ throw NULL; }
	/** Setter: Method used for displaying images on the screen */
	void image_draw_method(image_draw_method_enum value) { /* not implemented */ }

	/** Getter: Use Vertex Buffer Objects (or Vertex Arrays, if unsupported) for viewport rendering */
	bool use_vertex_buffer_objects() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_vertex_buffer_objects")) == 1;
	}

	/** Setter: Use Vertex Buffer Objects (or Vertex Arrays, if unsupported) for viewport rendering */
	void use_vertex_buffer_objects(bool value) {
		PyObject_SetAttrString(pyobjref, "use_vertex_buffer_objects", Py_BuildValue("i", value));
	}

	enum anisotropic_filter_enum {
		anisotropic_filter_FILTER_0 = 1,
		anisotropic_filter_FILTER_2 = 2,
		anisotropic_filter_FILTER_4 = 4,
		anisotropic_filter_FILTER_8 = 8,
		anisotropic_filter_FILTER_16 = 16,
	};

	/** Getter: Quality of the anisotropic filtering (values greater than 1.0 enable anisotropic filtering) */
	anisotropic_filter_enum anisotropic_filter() { /* not implemented */ throw NULL; }
	/** Setter: Quality of the anisotropic filtering (values greater than 1.0 enable anisotropic filtering) */
	void anisotropic_filter(anisotropic_filter_enum value) { /* not implemented */ }

	enum gl_texture_limit_enum {
		gl_texture_limit_CLAMP_OFF = 0,
		gl_texture_limit_CLAMP_8192 = 8192,
		gl_texture_limit_CLAMP_4096 = 4096,
		gl_texture_limit_CLAMP_2048 = 2048,
		gl_texture_limit_CLAMP_1024 = 1024,
		gl_texture_limit_CLAMP_512 = 512,
		gl_texture_limit_CLAMP_256 = 256,
		gl_texture_limit_CLAMP_128 = 128,
	};

	/** Getter: Limit the texture size to save graphics memory */
	gl_texture_limit_enum gl_texture_limit() { /* not implemented */ throw NULL; }
	/** Setter: Limit the texture size to save graphics memory */
	void gl_texture_limit(gl_texture_limit_enum value) { /* not implemented */ }

	/** Getter: Time since last access of a GL texture in seconds after which it is freed (set to 0 to keep textures allocated) */
	int texture_time_out() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "texture_time_out"));
	}

	/** Setter: Time since last access of a GL texture in seconds after which it is freed (set to 0 to keep textures allocated) */
	void texture_time_out(int value) {
		PyObject_SetAttrString(pyobjref, "texture_time_out", Py_BuildValue("i", value));
	}

	/** Getter: Number of seconds between each run of the GL texture garbage collector */
	int texture_collection_rate() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "texture_collection_rate"));
	}

	/** Setter: Number of seconds between each run of the GL texture garbage collector */
	void texture_collection_rate(int value) {
		PyObject_SetAttrString(pyobjref, "texture_collection_rate", Py_BuildValue("i", value));
	}

	enum window_draw_method_enum {
		window_draw_method_AUTOMATIC = 3,
		window_draw_method_TRIPLE_BUFFER = 0,
		window_draw_method_OVERLAP = 1,
		window_draw_method_OVERLAP_FLIP = 4,
		window_draw_method_FULL = 2,
	};

	/** Getter: Drawing method used by the window manager */
	window_draw_method_enum window_draw_method() { /* not implemented */ throw NULL; }
	/** Setter: Drawing method used by the window manager */
	void window_draw_method(window_draw_method_enum value) { /* not implemented */ }

	enum audio_mixing_buffer_enum {
		audio_mixing_buffer_SAMPLES_256 = 256,
		audio_mixing_buffer_SAMPLES_512 = 512,
		audio_mixing_buffer_SAMPLES_1024 = 1024,
		audio_mixing_buffer_SAMPLES_2048 = 2048,
		audio_mixing_buffer_SAMPLES_4096 = 4096,
		audio_mixing_buffer_SAMPLES_8192 = 8192,
		audio_mixing_buffer_SAMPLES_16384 = 16384,
		audio_mixing_buffer_SAMPLES_32768 = 32768,
	};

	/** Getter: Number of samples used by the audio mixing buffer */
	audio_mixing_buffer_enum audio_mixing_buffer() { /* not implemented */ throw NULL; }
	/** Setter: Number of samples used by the audio mixing buffer */
	void audio_mixing_buffer(audio_mixing_buffer_enum value) { /* not implemented */ }

	enum audio_device_enum {
		audio_device_NONE = 0,
		audio_device_SDL = 1,
		audio_device_OPENAL = 2,
		audio_device_JACK = 3,
	};

	/** Getter: Audio output device */
	audio_device_enum audio_device() { /* not implemented */ throw NULL; }
	/** Setter: Audio output device */
	void audio_device(audio_device_enum value) { /* not implemented */ }

	enum audio_sample_rate_enum {
		audio_sample_rate_RATE_44100 = 44100,
		audio_sample_rate_RATE_48000 = 48000,
		audio_sample_rate_RATE_96000 = 96000,
		audio_sample_rate_RATE_192000 = 192000,
	};

	/** Getter: Audio sample rate */
	audio_sample_rate_enum audio_sample_rate() { /* not implemented */ throw NULL; }
	/** Setter: Audio sample rate */
	void audio_sample_rate(audio_sample_rate_enum value) { /* not implemented */ }

	enum audio_sample_format_enum {
		audio_sample_format_U8 = 1,
		audio_sample_format_S16 = 18,
		audio_sample_format_S24 = 19,
		audio_sample_format_S32 = 20,
		audio_sample_format_FLOAT = 36,
		audio_sample_format_DOUBLE = 40,
	};

	/** Getter: Audio sample format */
	audio_sample_format_enum audio_sample_format() { /* not implemented */ throw NULL; }
	/** Setter: Audio sample format */
	void audio_sample_format(audio_sample_format_enum value) { /* not implemented */ }

	enum audio_channels_enum {
		audio_channels_MONO = 1,
		audio_channels_STEREO = 2,
		audio_channels_SURROUND4 = 4,
		audio_channels_SURROUND51 = 6,
		audio_channels_SURROUND71 = 8,
	};

	/** Getter: Audio channel count */
	audio_channels_enum audio_channels() { /* not implemented */ throw NULL; }
	/** Setter: Audio channel count */
	void audio_channels(audio_channels_enum value) { /* not implemented */ }

	/** Getter: Frame rate for the screencast to be played back */
	int screencast_fps() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "screencast_fps"));
	}

	/** Setter: Frame rate for the screencast to be played back */
	void screencast_fps(int value) {
		PyObject_SetAttrString(pyobjref, "screencast_fps", Py_BuildValue("i", value));
	}

	/** Getter: Time in milliseconds between each frame recorded for screencast */
	int screencast_wait_time() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "screencast_wait_time"));
	}

	/** Setter: Time in milliseconds between each frame recorded for screencast */
	void screencast_wait_time(int value) {
		PyObject_SetAttrString(pyobjref, "screencast_wait_time", Py_BuildValue("i", value));
	}

	/** Getter: Draw user interface text anti-aliased */
	bool use_text_antialiasing() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_text_antialiasing")) == 1;
	}

	/** Setter: Draw user interface text anti-aliased */
	void use_text_antialiasing(bool value) {
		PyObject_SetAttrString(pyobjref, "use_text_antialiasing", Py_BuildValue("i", value));
	}

	enum select_method_enum {
		select_method_AUTO = 0,
		select_method_GL_SELECT = 2,
		select_method_GL_QUERY = 1,
	};

	/** Getter: Use OpenGL occlusion queries or selection render mode to accelerate selection */
	select_method_enum select_method() { /* not implemented */ throw NULL; }
	/** Setter: Use OpenGL occlusion queries or selection render mode to accelerate selection */
	void select_method(select_method_enum value) { /* not implemented */ }

	enum multi_sample_enum {
		multi_sample_NONE = 0,
		multi_sample_2 = 2,
		multi_sample_4 = 4,
		multi_sample_8 = 8,
		multi_sample_16 = 16,
	};

	/** Getter: Enable OpenGL multi-sampling, only for systems that support it, requires restart */
	multi_sample_enum multi_sample() { /* not implemented */ throw NULL; }
	/** Setter: Enable OpenGL multi-sampling, only for systems that support it, requires restart */
	void multi_sample(multi_sample_enum value) { /* not implemented */ }

	/** Getter: Draw tool/property regions over the main region, when using Triple Buffer */
	bool use_region_overlap() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_region_overlap")) == 1;
	}

	/** Setter: Draw tool/property regions over the main region, when using Triple Buffer */
	void use_region_overlap(bool value) {
		PyObject_SetAttrString(pyobjref, "use_region_overlap", Py_BuildValue("i", value));
	}

	enum compute_device_type_enum {
		compute_device_type_NONE = 0,
		compute_device_type_CUDA = 2,
		compute_device_type_OPENCL = 1,
	};

	/** Getter: Device to use for computation (rendering with Cycles) */
	compute_device_type_enum compute_device_type() { /* not implemented */ throw NULL; }
	/** Setter: Device to use for computation (rendering with Cycles) */
	void compute_device_type(compute_device_type_enum value) { /* not implemented */ }

	enum compute_device_enum {
		compute_device_CPU = 0,
	};

	/** Getter: Device to use for computation */
	compute_device_enum compute_device() { /* not implemented */ throw NULL; }
	/** Setter: Device to use for computation */
	void compute_device(compute_device_enum value) { /* not implemented */ }

	/**
	 * Function: is_occlusion_query_supported
	 * @return Check if GPU supports Occlusion Queries
	 */
	bool is_occlusion_query_supported()
	{
		// not implemented
		return true;
	}

};

/**************** Addon ****************/

/**
 * Python addons to be loaded automatically
 */
class Addon : public pyUniplug {
public:
	Addon(PyObject* pyobj) : pyUniplug(pyobj) {}

	Addon() : pyUniplug(0)
	{
		// not implemented
	}

	/** Getter: Module name */
	std::string module() { /* not implemented */ throw NULL; }
	/** Setter: Module name */
	void module(const std::string& value) { /* not implemented */ }

	/** Getter:  */
	AddonPreferences preferences();

};

/**************** Addon Preferences ****************/

/**
 * 
 */
class AddonPreferences : public pyUniplug {
public:
	AddonPreferences(PyObject* pyobj) : pyUniplug(pyobj) {}

	AddonPreferences() : pyUniplug(0)
	{
		// not implemented
	}

	/** Getter:  */
	std::string bl_idname() { /* not implemented */ throw NULL; }
	/** Setter:  */
	void bl_idname(const std::string& value) { /* not implemented */ }

};

/**************** Path Compare ****************/

/**
 * Match paths against this value
 */
class PathCompare : public pyUniplug {
public:
	PathCompare(PyObject* pyobj) : pyUniplug(pyobj) {}

	PathCompare() : pyUniplug(0)
	{
		// not implemented
	}

	/** Getter:  */
	std::string path() { /* not implemented */ throw NULL; }
	/** Setter:  */
	void path(const std::string& value) { /* not implemented */ }

	/** Getter: Enable wildcard globbing */
	bool use_glob() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_glob")) == 1;
	}

	/** Setter: Enable wildcard globbing */
	void use_glob(bool value) {
		PyObject_SetAttrString(pyobjref, "use_glob", Py_BuildValue("i", value));
	}

};

/**************** Vector Font ****************/

/**
 * Vector font for Text objects
 */
class VectorFont : public ID {
public:
	VectorFont(PyObject* pyobj) : ID(pyobj) {}

	VectorFont() : ID(0)
	{
		// not implemented
	}

	/** Getter:  */
	std::string filepath() { /* not implemented */ throw NULL; }
	/** Setter:  */
	void filepath(const std::string& value) { /* not implemented */ }

	/** Getter:  */
	PackedFile packed_file() {
		/* not implemented */ throw NULL;
	}

	/**
	 * Pack the font into the current blend file
	 */
	void pack()
	{
		// not implemented
	}

	/**
	 * Enum: unpack_method_items
	 */
	enum unpack_method_items {
		unpack_method_items_USE_LOCAL = 5,	
		unpack_method_items_WRITE_LOCAL = 4,	
		unpack_method_items_USE_ORIGINAL = 6,	
		unpack_method_items_WRITE_ORIGINAL = 3	
	};

	/**
	 * Unpack the font to the samples filename
	 * @param How to unpack
	 */
	void unpack(unpack_method_items method = unpack_method_items_USE_LOCAL)
	{
		// not implemented
	}

};

/**************** Operator ****************/

/**
 * Storage of an operator being executed, or registered after execution
 */
class Operator : public pyUniplug {
public:
	Operator(PyObject* pyobj) : pyUniplug(pyobj) {}

	Operator() : pyUniplug(0)
	{
		// not implemented
	}

	/** Getter:  */
	std::string name() { /* not implemented */ throw NULL; }
	/** Setter:  */
	void name(const std::string& value) { /* not implemented */ }

	/** Getter:  */
	OperatorProperties properties();

	/** Getter: Operator has a set of reports (warnings and errors) from last execution */
	bool has_reports() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "has_reports")) == 1;
	}

	/** Setter: Operator has a set of reports (warnings and errors) from last execution */
	void has_reports(bool value) {
		PyObject_SetAttrString(pyobjref, "has_reports", Py_BuildValue("i", value));
	}

	/** Getter:  */
	UILayout layout() {
		/* not implemented */ throw NULL;
	}

	/** Getter: Runtime options */
	OperatorOptions options();

	/** Getter:  */
	std::string bl_idname() { /* not implemented */ throw NULL; }
	/** Setter:  */
	void bl_idname(const std::string& value) { /* not implemented */ }

	/** Getter:  */
	std::string bl_label() { /* not implemented */ throw NULL; }
	/** Setter:  */
	void bl_label(const std::string& value) { /* not implemented */ }

	/** Getter:  */
	std::string bl_translation_context() { /* not implemented */ throw NULL; }
	/** Setter:  */
	void bl_translation_context(const std::string& value) { /* not implemented */ }

	/** Getter:  */
	std::string bl_description() { /* not implemented */ throw NULL; }
	/** Setter:  */
	void bl_description(const std::string& value) { /* not implemented */ }

	enum bl_options_enum {
		bl_options_REGISTER = 1,
		bl_options_UNDO = 2,
		bl_options_BLOCKING = 4,
		bl_options_MACRO = 8,
		bl_options_GRAB_CURSOR = 16,
		bl_options_PRESET = 32,
		bl_options_INTERNAL = 64,
	};

	/** Getter: Options for this operator type */
	bl_options_enum bl_options() { /* not implemented */ throw NULL; }
	/** Setter: Options for this operator type */
	void bl_options(bl_options_enum value) { /* not implemented */ }

	/** Getter:  */
	std::map<std::string, Macro> macros();
	/** Setter:  */
	void macros(std::map<std::string, Macro> value);

	/**
	 * Enum: items
	 */
	enum items {
		items_DEBUG = 1,	
		items_INFO = 2,	
		items_OPERATOR = 4,	
		items_PROPERTY = 8,	
		items_WARNING = 16,	
		items_ERROR = 32,	
		items_ERROR_INVALID_INPUT = 64,	
		items_ERROR_INVALID_CONTEXT = 128,	
		items_ERROR_OUT_OF_MEMORY = 256	
	};

	/**
	 * Function: report
	 * @param Param 'type'
	 * @param Param 'message'
	 */
	void report(items type, const std::string message)
	{
		// not implemented
	}

};

/**************** Operator Properties ****************/

/**
 * Input properties of an Operator
 */
class OperatorProperties : public pyUniplug {
public:
	OperatorProperties(PyObject* pyobj) : pyUniplug(pyobj) {}

	OperatorProperties() : pyUniplug(0)
	{
		// not implemented
	}

};

/**************** Operator Options ****************/

/**
 * Runtime options
 */
class OperatorOptions : public pyUniplug {
public:
	OperatorOptions(PyObject* pyobj) : pyUniplug(pyobj) {}

	OperatorOptions() : pyUniplug(0)
	{
		// not implemented
	}

	/** Getter: True when the cursor is grabbed */
	bool is_grab_cursor() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "is_grab_cursor")) == 1;
	}

	/** Setter: True when the cursor is grabbed */
	void is_grab_cursor(bool value) {
		PyObject_SetAttrString(pyobjref, "is_grab_cursor", Py_BuildValue("i", value));
	}

	/** Getter: True when invoked (even if only the execute callbacks available) */
	bool is_invoke() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "is_invoke")) == 1;
	}

	/** Setter: True when invoked (even if only the execute callbacks available) */
	void is_invoke(bool value) {
		PyObject_SetAttrString(pyobjref, "is_invoke", Py_BuildValue("i", value));
	}

	/** Getter: Enable to use the region under the cursor for modal execution */
	bool use_cursor_region() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_cursor_region")) == 1;
	}

	/** Setter: Enable to use the region under the cursor for modal execution */
	void use_cursor_region(bool value) {
		PyObject_SetAttrString(pyobjref, "use_cursor_region", Py_BuildValue("i", value));
	}

};

/**************** Operator Mouse Path ****************/

/**
 * Mouse path values for operators that record such paths
 */
class OperatorMousePath : public PropertyGroup {
public:
	OperatorMousePath(PyObject* pyobj) : PropertyGroup(pyobj) {}

	OperatorMousePath() : PropertyGroup(0)
	{
		// not implemented
	}

	/** Getter: Mouse location */
	std::array<float, 2> loc() {
		// TODO: MISSING DEREF! USE #DEFINE!
		PyObject *seqval = PyObject_GetAttrString(pyobjref, "loc");
		std::array<float, 2> resarr;
		for (int i = 0; i < 2; i++)
			resarr[i] = (float)PyFloat_AsDouble(PySequence_GetItem(seqval, i));
		return resarr;
	}

	/** Setter: Mouse location */
	void loc(float values[2]) { /* not implemented */ }

	/** Getter: Time of mouse location */
	float time() { /* not implemented */ throw NULL; }
	/** Setter: Time of mouse location */
	void time(float value) {
		PyObject_SetAttrString(pyobjref, "time", Py_BuildValue("f", value));
	}

};

/**************** Operator File List Element ****************/

/**
 * 
 */
class OperatorFileListElement : public PropertyGroup {
public:
	OperatorFileListElement(PyObject* pyobj) : PropertyGroup(pyobj) {}

	OperatorFileListElement() : PropertyGroup(0)
	{
		// not implemented
	}

	/** Getter: Name of a file or directory within a file list */
	std::string name() { /* not implemented */ throw NULL; }
	/** Setter: Name of a file or directory within a file list */
	void name(const std::string& value) { /* not implemented */ }

};

/**************** Macro Operator ****************/

/**
 * Storage of a macro operator being executed, or registered after execution
 */
class Macro : public pyUniplug {
public:
	Macro(PyObject* pyobj) : pyUniplug(pyobj) {}

	Macro() : pyUniplug(0)
	{
		// not implemented
	}

	/** Getter:  */
	std::string name() { /* not implemented */ throw NULL; }
	/** Setter:  */
	void name(const std::string& value) { /* not implemented */ }

	/** Getter:  */
	OperatorProperties properties() {
		/* not implemented */ throw NULL;
	}

	/** Getter:  */
	std::string bl_idname() { /* not implemented */ throw NULL; }
	/** Setter:  */
	void bl_idname(const std::string& value) { /* not implemented */ }

	/** Getter:  */
	std::string bl_label() { /* not implemented */ throw NULL; }
	/** Setter:  */
	void bl_label(const std::string& value) { /* not implemented */ }

	/** Getter:  */
	std::string bl_translation_context() { /* not implemented */ throw NULL; }
	/** Setter:  */
	void bl_translation_context(const std::string& value) { /* not implemented */ }

	/** Getter:  */
	std::string bl_description() { /* not implemented */ throw NULL; }
	/** Setter:  */
	void bl_description(const std::string& value) { /* not implemented */ }

	enum bl_options_enum {
		bl_options_REGISTER = 1,
		bl_options_UNDO = 2,
		bl_options_BLOCKING = 4,
		bl_options_MACRO = 8,
		bl_options_GRAB_CURSOR = 16,
		bl_options_PRESET = 32,
		bl_options_INTERNAL = 64,
	};

	/** Getter: Options for this operator type */
	bl_options_enum bl_options() { /* not implemented */ throw NULL; }
	/** Setter: Options for this operator type */
	void bl_options(bl_options_enum value) { /* not implemented */ }

	/**
	 * Enum: items
	 */
	enum items {
		items_DEBUG = 1,	
		items_INFO = 2,	
		items_OPERATOR = 4,	
		items_PROPERTY = 8,	
		items_WARNING = 16,	
		items_ERROR = 32,	
		items_ERROR_INVALID_INPUT = 64,	
		items_ERROR_INVALID_CONTEXT = 128,	
		items_ERROR_OUT_OF_MEMORY = 256	
	};

	/**
	 * Function: report
	 * @param Param 'type'
	 * @param Param 'message'
	 */
	void report(items type, const std::string message)
	{
		// not implemented
	}

};

/**************** Operator Macro ****************/

/**
 * Storage of a sub operator in a macro after it has been added
 */
class OperatorMacro : public pyUniplug {
public:
	OperatorMacro(PyObject* pyobj) : pyUniplug(pyobj) {}

	OperatorMacro() : pyUniplug(0)
	{
		// not implemented
	}

	/** Getter:  */
	OperatorProperties properties() {
		/* not implemented */ throw NULL;
	}

};

/**************** Event ****************/

/**
 * Window Manager Event
 */
class Event : public pyUniplug {
public:
	Event(PyObject* pyobj) : pyUniplug(pyobj) {}

	Event() : pyUniplug(0)
	{
		// not implemented
	}

	/** Getter: Single ASCII character for this event */
	std::string ascii() { /* not implemented */ throw NULL; }
	/** Setter: Single ASCII character for this event */
	void ascii(const std::string& value) { /* not implemented */ }

	/** Getter: Single unicode character for this event */
	std::string unicode() { /* not implemented */ throw NULL; }
	/** Setter: Single unicode character for this event */
	void unicode(const std::string& value) { /* not implemented */ }

	enum value_enum {
		value_ANY = -1,
		value_NOTHING = 0,
		value_PRESS = 1,
		value_RELEASE = 2,
		value_CLICK = 3,
		value_DOUBLE_CLICK = 4,
		value_NORTH = 1,
		value_NORTH_EAST = 2,
		value_EAST = 3,
		value_SOUTH_EAST = 4,
		value_SOUTH = 5,
		value_SOUTH_WEST = 6,
		value_WEST = 7,
		value_NORTH_WEST = 8,
	};

	/** Getter: The type of event, only applies to some */
	value_enum value() { /* not implemented */ throw NULL; }
	/** Setter: The type of event, only applies to some */
	void value(value_enum value) { /* not implemented */ }

	enum type_enum {
		type_NONE = 0,
		type_LEFTMOUSE = 1,
		type_MIDDLEMOUSE = 2,
		type_RIGHTMOUSE = 3,
		type_BUTTON4MOUSE = 7,
		type_BUTTON5MOUSE = 8,
		type_BUTTON6MOUSE = 18,
		type_BUTTON7MOUSE = 19,
		type_ACTIONMOUSE = 5,
		type_SELECTMOUSE = 6,
		type_MOUSEMOVE = 4,
		type_INBETWEEN_MOUSEMOVE = 17,
		type_TRACKPADPAN = 14,
		type_TRACKPADZOOM = 15,
		type_MOUSEROTATE = 16,
		type_WHEELUPMOUSE = 10,
		type_WHEELDOWNMOUSE = 11,
		type_WHEELINMOUSE = 12,
		type_WHEELOUTMOUSE = 13,
		type_EVT_TWEAK_L = 20482,
		type_EVT_TWEAK_M = 20483,
		type_EVT_TWEAK_R = 20484,
		type_EVT_TWEAK_A = 20485,
		type_EVT_TWEAK_S = 20486,
		type_A = 97,
		type_B = 98,
		type_C = 99,
		type_D = 100,
		type_E = 101,
		type_F = 102,
		type_G = 103,
		type_H = 104,
		type_I = 105,
		type_J = 106,
		type_K = 107,
		type_L = 108,
		type_M = 109,
		type_N = 110,
		type_O = 111,
		type_P = 112,
		type_Q = 113,
		type_R = 114,
		type_S = 115,
		type_T = 116,
		type_U = 117,
		type_V = 118,
		type_W = 119,
		type_X = 120,
		type_Y = 121,
		type_Z = 122,
		type_ZERO = 48,
		type_ONE = 49,
		type_TWO = 50,
		type_THREE = 51,
		type_FOUR = 52,
		type_FIVE = 53,
		type_SIX = 54,
		type_SEVEN = 55,
		type_EIGHT = 56,
		type_NINE = 57,
		type_LEFT_CTRL = 212,
		type_LEFT_ALT = 213,
		type_LEFT_SHIFT = 217,
		type_RIGHT_ALT = 214,
		type_RIGHT_CTRL = 215,
		type_RIGHT_SHIFT = 216,
		type_OSKEY = 172,
		type_GRLESS = 173,
		type_ESC = 218,
		type_TAB = 219,
		type_RET = 220,
		type_SPACE = 221,
		type_LINE_FEED = 222,
		type_BACK_SPACE = 223,
		type_DEL = 224,
		type_SEMI_COLON = 225,
		type_PERIOD = 226,
		type_COMMA = 227,
		type_QUOTE = 228,
		type_ACCENT_GRAVE = 229,
		type_MINUS = 230,
		type_SLASH = 232,
		type_BACK_SLASH = 233,
		type_EQUAL = 234,
		type_LEFT_BRACKET = 235,
		type_RIGHT_BRACKET = 236,
		type_LEFT_ARROW = 137,
		type_DOWN_ARROW = 138,
		type_RIGHT_ARROW = 139,
		type_UP_ARROW = 140,
		type_NUMPAD_2 = 152,
		type_NUMPAD_4 = 154,
		type_NUMPAD_6 = 156,
		type_NUMPAD_8 = 158,
		type_NUMPAD_1 = 151,
		type_NUMPAD_3 = 153,
		type_NUMPAD_5 = 155,
		type_NUMPAD_7 = 157,
		type_NUMPAD_9 = 159,
		type_NUMPAD_PERIOD = 199,
		type_NUMPAD_SLASH = 161,
		type_NUMPAD_ASTERIX = 160,
		type_NUMPAD_0 = 150,
		type_NUMPAD_MINUS = 162,
		type_NUMPAD_ENTER = 163,
		type_NUMPAD_PLUS = 164,
		type_F1 = 300,
		type_F2 = 301,
		type_F3 = 302,
		type_F4 = 303,
		type_F5 = 304,
		type_F6 = 305,
		type_F7 = 306,
		type_F8 = 307,
		type_F9 = 308,
		type_F10 = 309,
		type_F11 = 310,
		type_F12 = 311,
		type_F13 = 312,
		type_F14 = 313,
		type_F15 = 314,
		type_F16 = 315,
		type_F17 = 316,
		type_F18 = 317,
		type_F19 = 318,
		type_PAUSE = 165,
		type_INSERT = 166,
		type_HOME = 167,
		type_PAGE_UP = 168,
		type_PAGE_DOWN = 169,
		type_END = 170,
		type_MEDIA_PLAY = 174,
		type_MEDIA_STOP = 175,
		type_MEDIA_FIRST = 176,
		type_MEDIA_LAST = 177,
		type_TEXTINPUT = -2,
		type_WINDOW_DEACTIVATE = 260,
		type_TIMER = 272,
		type_TIMER0 = 273,
		type_TIMER1 = 274,
		type_TIMER2 = 275,
		type_TIMER_JOBS = 276,
		type_TIMER_AUTOSAVE = 277,
		type_TIMER_REPORT = 278,
		type_TIMERREGION = 279,
		type_NDOF_MOTION = 400,
		type_NDOF_BUTTON_MENU = 401,
		type_NDOF_BUTTON_FIT = 402,
		type_NDOF_BUTTON_TOP = 403,
		type_NDOF_BUTTON_BOTTOM = 404,
		type_NDOF_BUTTON_LEFT = 405,
		type_NDOF_BUTTON_RIGHT = 406,
		type_NDOF_BUTTON_FRONT = 407,
		type_NDOF_BUTTON_BACK = 408,
		type_NDOF_BUTTON_ISO1 = 409,
		type_NDOF_BUTTON_ISO2 = 410,
		type_NDOF_BUTTON_ROLL_CW = 411,
		type_NDOF_BUTTON_ROLL_CCW = 412,
		type_NDOF_BUTTON_SPIN_CW = 413,
		type_NDOF_BUTTON_SPIN_CCW = 414,
		type_NDOF_BUTTON_TILT_CW = 415,
		type_NDOF_BUTTON_TILT_CCW = 416,
		type_NDOF_BUTTON_ROTATE = 417,
		type_NDOF_BUTTON_PANZOOM = 418,
		type_NDOF_BUTTON_DOMINANT = 419,
		type_NDOF_BUTTON_PLUS = 420,
		type_NDOF_BUTTON_MINUS = 421,
		type_NDOF_BUTTON_ESC = 422,
		type_NDOF_BUTTON_ALT = 423,
		type_NDOF_BUTTON_SHIFT = 424,
		type_NDOF_BUTTON_CTRL = 425,
		type_NDOF_BUTTON_1 = 426,
		type_NDOF_BUTTON_2 = 427,
		type_NDOF_BUTTON_3 = 428,
		type_NDOF_BUTTON_4 = 429,
		type_NDOF_BUTTON_5 = 430,
		type_NDOF_BUTTON_6 = 431,
		type_NDOF_BUTTON_7 = 432,
		type_NDOF_BUTTON_8 = 433,
		type_NDOF_BUTTON_9 = 434,
		type_NDOF_BUTTON_10 = 435,
		type_NDOF_BUTTON_A = 436,
		type_NDOF_BUTTON_B = 437,
		type_NDOF_BUTTON_C = 438,
	};

	/** Getter:  */
	type_enum type() { /* not implemented */ throw NULL; }
	/** Setter:  */
	void type(type_enum value) { /* not implemented */ }

	/** Getter: The window relative horizontal location of the mouse */
	int mouse_x() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "mouse_x"));
	}

	/** Setter: The window relative horizontal location of the mouse */
	void mouse_x(int value) {
		PyObject_SetAttrString(pyobjref, "mouse_x", Py_BuildValue("i", value));
	}

	/** Getter: The window relative vertical location of the mouse */
	int mouse_y() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "mouse_y"));
	}

	/** Setter: The window relative vertical location of the mouse */
	void mouse_y(int value) {
		PyObject_SetAttrString(pyobjref, "mouse_y", Py_BuildValue("i", value));
	}

	/** Getter: The region relative horizontal location of the mouse */
	int mouse_region_x() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "mouse_region_x"));
	}

	/** Setter: The region relative horizontal location of the mouse */
	void mouse_region_x(int value) {
		PyObject_SetAttrString(pyobjref, "mouse_region_x", Py_BuildValue("i", value));
	}

	/** Getter: The region relative vertical location of the mouse */
	int mouse_region_y() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "mouse_region_y"));
	}

	/** Setter: The region relative vertical location of the mouse */
	void mouse_region_y(int value) {
		PyObject_SetAttrString(pyobjref, "mouse_region_y", Py_BuildValue("i", value));
	}

	/** Getter: The window relative horizontal location of the mouse */
	int mouse_prev_x() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "mouse_prev_x"));
	}

	/** Setter: The window relative horizontal location of the mouse */
	void mouse_prev_x(int value) {
		PyObject_SetAttrString(pyobjref, "mouse_prev_x", Py_BuildValue("i", value));
	}

	/** Getter: The window relative vertical location of the mouse */
	int mouse_prev_y() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "mouse_prev_y"));
	}

	/** Setter: The window relative vertical location of the mouse */
	void mouse_prev_y(int value) {
		PyObject_SetAttrString(pyobjref, "mouse_prev_y", Py_BuildValue("i", value));
	}

	/** Getter: The pressure of the tablet or 1.0 if no tablet present */
	float pressure() { /* not implemented */ throw NULL; }
	/** Setter: The pressure of the tablet or 1.0 if no tablet present */
	void pressure(float value) {
		PyObject_SetAttrString(pyobjref, "pressure", Py_BuildValue("f", value));
	}

	/** Getter: The pressure of the tablet or zeroes if no tablet present */
	std::array<float, 2> tilt() {
		// TODO: MISSING DEREF! USE #DEFINE!
		PyObject *seqval = PyObject_GetAttrString(pyobjref, "tilt");
		std::array<float, 2> resarr;
		for (int i = 0; i < 2; i++)
			resarr[i] = (float)PyFloat_AsDouble(PySequence_GetItem(seqval, i));
		return resarr;
	}

	/** Setter: The pressure of the tablet or zeroes if no tablet present */
	void tilt(float values[2]) { /* not implemented */ }

	/** Getter: The pressure of the tablet or 1.0 if no tablet present */
	bool is_tablet() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "is_tablet")) == 1;
	}

	/** Setter: The pressure of the tablet or 1.0 if no tablet present */
	void is_tablet(bool value) {
		PyObject_SetAttrString(pyobjref, "is_tablet", Py_BuildValue("i", value));
	}

	/** Getter: True when the Shift key is held */
	bool shift() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "shift")) == 1;
	}

	/** Setter: True when the Shift key is held */
	void shift(bool value) {
		PyObject_SetAttrString(pyobjref, "shift", Py_BuildValue("i", value));
	}

	/** Getter: True when the Ctrl key is held */
	bool ctrl() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "ctrl")) == 1;
	}

	/** Setter: True when the Ctrl key is held */
	void ctrl(bool value) {
		PyObject_SetAttrString(pyobjref, "ctrl", Py_BuildValue("i", value));
	}

	/** Getter: True when the Alt/Option key is held */
	bool alt() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "alt")) == 1;
	}

	/** Setter: True when the Alt/Option key is held */
	void alt(bool value) {
		PyObject_SetAttrString(pyobjref, "alt", Py_BuildValue("i", value));
	}

	/** Getter: True when the Cmd key is held */
	bool oskey() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "oskey")) == 1;
	}

	/** Setter: True when the Cmd key is held */
	void oskey(bool value) {
		PyObject_SetAttrString(pyobjref, "oskey", Py_BuildValue("i", value));
	}

};

/**************** Timer ****************/

/**
 * Window event timer
 */
class Timer : public pyUniplug {
public:
	Timer(PyObject* pyobj) : pyUniplug(pyobj) {}

	Timer() : pyUniplug(0)
	{
		// not implemented
	}

	/** Getter:  */
	float time_step() { /* not implemented */ throw NULL; }
	/** Setter:  */
	void time_step(float value) {
		PyObject_SetAttrString(pyobjref, "time_step", Py_BuildValue("f", value));
	}

	/** Getter: Time since last step in seconds */
	float time_delta() { /* not implemented */ throw NULL; }
	/** Setter: Time since last step in seconds */
	void time_delta(float value) {
		PyObject_SetAttrString(pyobjref, "time_delta", Py_BuildValue("f", value));
	}

	/** Getter: Time since last step in seconds */
	float time_duration() { /* not implemented */ throw NULL; }
	/** Setter: Time since last step in seconds */
	void time_duration(float value) {
		PyObject_SetAttrString(pyobjref, "time_duration", Py_BuildValue("f", value));
	}

};

/**************** PopupMenu ****************/

/**
 * 
 */
class UIPopupMenu : public pyUniplug {
public:
	UIPopupMenu(PyObject* pyobj) : pyUniplug(pyobj) {}

	UIPopupMenu() : pyUniplug(0)
	{
		// not implemented
	}

	/** Getter:  */
	UILayout layout() {
		/* not implemented */ throw NULL;
	}

};

/**************** PieMenu ****************/

/**
 * 
 */
class UIPieMenu : public pyUniplug {
public:
	UIPieMenu(PyObject* pyobj) : pyUniplug(pyobj) {}

	UIPieMenu() : pyUniplug(0)
	{
		// not implemented
	}

	/** Getter:  */
	UILayout layout() {
		/* not implemented */ throw NULL;
	}

};

/**************** Window ****************/

/**
 * Open window
 */
class Window : public pyUniplug {
public:
	Window(PyObject* pyobj) : pyUniplug(pyobj) {}

	Window() : pyUniplug(0)
	{
		// not implemented
	}

	/** Getter: Active screen showing in the window */
	Screen screen() {
		/* not implemented */ throw NULL;
	}

	/** Getter: Horizontal location of the window */
	int x() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "x"));
	}

	/** Setter: Horizontal location of the window */
	void x(int value) {
		PyObject_SetAttrString(pyobjref, "x", Py_BuildValue("i", value));
	}

	/** Getter: Vertical location of the window */
	int y() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "y"));
	}

	/** Setter: Vertical location of the window */
	void y(int value) {
		PyObject_SetAttrString(pyobjref, "y", Py_BuildValue("i", value));
	}

	/** Getter: Window width */
	int width() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "width"));
	}

	/** Setter: Window width */
	void width(int value) {
		PyObject_SetAttrString(pyobjref, "width", Py_BuildValue("i", value));
	}

	/** Getter: Window height */
	int height() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "height"));
	}

	/** Setter: Window height */
	void height(int value) {
		PyObject_SetAttrString(pyobjref, "height", Py_BuildValue("i", value));
	}

	/** Getter: Settings for stereo 3d display */
	Stereo3dDisplay stereo_3d_display();

	/**
	 * Set the cursor position
	 * @param Param 'x'
	 * @param Param 'y'
	 */
	void cursor_warp(int x, int y)
	{
		// not implemented
	}

	/**
	 * Enum: window_cursor_items
	 */
	enum window_cursor_items {
		window_cursor_items_DEFAULT = 1006,	
		window_cursor_items_NONE = 1007,	
		window_cursor_items_WAIT = 1001,	
		window_cursor_items_CROSSHAIR = 1002,	
		window_cursor_items_MOVE_X = 1003,	
		window_cursor_items_MOVE_Y = 1004,	
		window_cursor_items_KNIFE = 9,	
		window_cursor_items_TEXT = 11,	
		window_cursor_items_PAINT_BRUSH = 12,	
		window_cursor_items_HAND = 13,	
		window_cursor_items_SCROLL_X = 16,	
		window_cursor_items_SCROLL_Y = 15,	
		window_cursor_items_SCROLL_XY = 14,	
		window_cursor_items_EYEDROPPER = 17	
	};

	/**
	 * Set the cursor
	 * @param Param 'cursor'
	 */
	void cursor_set(window_cursor_items cursor)
	{
		// not implemented
	}

	/**
	 * Restore the previous cursor after calling ``cursor_modal_set``
	 * @param Param 'cursor'
	 */
	void cursor_modal_set(window_cursor_items cursor)
	{
		// not implemented
	}

	/**
	 * Function: cursor_modal_restore
	 */
	void cursor_modal_restore()
	{
		// not implemented
	}

};

/**************** Stereo 3D Display ****************/

/**
 * Settings for stereo 3D display
 */
class Stereo3dDisplay : public pyUniplug {
public:
	Stereo3dDisplay(PyObject* pyobj) : pyUniplug(pyobj) {}

	Stereo3dDisplay() : pyUniplug(0)
	{
		// not implemented
	}

	enum display_mode_enum {
		display_mode_ANAGLYPH = 0,
		display_mode_INTERLACE = 1,
		display_mode_TIMESEQUENTIAL = 2,
		display_mode_SIDEBYSIDE = 3,
		display_mode_TOPBOTTOM = 4,
	};

	/** Getter:  */
	display_mode_enum display_mode() { /* not implemented */ throw NULL; }
	/** Setter:  */
	void display_mode(display_mode_enum value) { /* not implemented */ }

	enum anaglyph_type_enum {
		anaglyph_type_RED_CYAN = 0,
		anaglyph_type_GREEN_MAGENTA = 1,
		anaglyph_type_YELLOW_BLUE = 2,
	};

	/** Getter:  */
	anaglyph_type_enum anaglyph_type() { /* not implemented */ throw NULL; }
	/** Setter:  */
	void anaglyph_type(anaglyph_type_enum value) { /* not implemented */ }

	enum interlace_type_enum {
		interlace_type_ROW_INTERLEAVED = 0,
		interlace_type_COLUMN_INTERLEAVED = 1,
		interlace_type_CHECKERBOARD_INTERLEAVED = 2,
	};

	/** Getter:  */
	interlace_type_enum interlace_type() { /* not implemented */ throw NULL; }
	/** Setter:  */
	void interlace_type(interlace_type_enum value) { /* not implemented */ }

	/** Getter: Swap left and right stereo channels */
	bool use_interlace_swap() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_interlace_swap")) == 1;
	}

	/** Setter: Swap left and right stereo channels */
	void use_interlace_swap(bool value) {
		PyObject_SetAttrString(pyobjref, "use_interlace_swap", Py_BuildValue("i", value));
	}

	/** Getter: Right eye should see left image and vice-versa */
	bool use_sidebyside_crosseyed() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_sidebyside_crosseyed")) == 1;
	}

	/** Setter: Right eye should see left image and vice-versa */
	void use_sidebyside_crosseyed(bool value) {
		PyObject_SetAttrString(pyobjref, "use_sidebyside_crosseyed", Py_BuildValue("i", value));
	}

};

/**************** Window Manager ****************/

/**
 * Window manager datablock defining open windows and other user interface data
 */
class WindowManager : public ID {
public:
	WindowManager(PyObject* pyobj) : ID(pyobj) {}

	WindowManager() : ID(0)
	{
		// not implemented
	}

	/** Getter: Operator registry */
	std::map<std::string, Operator> operators() {
		// TODO: MISSING DEREF! USE #DEFINE!
		PyObject *seqval = PyObject_GetAttrString(pyobjref, "operators");
		PyObject *seqkeys = PyObject_CallMethod(seqval, "keys", NULL);
		std::map<std::string, Operator> resmap;
		for (int i = 0; i < PySequence_Length(seqval); i++) {
			PyObject *keyobj = PySequence_GetItem(seqkeys, i);
			std::string key = PyBytes_AsString(PyUnicode_AsASCIIString(keyobj));
			Operator value = Operator(PySequence_GetItem(seqval, i));
			resmap.insert(std::pair<std::string,Operator>(key, value));
		}
		return resmap;
	}

	/** Setter: Operator registry */
	void operators(std::map<std::string, Operator> value) { /* not implemented */ }

	/** Getter: Open windows */
	std::map<std::string, Window> windows() {
		// TODO: MISSING DEREF! USE #DEFINE!
		PyObject *seqval = PyObject_GetAttrString(pyobjref, "windows");
		PyObject *seqkeys = PyObject_CallMethod(seqval, "keys", NULL);
		std::map<std::string, Window> resmap;
		for (int i = 0; i < PySequence_Length(seqval); i++) {
			PyObject *keyobj = PySequence_GetItem(seqkeys, i);
			std::string key = PyBytes_AsString(PyUnicode_AsASCIIString(keyobj));
			Window value = Window(PySequence_GetItem(seqval, i));
			resmap.insert(std::pair<std::string,Window>(key, value));
		}
		return resmap;
	}

	/** Setter: Open windows */
	void windows(std::map<std::string, Window> value) { /* not implemented */ }

	/** Getter: Registered key configurations */
	std::map<std::string, KeyConfig> keyconfigs();
	/** Setter: Registered key configurations */
	void keyconfigs(std::map<std::string, KeyConfig> value);

	/** Getter:  */
	std::string clipboard() { /* not implemented */ throw NULL; }
	/** Setter:  */
	void clipboard(const std::string& value) { /* not implemented */ }

	/**
	 * Opens a file selector with an operator. The string properties 'filepath', 'filename', 'directory' and a 'files' collection are assigned when present in the operator
	 * @param Operator to call
	 */
	void fileselect_add(Operator operator_value)
	{
		// not implemented
	}

	/**
	 * Function: modal_handler_add
	 * @param Operator to call
	 * @return 
	 */
	bool modal_handler_add(Operator operator_value)
	{
		// not implemented
		return true;
	}

	/**
	 * Function: event_timer_add
	 * @param Interval in seconds between timer events
	 * @param Window to attach the timer to or None
	 * @return 
	 */
	Timer event_timer_add(float time_step, Window window)
	{
		// not implemented
		return Timer();
	}

	/**
	 * Function: event_timer_remove
	 * @param Param 'timer'
	 */
	void event_timer_remove(Timer timer)
	{
		// not implemented
	}

	/**
	 * Start Progress bar
	 * @param any value in range [0,9999]
	 * @param any value in range [min+1,9998]
	 */
	void progress_begin(float min, float max)
	{
		// not implemented
	}

	/**
	 * Function: progress_update
	 * @param any value between min and max as set in progress_begin()
	 */
	void progress_update(float value)
	{
		// not implemented
	}

	/**
	 * Terminate Progress bar
	 */
	void progress_end()
	{
		// not implemented
	}

	/**
	 * Enum: items
	 */
	enum items {
		items_RUNNING_MODAL = 1,	/**< Keep the operator running with blender */
		items_CANCELLED = 2,	/**< When no action has been taken, operator exits */
		items_FINISHED = 4,	/**< When the operator is complete, operator exits */
		items_PASS_THROUGH = 8,	/**< Do nothing and pass the event on */
		items_INTERFACE = 32	/**< Handled but not executed (popup menus) */
	};

	/**
	 * Operator popup invoke
	 * @param Operator to call
	 * @param Event
	 * @return 
	 */
	items invoke_props_popup(Operator operator_value, Event event)
	{
		// not implemented
		throw NULL;
	}

	/**
	 * Operator dialog (non-autoexec popup) invoke
	 * @param Operator to call
	 * @param Width of the popup
	 * @param Height of the popup
	 * @return 
	 */
	items invoke_props_dialog(Operator operator_value, int width = 300, int height = 20)
	{
		// not implemented
		throw NULL;
	}

	/**
	 * Function: invoke_search_popup
	 * @param Operator to call
	 */
	void invoke_search_popup(Operator operator_value)
	{
		// not implemented
	}

	/**
	 * Operator popup invoke
	 * @param Operator to call
	 * @param Width of the popup
	 * @param Height of the popup
	 * @return 
	 */
	items invoke_popup(Operator operator_value, int width = 300, int height = 20)
	{
		// not implemented
		throw NULL;
	}

	/**
	 * Operator confirmation
	 * @param Operator to call
	 * @param Event
	 * @return 
	 */
	items invoke_confirm(Operator operator_value, Event event)
	{
		// not implemented
		throw NULL;
	}

	/**
	 * Enum: icon_items
	 */
	enum icon_items {
		icon_items_NONE = 0,	
		icon_items_QUESTION = 1,	
		icon_items_ERROR = 2,	
		icon_items_CANCEL = 3,	
		icon_items_TRIA_RIGHT = 4,	
		icon_items_TRIA_DOWN = 5,	
		icon_items_TRIA_LEFT = 6,	
		icon_items_TRIA_UP = 7,	
		icon_items_ARROW_LEFTRIGHT = 8,	
		icon_items_PLUS = 9,	
		icon_items_DISCLOSURE_TRI_DOWN = 10,	
		icon_items_DISCLOSURE_TRI_RIGHT = 11,	
		icon_items_RADIOBUT_OFF = 12,	
		icon_items_RADIOBUT_ON = 13,	
		icon_items_MENU_PANEL = 14,	
		icon_items_BLENDER = 15,	
		icon_items_GRIP = 16,	
		icon_items_DOT = 17,	
		icon_items_COLLAPSEMENU = 18,	
		icon_items_X = 19,	
		icon_items_GO_LEFT = 21,	
		icon_items_PLUG = 22,	
		icon_items_UI = 23,	
		icon_items_NODE = 24,	
		icon_items_NODE_SEL = 25,	
		icon_items_FULLSCREEN = 26,	
		icon_items_SPLITSCREEN = 27,	
		icon_items_RIGHTARROW_THIN = 28,	
		icon_items_BORDERMOVE = 29,	
		icon_items_VIEWZOOM = 30,	
		icon_items_ZOOMIN = 31,	
		icon_items_ZOOMOUT = 32,	
		icon_items_PANEL_CLOSE = 33,	
		icon_items_COPY_ID = 34,	
		icon_items_EYEDROPPER = 35,	
		icon_items_LINK_AREA = 36,	
		icon_items_AUTO = 37,	
		icon_items_CHECKBOX_DEHLT = 38,	
		icon_items_CHECKBOX_HLT = 39,	
		icon_items_UNLOCKED = 40,	
		icon_items_LOCKED = 41,	
		icon_items_UNPINNED = 42,	
		icon_items_PINNED = 43,	
		icon_items_SCREEN_BACK = 44,	
		icon_items_RIGHTARROW = 45,	
		icon_items_DOWNARROW_HLT = 46,	
		icon_items_DOTSUP = 47,	
		icon_items_DOTSDOWN = 48,	
		icon_items_LINK = 49,	
		icon_items_INLINK = 50,	
		icon_items_PLUGIN = 51,	
		icon_items_HELP = 52,	
		icon_items_GHOST_ENABLED = 53,	
		icon_items_COLOR = 54,	
		icon_items_LINKED = 55,	
		icon_items_UNLINKED = 56,	
		icon_items_HAND = 57,	
		icon_items_ZOOM_ALL = 58,	
		icon_items_ZOOM_SELECTED = 59,	
		icon_items_ZOOM_PREVIOUS = 60,	
		icon_items_ZOOM_IN = 61,	
		icon_items_ZOOM_OUT = 62,	
		icon_items_RENDER_REGION = 63,	
		icon_items_BORDER_RECT = 64,	
		icon_items_BORDER_LASSO = 65,	
		icon_items_FREEZE = 66,	
		icon_items_STYLUS_PRESSURE = 67,	
		icon_items_GHOST_DISABLED = 68,	
		icon_items_NEW = 69,	
		icon_items_FILE_TICK = 70,	
		icon_items_QUIT = 71,	
		icon_items_URL = 72,	
		icon_items_RECOVER_LAST = 73,	
		icon_items_FULLSCREEN_ENTER = 75,	
		icon_items_FULLSCREEN_EXIT = 76,	
		icon_items_BLANK1 = 77,	
		icon_items_LAMP = 78,	
		icon_items_MATERIAL = 79,	
		icon_items_TEXTURE = 80,	
		icon_items_ANIM = 81,	
		icon_items_WORLD = 82,	
		icon_items_SCENE = 83,	
		icon_items_EDIT = 84,	
		icon_items_GAME = 85,	
		icon_items_RADIO = 86,	
		icon_items_SCRIPT = 87,	
		icon_items_PARTICLES = 88,	
		icon_items_PHYSICS = 89,	
		icon_items_SPEAKER = 90,	
		icon_items_TEXTURE_SHADED = 91,	
		icon_items_VIEW3D = 104,	
		icon_items_IPO = 105,	
		icon_items_OOPS = 106,	
		icon_items_BUTS = 107,	
		icon_items_FILESEL = 108,	
		icon_items_IMAGE_COL = 109,	
		icon_items_INFO = 110,	
		icon_items_SEQUENCE = 111,	
		icon_items_TEXT = 112,	
		icon_items_IMASEL = 113,	
		icon_items_SOUND = 114,	
		icon_items_ACTION = 115,	
		icon_items_NLA = 116,	
		icon_items_SCRIPTWIN = 117,	
		icon_items_TIME = 118,	
		icon_items_NODETREE = 119,	
		icon_items_LOGIC = 120,	
		icon_items_CONSOLE = 121,	
		icon_items_PREFERENCES = 122,	
		icon_items_CLIP = 123,	
		icon_items_ASSET_MANAGER = 124,	
		icon_items_OBJECT_DATAMODE = 130,	
		icon_items_EDITMODE_HLT = 131,	
		icon_items_FACESEL_HLT = 132,	
		icon_items_VPAINT_HLT = 133,	
		icon_items_TPAINT_HLT = 134,	
		icon_items_WPAINT_HLT = 135,	
		icon_items_SCULPTMODE_HLT = 136,	
		icon_items_POSE_HLT = 137,	
		icon_items_PARTICLEMODE = 138,	
		icon_items_LIGHTPAINT = 139,	
		icon_items_SCENE_DATA = 156,	
		icon_items_RENDERLAYERS = 157,	
		icon_items_WORLD_DATA = 158,	
		icon_items_OBJECT_DATA = 159,	
		icon_items_MESH_DATA = 160,	
		icon_items_CURVE_DATA = 161,	
		icon_items_META_DATA = 162,	
		icon_items_LATTICE_DATA = 163,	
		icon_items_LAMP_DATA = 164,	
		icon_items_MATERIAL_DATA = 165,	
		icon_items_TEXTURE_DATA = 166,	
		icon_items_ANIM_DATA = 167,	
		icon_items_CAMERA_DATA = 168,	
		icon_items_PARTICLE_DATA = 169,	
		icon_items_LIBRARY_DATA_DIRECT = 170,	
		icon_items_GROUP = 171,	
		icon_items_ARMATURE_DATA = 172,	
		icon_items_POSE_DATA = 173,	
		icon_items_BONE_DATA = 174,	
		icon_items_CONSTRAINT = 175,	
		icon_items_SHAPEKEY_DATA = 176,	
		icon_items_CONSTRAINT_BONE = 177,	
		icon_items_CAMERA_STEREO = 178,	
		icon_items_PACKAGE = 179,	
		icon_items_UGLYPACKAGE = 180,	
		icon_items_BRUSH_DATA = 182,	
		icon_items_IMAGE_DATA = 183,	
		icon_items_FILE = 184,	
		icon_items_FCURVE = 185,	
		icon_items_FONT_DATA = 186,	
		icon_items_RENDER_RESULT = 187,	
		icon_items_SURFACE_DATA = 188,	
		icon_items_EMPTY_DATA = 189,	
		icon_items_SETTINGS = 190,	
		icon_items_RENDER_ANIMATION = 191,	
		icon_items_RENDER_STILL = 192,	
		icon_items_BOIDS = 194,	
		icon_items_STRANDS = 195,	
		icon_items_LIBRARY_DATA_INDIRECT = 196,	
		icon_items_GREASEPENCIL = 197,	
		icon_items_LINE_DATA = 198,	
		icon_items_GROUP_BONE = 200,	
		icon_items_GROUP_VERTEX = 201,	
		icon_items_GROUP_VCOL = 202,	
		icon_items_GROUP_UVS = 203,	
		icon_items_RNA = 206,	
		icon_items_RNA_ADD = 207,	
		icon_items_OUTLINER_OB_EMPTY = 234,	
		icon_items_OUTLINER_OB_MESH = 235,	
		icon_items_OUTLINER_OB_CURVE = 236,	
		icon_items_OUTLINER_OB_LATTICE = 237,	
		icon_items_OUTLINER_OB_META = 238,	
		icon_items_OUTLINER_OB_LAMP = 239,	
		icon_items_OUTLINER_OB_CAMERA = 240,	
		icon_items_OUTLINER_OB_ARMATURE = 241,	
		icon_items_OUTLINER_OB_FONT = 242,	
		icon_items_OUTLINER_OB_SURFACE = 243,	
		icon_items_OUTLINER_OB_SPEAKER = 244,	
		icon_items_RESTRICT_VIEW_OFF = 253,	
		icon_items_RESTRICT_VIEW_ON = 254,	
		icon_items_RESTRICT_SELECT_OFF = 255,	
		icon_items_RESTRICT_SELECT_ON = 256,	
		icon_items_RESTRICT_RENDER_OFF = 257,	
		icon_items_RESTRICT_RENDER_ON = 258,	
		icon_items_OUTLINER_DATA_EMPTY = 260,	
		icon_items_OUTLINER_DATA_MESH = 261,	
		icon_items_OUTLINER_DATA_CURVE = 262,	
		icon_items_OUTLINER_DATA_LATTICE = 263,	
		icon_items_OUTLINER_DATA_META = 264,	
		icon_items_OUTLINER_DATA_LAMP = 265,	
		icon_items_OUTLINER_DATA_CAMERA = 266,	
		icon_items_OUTLINER_DATA_ARMATURE = 267,	
		icon_items_OUTLINER_DATA_FONT = 268,	
		icon_items_OUTLINER_DATA_SURFACE = 269,	
		icon_items_OUTLINER_DATA_SPEAKER = 270,	
		icon_items_OUTLINER_DATA_POSE = 271,	
		icon_items_MESH_PLANE = 286,	
		icon_items_MESH_CUBE = 287,	
		icon_items_MESH_CIRCLE = 288,	
		icon_items_MESH_UVSPHERE = 289,	
		icon_items_MESH_ICOSPHERE = 290,	
		icon_items_MESH_GRID = 291,	
		icon_items_MESH_MONKEY = 292,	
		icon_items_MESH_CYLINDER = 293,	
		icon_items_MESH_TORUS = 294,	
		icon_items_MESH_CONE = 295,	
		icon_items_LAMP_POINT = 298,	
		icon_items_LAMP_SUN = 299,	
		icon_items_LAMP_SPOT = 300,	
		icon_items_LAMP_HEMI = 301,	
		icon_items_LAMP_AREA = 302,	
		icon_items_META_EMPTY = 305,	
		icon_items_META_PLANE = 306,	
		icon_items_META_CUBE = 307,	
		icon_items_META_BALL = 308,	
		icon_items_META_ELLIPSOID = 309,	
		icon_items_META_CAPSULE = 310,	
		icon_items_SURFACE_NCURVE = 312,	
		icon_items_SURFACE_NCIRCLE = 313,	
		icon_items_SURFACE_NSURFACE = 314,	
		icon_items_SURFACE_NCYLINDER = 315,	
		icon_items_SURFACE_NSPHERE = 316,	
		icon_items_SURFACE_NTORUS = 317,	
		icon_items_CURVE_BEZCURVE = 321,	
		icon_items_CURVE_BEZCIRCLE = 322,	
		icon_items_CURVE_NCURVE = 323,	
		icon_items_CURVE_NCIRCLE = 324,	
		icon_items_CURVE_PATH = 325,	
		icon_items_COLOR_RED = 331,	
		icon_items_COLOR_GREEN = 332,	
		icon_items_COLOR_BLUE = 333,	
		icon_items_TRIA_RIGHT_BAR = 334,	
		icon_items_TRIA_DOWN_BAR = 335,	
		icon_items_TRIA_LEFT_BAR = 336,	
		icon_items_TRIA_UP_BAR = 337,	
		icon_items_FORCE_FORCE = 338,	
		icon_items_FORCE_WIND = 339,	
		icon_items_FORCE_VORTEX = 340,	
		icon_items_FORCE_MAGNETIC = 341,	
		icon_items_FORCE_HARMONIC = 342,	
		icon_items_FORCE_CHARGE = 343,	
		icon_items_FORCE_LENNARDJONES = 344,	
		icon_items_FORCE_TEXTURE = 345,	
		icon_items_FORCE_CURVE = 346,	
		icon_items_FORCE_BOID = 347,	
		icon_items_FORCE_TURBULENCE = 348,	
		icon_items_FORCE_DRAG = 349,	
		icon_items_FORCE_SMOKEFLOW = 350,	
		icon_items_MODIFIER = 442,	
		icon_items_MOD_WAVE = 443,	
		icon_items_MOD_BUILD = 444,	
		icon_items_MOD_DECIM = 445,	
		icon_items_MOD_MIRROR = 446,	
		icon_items_MOD_SOFT = 447,	
		icon_items_MOD_SUBSURF = 448,	
		icon_items_HOOK = 449,	
		icon_items_MOD_PHYSICS = 450,	
		icon_items_MOD_PARTICLES = 451,	
		icon_items_MOD_BOOLEAN = 452,	
		icon_items_MOD_EDGESPLIT = 453,	
		icon_items_MOD_ARRAY = 454,	
		icon_items_MOD_UVPROJECT = 455,	
		icon_items_MOD_DISPLACE = 456,	
		icon_items_MOD_CURVE = 457,	
		icon_items_MOD_LATTICE = 458,	
		icon_items_CONSTRAINT_DATA = 459,	
		icon_items_MOD_ARMATURE = 460,	
		icon_items_MOD_SHRINKWRAP = 461,	
		icon_items_MOD_CAST = 462,	
		icon_items_MOD_MESHDEFORM = 463,	
		icon_items_MOD_BEVEL = 464,	
		icon_items_MOD_SMOOTH = 465,	
		icon_items_MOD_SIMPLEDEFORM = 466,	
		icon_items_MOD_MASK = 467,	
		icon_items_MOD_CLOTH = 468,	
		icon_items_MOD_EXPLODE = 469,	
		icon_items_MOD_FLUIDSIM = 470,	
		icon_items_MOD_MULTIRES = 471,	
		icon_items_MOD_SMOKE = 472,	
		icon_items_MOD_SOLIDIFY = 473,	
		icon_items_MOD_SCREW = 474,	
		icon_items_MOD_VERTEX_WEIGHT = 475,	
		icon_items_MOD_DYNAMICPAINT = 476,	
		icon_items_MOD_REMESH = 477,	
		icon_items_MOD_OCEAN = 478,	
		icon_items_MOD_WARP = 479,	
		icon_items_MOD_SKIN = 480,	
		icon_items_MOD_TRIANGULATE = 481,	
		icon_items_MOD_WIREFRAME = 482,	
		icon_items_MOD_DATA_TRANSFER = 483,	
		icon_items_MOD_NORMALEDIT = 484,	
		icon_items_REC = 494,	
		icon_items_PLAY = 495,	
		icon_items_FF = 496,	
		icon_items_REW = 497,	
		icon_items_PAUSE = 498,	
		icon_items_PREV_KEYFRAME = 499,	
		icon_items_NEXT_KEYFRAME = 500,	
		icon_items_PLAY_AUDIO = 501,	
		icon_items_PLAY_REVERSE = 502,	
		icon_items_PREVIEW_RANGE = 503,	
		icon_items_ACTION_TWEAK = 504,	
		icon_items_PMARKER_ACT = 505,	
		icon_items_PMARKER_SEL = 506,	
		icon_items_PMARKER = 507,	
		icon_items_MARKER_HLT = 508,	
		icon_items_MARKER = 509,	
		icon_items_SPACE2 = 510,	
		icon_items_SPACE3 = 511,	
		icon_items_KEYINGSET = 512,	
		icon_items_KEY_DEHLT = 513,	
		icon_items_KEY_HLT = 514,	
		icon_items_MUTE_IPO_OFF = 515,	
		icon_items_MUTE_IPO_ON = 516,	
		icon_items_VISIBLE_IPO_OFF = 517,	
		icon_items_VISIBLE_IPO_ON = 518,	
		icon_items_DRIVER = 519,	
		icon_items_SOLO_OFF = 520,	
		icon_items_SOLO_ON = 521,	
		icon_items_FRAME_PREV = 522,	
		icon_items_FRAME_NEXT = 523,	
		icon_items_NLA_PUSHDOWN = 524,	
		icon_items_IPO_CONSTANT = 525,	
		icon_items_IPO_LINEAR = 526,	
		icon_items_IPO_BEZIER = 527,	
		icon_items_IPO_SINE = 528,	
		icon_items_IPO_QUAD = 529,	
		icon_items_IPO_CUBIC = 530,	
		icon_items_IPO_QUART = 531,	
		icon_items_IPO_QUINT = 532,	
		icon_items_IPO_EXPO = 533,	
		icon_items_IPO_CIRC = 534,	
		icon_items_IPO_BOUNCE = 535,	
		icon_items_IPO_ELASTIC = 536,	
		icon_items_IPO_BACK = 537,	
		icon_items_IPO_EASE_IN = 538,	
		icon_items_IPO_EASE_OUT = 539,	
		icon_items_IPO_EASE_IN_OUT = 540,	
		icon_items_VERTEXSEL = 546,	
		icon_items_EDGESEL = 547,	
		icon_items_FACESEL = 548,	
		icon_items_LOOPSEL = 549,	
		icon_items_ROTATE = 551,	
		icon_items_CURSOR = 552,	
		icon_items_ROTATECOLLECTION = 553,	
		icon_items_ROTATECENTER = 554,	
		icon_items_ROTACTIVE = 555,	
		icon_items_ALIGN = 556,	
		icon_items_SMOOTHCURVE = 558,	
		icon_items_SPHERECURVE = 559,	
		icon_items_ROOTCURVE = 560,	
		icon_items_SHARPCURVE = 561,	
		icon_items_LINCURVE = 562,	
		icon_items_NOCURVE = 563,	
		icon_items_RNDCURVE = 564,	
		icon_items_PROP_OFF = 565,	
		icon_items_PROP_ON = 566,	
		icon_items_PROP_CON = 567,	
		icon_items_SCULPT_DYNTOPO = 568,	
		icon_items_PARTICLE_POINT = 569,	
		icon_items_PARTICLE_TIP = 570,	
		icon_items_PARTICLE_PATH = 571,	
		icon_items_MAN_TRANS = 572,	
		icon_items_MAN_ROT = 573,	
		icon_items_MAN_SCALE = 574,	
		icon_items_MANIPUL = 575,	
		icon_items_SNAP_OFF = 576,	
		icon_items_SNAP_ON = 577,	
		icon_items_SNAP_NORMAL = 578,	
		icon_items_SNAP_INCREMENT = 579,	
		icon_items_SNAP_VERTEX = 580,	
		icon_items_SNAP_EDGE = 581,	
		icon_items_SNAP_FACE = 582,	
		icon_items_SNAP_VOLUME = 583,	
		icon_items_STICKY_UVS_LOC = 585,	
		icon_items_STICKY_UVS_DISABLE = 586,	
		icon_items_STICKY_UVS_VERT = 587,	
		icon_items_CLIPUV_DEHLT = 588,	
		icon_items_CLIPUV_HLT = 589,	
		icon_items_SNAP_PEEL_OBJECT = 590,	
		icon_items_GRID = 591,	
		icon_items_PASTEDOWN = 598,	
		icon_items_COPYDOWN = 599,	
		icon_items_PASTEFLIPUP = 600,	
		icon_items_PASTEFLIPDOWN = 601,	
		icon_items_SNAP_SURFACE = 606,	
		icon_items_AUTOMERGE_ON = 607,	
		icon_items_AUTOMERGE_OFF = 608,	
		icon_items_RETOPO = 609,	
		icon_items_UV_VERTEXSEL = 610,	
		icon_items_UV_EDGESEL = 611,	
		icon_items_UV_FACESEL = 612,	
		icon_items_UV_ISLANDSEL = 613,	
		icon_items_UV_SYNC_SELECT = 614,	
		icon_items_BBOX = 624,	
		icon_items_WIRE = 625,	
		icon_items_SOLID = 626,	
		icon_items_SMOOTH = 627,	
		icon_items_POTATO = 628,	
		icon_items_ORTHO = 630,	
		icon_items_LOCKVIEW_OFF = 633,	
		icon_items_LOCKVIEW_ON = 634,	
		icon_items_AXIS_SIDE = 636,	
		icon_items_AXIS_FRONT = 637,	
		icon_items_AXIS_TOP = 638,	
		icon_items_NDOF_DOM = 639,	
		icon_items_NDOF_TURN = 640,	
		icon_items_NDOF_FLY = 641,	
		icon_items_NDOF_TRANS = 642,	
		icon_items_LAYER_USED = 643,	
		icon_items_LAYER_ACTIVE = 644,	
		icon_items_SORTALPHA = 676,	
		icon_items_SORTBYEXT = 677,	
		icon_items_SORTTIME = 678,	
		icon_items_SORTSIZE = 679,	
		icon_items_LONGDISPLAY = 680,	
		icon_items_SHORTDISPLAY = 681,	
		icon_items_GHOST = 682,	
		icon_items_IMGDISPLAY = 683,	
		icon_items_SAVE_AS = 684,	
		icon_items_SAVE_COPY = 685,	
		icon_items_BOOKMARKS = 686,	
		icon_items_FONTPREVIEW = 687,	
		icon_items_FILTER = 688,	
		icon_items_NEWFOLDER = 689,	
		icon_items_OPEN_RECENT = 690,	
		icon_items_FILE_PARENT = 691,	
		icon_items_FILE_REFRESH = 692,	
		icon_items_FILE_FOLDER = 693,	
		icon_items_FILE_BLANK = 694,	
		icon_items_FILE_BLEND = 695,	
		icon_items_FILE_IMAGE = 696,	
		icon_items_FILE_MOVIE = 697,	
		icon_items_FILE_SCRIPT = 698,	
		icon_items_FILE_SOUND = 699,	
		icon_items_FILE_FONT = 700,	
		icon_items_FILE_TEXT = 701,	
		icon_items_RECOVER_AUTO = 702,	
		icon_items_SAVE_PREFS = 703,	
		icon_items_LINK_BLEND = 704,	
		icon_items_APPEND_BLEND = 705,	
		icon_items_IMPORT = 706,	
		icon_items_EXPORT = 707,	
		icon_items_EXTERNAL_DATA = 708,	
		icon_items_LOAD_FACTORY = 709,	
		icon_items_LOOP_BACK = 715,	
		icon_items_LOOP_FORWARDS = 716,	
		icon_items_BACK = 717,	
		icon_items_FORWARD = 718,	
		icon_items_FILE_HIDDEN = 725,	
		icon_items_FILE_BACKUP = 726,	
		icon_items_DISK_DRIVE = 727,	
		icon_items_MATPLANE = 728,	
		icon_items_MATSPHERE = 729,	
		icon_items_MATCUBE = 730,	
		icon_items_MONKEY = 731,	
		icon_items_HAIR = 732,	
		icon_items_ALIASED = 733,	
		icon_items_ANTIALIASED = 734,	
		icon_items_MAT_SPHERE_SKY = 735,	
		icon_items_WORDWRAP_OFF = 740,	
		icon_items_WORDWRAP_ON = 741,	
		icon_items_SYNTAX_OFF = 742,	
		icon_items_SYNTAX_ON = 743,	
		icon_items_LINENUMBERS_OFF = 744,	
		icon_items_LINENUMBERS_ON = 745,	
		icon_items_SCRIPTPLUGINS = 746,	
		icon_items_SEQ_SEQUENCER = 754,	
		icon_items_SEQ_PREVIEW = 755,	
		icon_items_SEQ_LUMA_WAVEFORM = 756,	
		icon_items_SEQ_CHROMA_SCOPE = 757,	
		icon_items_SEQ_HISTOGRAM = 758,	
		icon_items_SEQ_SPLITVIEW = 759,	
		icon_items_IMAGE_RGB = 763,	
		icon_items_IMAGE_RGB_ALPHA = 764,	
		icon_items_IMAGE_ALPHA = 765,	
		icon_items_IMAGE_ZDEPTH = 766,	
		icon_items_IMAGEFILE = 767,	
		icon_items_BRUSH_ADD = 780,	
		icon_items_BRUSH_BLOB = 781,	
		icon_items_BRUSH_BLUR = 782,	
		icon_items_BRUSH_CLAY = 783,	
		icon_items_BRUSH_CLAY_STRIPS = 784,	
		icon_items_BRUSH_CLONE = 785,	
		icon_items_BRUSH_CREASE = 786,	
		icon_items_BRUSH_DARKEN = 787,	
		icon_items_BRUSH_FILL = 788,	
		icon_items_BRUSH_FLATTEN = 789,	
		icon_items_BRUSH_GRAB = 790,	
		icon_items_BRUSH_INFLATE = 791,	
		icon_items_BRUSH_LAYER = 792,	
		icon_items_BRUSH_LIGHTEN = 793,	
		icon_items_BRUSH_MASK = 794,	
		icon_items_BRUSH_MIX = 795,	
		icon_items_BRUSH_MULTIPLY = 796,	
		icon_items_BRUSH_NUDGE = 797,	
		icon_items_BRUSH_PINCH = 798,	
		icon_items_BRUSH_SCRAPE = 799,	
		icon_items_BRUSH_SCULPT_DRAW = 800,	
		icon_items_BRUSH_SMEAR = 801,	
		icon_items_BRUSH_SMOOTH = 802,	
		icon_items_BRUSH_SNAKE_HOOK = 803,	
		icon_items_BRUSH_SOFTEN = 804,	
		icon_items_BRUSH_SUBTRACT = 805,	
		icon_items_BRUSH_TEXDRAW = 806,	
		icon_items_BRUSH_TEXFILL = 807,	
		icon_items_BRUSH_TEXMASK = 808,	
		icon_items_BRUSH_THUMB = 809,	
		icon_items_BRUSH_ROTATE = 810,	
		icon_items_BRUSH_VERTEXDRAW = 811,	
		icon_items_MATCAP_01 = 812,	
		icon_items_MATCAP_02 = 813,	
		icon_items_MATCAP_03 = 814,	
		icon_items_MATCAP_04 = 815,	
		icon_items_MATCAP_05 = 816,	
		icon_items_MATCAP_06 = 817,	
		icon_items_MATCAP_07 = 818,	
		icon_items_MATCAP_08 = 819,	
		icon_items_MATCAP_09 = 820,	
		icon_items_MATCAP_10 = 821,	
		icon_items_MATCAP_11 = 822,	
		icon_items_MATCAP_12 = 823,	
		icon_items_MATCAP_13 = 824,	
		icon_items_MATCAP_14 = 825,	
		icon_items_MATCAP_15 = 826,	
		icon_items_MATCAP_16 = 827,	
		icon_items_MATCAP_17 = 828,	
		icon_items_MATCAP_18 = 829,	
		icon_items_MATCAP_19 = 830,	
		icon_items_MATCAP_20 = 831,	
		icon_items_MATCAP_21 = 832,	
		icon_items_MATCAP_22 = 833,	
		icon_items_MATCAP_23 = 834,	
		icon_items_MATCAP_24 = 835,	
		icon_items_VIEW3D_VEC = 836,	
		icon_items_EDIT_VEC = 837,	
		icon_items_EDITMODE_VEC_DEHLT = 838,	
		icon_items_EDITMODE_VEC_HLT = 839,	
		icon_items_DISCLOSURE_TRI_RIGHT_VEC = 840,	
		icon_items_DISCLOSURE_TRI_DOWN_VEC = 841,	
		icon_items_MOVE_UP_VEC = 842,	
		icon_items_MOVE_DOWN_VEC = 843,	
		icon_items_X_VEC = 844,	
		icon_items_SMALL_TRI_RIGHT_VEC = 845	
	};

	/**
	 * Function: pupmenu_begin__internal
	 * @param Param 'title'
	 * @param Param 'icon'
	 * @return 
	 */
	UIPopupMenu pupmenu_begin__internal(const std::string title, icon_items icon = icon_items_NONE)
	{
		// not implemented
		return UIPopupMenu();
	}

	/**
	 * Function: pupmenu_end__internal
	 * @param Param 'menu'
	 */
	void pupmenu_end__internal(UIPopupMenu menu)
	{
		// not implemented
	}

	/**
	 * Function: piemenu_begin__internal
	 * @param Param 'title'
	 * @param Param 'icon'
	 * @param Param 'event'
	 * @return 
	 */
	UIPieMenu piemenu_begin__internal(const std::string title, icon_items icon, Event event)
	{
		// not implemented
		return UIPieMenu();
	}

	/**
	 * Function: piemenu_end__internal
	 * @param Param 'menu'
	 */
	void piemenu_end__internal(UIPieMenu menu)
	{
		// not implemented
	}

};

/**************** Key Configuration ****************/

/**
 * Input configuration, including keymaps
 */
class KeyConfig : public pyUniplug {
public:
	KeyConfig(PyObject* pyobj) : pyUniplug(pyobj) {}

	KeyConfig() : pyUniplug(0)
	{
		// not implemented
	}

	/** Getter: Name of the key configuration */
	std::string name() { /* not implemented */ throw NULL; }
	/** Setter: Name of the key configuration */
	void name(const std::string& value) { /* not implemented */ }

	/** Getter: Key maps configured as part of this configuration */
	std::map<std::string, KeyMap> keymaps();
	/** Setter: Key maps configured as part of this configuration */
	void keymaps(std::map<std::string, KeyMap> value);

	/** Getter: Indicates that a keyconfig was defined by the user */
	bool is_user_defined() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "is_user_defined")) == 1;
	}

	/** Setter: Indicates that a keyconfig was defined by the user */
	void is_user_defined(bool value) {
		PyObject_SetAttrString(pyobjref, "is_user_defined", Py_BuildValue("i", value));
	}

};

/**************** Key Map ****************/

/**
 * Input configuration, including keymaps
 */
class KeyMap : public pyUniplug {
public:
	KeyMap(PyObject* pyobj) : pyUniplug(pyobj) {}

	KeyMap() : pyUniplug(0)
	{
		// not implemented
	}

	/** Getter: Name of the key map */
	std::string name() { /* not implemented */ throw NULL; }
	/** Setter: Name of the key map */
	void name(const std::string& value) { /* not implemented */ }

	enum space_type_enum {
		space_type_EMPTY = 0,
		space_type_VIEW_3D = 1,
		space_type_TIMELINE = 15,
		space_type_GRAPH_EDITOR = 2,
		space_type_DOPESHEET_EDITOR = 12,
		space_type_NLA_EDITOR = 13,
		space_type_IMAGE_EDITOR = 6,
		space_type_SEQUENCE_EDITOR = 8,
		space_type_CLIP_EDITOR = 20,
		space_type_TEXT_EDITOR = 9,
		space_type_NODE_EDITOR = 16,
		space_type_LOGIC_EDITOR = 17,
		space_type_PROPERTIES = 4,
		space_type_OUTLINER = 3,
		space_type_USER_PREFERENCES = 19,
		space_type_INFO = 7,
		space_type_FILE_BROWSER = 5,
		space_type_CONSOLE = 18,
	};

	/** Getter: Optional space type keymap is associated with */
	space_type_enum space_type() { /* not implemented */ throw NULL; }
	/** Setter: Optional space type keymap is associated with */
	void space_type(space_type_enum value) { /* not implemented */ }

	enum region_type_enum {
		region_type_WINDOW = 0,
		region_type_HEADER = 1,
		region_type_CHANNELS = 2,
		region_type_TEMPORARY = 3,
		region_type_UI = 4,
		region_type_TOOLS = 5,
		region_type_TOOL_PROPS = 6,
		region_type_PREVIEW = 7,
	};

	/** Getter: Optional region type keymap is associated with */
	region_type_enum region_type() { /* not implemented */ throw NULL; }
	/** Setter: Optional region type keymap is associated with */
	void region_type(region_type_enum value) { /* not implemented */ }

	/** Getter: Items in the keymap, linking an operator to an input event */
	std::map<std::string, KeyMapItem> keymap_items();
	/** Setter: Items in the keymap, linking an operator to an input event */
	void keymap_items(std::map<std::string, KeyMapItem> value);

	/** Getter: Keymap is defined by the user */
	bool is_user_modified() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "is_user_modified")) == 1;
	}

	/** Setter: Keymap is defined by the user */
	void is_user_modified(bool value) {
		PyObject_SetAttrString(pyobjref, "is_user_modified", Py_BuildValue("i", value));
	}

	/** Getter: Indicates that a keymap is used for translate modal events for an operator */
	bool is_modal() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "is_modal")) == 1;
	}

	/** Setter: Indicates that a keymap is used for translate modal events for an operator */
	void is_modal(bool value) {
		PyObject_SetAttrString(pyobjref, "is_modal", Py_BuildValue("i", value));
	}

	/** Getter: Expanded in the user interface */
	bool show_expanded_items() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "show_expanded_items")) == 1;
	}

	/** Setter: Expanded in the user interface */
	void show_expanded_items(bool value) {
		PyObject_SetAttrString(pyobjref, "show_expanded_items", Py_BuildValue("i", value));
	}

	/** Getter: Children expanded in the user interface */
	bool show_expanded_children() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "show_expanded_children")) == 1;
	}

	/** Setter: Children expanded in the user interface */
	void show_expanded_children(bool value) {
		PyObject_SetAttrString(pyobjref, "show_expanded_children", Py_BuildValue("i", value));
	}

	/**
	 * Function: active
	 * @return Active key map
	 */
	KeyMap active()
	{
		// not implemented
		return KeyMap();
	}

	/**
	 * Function: restore_to_default
	 */
	void restore_to_default()
	{
		// not implemented
	}

	/**
	 * Function: restore_item_to_default
	 * @param Param 'item'
	 */
	void restore_item_to_default(KeyMapItem item);

};

/**************** Key Map Item ****************/

/**
 * Item in a Key Map
 */
class KeyMapItem : public pyUniplug {
public:
	KeyMapItem(PyObject* pyobj) : pyUniplug(pyobj) {}

	KeyMapItem() : pyUniplug(0)
	{
		// not implemented
	}

	/** Getter: Identifier of operator to call on input event */
	std::string idname() { /* not implemented */ throw NULL; }
	/** Setter: Identifier of operator to call on input event */
	void idname(const std::string& value) { /* not implemented */ }

	/** Getter: Name of operator (translated) to call on input event */
	std::string name() { /* not implemented */ throw NULL; }
	/** Setter: Name of operator (translated) to call on input event */
	void name(const std::string& value) { /* not implemented */ }

	/** Getter: Properties to set when the operator is called */
	OperatorProperties properties() {
		/* not implemented */ throw NULL;
	}

	enum map_type_enum {
		map_type_KEYBOARD = 0,
		map_type_TWEAK = 2,
		map_type_MOUSE = 1,
		map_type_NDOF = 5,
		map_type_TEXTINPUT = 3,
		map_type_TIMER = 4,
	};

	/** Getter: Type of event mapping */
	map_type_enum map_type() { /* not implemented */ throw NULL; }
	/** Setter: Type of event mapping */
	void map_type(map_type_enum value) { /* not implemented */ }

	enum type_enum {
		type_NONE = 0,
		type_LEFTMOUSE = 1,
		type_MIDDLEMOUSE = 2,
		type_RIGHTMOUSE = 3,
		type_BUTTON4MOUSE = 7,
		type_BUTTON5MOUSE = 8,
		type_BUTTON6MOUSE = 18,
		type_BUTTON7MOUSE = 19,
		type_ACTIONMOUSE = 5,
		type_SELECTMOUSE = 6,
		type_MOUSEMOVE = 4,
		type_INBETWEEN_MOUSEMOVE = 17,
		type_TRACKPADPAN = 14,
		type_TRACKPADZOOM = 15,
		type_MOUSEROTATE = 16,
		type_WHEELUPMOUSE = 10,
		type_WHEELDOWNMOUSE = 11,
		type_WHEELINMOUSE = 12,
		type_WHEELOUTMOUSE = 13,
		type_EVT_TWEAK_L = 20482,
		type_EVT_TWEAK_M = 20483,
		type_EVT_TWEAK_R = 20484,
		type_EVT_TWEAK_A = 20485,
		type_EVT_TWEAK_S = 20486,
		type_A = 97,
		type_B = 98,
		type_C = 99,
		type_D = 100,
		type_E = 101,
		type_F = 102,
		type_G = 103,
		type_H = 104,
		type_I = 105,
		type_J = 106,
		type_K = 107,
		type_L = 108,
		type_M = 109,
		type_N = 110,
		type_O = 111,
		type_P = 112,
		type_Q = 113,
		type_R = 114,
		type_S = 115,
		type_T = 116,
		type_U = 117,
		type_V = 118,
		type_W = 119,
		type_X = 120,
		type_Y = 121,
		type_Z = 122,
		type_ZERO = 48,
		type_ONE = 49,
		type_TWO = 50,
		type_THREE = 51,
		type_FOUR = 52,
		type_FIVE = 53,
		type_SIX = 54,
		type_SEVEN = 55,
		type_EIGHT = 56,
		type_NINE = 57,
		type_LEFT_CTRL = 212,
		type_LEFT_ALT = 213,
		type_LEFT_SHIFT = 217,
		type_RIGHT_ALT = 214,
		type_RIGHT_CTRL = 215,
		type_RIGHT_SHIFT = 216,
		type_OSKEY = 172,
		type_GRLESS = 173,
		type_ESC = 218,
		type_TAB = 219,
		type_RET = 220,
		type_SPACE = 221,
		type_LINE_FEED = 222,
		type_BACK_SPACE = 223,
		type_DEL = 224,
		type_SEMI_COLON = 225,
		type_PERIOD = 226,
		type_COMMA = 227,
		type_QUOTE = 228,
		type_ACCENT_GRAVE = 229,
		type_MINUS = 230,
		type_SLASH = 232,
		type_BACK_SLASH = 233,
		type_EQUAL = 234,
		type_LEFT_BRACKET = 235,
		type_RIGHT_BRACKET = 236,
		type_LEFT_ARROW = 137,
		type_DOWN_ARROW = 138,
		type_RIGHT_ARROW = 139,
		type_UP_ARROW = 140,
		type_NUMPAD_2 = 152,
		type_NUMPAD_4 = 154,
		type_NUMPAD_6 = 156,
		type_NUMPAD_8 = 158,
		type_NUMPAD_1 = 151,
		type_NUMPAD_3 = 153,
		type_NUMPAD_5 = 155,
		type_NUMPAD_7 = 157,
		type_NUMPAD_9 = 159,
		type_NUMPAD_PERIOD = 199,
		type_NUMPAD_SLASH = 161,
		type_NUMPAD_ASTERIX = 160,
		type_NUMPAD_0 = 150,
		type_NUMPAD_MINUS = 162,
		type_NUMPAD_ENTER = 163,
		type_NUMPAD_PLUS = 164,
		type_F1 = 300,
		type_F2 = 301,
		type_F3 = 302,
		type_F4 = 303,
		type_F5 = 304,
		type_F6 = 305,
		type_F7 = 306,
		type_F8 = 307,
		type_F9 = 308,
		type_F10 = 309,
		type_F11 = 310,
		type_F12 = 311,
		type_F13 = 312,
		type_F14 = 313,
		type_F15 = 314,
		type_F16 = 315,
		type_F17 = 316,
		type_F18 = 317,
		type_F19 = 318,
		type_PAUSE = 165,
		type_INSERT = 166,
		type_HOME = 167,
		type_PAGE_UP = 168,
		type_PAGE_DOWN = 169,
		type_END = 170,
		type_MEDIA_PLAY = 174,
		type_MEDIA_STOP = 175,
		type_MEDIA_FIRST = 176,
		type_MEDIA_LAST = 177,
		type_TEXTINPUT = -2,
		type_WINDOW_DEACTIVATE = 260,
		type_TIMER = 272,
		type_TIMER0 = 273,
		type_TIMER1 = 274,
		type_TIMER2 = 275,
		type_TIMER_JOBS = 276,
		type_TIMER_AUTOSAVE = 277,
		type_TIMER_REPORT = 278,
		type_TIMERREGION = 279,
		type_NDOF_MOTION = 400,
		type_NDOF_BUTTON_MENU = 401,
		type_NDOF_BUTTON_FIT = 402,
		type_NDOF_BUTTON_TOP = 403,
		type_NDOF_BUTTON_BOTTOM = 404,
		type_NDOF_BUTTON_LEFT = 405,
		type_NDOF_BUTTON_RIGHT = 406,
		type_NDOF_BUTTON_FRONT = 407,
		type_NDOF_BUTTON_BACK = 408,
		type_NDOF_BUTTON_ISO1 = 409,
		type_NDOF_BUTTON_ISO2 = 410,
		type_NDOF_BUTTON_ROLL_CW = 411,
		type_NDOF_BUTTON_ROLL_CCW = 412,
		type_NDOF_BUTTON_SPIN_CW = 413,
		type_NDOF_BUTTON_SPIN_CCW = 414,
		type_NDOF_BUTTON_TILT_CW = 415,
		type_NDOF_BUTTON_TILT_CCW = 416,
		type_NDOF_BUTTON_ROTATE = 417,
		type_NDOF_BUTTON_PANZOOM = 418,
		type_NDOF_BUTTON_DOMINANT = 419,
		type_NDOF_BUTTON_PLUS = 420,
		type_NDOF_BUTTON_MINUS = 421,
		type_NDOF_BUTTON_ESC = 422,
		type_NDOF_BUTTON_ALT = 423,
		type_NDOF_BUTTON_SHIFT = 424,
		type_NDOF_BUTTON_CTRL = 425,
		type_NDOF_BUTTON_1 = 426,
		type_NDOF_BUTTON_2 = 427,
		type_NDOF_BUTTON_3 = 428,
		type_NDOF_BUTTON_4 = 429,
		type_NDOF_BUTTON_5 = 430,
		type_NDOF_BUTTON_6 = 431,
		type_NDOF_BUTTON_7 = 432,
		type_NDOF_BUTTON_8 = 433,
		type_NDOF_BUTTON_9 = 434,
		type_NDOF_BUTTON_10 = 435,
		type_NDOF_BUTTON_A = 436,
		type_NDOF_BUTTON_B = 437,
		type_NDOF_BUTTON_C = 438,
	};

	/** Getter: Type of event */
	type_enum type() { /* not implemented */ throw NULL; }
	/** Setter: Type of event */
	void type(type_enum value) { /* not implemented */ }

	enum value_enum {
		value_ANY = -1,
		value_NOTHING = 0,
		value_PRESS = 1,
		value_RELEASE = 2,
		value_CLICK = 3,
		value_DOUBLE_CLICK = 4,
		value_NORTH = 1,
		value_NORTH_EAST = 2,
		value_EAST = 3,
		value_SOUTH_EAST = 4,
		value_SOUTH = 5,
		value_SOUTH_WEST = 6,
		value_WEST = 7,
		value_NORTH_WEST = 8,
	};

	/** Getter:  */
	value_enum value() { /* not implemented */ throw NULL; }
	/** Setter:  */
	void value(value_enum value) { /* not implemented */ }

	/** Getter: ID of the item */
	int id() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "id"));
	}

	/** Setter: ID of the item */
	void id(int value) {
		PyObject_SetAttrString(pyobjref, "id", Py_BuildValue("i", value));
	}

	/** Getter: Any modifier keys pressed */
	bool any() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "any")) == 1;
	}

	/** Setter: Any modifier keys pressed */
	void any(bool value) {
		PyObject_SetAttrString(pyobjref, "any", Py_BuildValue("i", value));
	}

	/** Getter: Shift key pressed */
	bool shift() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "shift")) == 1;
	}

	/** Setter: Shift key pressed */
	void shift(bool value) {
		PyObject_SetAttrString(pyobjref, "shift", Py_BuildValue("i", value));
	}

	/** Getter: Control key pressed */
	bool ctrl() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "ctrl")) == 1;
	}

	/** Setter: Control key pressed */
	void ctrl(bool value) {
		PyObject_SetAttrString(pyobjref, "ctrl", Py_BuildValue("i", value));
	}

	/** Getter: Alt key pressed */
	bool alt() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "alt")) == 1;
	}

	/** Setter: Alt key pressed */
	void alt(bool value) {
		PyObject_SetAttrString(pyobjref, "alt", Py_BuildValue("i", value));
	}

	/** Getter: Operating system key pressed */
	bool oskey() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "oskey")) == 1;
	}

	/** Setter: Operating system key pressed */
	void oskey(bool value) {
		PyObject_SetAttrString(pyobjref, "oskey", Py_BuildValue("i", value));
	}

	enum key_modifier_enum {
		key_modifier_NONE = 0,
		key_modifier_LEFTMOUSE = 1,
		key_modifier_MIDDLEMOUSE = 2,
		key_modifier_RIGHTMOUSE = 3,
		key_modifier_BUTTON4MOUSE = 7,
		key_modifier_BUTTON5MOUSE = 8,
		key_modifier_BUTTON6MOUSE = 18,
		key_modifier_BUTTON7MOUSE = 19,
		key_modifier_ACTIONMOUSE = 5,
		key_modifier_SELECTMOUSE = 6,
		key_modifier_MOUSEMOVE = 4,
		key_modifier_INBETWEEN_MOUSEMOVE = 17,
		key_modifier_TRACKPADPAN = 14,
		key_modifier_TRACKPADZOOM = 15,
		key_modifier_MOUSEROTATE = 16,
		key_modifier_WHEELUPMOUSE = 10,
		key_modifier_WHEELDOWNMOUSE = 11,
		key_modifier_WHEELINMOUSE = 12,
		key_modifier_WHEELOUTMOUSE = 13,
		key_modifier_EVT_TWEAK_L = 20482,
		key_modifier_EVT_TWEAK_M = 20483,
		key_modifier_EVT_TWEAK_R = 20484,
		key_modifier_EVT_TWEAK_A = 20485,
		key_modifier_EVT_TWEAK_S = 20486,
		key_modifier_A = 97,
		key_modifier_B = 98,
		key_modifier_C = 99,
		key_modifier_D = 100,
		key_modifier_E = 101,
		key_modifier_F = 102,
		key_modifier_G = 103,
		key_modifier_H = 104,
		key_modifier_I = 105,
		key_modifier_J = 106,
		key_modifier_K = 107,
		key_modifier_L = 108,
		key_modifier_M = 109,
		key_modifier_N = 110,
		key_modifier_O = 111,
		key_modifier_P = 112,
		key_modifier_Q = 113,
		key_modifier_R = 114,
		key_modifier_S = 115,
		key_modifier_T = 116,
		key_modifier_U = 117,
		key_modifier_V = 118,
		key_modifier_W = 119,
		key_modifier_X = 120,
		key_modifier_Y = 121,
		key_modifier_Z = 122,
		key_modifier_ZERO = 48,
		key_modifier_ONE = 49,
		key_modifier_TWO = 50,
		key_modifier_THREE = 51,
		key_modifier_FOUR = 52,
		key_modifier_FIVE = 53,
		key_modifier_SIX = 54,
		key_modifier_SEVEN = 55,
		key_modifier_EIGHT = 56,
		key_modifier_NINE = 57,
		key_modifier_LEFT_CTRL = 212,
		key_modifier_LEFT_ALT = 213,
		key_modifier_LEFT_SHIFT = 217,
		key_modifier_RIGHT_ALT = 214,
		key_modifier_RIGHT_CTRL = 215,
		key_modifier_RIGHT_SHIFT = 216,
		key_modifier_OSKEY = 172,
		key_modifier_GRLESS = 173,
		key_modifier_ESC = 218,
		key_modifier_TAB = 219,
		key_modifier_RET = 220,
		key_modifier_SPACE = 221,
		key_modifier_LINE_FEED = 222,
		key_modifier_BACK_SPACE = 223,
		key_modifier_DEL = 224,
		key_modifier_SEMI_COLON = 225,
		key_modifier_PERIOD = 226,
		key_modifier_COMMA = 227,
		key_modifier_QUOTE = 228,
		key_modifier_ACCENT_GRAVE = 229,
		key_modifier_MINUS = 230,
		key_modifier_SLASH = 232,
		key_modifier_BACK_SLASH = 233,
		key_modifier_EQUAL = 234,
		key_modifier_LEFT_BRACKET = 235,
		key_modifier_RIGHT_BRACKET = 236,
		key_modifier_LEFT_ARROW = 137,
		key_modifier_DOWN_ARROW = 138,
		key_modifier_RIGHT_ARROW = 139,
		key_modifier_UP_ARROW = 140,
		key_modifier_NUMPAD_2 = 152,
		key_modifier_NUMPAD_4 = 154,
		key_modifier_NUMPAD_6 = 156,
		key_modifier_NUMPAD_8 = 158,
		key_modifier_NUMPAD_1 = 151,
		key_modifier_NUMPAD_3 = 153,
		key_modifier_NUMPAD_5 = 155,
		key_modifier_NUMPAD_7 = 157,
		key_modifier_NUMPAD_9 = 159,
		key_modifier_NUMPAD_PERIOD = 199,
		key_modifier_NUMPAD_SLASH = 161,
		key_modifier_NUMPAD_ASTERIX = 160,
		key_modifier_NUMPAD_0 = 150,
		key_modifier_NUMPAD_MINUS = 162,
		key_modifier_NUMPAD_ENTER = 163,
		key_modifier_NUMPAD_PLUS = 164,
		key_modifier_F1 = 300,
		key_modifier_F2 = 301,
		key_modifier_F3 = 302,
		key_modifier_F4 = 303,
		key_modifier_F5 = 304,
		key_modifier_F6 = 305,
		key_modifier_F7 = 306,
		key_modifier_F8 = 307,
		key_modifier_F9 = 308,
		key_modifier_F10 = 309,
		key_modifier_F11 = 310,
		key_modifier_F12 = 311,
		key_modifier_F13 = 312,
		key_modifier_F14 = 313,
		key_modifier_F15 = 314,
		key_modifier_F16 = 315,
		key_modifier_F17 = 316,
		key_modifier_F18 = 317,
		key_modifier_F19 = 318,
		key_modifier_PAUSE = 165,
		key_modifier_INSERT = 166,
		key_modifier_HOME = 167,
		key_modifier_PAGE_UP = 168,
		key_modifier_PAGE_DOWN = 169,
		key_modifier_END = 170,
		key_modifier_MEDIA_PLAY = 174,
		key_modifier_MEDIA_STOP = 175,
		key_modifier_MEDIA_FIRST = 176,
		key_modifier_MEDIA_LAST = 177,
		key_modifier_TEXTINPUT = -2,
		key_modifier_WINDOW_DEACTIVATE = 260,
		key_modifier_TIMER = 272,
		key_modifier_TIMER0 = 273,
		key_modifier_TIMER1 = 274,
		key_modifier_TIMER2 = 275,
		key_modifier_TIMER_JOBS = 276,
		key_modifier_TIMER_AUTOSAVE = 277,
		key_modifier_TIMER_REPORT = 278,
		key_modifier_TIMERREGION = 279,
		key_modifier_NDOF_MOTION = 400,
		key_modifier_NDOF_BUTTON_MENU = 401,
		key_modifier_NDOF_BUTTON_FIT = 402,
		key_modifier_NDOF_BUTTON_TOP = 403,
		key_modifier_NDOF_BUTTON_BOTTOM = 404,
		key_modifier_NDOF_BUTTON_LEFT = 405,
		key_modifier_NDOF_BUTTON_RIGHT = 406,
		key_modifier_NDOF_BUTTON_FRONT = 407,
		key_modifier_NDOF_BUTTON_BACK = 408,
		key_modifier_NDOF_BUTTON_ISO1 = 409,
		key_modifier_NDOF_BUTTON_ISO2 = 410,
		key_modifier_NDOF_BUTTON_ROLL_CW = 411,
		key_modifier_NDOF_BUTTON_ROLL_CCW = 412,
		key_modifier_NDOF_BUTTON_SPIN_CW = 413,
		key_modifier_NDOF_BUTTON_SPIN_CCW = 414,
		key_modifier_NDOF_BUTTON_TILT_CW = 415,
		key_modifier_NDOF_BUTTON_TILT_CCW = 416,
		key_modifier_NDOF_BUTTON_ROTATE = 417,
		key_modifier_NDOF_BUTTON_PANZOOM = 418,
		key_modifier_NDOF_BUTTON_DOMINANT = 419,
		key_modifier_NDOF_BUTTON_PLUS = 420,
		key_modifier_NDOF_BUTTON_MINUS = 421,
		key_modifier_NDOF_BUTTON_ESC = 422,
		key_modifier_NDOF_BUTTON_ALT = 423,
		key_modifier_NDOF_BUTTON_SHIFT = 424,
		key_modifier_NDOF_BUTTON_CTRL = 425,
		key_modifier_NDOF_BUTTON_1 = 426,
		key_modifier_NDOF_BUTTON_2 = 427,
		key_modifier_NDOF_BUTTON_3 = 428,
		key_modifier_NDOF_BUTTON_4 = 429,
		key_modifier_NDOF_BUTTON_5 = 430,
		key_modifier_NDOF_BUTTON_6 = 431,
		key_modifier_NDOF_BUTTON_7 = 432,
		key_modifier_NDOF_BUTTON_8 = 433,
		key_modifier_NDOF_BUTTON_9 = 434,
		key_modifier_NDOF_BUTTON_10 = 435,
		key_modifier_NDOF_BUTTON_A = 436,
		key_modifier_NDOF_BUTTON_B = 437,
		key_modifier_NDOF_BUTTON_C = 438,
	};

	/** Getter: Regular key pressed as a modifier */
	key_modifier_enum key_modifier() { /* not implemented */ throw NULL; }
	/** Setter: Regular key pressed as a modifier */
	void key_modifier(key_modifier_enum value) { /* not implemented */ }

	/** Getter: Show key map event and property details in the user interface */
	bool show_expanded() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "show_expanded")) == 1;
	}

	/** Setter: Show key map event and property details in the user interface */
	void show_expanded(bool value) {
		PyObject_SetAttrString(pyobjref, "show_expanded", Py_BuildValue("i", value));
	}

	enum propvalue_enum {
		propvalue_NONE = 0,
	};

	/** Getter: The value this event translates to in a modal keymap */
	propvalue_enum propvalue() { /* not implemented */ throw NULL; }
	/** Setter: The value this event translates to in a modal keymap */
	void propvalue(propvalue_enum value) { /* not implemented */ }

	/** Getter: Activate or deactivate item */
	bool active() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "active")) == 1;
	}

	/** Setter: Activate or deactivate item */
	void active(bool value) {
		PyObject_SetAttrString(pyobjref, "active", Py_BuildValue("i", value));
	}

	/** Getter: Is this keymap item modified by the user */
	bool is_user_modified() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "is_user_modified")) == 1;
	}

	/** Setter: Is this keymap item modified by the user */
	void is_user_modified(bool value) {
		PyObject_SetAttrString(pyobjref, "is_user_modified", Py_BuildValue("i", value));
	}

	/** Getter: Is this keymap item user defined (doesn't just replace a builtin item) */
	bool is_user_defined() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "is_user_defined")) == 1;
	}

	/** Setter: Is this keymap item user defined (doesn't just replace a builtin item) */
	void is_user_defined(bool value) {
		PyObject_SetAttrString(pyobjref, "is_user_defined", Py_BuildValue("i", value));
	}

	/**
	 * Function: compare
	 * @param Param 'item'
	 * @return 
	 */
	bool compare(KeyMapItem item)
	{
		// not implemented
		return true;
	}

};

/**************** World ****************/

/**
 * World datablock describing the environment and ambient lighting of a scene
 */
class World : public ID {
public:
	World(PyObject* pyobj) : ID(pyobj) {}

	World() : ID(0)
	{
		// not implemented
	}

	/** Getter: Animation data for this datablock */
	AnimData animation_data() {
		/* not implemented */ throw NULL;
	}

	/** Getter: Texture slots defining the mapping and influence of textures */
	std::map<std::string, WorldTextureSlot> texture_slots();
	/** Setter: Texture slots defining the mapping and influence of textures */
	void texture_slots(std::map<std::string, WorldTextureSlot> value);

	/** Getter: Active texture slot being displayed */
	Texture active_texture() {
		/* not implemented */ throw NULL;
	}

	/** Getter: Index of active texture slot */
	int active_texture_index() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "active_texture_index"));
	}

	/** Setter: Index of active texture slot */
	void active_texture_index(int value) {
		PyObject_SetAttrString(pyobjref, "active_texture_index", Py_BuildValue("i", value));
	}

	/** Getter: Color at the horizon */
	std::array<float, 3> horizon_color() {
		// TODO: MISSING DEREF! USE #DEFINE!
		PyObject *seqval = PyObject_GetAttrString(pyobjref, "horizon_color");
		std::array<float, 3> resarr;
		for (int i = 0; i < 3; i++)
			resarr[i] = (float)PyFloat_AsDouble(PySequence_GetItem(seqval, i));
		return resarr;
	}

	/** Setter: Color at the horizon */
	void horizon_color(float values[3]) { /* not implemented */ }

	/** Getter: Color at the zenith */
	std::array<float, 3> zenith_color() {
		// TODO: MISSING DEREF! USE #DEFINE!
		PyObject *seqval = PyObject_GetAttrString(pyobjref, "zenith_color");
		std::array<float, 3> resarr;
		for (int i = 0; i < 3; i++)
			resarr[i] = (float)PyFloat_AsDouble(PySequence_GetItem(seqval, i));
		return resarr;
	}

	/** Setter: Color at the zenith */
	void zenith_color(float values[3]) { /* not implemented */ }

	/** Getter: Ambient color of the world */
	std::array<float, 3> ambient_color() {
		// TODO: MISSING DEREF! USE #DEFINE!
		PyObject *seqval = PyObject_GetAttrString(pyobjref, "ambient_color");
		std::array<float, 3> resarr;
		for (int i = 0; i < 3; i++)
			resarr[i] = (float)PyFloat_AsDouble(PySequence_GetItem(seqval, i));
		return resarr;
	}

	/** Setter: Ambient color of the world */
	void ambient_color(float values[3]) { /* not implemented */ }

	/** Getter: Amount of exponential color correction for light */
	float exposure() { /* not implemented */ throw NULL; }
	/** Setter: Amount of exponential color correction for light */
	void exposure(float value) {
		PyObject_SetAttrString(pyobjref, "exposure", Py_BuildValue("f", value));
	}

	/** Getter: The color range that will be mapped to 0-1 */
	float color_range() { /* not implemented */ throw NULL; }
	/** Setter: The color range that will be mapped to 0-1 */
	void color_range(float value) {
		PyObject_SetAttrString(pyobjref, "color_range", Py_BuildValue("f", value));
	}

	/** Getter: Render background with natural progression from horizon to zenith */
	bool use_sky_blend() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_sky_blend")) == 1;
	}

	/** Setter: Render background with natural progression from horizon to zenith */
	void use_sky_blend(bool value) {
		PyObject_SetAttrString(pyobjref, "use_sky_blend", Py_BuildValue("i", value));
	}

	/** Getter: Flatten blend or texture coordinates */
	bool use_sky_paper() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_sky_paper")) == 1;
	}

	/** Setter: Flatten blend or texture coordinates */
	void use_sky_paper(bool value) {
		PyObject_SetAttrString(pyobjref, "use_sky_paper", Py_BuildValue("i", value));
	}

	/** Getter: Render background with a real horizon, relative to the camera angle */
	bool use_sky_real() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_sky_real")) == 1;
	}

	/** Setter: Render background with a real horizon, relative to the camera angle */
	void use_sky_real(bool value) {
		PyObject_SetAttrString(pyobjref, "use_sky_real", Py_BuildValue("i", value));
	}

	/** Getter: World lighting settings */
	WorldLighting light_settings();

	/** Getter: World mist settings */
	WorldMistSettings mist_settings();

	/** Getter: Node tree for node based worlds */
	NodeTree node_tree() {
		/* not implemented */ throw NULL;
	}

	/** Getter: Use shader nodes to render the world */
	bool use_nodes() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_nodes")) == 1;
	}

	/** Setter: Use shader nodes to render the world */
	void use_nodes(bool value) {
		PyObject_SetAttrString(pyobjref, "use_nodes", Py_BuildValue("i", value));
	}

};

/**************** Lighting ****************/

/**
 * Lighting for a World datablock
 */
class WorldLighting : public pyUniplug {
public:
	WorldLighting(PyObject* pyobj) : pyUniplug(pyobj) {}

	WorldLighting() : pyUniplug(0)
	{
		// not implemented
	}

	/** Getter: Use Ambient Occlusion to add shadowing based on distance between objects */
	bool use_ambient_occlusion() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_ambient_occlusion")) == 1;
	}

	/** Setter: Use Ambient Occlusion to add shadowing based on distance between objects */
	void use_ambient_occlusion(bool value) {
		PyObject_SetAttrString(pyobjref, "use_ambient_occlusion", Py_BuildValue("i", value));
	}

	/** Getter: Factor for ambient occlusion blending */
	float ao_factor() { /* not implemented */ throw NULL; }
	/** Setter: Factor for ambient occlusion blending */
	void ao_factor(float value) {
		PyObject_SetAttrString(pyobjref, "ao_factor", Py_BuildValue("f", value));
	}

	enum ao_blend_type_enum {
		ao_blend_type_MULTIPLY = 3,
		ao_blend_type_ADD = 0,
	};

	/** Getter: Defines how AO mixes with material shading */
	ao_blend_type_enum ao_blend_type() { /* not implemented */ throw NULL; }
	/** Setter: Defines how AO mixes with material shading */
	void ao_blend_type(ao_blend_type_enum value) { /* not implemented */ }

	/** Getter: Add light coming from the environment */
	bool use_environment_light() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_environment_light")) == 1;
	}

	/** Setter: Add light coming from the environment */
	void use_environment_light(bool value) {
		PyObject_SetAttrString(pyobjref, "use_environment_light", Py_BuildValue("i", value));
	}

	/** Getter: Defines the strength of environment light */
	float environment_energy() { /* not implemented */ throw NULL; }
	/** Setter: Defines the strength of environment light */
	void environment_energy(float value) {
		PyObject_SetAttrString(pyobjref, "environment_energy", Py_BuildValue("f", value));
	}

	enum environment_color_enum {
		environment_color_PLAIN = 0,
		environment_color_SKY_COLOR = 1,
		environment_color_SKY_TEXTURE = 2,
	};

	/** Getter: Defines where the color of the environment light comes from */
	environment_color_enum environment_color() { /* not implemented */ throw NULL; }
	/** Setter: Defines where the color of the environment light comes from */
	void environment_color(environment_color_enum value) { /* not implemented */ }

	/** Getter: Add indirect light bouncing of surrounding objects */
	bool use_indirect_light() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_indirect_light")) == 1;
	}

	/** Setter: Add indirect light bouncing of surrounding objects */
	void use_indirect_light(bool value) {
		PyObject_SetAttrString(pyobjref, "use_indirect_light", Py_BuildValue("i", value));
	}

	/** Getter: Factor for how much surrounding objects contribute to light */
	float indirect_factor() { /* not implemented */ throw NULL; }
	/** Setter: Factor for how much surrounding objects contribute to light */
	void indirect_factor(float value) {
		PyObject_SetAttrString(pyobjref, "indirect_factor", Py_BuildValue("f", value));
	}

	/** Getter: Number of indirect diffuse light bounces */
	int indirect_bounces() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "indirect_bounces"));
	}

	/** Setter: Number of indirect diffuse light bounces */
	void indirect_bounces(int value) {
		PyObject_SetAttrString(pyobjref, "indirect_bounces", Py_BuildValue("i", value));
	}

	enum gather_method_enum {
		gather_method_RAYTRACE = 0,
		gather_method_APPROXIMATE = 1,
	};

	/** Getter:  */
	gather_method_enum gather_method() { /* not implemented */ throw NULL; }
	/** Setter:  */
	void gather_method(gather_method_enum value) { /* not implemented */ }

	/** Getter: Number of preprocessing passes to reduce over-occlusion */
	int passes() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "passes"));
	}

	/** Setter: Number of preprocessing passes to reduce over-occlusion */
	void passes(int value) {
		PyObject_SetAttrString(pyobjref, "passes", Py_BuildValue("i", value));
	}

	/** Getter: Length of rays, defines how far away other faces give occlusion effect */
	float distance() { /* not implemented */ throw NULL; }
	/** Setter: Length of rays, defines how far away other faces give occlusion effect */
	void distance(float value) {
		PyObject_SetAttrString(pyobjref, "distance", Py_BuildValue("f", value));
	}

	/** Getter: Attenuation falloff strength, the higher, the less influence distant objects have */
	float falloff_strength() { /* not implemented */ throw NULL; }
	/** Setter: Attenuation falloff strength, the higher, the less influence distant objects have */
	void falloff_strength(float value) {
		PyObject_SetAttrString(pyobjref, "falloff_strength", Py_BuildValue("f", value));
	}

	/** Getter: Bias (in radians) to prevent smoothed faces from showing banding (for Raytrace Constant Jittered) */
	float bias() { /* not implemented */ throw NULL; }
	/** Setter: Bias (in radians) to prevent smoothed faces from showing banding (for Raytrace Constant Jittered) */
	void bias(float value) {
		PyObject_SetAttrString(pyobjref, "bias", Py_BuildValue("f", value));
	}

	/** Getter: Samples below this threshold will be considered fully shadowed/unshadowed and skipped (for Raytrace Adaptive QMC) */
	float threshold() { /* not implemented */ throw NULL; }
	/** Setter: Samples below this threshold will be considered fully shadowed/unshadowed and skipped (for Raytrace Adaptive QMC) */
	void threshold(float value) {
		PyObject_SetAttrString(pyobjref, "threshold", Py_BuildValue("f", value));
	}

	/** Getter: Use the speed vector pass to reduce AO samples in fast moving pixels - higher values result in more aggressive sample reduction (requires Vec pass enabled, for Raytrace Adaptive QMC) */
	float adapt_to_speed() { /* not implemented */ throw NULL; }
	/** Setter: Use the speed vector pass to reduce AO samples in fast moving pixels - higher values result in more aggressive sample reduction (requires Vec pass enabled, for Raytrace Adaptive QMC) */
	void adapt_to_speed(float value) {
		PyObject_SetAttrString(pyobjref, "adapt_to_speed", Py_BuildValue("f", value));
	}

	/** Getter: Low values are slower and higher quality */
	float error_threshold() { /* not implemented */ throw NULL; }
	/** Setter: Low values are slower and higher quality */
	void error_threshold(float value) {
		PyObject_SetAttrString(pyobjref, "error_threshold", Py_BuildValue("f", value));
	}

	/** Getter: Ad-hoc correction for over-occlusion due to the approximation */
	float correction() { /* not implemented */ throw NULL; }
	/** Setter: Ad-hoc correction for over-occlusion due to the approximation */
	void correction(float value) {
		PyObject_SetAttrString(pyobjref, "correction", Py_BuildValue("f", value));
	}

	/** Getter: Distance will be used to attenuate shadows */
	bool use_falloff() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_falloff")) == 1;
	}

	/** Setter: Distance will be used to attenuate shadows */
	void use_falloff(bool value) {
		PyObject_SetAttrString(pyobjref, "use_falloff", Py_BuildValue("i", value));
	}

	/** Getter: Cache AO results in pixels and interpolate over neighboring pixels for speedup */
	bool use_cache() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_cache")) == 1;
	}

	/** Setter: Cache AO results in pixels and interpolate over neighboring pixels for speedup */
	void use_cache(bool value) {
		PyObject_SetAttrString(pyobjref, "use_cache", Py_BuildValue("i", value));
	}

	/** Getter: Amount of ray samples. Higher values give smoother results and longer rendering times */
	int samples() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "samples"));
	}

	/** Setter: Amount of ray samples. Higher values give smoother results and longer rendering times */
	void samples(int value) {
		PyObject_SetAttrString(pyobjref, "samples", Py_BuildValue("i", value));
	}

	enum sample_method_enum {
		sample_method_CONSTANT_JITTERED = 0,
		sample_method_ADAPTIVE_QMC = 1,
		sample_method_CONSTANT_QMC = 2,
	};

	/** Getter: Method for generating shadow samples (for Raytrace) */
	sample_method_enum sample_method() { /* not implemented */ throw NULL; }
	/** Setter: Method for generating shadow samples (for Raytrace) */
	void sample_method(sample_method_enum value) { /* not implemented */ }

};

/**************** World Mist ****************/

/**
 * Mist settings for a World data-block
 */
class WorldMistSettings : public pyUniplug {
public:
	WorldMistSettings(PyObject* pyobj) : pyUniplug(pyobj) {}

	WorldMistSettings() : pyUniplug(0)
	{
		// not implemented
	}

	/** Getter: Occlude objects with the environment color as they are further away */
	bool use_mist() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_mist")) == 1;
	}

	/** Setter: Occlude objects with the environment color as they are further away */
	void use_mist(bool value) {
		PyObject_SetAttrString(pyobjref, "use_mist", Py_BuildValue("i", value));
	}

	/** Getter: Overall minimum intensity of the mist effect */
	float intensity() { /* not implemented */ throw NULL; }
	/** Setter: Overall minimum intensity of the mist effect */
	void intensity(float value) {
		PyObject_SetAttrString(pyobjref, "intensity", Py_BuildValue("f", value));
	}

	/** Getter: Starting distance of the mist, measured from the camera */
	float start() { /* not implemented */ throw NULL; }
	/** Setter: Starting distance of the mist, measured from the camera */
	void start(float value) {
		PyObject_SetAttrString(pyobjref, "start", Py_BuildValue("f", value));
	}

	/** Getter: Distance over which the mist effect fades in */
	float depth() { /* not implemented */ throw NULL; }
	/** Setter: Distance over which the mist effect fades in */
	void depth(float value) {
		PyObject_SetAttrString(pyobjref, "depth", Py_BuildValue("f", value));
	}

	/** Getter: Control how much mist density decreases with height */
	float height() { /* not implemented */ throw NULL; }
	/** Setter: Control how much mist density decreases with height */
	void height(float value) {
		PyObject_SetAttrString(pyobjref, "height", Py_BuildValue("f", value));
	}

	enum falloff_enum {
		falloff_QUADRATIC = 0,
		falloff_LINEAR = 1,
		falloff_INVERSE_QUADRATIC = 2,
	};

	/** Getter: Type of transition used to fade mist */
	falloff_enum falloff() { /* not implemented */ throw NULL; }
	/** Setter: Type of transition used to fade mist */
	void falloff(falloff_enum value) { /* not implemented */ }

};

/**************** World Texture Slot ****************/

/**
 * Texture slot for textures in a World datablock
 */
class WorldTextureSlot : public TextureSlot {
public:
	WorldTextureSlot(PyObject* pyobj) : TextureSlot(pyobj) {}

	WorldTextureSlot() : TextureSlot(0)
	{
		// not implemented
	}

	/** Getter: Affect the color progression of the background */
	bool use_map_blend() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_map_blend")) == 1;
	}

	/** Setter: Affect the color progression of the background */
	void use_map_blend(bool value) {
		PyObject_SetAttrString(pyobjref, "use_map_blend", Py_BuildValue("i", value));
	}

	/** Getter: Affect the color of the horizon */
	bool use_map_horizon() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_map_horizon")) == 1;
	}

	/** Setter: Affect the color of the horizon */
	void use_map_horizon(bool value) {
		PyObject_SetAttrString(pyobjref, "use_map_horizon", Py_BuildValue("i", value));
	}

	/** Getter: Affect the color of the zenith above */
	bool use_map_zenith_up() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_map_zenith_up")) == 1;
	}

	/** Setter: Affect the color of the zenith above */
	void use_map_zenith_up(bool value) {
		PyObject_SetAttrString(pyobjref, "use_map_zenith_up", Py_BuildValue("i", value));
	}

	/** Getter: Affect the color of the zenith below */
	bool use_map_zenith_down() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_map_zenith_down")) == 1;
	}

	/** Setter: Affect the color of the zenith below */
	void use_map_zenith_down(bool value) {
		PyObject_SetAttrString(pyobjref, "use_map_zenith_down", Py_BuildValue("i", value));
	}

	enum texture_coords_enum {
		texture_coords_VIEW = 128,
		texture_coords_GLOBAL = 8,
		texture_coords_ANGMAP = 64,
		texture_coords_SPHERE = 256,
		texture_coords_EQUIRECT = 2048,
		texture_coords_TUBE = 1024,
		texture_coords_OBJECT = 32,
	};

	/** Getter: Texture coordinates used to map the texture onto the background */
	texture_coords_enum texture_coords() { /* not implemented */ throw NULL; }
	/** Setter: Texture coordinates used to map the texture onto the background */
	void texture_coords(texture_coords_enum value) { /* not implemented */ }

	/** Getter: Object to use for mapping with Object texture coordinates */
	Object object_value() {
		/* not implemented */ throw NULL;
	}

	/** Getter: Amount texture affects color progression of the background */
	float blend_factor() { /* not implemented */ throw NULL; }
	/** Setter: Amount texture affects color progression of the background */
	void blend_factor(float value) {
		PyObject_SetAttrString(pyobjref, "blend_factor", Py_BuildValue("f", value));
	}

	/** Getter: Amount texture affects color of the horizon */
	float horizon_factor() { /* not implemented */ throw NULL; }
	/** Setter: Amount texture affects color of the horizon */
	void horizon_factor(float value) {
		PyObject_SetAttrString(pyobjref, "horizon_factor", Py_BuildValue("f", value));
	}

	/** Getter: Amount texture affects color of the zenith above */
	float zenith_up_factor() { /* not implemented */ throw NULL; }
	/** Setter: Amount texture affects color of the zenith above */
	void zenith_up_factor(float value) {
		PyObject_SetAttrString(pyobjref, "zenith_up_factor", Py_BuildValue("f", value));
	}

	/** Getter: Amount texture affects color of the zenith below */
	float zenith_down_factor() { /* not implemented */ throw NULL; }
	/** Setter: Amount texture affects color of the zenith below */
	void zenith_down_factor(float value) {
		PyObject_SetAttrString(pyobjref, "zenith_down_factor", Py_BuildValue("f", value));
	}

};

/**************** MovieClip ****************/

/**
 * MovieClip datablock referencing an external movie file
 */
class MovieClip : public ID {
public:
	MovieClip(PyObject* pyobj) : ID(pyobj) {}

	MovieClip() : ID(0)
	{
		// not implemented
	}

	/** Getter: Filename of the movie or sequence file */
	std::string filepath() { /* not implemented */ throw NULL; }
	/** Setter: Filename of the movie or sequence file */
	void filepath(const std::string& value) { /* not implemented */ }

	/** Getter:  */
	MovieTracking tracking();

	/** Getter:  */
	MovieClipProxy proxy();

	/** Getter: Use a preview proxy and/or timecode index for this clip */
	bool use_proxy() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_proxy")) == 1;
	}

	/** Setter: Use a preview proxy and/or timecode index for this clip */
	void use_proxy(bool value) {
		PyObject_SetAttrString(pyobjref, "use_proxy", Py_BuildValue("i", value));
	}

	/** Getter: Width and height in pixels, zero when image data cant be loaded */
	std::array<int, 2> size() {
		// TODO: MISSING DEREF! USE #DEFINE!
		PyObject *seqval = PyObject_GetAttrString(pyobjref, "size");
		std::array<int, 2> resarr;
		for (int i = 0; i < 2; i++)
			resarr[i] = PyLong_AsLong(PySequence_GetItem(seqval, i));
		return resarr;
	}

	/** Setter: Width and height in pixels, zero when image data cant be loaded */
	void size(int values[2]) { /* not implemented */ }

	/** Getter: Display Aspect for this clip, does not affect rendering */
	std::array<float, 2> display_aspect() {
		// TODO: MISSING DEREF! USE #DEFINE!
		PyObject *seqval = PyObject_GetAttrString(pyobjref, "display_aspect");
		std::array<float, 2> resarr;
		for (int i = 0; i < 2; i++)
			resarr[i] = (float)PyFloat_AsDouble(PySequence_GetItem(seqval, i));
		return resarr;
	}

	/** Setter: Display Aspect for this clip, does not affect rendering */
	void display_aspect(float values[2]) { /* not implemented */ }

	enum source_enum {
		source_SEQUENCE = 1,
		source_MOVIE = 2,
	};

	/** Getter: Where the clip comes from */
	source_enum source() { /* not implemented */ throw NULL; }
	/** Setter: Where the clip comes from */
	void source(source_enum value) { /* not implemented */ }

	/** Getter: Create proxy images in a custom directory (default is movie location) */
	bool use_proxy_custom_directory() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_proxy_custom_directory")) == 1;
	}

	/** Setter: Create proxy images in a custom directory (default is movie location) */
	void use_proxy_custom_directory(bool value) {
		PyObject_SetAttrString(pyobjref, "use_proxy_custom_directory", Py_BuildValue("i", value));
	}

	/** Getter: Grease pencil data for this movie clip */
	GreasePencil grease_pencil() {
		/* not implemented */ throw NULL;
	}

	/** Getter: Global scene frame number at which this movie starts playing (affects all data associated with a clip) */
	int frame_start() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "frame_start"));
	}

	/** Setter: Global scene frame number at which this movie starts playing (affects all data associated with a clip) */
	void frame_start(int value) {
		PyObject_SetAttrString(pyobjref, "frame_start", Py_BuildValue("i", value));
	}

	/** Getter: Offset of footage first frame relative to it's file name (affects only how footage is loading, does not change data associated with a clip) */
	int frame_offset() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "frame_offset"));
	}

	/** Setter: Offset of footage first frame relative to it's file name (affects only how footage is loading, does not change data associated with a clip) */
	void frame_offset(int value) {
		PyObject_SetAttrString(pyobjref, "frame_offset", Py_BuildValue("i", value));
	}

	/** Getter: Detected duration of movie clip in frames */
	int frame_duration() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "frame_duration"));
	}

	/** Setter: Detected duration of movie clip in frames */
	void frame_duration(int value) {
		PyObject_SetAttrString(pyobjref, "frame_duration", Py_BuildValue("i", value));
	}

	/** Getter: Input color space settings */
	ColorManagedInputColorspaceSettings colorspace_settings() {
		/* not implemented */ throw NULL;
	}

};

/**************** Movie Clip Proxy ****************/

/**
 * Proxy parameters for a movie clip
 */
class MovieClipProxy : public pyUniplug {
public:
	MovieClipProxy(PyObject* pyobj) : pyUniplug(pyobj) {}

	MovieClipProxy() : pyUniplug(0)
	{
		// not implemented
	}

	/** Getter: Build proxy resolution 25% of the original footage dimension */
	bool build_25() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "build_25")) == 1;
	}

	/** Setter: Build proxy resolution 25% of the original footage dimension */
	void build_25(bool value) {
		PyObject_SetAttrString(pyobjref, "build_25", Py_BuildValue("i", value));
	}

	/** Getter: Build proxy resolution 50% of the original footage dimension */
	bool build_50() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "build_50")) == 1;
	}

	/** Setter: Build proxy resolution 50% of the original footage dimension */
	void build_50(bool value) {
		PyObject_SetAttrString(pyobjref, "build_50", Py_BuildValue("i", value));
	}

	/** Getter: Build proxy resolution 75% of the original footage dimension */
	bool build_75() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "build_75")) == 1;
	}

	/** Setter: Build proxy resolution 75% of the original footage dimension */
	void build_75(bool value) {
		PyObject_SetAttrString(pyobjref, "build_75", Py_BuildValue("i", value));
	}

	/** Getter: Build proxy resolution 100% of the original footage dimension */
	bool build_100() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "build_100")) == 1;
	}

	/** Setter: Build proxy resolution 100% of the original footage dimension */
	void build_100(bool value) {
		PyObject_SetAttrString(pyobjref, "build_100", Py_BuildValue("i", value));
	}

	/** Getter: Build proxy resolution 25% of the original undistorted footage dimension */
	bool build_undistorted_25() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "build_undistorted_25")) == 1;
	}

	/** Setter: Build proxy resolution 25% of the original undistorted footage dimension */
	void build_undistorted_25(bool value) {
		PyObject_SetAttrString(pyobjref, "build_undistorted_25", Py_BuildValue("i", value));
	}

	/** Getter: Build proxy resolution 50% of the original undistorted footage dimension */
	bool build_undistorted_50() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "build_undistorted_50")) == 1;
	}

	/** Setter: Build proxy resolution 50% of the original undistorted footage dimension */
	void build_undistorted_50(bool value) {
		PyObject_SetAttrString(pyobjref, "build_undistorted_50", Py_BuildValue("i", value));
	}

	/** Getter: Build proxy resolution 75% of the original undistorted footage dimension */
	bool build_undistorted_75() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "build_undistorted_75")) == 1;
	}

	/** Setter: Build proxy resolution 75% of the original undistorted footage dimension */
	void build_undistorted_75(bool value) {
		PyObject_SetAttrString(pyobjref, "build_undistorted_75", Py_BuildValue("i", value));
	}

	/** Getter: Build proxy resolution 100% of the original undistorted footage dimension */
	bool build_undistorted_100() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "build_undistorted_100")) == 1;
	}

	/** Setter: Build proxy resolution 100% of the original undistorted footage dimension */
	void build_undistorted_100(bool value) {
		PyObject_SetAttrString(pyobjref, "build_undistorted_100", Py_BuildValue("i", value));
	}

	/** Getter: Build record run time code index */
	bool build_record_run() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "build_record_run")) == 1;
	}

	/** Setter: Build record run time code index */
	void build_record_run(bool value) {
		PyObject_SetAttrString(pyobjref, "build_record_run", Py_BuildValue("i", value));
	}

	/** Getter: Build free run time code index */
	bool build_free_run() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "build_free_run")) == 1;
	}

	/** Setter: Build free run time code index */
	void build_free_run(bool value) {
		PyObject_SetAttrString(pyobjref, "build_free_run", Py_BuildValue("i", value));
	}

	/** Getter: Build free run time code index using Record Date/Time */
	bool build_free_run_rec_date() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "build_free_run_rec_date")) == 1;
	}

	/** Setter: Build free run time code index using Record Date/Time */
	void build_free_run_rec_date(bool value) {
		PyObject_SetAttrString(pyobjref, "build_free_run_rec_date", Py_BuildValue("i", value));
	}

	/** Getter: JPEG quality of proxy images */
	int quality() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "quality"));
	}

	/** Setter: JPEG quality of proxy images */
	void quality(int value) {
		PyObject_SetAttrString(pyobjref, "quality", Py_BuildValue("i", value));
	}

	enum timecode_enum {
		timecode_NONE = 0,
		timecode_RECORD_RUN = 1,
		timecode_FREE_RUN = 2,
		timecode_FREE_RUN_REC_DATE = 4,
		timecode_FREE_RUN_NO_GAPS = 8,
	};

	/** Getter:  */
	timecode_enum timecode() { /* not implemented */ throw NULL; }
	/** Setter:  */
	void timecode(timecode_enum value) { /* not implemented */ }

	/** Getter: Location to store the proxy files */
	std::string directory() { /* not implemented */ throw NULL; }
	/** Setter: Location to store the proxy files */
	void directory(const std::string& value) { /* not implemented */ }

};

/**************** Movie Clip User ****************/

/**
 * Parameters defining how a MovieClip datablock is used by another datablock
 */
class MovieClipUser : public pyUniplug {
public:
	MovieClipUser(PyObject* pyobj) : pyUniplug(pyobj) {}

	MovieClipUser() : pyUniplug(0)
	{
		// not implemented
	}

	/** Getter: Current frame number in movie or image sequence */
	int frame_current() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "frame_current"));
	}

	/** Setter: Current frame number in movie or image sequence */
	void frame_current(int value) {
		PyObject_SetAttrString(pyobjref, "frame_current", Py_BuildValue("i", value));
	}

	enum proxy_render_size_enum {
		proxy_render_size_PROXY_25 = 1,
		proxy_render_size_PROXY_50 = 2,
		proxy_render_size_PROXY_75 = 3,
		proxy_render_size_PROXY_100 = 4,
		proxy_render_size_FULL = 0,
	};

	/** Getter: Draw preview using full resolution or different proxy resolutions */
	proxy_render_size_enum proxy_render_size() { /* not implemented */ throw NULL; }
	/** Setter: Draw preview using full resolution or different proxy resolutions */
	void proxy_render_size(proxy_render_size_enum value) { /* not implemented */ }

	/** Getter: Render preview using undistorted proxy */
	bool use_render_undistorted() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_render_undistorted")) == 1;
	}

	/** Setter: Render preview using undistorted proxy */
	void use_render_undistorted(bool value) {
		PyObject_SetAttrString(pyobjref, "use_render_undistorted", Py_BuildValue("i", value));
	}

};

/**************** MovieClipScopes ****************/

/**
 * Scopes for statistical view of a movie clip
 */
class MovieClipScopes : public pyUniplug {
public:
	MovieClipScopes(PyObject* pyobj) : pyUniplug(pyobj) {}

	MovieClipScopes() : pyUniplug(0)
	{
		// not implemented
	}

};

/**************** Movie tracking settings ****************/

/**
 * Match moving settings
 */
class MovieTrackingSettings : public pyUniplug {
public:
	MovieTrackingSettings(PyObject* pyobj) : pyUniplug(pyobj) {}

	MovieTrackingSettings() : pyUniplug(0)
	{
		// not implemented
	}

	enum speed_enum {
		speed_FASTEST = 0,
		speed_DOUBLE = 5,
		speed_REALTIME = 1,
		speed_HALF = 2,
		speed_QUARTER = 4,
	};

	/** Getter: Limit speed of tracking to make visual feedback easier (this does not affect the tracking quality) */
	speed_enum speed() { /* not implemented */ throw NULL; }
	/** Setter: Limit speed of tracking to make visual feedback easier (this does not affect the tracking quality) */
	void speed(speed_enum value) { /* not implemented */ }

	/** Getter: Automatically select keyframes when solving camera/object motion */
	bool use_keyframe_selection() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_keyframe_selection")) == 1;
	}

	/** Setter: Automatically select keyframes when solving camera/object motion */
	void use_keyframe_selection(bool value) {
		PyObject_SetAttrString(pyobjref, "use_keyframe_selection", Py_BuildValue("i", value));
	}

	enum refine_intrinsics_enum {
		refine_intrinsics_NONE = 0,
		refine_intrinsics_FOCAL_LENGTH = 1,
		refine_intrinsics_FOCAL_LENGTH_RADIAL_K1 = 5,
		refine_intrinsics_FOCAL_LENGTH_RADIAL_K1_K2 = 21,
		refine_intrinsics_FOCAL_LENGTH_PRINCIPAL_POINT_RADIAL_K1_K2 = 23,
		refine_intrinsics_FOCAL_LENGTH_PRINCIPAL_POINT = 3,
		refine_intrinsics_RADIAL_K1_K2 = 20,
	};

	/** Getter: Refine intrinsics during camera solving */
	refine_intrinsics_enum refine_intrinsics() { /* not implemented */ throw NULL; }
	/** Setter: Refine intrinsics during camera solving */
	void refine_intrinsics(refine_intrinsics_enum value) { /* not implemented */ }

	/** Getter: Distance between two bundles used for scene scaling */
	float distance() { /* not implemented */ throw NULL; }
	/** Setter: Distance between two bundles used for scene scaling */
	void distance(float value) {
		PyObject_SetAttrString(pyobjref, "distance", Py_BuildValue("f", value));
	}

	/** Getter: Effect on tracks which are tracked less than the specified amount of frames */
	int clean_frames() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "clean_frames"));
	}

	/** Setter: Effect on tracks which are tracked less than the specified amount of frames */
	void clean_frames(int value) {
		PyObject_SetAttrString(pyobjref, "clean_frames", Py_BuildValue("i", value));
	}

	/** Getter: Effect on tracks which have a larger re-projection error */
	float clean_error() { /* not implemented */ throw NULL; }
	/** Setter: Effect on tracks which have a larger re-projection error */
	void clean_error(float value) {
		PyObject_SetAttrString(pyobjref, "clean_error", Py_BuildValue("f", value));
	}

	enum clean_action_enum {
		clean_action_SELECT = 0,
		clean_action_DELETE_TRACK = 1,
		clean_action_DELETE_SEGMENTS = 2,
	};

	/** Getter: Cleanup action to execute */
	clean_action_enum clean_action() { /* not implemented */ throw NULL; }
	/** Setter: Cleanup action to execute */
	void clean_action(clean_action_enum value) { /* not implemented */ }

	/** Getter: Show default options expanded in the user interface */
	bool show_default_expanded() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "show_default_expanded")) == 1;
	}

	/** Setter: Show default options expanded in the user interface */
	void show_default_expanded(bool value) {
		PyObject_SetAttrString(pyobjref, "show_default_expanded", Py_BuildValue("i", value));
	}

	/** Getter: Show extra options expanded in the user interface */
	bool show_extra_expanded() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "show_extra_expanded")) == 1;
	}

	/** Setter: Show extra options expanded in the user interface */
	void show_extra_expanded(bool value) {
		PyObject_SetAttrString(pyobjref, "show_extra_expanded", Py_BuildValue("i", value));
	}

	/** Getter: Use special solver to track a stable camera position, such as a tripod */
	bool use_tripod_solver() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_tripod_solver")) == 1;
	}

	/** Setter: Use special solver to track a stable camera position, such as a tripod */
	void use_tripod_solver(bool value) {
		PyObject_SetAttrString(pyobjref, "use_tripod_solver", Py_BuildValue("i", value));
	}

	/** Getter: Every tracking cycle, this number of frames are tracked */
	int default_frames_limit() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "default_frames_limit"));
	}

	/** Setter: Every tracking cycle, this number of frames are tracked */
	void default_frames_limit(int value) {
		PyObject_SetAttrString(pyobjref, "default_frames_limit", Py_BuildValue("i", value));
	}

	enum default_pattern_match_enum {
		default_pattern_match_KEYFRAME = 0,
		default_pattern_match_PREV_FRAME = 1,
	};

	/** Getter: Track pattern from given frame when tracking marker to next frame */
	default_pattern_match_enum default_pattern_match() { /* not implemented */ throw NULL; }
	/** Setter: Track pattern from given frame when tracking marker to next frame */
	void default_pattern_match(default_pattern_match_enum value) { /* not implemented */ }

	/** Getter: Default distance from image boundary at which marker stops tracking */
	int default_margin() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "default_margin"));
	}

	/** Setter: Default distance from image boundary at which marker stops tracking */
	void default_margin(int value) {
		PyObject_SetAttrString(pyobjref, "default_margin", Py_BuildValue("i", value));
	}

	enum default_motion_model_enum {
		default_motion_model_Perspective = 5,
		default_motion_model_Affine = 4,
		default_motion_model_LocRotScale = 3,
		default_motion_model_LocScale = 2,
		default_motion_model_LocRot = 1,
		default_motion_model_Loc = 0,
	};

	/** Getter: Default motion model to use for tracking */
	default_motion_model_enum default_motion_model() { /* not implemented */ throw NULL; }
	/** Setter: Default motion model to use for tracking */
	void default_motion_model(default_motion_model_enum value) { /* not implemented */ }

	/** Getter: Use a brute-force translation-only initialization when tracking */
	bool use_default_brute() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_default_brute")) == 1;
	}

	/** Setter: Use a brute-force translation-only initialization when tracking */
	void use_default_brute(bool value) {
		PyObject_SetAttrString(pyobjref, "use_default_brute", Py_BuildValue("i", value));
	}

	/** Getter: Use a grease pencil datablock as a mask to use only specified areas of pattern when tracking */
	bool use_default_mask() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_default_mask")) == 1;
	}

	/** Setter: Use a grease pencil datablock as a mask to use only specified areas of pattern when tracking */
	void use_default_mask(bool value) {
		PyObject_SetAttrString(pyobjref, "use_default_mask", Py_BuildValue("i", value));
	}

	/** Getter: Normalize light intensities while tracking (slower) */
	bool use_default_normalization() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_default_normalization")) == 1;
	}

	/** Setter: Normalize light intensities while tracking (slower) */
	void use_default_normalization(bool value) {
		PyObject_SetAttrString(pyobjref, "use_default_normalization", Py_BuildValue("i", value));
	}

	/** Getter: Default minimum value of correlation between matched pattern and reference that is still treated as successful tracking */
	float default_correlation_min() { /* not implemented */ throw NULL; }
	/** Setter: Default minimum value of correlation between matched pattern and reference that is still treated as successful tracking */
	void default_correlation_min(float value) {
		PyObject_SetAttrString(pyobjref, "default_correlation_min", Py_BuildValue("f", value));
	}

	/** Getter: Size of pattern area for newly created tracks */
	int default_pattern_size() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "default_pattern_size"));
	}

	/** Setter: Size of pattern area for newly created tracks */
	void default_pattern_size(int value) {
		PyObject_SetAttrString(pyobjref, "default_pattern_size", Py_BuildValue("i", value));
	}

	/** Getter: Size of search area for newly created tracks */
	int default_search_size() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "default_search_size"));
	}

	/** Setter: Size of search area for newly created tracks */
	void default_search_size(int value) {
		PyObject_SetAttrString(pyobjref, "default_search_size", Py_BuildValue("i", value));
	}

	/** Getter: Use red channel from footage for tracking */
	bool use_default_red_channel() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_default_red_channel")) == 1;
	}

	/** Setter: Use red channel from footage for tracking */
	void use_default_red_channel(bool value) {
		PyObject_SetAttrString(pyobjref, "use_default_red_channel", Py_BuildValue("i", value));
	}

	/** Getter: Use green channel from footage for tracking */
	bool use_default_green_channel() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_default_green_channel")) == 1;
	}

	/** Setter: Use green channel from footage for tracking */
	void use_default_green_channel(bool value) {
		PyObject_SetAttrString(pyobjref, "use_default_green_channel", Py_BuildValue("i", value));
	}

	/** Getter: Use blue channel from footage for tracking */
	bool use_default_blue_channel() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_default_blue_channel")) == 1;
	}

	/** Setter: Use blue channel from footage for tracking */
	void use_default_blue_channel(bool value) {
		PyObject_SetAttrString(pyobjref, "use_default_blue_channel", Py_BuildValue("i", value));
	}

	/** Getter: Influence of newly created track on a final solution */
	float default_weight() { /* not implemented */ throw NULL; }
	/** Setter: Influence of newly created track on a final solution */
	void default_weight(float value) {
		PyObject_SetAttrString(pyobjref, "default_weight", Py_BuildValue("f", value));
	}

	/** Getter: Distance between two bundles used for object scaling */
	float object_distance() { /* not implemented */ throw NULL; }
	/** Setter: Distance between two bundles used for object scaling */
	void object_distance(float value) {
		PyObject_SetAttrString(pyobjref, "object_distance", Py_BuildValue("f", value));
	}

};

/**************** Movie tracking camera data ****************/

/**
 * Match-moving camera data for tracking
 */
class MovieTrackingCamera : public pyUniplug {
public:
	MovieTrackingCamera(PyObject* pyobj) : pyUniplug(pyobj) {}

	MovieTrackingCamera() : pyUniplug(0)
	{
		// not implemented
	}

	enum distortion_model_enum {
		distortion_model_POLYNOMIAL = 0,
		distortion_model_DIVISION = 1,
	};

	/** Getter: Distortion model used for camera lenses */
	distortion_model_enum distortion_model() { /* not implemented */ throw NULL; }
	/** Setter: Distortion model used for camera lenses */
	void distortion_model(distortion_model_enum value) { /* not implemented */ }

	/** Getter: Width of CCD sensor in millimeters */
	float sensor_width() { /* not implemented */ throw NULL; }
	/** Setter: Width of CCD sensor in millimeters */
	void sensor_width(float value) {
		PyObject_SetAttrString(pyobjref, "sensor_width", Py_BuildValue("f", value));
	}

	/** Getter: Camera's focal length */
	float focal_length() { /* not implemented */ throw NULL; }
	/** Setter: Camera's focal length */
	void focal_length(float value) {
		PyObject_SetAttrString(pyobjref, "focal_length", Py_BuildValue("f", value));
	}

	/** Getter: Camera's focal length */
	float focal_length_pixels() { /* not implemented */ throw NULL; }
	/** Setter: Camera's focal length */
	void focal_length_pixels(float value) {
		PyObject_SetAttrString(pyobjref, "focal_length_pixels", Py_BuildValue("f", value));
	}

	enum units_enum {
		units_PIXELS = 0,
		units_MILLIMETERS = 1,
	};

	/** Getter: Units used for camera focal length */
	units_enum units() { /* not implemented */ throw NULL; }
	/** Setter: Units used for camera focal length */
	void units(units_enum value) { /* not implemented */ }

	/** Getter: Optical center of lens */
	std::array<float, 2> principal() {
		// TODO: MISSING DEREF! USE #DEFINE!
		PyObject *seqval = PyObject_GetAttrString(pyobjref, "principal");
		std::array<float, 2> resarr;
		for (int i = 0; i < 2; i++)
			resarr[i] = (float)PyFloat_AsDouble(PySequence_GetItem(seqval, i));
		return resarr;
	}

	/** Setter: Optical center of lens */
	void principal(float values[2]) { /* not implemented */ }

	/** Getter: First coefficient of third order polynomial radial distortion */
	float k1() { /* not implemented */ throw NULL; }
	/** Setter: First coefficient of third order polynomial radial distortion */
	void k1(float value) {
		PyObject_SetAttrString(pyobjref, "k1", Py_BuildValue("f", value));
	}

	/** Getter: Second coefficient of third order polynomial radial distortion */
	float k2() { /* not implemented */ throw NULL; }
	/** Setter: Second coefficient of third order polynomial radial distortion */
	void k2(float value) {
		PyObject_SetAttrString(pyobjref, "k2", Py_BuildValue("f", value));
	}

	/** Getter: Third coefficient of third order polynomial radial distortion */
	float k3() { /* not implemented */ throw NULL; }
	/** Setter: Third coefficient of third order polynomial radial distortion */
	void k3(float value) {
		PyObject_SetAttrString(pyobjref, "k3", Py_BuildValue("f", value));
	}

	/** Getter: First coefficient of second order division distortion */
	float division_k1() { /* not implemented */ throw NULL; }
	/** Setter: First coefficient of second order division distortion */
	void division_k1(float value) {
		PyObject_SetAttrString(pyobjref, "division_k1", Py_BuildValue("f", value));
	}

	/** Getter: First coefficient of second order division distortion */
	float division_k2() { /* not implemented */ throw NULL; }
	/** Setter: First coefficient of second order division distortion */
	void division_k2(float value) {
		PyObject_SetAttrString(pyobjref, "division_k2", Py_BuildValue("f", value));
	}

	/** Getter: Pixel aspect ratio */
	float pixel_aspect() { /* not implemented */ throw NULL; }
	/** Setter: Pixel aspect ratio */
	void pixel_aspect(float value) {
		PyObject_SetAttrString(pyobjref, "pixel_aspect", Py_BuildValue("f", value));
	}

};

/**************** Movie tracking marker data ****************/

/**
 * Match-moving marker data for tracking
 */
class MovieTrackingMarker : public pyUniplug {
public:
	MovieTrackingMarker(PyObject* pyobj) : pyUniplug(pyobj) {}

	MovieTrackingMarker() : pyUniplug(0)
	{
		// not implemented
	}

	/** Getter: Marker position at frame in normalized coordinates */
	std::array<float, 2> co() {
		// TODO: MISSING DEREF! USE #DEFINE!
		PyObject *seqval = PyObject_GetAttrString(pyobjref, "co");
		std::array<float, 2> resarr;
		for (int i = 0; i < 2; i++)
			resarr[i] = (float)PyFloat_AsDouble(PySequence_GetItem(seqval, i));
		return resarr;
	}

	/** Setter: Marker position at frame in normalized coordinates */
	void co(float values[2]) { /* not implemented */ }

	/** Getter: Frame number marker is keyframed on */
	int frame() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "frame"));
	}

	/** Setter: Frame number marker is keyframed on */
	void frame(int value) {
		PyObject_SetAttrString(pyobjref, "frame", Py_BuildValue("i", value));
	}

	/** Getter: Is marker muted for current frame */
	bool mute() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "mute")) == 1;
	}

	/** Setter: Is marker muted for current frame */
	void mute(bool value) {
		PyObject_SetAttrString(pyobjref, "mute", Py_BuildValue("i", value));
	}

	/** Getter: Array of coordinates which represents pattern's corners in normalized coordinates relative to marker position */
	std::array<float, 8> pattern_corners() {
		// TODO: MISSING DEREF! USE #DEFINE!
		PyObject *seqval = PyObject_GetAttrString(pyobjref, "pattern_corners");
		std::array<float, 8> resarr;
		for (int i = 0; i < 8; i++)
			resarr[i] = (float)PyFloat_AsDouble(PySequence_GetItem(seqval, i));
		return resarr;
	}

	/** Setter: Array of coordinates which represents pattern's corners in normalized coordinates relative to marker position */
	void pattern_corners(float values[8]) { /* not implemented */ }

	/** Getter: Pattern area bounding box in normalized coordinates */
	std::array<float, 4> pattern_bound_box() {
		// TODO: MISSING DEREF! USE #DEFINE!
		PyObject *seqval = PyObject_GetAttrString(pyobjref, "pattern_bound_box");
		std::array<float, 4> resarr;
		for (int i = 0; i < 4; i++)
			resarr[i] = (float)PyFloat_AsDouble(PySequence_GetItem(seqval, i));
		return resarr;
	}

	/** Setter: Pattern area bounding box in normalized coordinates */
	void pattern_bound_box(float values[4]) { /* not implemented */ }

	/** Getter: Left-bottom corner of search area in normalized coordinates relative to marker position */
	std::array<float, 2> search_min() {
		// TODO: MISSING DEREF! USE #DEFINE!
		PyObject *seqval = PyObject_GetAttrString(pyobjref, "search_min");
		std::array<float, 2> resarr;
		for (int i = 0; i < 2; i++)
			resarr[i] = (float)PyFloat_AsDouble(PySequence_GetItem(seqval, i));
		return resarr;
	}

	/** Setter: Left-bottom corner of search area in normalized coordinates relative to marker position */
	void search_min(float values[2]) { /* not implemented */ }

	/** Getter: Right-bottom corner of search area in normalized coordinates relative to marker position */
	std::array<float, 2> search_max() {
		// TODO: MISSING DEREF! USE #DEFINE!
		PyObject *seqval = PyObject_GetAttrString(pyobjref, "search_max");
		std::array<float, 2> resarr;
		for (int i = 0; i < 2; i++)
			resarr[i] = (float)PyFloat_AsDouble(PySequence_GetItem(seqval, i));
		return resarr;
	}

	/** Setter: Right-bottom corner of search area in normalized coordinates relative to marker position */
	void search_max(float values[2]) { /* not implemented */ }

	/** Getter: Whether the position of the marker is keyframed or tracked */
	bool is_keyed() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "is_keyed")) == 1;
	}

	/** Setter: Whether the position of the marker is keyframed or tracked */
	void is_keyed(bool value) {
		PyObject_SetAttrString(pyobjref, "is_keyed", Py_BuildValue("i", value));
	}

};

/**************** Movie tracking track data ****************/

/**
 * Match-moving track data for tracking
 */
class MovieTrackingTrack : public pyUniplug {
public:
	MovieTrackingTrack(PyObject* pyobj) : pyUniplug(pyobj) {}

	MovieTrackingTrack() : pyUniplug(0)
	{
		// not implemented
	}

	/** Getter: Unique name of track */
	std::string name() { /* not implemented */ throw NULL; }
	/** Setter: Unique name of track */
	void name(const std::string& value) { /* not implemented */ }

	/** Getter: Every tracking cycle, this number of frames are tracked */
	int frames_limit() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "frames_limit"));
	}

	/** Setter: Every tracking cycle, this number of frames are tracked */
	void frames_limit(int value) {
		PyObject_SetAttrString(pyobjref, "frames_limit", Py_BuildValue("i", value));
	}

	enum pattern_match_enum {
		pattern_match_KEYFRAME = 0,
		pattern_match_PREV_FRAME = 1,
	};

	/** Getter: Track pattern from given frame when tracking marker to next frame */
	pattern_match_enum pattern_match() { /* not implemented */ throw NULL; }
	/** Setter: Track pattern from given frame when tracking marker to next frame */
	void pattern_match(pattern_match_enum value) { /* not implemented */ }

	/** Getter: Distance from image boundary at which marker stops tracking */
	int margin() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "margin"));
	}

	/** Setter: Distance from image boundary at which marker stops tracking */
	void margin(int value) {
		PyObject_SetAttrString(pyobjref, "margin", Py_BuildValue("i", value));
	}

	enum motion_model_enum {
		motion_model_Perspective = 5,
		motion_model_Affine = 4,
		motion_model_LocRotScale = 3,
		motion_model_LocScale = 2,
		motion_model_LocRot = 1,
		motion_model_Loc = 0,
	};

	/** Getter: Default motion model to use for tracking */
	motion_model_enum motion_model() { /* not implemented */ throw NULL; }
	/** Setter: Default motion model to use for tracking */
	void motion_model(motion_model_enum value) { /* not implemented */ }

	/** Getter: Minimal value of correlation between matched pattern and reference that is still treated as successful tracking */
	float correlation_min() { /* not implemented */ throw NULL; }
	/** Setter: Minimal value of correlation between matched pattern and reference that is still treated as successful tracking */
	void correlation_min(float value) {
		PyObject_SetAttrString(pyobjref, "correlation_min", Py_BuildValue("f", value));
	}

	/** Getter: Use a brute-force translation only pre-track before refinement */
	bool use_brute() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_brute")) == 1;
	}

	/** Setter: Use a brute-force translation only pre-track before refinement */
	void use_brute(bool value) {
		PyObject_SetAttrString(pyobjref, "use_brute", Py_BuildValue("i", value));
	}

	/** Getter: Use a grease pencil datablock as a mask to use only specified areas of pattern when tracking */
	bool use_mask() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_mask")) == 1;
	}

	/** Setter: Use a grease pencil datablock as a mask to use only specified areas of pattern when tracking */
	void use_mask(bool value) {
		PyObject_SetAttrString(pyobjref, "use_mask", Py_BuildValue("i", value));
	}

	/** Getter: Normalize light intensities while tracking. Slower */
	bool use_normalization() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_normalization")) == 1;
	}

	/** Setter: Normalize light intensities while tracking. Slower */
	void use_normalization(bool value) {
		PyObject_SetAttrString(pyobjref, "use_normalization", Py_BuildValue("i", value));
	}

	/** Getter: Collection of markers in track */
	std::map<std::string, MovieTrackingMarker> markers() {
		// TODO: MISSING DEREF! USE #DEFINE!
		PyObject *seqval = PyObject_GetAttrString(pyobjref, "markers");
		PyObject *seqkeys = PyObject_CallMethod(seqval, "keys", NULL);
		std::map<std::string, MovieTrackingMarker> resmap;
		for (int i = 0; i < PySequence_Length(seqval); i++) {
			PyObject *keyobj = PySequence_GetItem(seqkeys, i);
			std::string key = PyBytes_AsString(PyUnicode_AsASCIIString(keyobj));
			MovieTrackingMarker value = MovieTrackingMarker(PySequence_GetItem(seqval, i));
			resmap.insert(std::pair<std::string,MovieTrackingMarker>(key, value));
		}
		return resmap;
	}

	/** Setter: Collection of markers in track */
	void markers(std::map<std::string, MovieTrackingMarker> value) { /* not implemented */ }

	/** Getter: Use red channel from footage for tracking */
	bool use_red_channel() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_red_channel")) == 1;
	}

	/** Setter: Use red channel from footage for tracking */
	void use_red_channel(bool value) {
		PyObject_SetAttrString(pyobjref, "use_red_channel", Py_BuildValue("i", value));
	}

	/** Getter: Use green channel from footage for tracking */
	bool use_green_channel() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_green_channel")) == 1;
	}

	/** Setter: Use green channel from footage for tracking */
	void use_green_channel(bool value) {
		PyObject_SetAttrString(pyobjref, "use_green_channel", Py_BuildValue("i", value));
	}

	/** Getter: Use blue channel from footage for tracking */
	bool use_blue_channel() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_blue_channel")) == 1;
	}

	/** Setter: Use blue channel from footage for tracking */
	void use_blue_channel(bool value) {
		PyObject_SetAttrString(pyobjref, "use_blue_channel", Py_BuildValue("i", value));
	}

	/** Getter: Display what the tracking algorithm sees in the preview */
	bool use_grayscale_preview() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_grayscale_preview")) == 1;
	}

	/** Setter: Display what the tracking algorithm sees in the preview */
	void use_grayscale_preview(bool value) {
		PyObject_SetAttrString(pyobjref, "use_grayscale_preview", Py_BuildValue("i", value));
	}

	/** Getter: Apply track's mask on displaying preview */
	bool use_alpha_preview() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_alpha_preview")) == 1;
	}

	/** Setter: Apply track's mask on displaying preview */
	void use_alpha_preview(bool value) {
		PyObject_SetAttrString(pyobjref, "use_alpha_preview", Py_BuildValue("i", value));
	}

	/** Getter: True if track has a valid bundle */
	bool has_bundle() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "has_bundle")) == 1;
	}

	/** Setter: True if track has a valid bundle */
	void has_bundle(bool value) {
		PyObject_SetAttrString(pyobjref, "has_bundle", Py_BuildValue("i", value));
	}

	/** Getter: Position of bundle reconstructed from this track */
	std::array<float, 3> bundle() {
		// TODO: MISSING DEREF! USE #DEFINE!
		PyObject *seqval = PyObject_GetAttrString(pyobjref, "bundle");
		std::array<float, 3> resarr;
		for (int i = 0; i < 3; i++)
			resarr[i] = (float)PyFloat_AsDouble(PySequence_GetItem(seqval, i));
		return resarr;
	}

	/** Setter: Position of bundle reconstructed from this track */
	void bundle(float values[3]) { /* not implemented */ }

	/** Getter: Track is hidden */
	bool hide() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "hide")) == 1;
	}

	/** Setter: Track is hidden */
	void hide(bool value) {
		PyObject_SetAttrString(pyobjref, "hide", Py_BuildValue("i", value));
	}

	/** Getter: Track is selected */
	bool select() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "select")) == 1;
	}

	/** Setter: Track is selected */
	void select(bool value) {
		PyObject_SetAttrString(pyobjref, "select", Py_BuildValue("i", value));
	}

	/** Getter: Track's anchor point is selected */
	bool select_anchor() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "select_anchor")) == 1;
	}

	/** Setter: Track's anchor point is selected */
	void select_anchor(bool value) {
		PyObject_SetAttrString(pyobjref, "select_anchor", Py_BuildValue("i", value));
	}

	/** Getter: Track's pattern area is selected */
	bool select_pattern() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "select_pattern")) == 1;
	}

	/** Setter: Track's pattern area is selected */
	void select_pattern(bool value) {
		PyObject_SetAttrString(pyobjref, "select_pattern", Py_BuildValue("i", value));
	}

	/** Getter: Track's search area is selected */
	bool select_search() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "select_search")) == 1;
	}

	/** Setter: Track's search area is selected */
	void select_search(bool value) {
		PyObject_SetAttrString(pyobjref, "select_search", Py_BuildValue("i", value));
	}

	/** Getter: Track is locked and all changes to it are disabled */
	bool lock_value() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "lock")) == 1;
	}

	/** Setter: Track is locked and all changes to it are disabled */
	void lock_value(bool value) {
		PyObject_SetAttrString(pyobjref, "lock", Py_BuildValue("i", value));
	}

	/** Getter: Use custom color instead of theme-defined */
	bool use_custom_color() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_custom_color")) == 1;
	}

	/** Setter: Use custom color instead of theme-defined */
	void use_custom_color(bool value) {
		PyObject_SetAttrString(pyobjref, "use_custom_color", Py_BuildValue("i", value));
	}

	/** Getter: Color of the track in the Movie Clip Editor and the 3D viewport after a solve */
	std::array<float, 3> color() {
		// TODO: MISSING DEREF! USE #DEFINE!
		PyObject *seqval = PyObject_GetAttrString(pyobjref, "color");
		std::array<float, 3> resarr;
		for (int i = 0; i < 3; i++)
			resarr[i] = (float)PyFloat_AsDouble(PySequence_GetItem(seqval, i));
		return resarr;
	}

	/** Setter: Color of the track in the Movie Clip Editor and the 3D viewport after a solve */
	void color(float values[3]) { /* not implemented */ }

	/** Getter: Average error of re-projection */
	float average_error() { /* not implemented */ throw NULL; }
	/** Setter: Average error of re-projection */
	void average_error(float value) {
		PyObject_SetAttrString(pyobjref, "average_error", Py_BuildValue("f", value));
	}

	/** Getter: Grease pencil data for this track */
	GreasePencil grease_pencil() {
		/* not implemented */ throw NULL;
	}

	/** Getter: Influence of this track on a final solution */
	float weight() { /* not implemented */ throw NULL; }
	/** Setter: Influence of this track on a final solution */
	void weight(float value) {
		PyObject_SetAttrString(pyobjref, "weight", Py_BuildValue("f", value));
	}

	/** Getter: Offset of track from the parenting point */
	std::array<float, 2> offset() {
		// TODO: MISSING DEREF! USE #DEFINE!
		PyObject *seqval = PyObject_GetAttrString(pyobjref, "offset");
		std::array<float, 2> resarr;
		for (int i = 0; i < 2; i++)
			resarr[i] = (float)PyFloat_AsDouble(PySequence_GetItem(seqval, i));
		return resarr;
	}

	/** Setter: Offset of track from the parenting point */
	void offset(float values[2]) { /* not implemented */ }

};

/**************** Movie Tracking Plane Marker Data ****************/

/**
 * Match-moving plane marker data for tracking
 */
class MovieTrackingPlaneMarker : public pyUniplug {
public:
	MovieTrackingPlaneMarker(PyObject* pyobj) : pyUniplug(pyobj) {}

	MovieTrackingPlaneMarker() : pyUniplug(0)
	{
		// not implemented
	}

	/** Getter: Frame number marker is keyframed on */
	int frame() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "frame"));
	}

	/** Setter: Frame number marker is keyframed on */
	void frame(int value) {
		PyObject_SetAttrString(pyobjref, "frame", Py_BuildValue("i", value));
	}

	/** Getter: Array of coordinates which represents UI rectangle corners in frame normalized coordinates */
	std::array<float, 8> corners() {
		// TODO: MISSING DEREF! USE #DEFINE!
		PyObject *seqval = PyObject_GetAttrString(pyobjref, "corners");
		std::array<float, 8> resarr;
		for (int i = 0; i < 8; i++)
			resarr[i] = (float)PyFloat_AsDouble(PySequence_GetItem(seqval, i));
		return resarr;
	}

	/** Setter: Array of coordinates which represents UI rectangle corners in frame normalized coordinates */
	void corners(float values[8]) { /* not implemented */ }

	/** Getter: Is marker muted for current frame */
	bool mute() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "mute")) == 1;
	}

	/** Setter: Is marker muted for current frame */
	void mute(bool value) {
		PyObject_SetAttrString(pyobjref, "mute", Py_BuildValue("i", value));
	}

};

/**************** Movie tracking plane track data ****************/

/**
 * Match-moving plane track data for tracking
 */
class MovieTrackingPlaneTrack : public pyUniplug {
public:
	MovieTrackingPlaneTrack(PyObject* pyobj) : pyUniplug(pyobj) {}

	MovieTrackingPlaneTrack() : pyUniplug(0)
	{
		// not implemented
	}

	/** Getter: Unique name of track */
	std::string name() { /* not implemented */ throw NULL; }
	/** Setter: Unique name of track */
	void name(const std::string& value) { /* not implemented */ }

	/** Getter: Collection of markers in track */
	std::map<std::string, MovieTrackingPlaneMarker> markers() {
		// TODO: MISSING DEREF! USE #DEFINE!
		PyObject *seqval = PyObject_GetAttrString(pyobjref, "markers");
		PyObject *seqkeys = PyObject_CallMethod(seqval, "keys", NULL);
		std::map<std::string, MovieTrackingPlaneMarker> resmap;
		for (int i = 0; i < PySequence_Length(seqval); i++) {
			PyObject *keyobj = PySequence_GetItem(seqkeys, i);
			std::string key = PyBytes_AsString(PyUnicode_AsASCIIString(keyobj));
			MovieTrackingPlaneMarker value = MovieTrackingPlaneMarker(PySequence_GetItem(seqval, i));
			resmap.insert(std::pair<std::string,MovieTrackingPlaneMarker>(key, value));
		}
		return resmap;
	}

	/** Setter: Collection of markers in track */
	void markers(std::map<std::string, MovieTrackingPlaneMarker> value) { /* not implemented */ }

	/** Getter: Plane track is selected */
	bool select() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "select")) == 1;
	}

	/** Setter: Plane track is selected */
	void select(bool value) {
		PyObject_SetAttrString(pyobjref, "select", Py_BuildValue("i", value));
	}

	/** Getter: Automatic keyframe insertion when moving plane corners */
	bool use_auto_keying() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_auto_keying")) == 1;
	}

	/** Setter: Automatic keyframe insertion when moving plane corners */
	void use_auto_keying(bool value) {
		PyObject_SetAttrString(pyobjref, "use_auto_keying", Py_BuildValue("i", value));
	}

	/** Getter: Image displayed in the track during editing in clip editor */
	Image image() {
		/* not implemented */ throw NULL;
	}

	/** Getter: Opacity of the image */
	float image_opacity() { /* not implemented */ throw NULL; }
	/** Setter: Opacity of the image */
	void image_opacity(float value) {
		PyObject_SetAttrString(pyobjref, "image_opacity", Py_BuildValue("f", value));
	}

};

/**************** Movie tracking stabilization data ****************/

/**
 * Match-moving stabilization data for tracking
 */
class MovieTrackingStabilization : public pyUniplug {
public:
	MovieTrackingStabilization(PyObject* pyobj) : pyUniplug(pyobj) {}

	MovieTrackingStabilization() : pyUniplug(0)
	{
		// not implemented
	}

	/** Getter: Use 2D stabilization for footage */
	bool use_2d_stabilization() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_2d_stabilization")) == 1;
	}

	/** Setter: Use 2D stabilization for footage */
	void use_2d_stabilization(bool value) {
		PyObject_SetAttrString(pyobjref, "use_2d_stabilization", Py_BuildValue("i", value));
	}

	/** Getter: Collection of tracks used for stabilization */
	std::map<std::string, MovieTrackingTrack> tracks() {
		// TODO: MISSING DEREF! USE #DEFINE!
		PyObject *seqval = PyObject_GetAttrString(pyobjref, "tracks");
		PyObject *seqkeys = PyObject_CallMethod(seqval, "keys", NULL);
		std::map<std::string, MovieTrackingTrack> resmap;
		for (int i = 0; i < PySequence_Length(seqval); i++) {
			PyObject *keyobj = PySequence_GetItem(seqkeys, i);
			std::string key = PyBytes_AsString(PyUnicode_AsASCIIString(keyobj));
			MovieTrackingTrack value = MovieTrackingTrack(PySequence_GetItem(seqval, i));
			resmap.insert(std::pair<std::string,MovieTrackingTrack>(key, value));
		}
		return resmap;
	}

	/** Setter: Collection of tracks used for stabilization */
	void tracks(std::map<std::string, MovieTrackingTrack> value) { /* not implemented */ }

	/** Getter: Track used to compensate rotation */
	MovieTrackingTrack rotation_track() {
		/* not implemented */ throw NULL;
	}

	/** Getter: Index of active track in stabilization tracks list */
	int active_track_index() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "active_track_index"));
	}

	/** Setter: Index of active track in stabilization tracks list */
	void active_track_index(int value) {
		PyObject_SetAttrString(pyobjref, "active_track_index", Py_BuildValue("i", value));
	}

	/** Getter: Automatically scale footage to cover unfilled areas when stabilizing */
	bool use_autoscale() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_autoscale")) == 1;
	}

	/** Setter: Automatically scale footage to cover unfilled areas when stabilizing */
	void use_autoscale(bool value) {
		PyObject_SetAttrString(pyobjref, "use_autoscale", Py_BuildValue("i", value));
	}

	/** Getter: Limit the amount of automatic scaling */
	float scale_max() { /* not implemented */ throw NULL; }
	/** Setter: Limit the amount of automatic scaling */
	void scale_max(float value) {
		PyObject_SetAttrString(pyobjref, "scale_max", Py_BuildValue("f", value));
	}

	/** Getter: Influence of stabilization algorithm on footage location */
	float influence_location() { /* not implemented */ throw NULL; }
	/** Setter: Influence of stabilization algorithm on footage location */
	void influence_location(float value) {
		PyObject_SetAttrString(pyobjref, "influence_location", Py_BuildValue("f", value));
	}

	/** Getter: Influence of stabilization algorithm on footage scale */
	float influence_scale() { /* not implemented */ throw NULL; }
	/** Setter: Influence of stabilization algorithm on footage scale */
	void influence_scale(float value) {
		PyObject_SetAttrString(pyobjref, "influence_scale", Py_BuildValue("f", value));
	}

	/** Getter: Stabilize horizon line on the shot */
	bool use_stabilize_rotation() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_stabilize_rotation")) == 1;
	}

	/** Setter: Stabilize horizon line on the shot */
	void use_stabilize_rotation(bool value) {
		PyObject_SetAttrString(pyobjref, "use_stabilize_rotation", Py_BuildValue("i", value));
	}

	/** Getter: Influence of stabilization algorithm on footage rotation */
	float influence_rotation() { /* not implemented */ throw NULL; }
	/** Setter: Influence of stabilization algorithm on footage rotation */
	void influence_rotation(float value) {
		PyObject_SetAttrString(pyobjref, "influence_rotation", Py_BuildValue("f", value));
	}

	enum filter_type_enum {
		filter_type_NEAREST = 0,
		filter_type_BILINEAR = 1,
		filter_type_BICUBIC = 2,
	};

	/** Getter: Method to use to filter stabilization */
	filter_type_enum filter_type() { /* not implemented */ throw NULL; }
	/** Setter: Method to use to filter stabilization */
	void filter_type(filter_type_enum value) { /* not implemented */ }

};

/**************** Movie tracking reconstructed camera data ****************/

/**
 * Match-moving reconstructed camera data from tracker
 */
class MovieReconstructedCamera : public pyUniplug {
public:
	MovieReconstructedCamera(PyObject* pyobj) : pyUniplug(pyobj) {}

	MovieReconstructedCamera() : pyUniplug(0)
	{
		// not implemented
	}

	/** Getter: Frame number marker is keyframed on */
	int frame() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "frame"));
	}

	/** Setter: Frame number marker is keyframed on */
	void frame(int value) {
		PyObject_SetAttrString(pyobjref, "frame", Py_BuildValue("i", value));
	}

	/** Getter: Worldspace transformation matrix */
	std::array<float, 16> matrix() {
		// TODO: MISSING DEREF! USE #DEFINE!
		PyObject *seqval = PyObject_GetAttrString(pyobjref, "matrix");
		std::array<float, 16> resarr;
		for (int i = 0; i < 16; i++)
			resarr[i] = (float)PyFloat_AsDouble(PySequence_GetItem(seqval, i));
		return resarr;
	}

	/** Setter: Worldspace transformation matrix */
	void matrix(float values[16]) { /* not implemented */ }

	/** Getter: Average error of reconstruction */
	float average_error() { /* not implemented */ throw NULL; }
	/** Setter: Average error of reconstruction */
	void average_error(float value) {
		PyObject_SetAttrString(pyobjref, "average_error", Py_BuildValue("f", value));
	}

};

/**************** Movie tracking reconstruction data ****************/

/**
 * Match-moving reconstruction data from tracker
 */
class MovieTrackingReconstruction : public pyUniplug {
public:
	MovieTrackingReconstruction(PyObject* pyobj) : pyUniplug(pyobj) {}

	MovieTrackingReconstruction() : pyUniplug(0)
	{
		// not implemented
	}

	/** Getter: Is tracking data contains valid reconstruction information */
	bool is_valid() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "is_valid")) == 1;
	}

	/** Setter: Is tracking data contains valid reconstruction information */
	void is_valid(bool value) {
		PyObject_SetAttrString(pyobjref, "is_valid", Py_BuildValue("i", value));
	}

	/** Getter: Average error of reconstruction */
	float average_error() { /* not implemented */ throw NULL; }
	/** Setter: Average error of reconstruction */
	void average_error(float value) {
		PyObject_SetAttrString(pyobjref, "average_error", Py_BuildValue("f", value));
	}

	/** Getter: Collection of solved cameras */
	std::map<std::string, MovieReconstructedCamera> cameras() {
		// TODO: MISSING DEREF! USE #DEFINE!
		PyObject *seqval = PyObject_GetAttrString(pyobjref, "cameras");
		PyObject *seqkeys = PyObject_CallMethod(seqval, "keys", NULL);
		std::map<std::string, MovieReconstructedCamera> resmap;
		for (int i = 0; i < PySequence_Length(seqval); i++) {
			PyObject *keyobj = PySequence_GetItem(seqkeys, i);
			std::string key = PyBytes_AsString(PyUnicode_AsASCIIString(keyobj));
			MovieReconstructedCamera value = MovieReconstructedCamera(PySequence_GetItem(seqval, i));
			resmap.insert(std::pair<std::string,MovieReconstructedCamera>(key, value));
		}
		return resmap;
	}

	/** Setter: Collection of solved cameras */
	void cameras(std::map<std::string, MovieReconstructedCamera> value) { /* not implemented */ }

};

/**************** Movie tracking object data ****************/

/**
 * Match-moving object tracking and reconstruction data
 */
class MovieTrackingObject : public pyUniplug {
public:
	MovieTrackingObject(PyObject* pyobj) : pyUniplug(pyobj) {}

	MovieTrackingObject() : pyUniplug(0)
	{
		// not implemented
	}

	/** Getter: Unique name of object */
	std::string name() { /* not implemented */ throw NULL; }
	/** Setter: Unique name of object */
	void name(const std::string& value) { /* not implemented */ }

	/** Getter: Object is used for camera tracking */
	bool is_camera() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "is_camera")) == 1;
	}

	/** Setter: Object is used for camera tracking */
	void is_camera(bool value) {
		PyObject_SetAttrString(pyobjref, "is_camera", Py_BuildValue("i", value));
	}

	/** Getter: Collection of tracks in this tracking data object */
	std::map<std::string, MovieTrackingTrack> tracks() {
		// TODO: MISSING DEREF! USE #DEFINE!
		PyObject *seqval = PyObject_GetAttrString(pyobjref, "tracks");
		PyObject *seqkeys = PyObject_CallMethod(seqval, "keys", NULL);
		std::map<std::string, MovieTrackingTrack> resmap;
		for (int i = 0; i < PySequence_Length(seqval); i++) {
			PyObject *keyobj = PySequence_GetItem(seqkeys, i);
			std::string key = PyBytes_AsString(PyUnicode_AsASCIIString(keyobj));
			MovieTrackingTrack value = MovieTrackingTrack(PySequence_GetItem(seqval, i));
			resmap.insert(std::pair<std::string,MovieTrackingTrack>(key, value));
		}
		return resmap;
	}

	/** Setter: Collection of tracks in this tracking data object */
	void tracks(std::map<std::string, MovieTrackingTrack> value) { /* not implemented */ }

	/** Getter: Collection of plane tracks in this tracking data object */
	std::map<std::string, MovieTrackingPlaneTrack> plane_tracks() {
		// TODO: MISSING DEREF! USE #DEFINE!
		PyObject *seqval = PyObject_GetAttrString(pyobjref, "plane_tracks");
		PyObject *seqkeys = PyObject_CallMethod(seqval, "keys", NULL);
		std::map<std::string, MovieTrackingPlaneTrack> resmap;
		for (int i = 0; i < PySequence_Length(seqval); i++) {
			PyObject *keyobj = PySequence_GetItem(seqkeys, i);
			std::string key = PyBytes_AsString(PyUnicode_AsASCIIString(keyobj));
			MovieTrackingPlaneTrack value = MovieTrackingPlaneTrack(PySequence_GetItem(seqval, i));
			resmap.insert(std::pair<std::string,MovieTrackingPlaneTrack>(key, value));
		}
		return resmap;
	}

	/** Setter: Collection of plane tracks in this tracking data object */
	void plane_tracks(std::map<std::string, MovieTrackingPlaneTrack> value) { /* not implemented */ }

	/** Getter:  */
	MovieTrackingReconstruction reconstruction() {
		/* not implemented */ throw NULL;
	}

	/** Getter: Scale of object solution in camera space */
	float scale() { /* not implemented */ throw NULL; }
	/** Setter: Scale of object solution in camera space */
	void scale(float value) {
		PyObject_SetAttrString(pyobjref, "scale", Py_BuildValue("f", value));
	}

	/** Getter: First keyframe used for reconstruction initialization */
	int keyframe_a() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "keyframe_a"));
	}

	/** Setter: First keyframe used for reconstruction initialization */
	void keyframe_a(int value) {
		PyObject_SetAttrString(pyobjref, "keyframe_a", Py_BuildValue("i", value));
	}

	/** Getter: Second keyframe used for reconstruction initialization */
	int keyframe_b() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "keyframe_b"));
	}

	/** Setter: Second keyframe used for reconstruction initialization */
	void keyframe_b(int value) {
		PyObject_SetAttrString(pyobjref, "keyframe_b", Py_BuildValue("i", value));
	}

};

/**************** Movie Tracking Dopesheet ****************/

/**
 * Match-moving dopesheet data
 */
class MovieTrackingDopesheet : public pyUniplug {
public:
	MovieTrackingDopesheet(PyObject* pyobj) : pyUniplug(pyobj) {}

	MovieTrackingDopesheet() : pyUniplug(0)
	{
		// not implemented
	}

	enum sort_method_enum {
		sort_method_NAME = 0,
		sort_method_LONGEST = 1,
		sort_method_TOTAL = 2,
		sort_method_AVERAGE_ERROR = 3,
	};

	/** Getter: Method to be used to sort channels in dopesheet view */
	sort_method_enum sort_method() { /* not implemented */ throw NULL; }
	/** Setter: Method to be used to sort channels in dopesheet view */
	void sort_method(sort_method_enum value) { /* not implemented */ }

	/** Getter: Invert sort order of dopesheet channels */
	bool use_invert_sort() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_invert_sort")) == 1;
	}

	/** Setter: Invert sort order of dopesheet channels */
	void use_invert_sort(bool value) {
		PyObject_SetAttrString(pyobjref, "use_invert_sort", Py_BuildValue("i", value));
	}

	/** Getter: Only include channels relating to selected objects and data */
	bool show_only_selected() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "show_only_selected")) == 1;
	}

	/** Setter: Only include channels relating to selected objects and data */
	void show_only_selected(bool value) {
		PyObject_SetAttrString(pyobjref, "show_only_selected", Py_BuildValue("i", value));
	}

	/** Getter: Include channels from objects/bone that aren't visible */
	bool show_hidden() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "show_hidden")) == 1;
	}

	/** Setter: Include channels from objects/bone that aren't visible */
	void show_hidden(bool value) {
		PyObject_SetAttrString(pyobjref, "show_hidden", Py_BuildValue("i", value));
	}

};

/**************** Movie tracking data ****************/

/**
 * Match-moving data for tracking
 */
class MovieTracking : public pyUniplug {
public:
	MovieTracking(PyObject* pyobj) : pyUniplug(pyobj) {}

	MovieTracking() : pyUniplug(0)
	{
		// not implemented
	}

	/** Getter:  */
	MovieTrackingSettings settings() {
		/* not implemented */ throw NULL;
	}

	/** Getter:  */
	MovieTrackingCamera camera() {
		/* not implemented */ throw NULL;
	}

	/** Getter: Collection of tracks in this tracking data object */
	std::map<std::string, MovieTrackingTrack> tracks() {
		// TODO: MISSING DEREF! USE #DEFINE!
		PyObject *seqval = PyObject_GetAttrString(pyobjref, "tracks");
		PyObject *seqkeys = PyObject_CallMethod(seqval, "keys", NULL);
		std::map<std::string, MovieTrackingTrack> resmap;
		for (int i = 0; i < PySequence_Length(seqval); i++) {
			PyObject *keyobj = PySequence_GetItem(seqkeys, i);
			std::string key = PyBytes_AsString(PyUnicode_AsASCIIString(keyobj));
			MovieTrackingTrack value = MovieTrackingTrack(PySequence_GetItem(seqval, i));
			resmap.insert(std::pair<std::string,MovieTrackingTrack>(key, value));
		}
		return resmap;
	}

	/** Setter: Collection of tracks in this tracking data object */
	void tracks(std::map<std::string, MovieTrackingTrack> value) { /* not implemented */ }

	/** Getter: Collection of plane tracks in this tracking data object */
	std::map<std::string, MovieTrackingPlaneTrack> plane_tracks() {
		// TODO: MISSING DEREF! USE #DEFINE!
		PyObject *seqval = PyObject_GetAttrString(pyobjref, "plane_tracks");
		PyObject *seqkeys = PyObject_CallMethod(seqval, "keys", NULL);
		std::map<std::string, MovieTrackingPlaneTrack> resmap;
		for (int i = 0; i < PySequence_Length(seqval); i++) {
			PyObject *keyobj = PySequence_GetItem(seqkeys, i);
			std::string key = PyBytes_AsString(PyUnicode_AsASCIIString(keyobj));
			MovieTrackingPlaneTrack value = MovieTrackingPlaneTrack(PySequence_GetItem(seqval, i));
			resmap.insert(std::pair<std::string,MovieTrackingPlaneTrack>(key, value));
		}
		return resmap;
	}

	/** Setter: Collection of plane tracks in this tracking data object */
	void plane_tracks(std::map<std::string, MovieTrackingPlaneTrack> value) { /* not implemented */ }

	/** Getter:  */
	MovieTrackingStabilization stabilization() {
		/* not implemented */ throw NULL;
	}

	/** Getter:  */
	MovieTrackingReconstruction reconstruction() {
		/* not implemented */ throw NULL;
	}

	/** Getter: Collection of objects in this tracking data object */
	std::map<std::string, MovieTrackingObject> objects() {
		// TODO: MISSING DEREF! USE #DEFINE!
		PyObject *seqval = PyObject_GetAttrString(pyobjref, "objects");
		PyObject *seqkeys = PyObject_CallMethod(seqval, "keys", NULL);
		std::map<std::string, MovieTrackingObject> resmap;
		for (int i = 0; i < PySequence_Length(seqval); i++) {
			PyObject *keyobj = PySequence_GetItem(seqkeys, i);
			std::string key = PyBytes_AsString(PyUnicode_AsASCIIString(keyobj));
			MovieTrackingObject value = MovieTrackingObject(PySequence_GetItem(seqval, i));
			resmap.insert(std::pair<std::string,MovieTrackingObject>(key, value));
		}
		return resmap;
	}

	/** Setter: Collection of objects in this tracking data object */
	void objects(std::map<std::string, MovieTrackingObject> value) { /* not implemented */ }

	/** Getter: Index of active object */
	int active_object_index() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "active_object_index"));
	}

	/** Setter: Index of active object */
	void active_object_index(int value) {
		PyObject_SetAttrString(pyobjref, "active_object_index", Py_BuildValue("i", value));
	}

	/** Getter:  */
	MovieTrackingDopesheet dopesheet() {
		/* not implemented */ throw NULL;
	}

};

/**************** Mask Parent ****************/

/**
 * Parenting settings for masking element
 */
class MaskParent : public pyUniplug {
public:
	MaskParent(PyObject* pyobj) : pyUniplug(pyobj) {}

	MaskParent() : pyUniplug(0)
	{
		// not implemented
	}

	/** Getter: ID-block to which masking element would be parented to or to it's property */
	ID id() {
		/* not implemented */ throw NULL;
	}

	enum id_type_enum {
		id_type_MOVIECLIP = 17229,
	};

	/** Getter: Type of ID-block that can be used */
	id_type_enum id_type() { /* not implemented */ throw NULL; }
	/** Setter: Type of ID-block that can be used */
	void id_type(id_type_enum value) { /* not implemented */ }

	enum type_enum {
		type_POINT_TRACK = 0,
		type_PLANE_TRACK = 1,
	};

	/** Getter: Parent Type */
	type_enum type() { /* not implemented */ throw NULL; }
	/** Setter: Parent Type */
	void type(type_enum value) { /* not implemented */ }

	/** Getter: Name of parent object in specified data block to which parenting happens */
	std::string parent() { /* not implemented */ throw NULL; }
	/** Setter: Name of parent object in specified data block to which parenting happens */
	void parent(const std::string& value) { /* not implemented */ }

	/** Getter: Name of parent sub-object in specified data block to which parenting happens */
	std::string sub_parent() { /* not implemented */ throw NULL; }
	/** Setter: Name of parent sub-object in specified data block to which parenting happens */
	void sub_parent(const std::string& value) { /* not implemented */ }

};

/**************** Mask Spline UW Point ****************/

/**
 * Single point in spline segment defining feather
 */
class MaskSplinePointUW : public pyUniplug {
public:
	MaskSplinePointUW(PyObject* pyobj) : pyUniplug(pyobj) {}

	MaskSplinePointUW() : pyUniplug(0)
	{
		// not implemented
	}

	/** Getter: U coordinate of point along spline segment */
	float u() { /* not implemented */ throw NULL; }
	/** Setter: U coordinate of point along spline segment */
	void u(float value) {
		PyObject_SetAttrString(pyobjref, "u", Py_BuildValue("f", value));
	}

	/** Getter: Weight of feather point */
	float weight() { /* not implemented */ throw NULL; }
	/** Setter: Weight of feather point */
	void weight(float value) {
		PyObject_SetAttrString(pyobjref, "weight", Py_BuildValue("f", value));
	}

	/** Getter: Selection status */
	bool select() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "select")) == 1;
	}

	/** Setter: Selection status */
	void select(bool value) {
		PyObject_SetAttrString(pyobjref, "select", Py_BuildValue("i", value));
	}

};

/**************** Mask Spline Point ****************/

/**
 * Single point in spline used for defining mask
 */
class MaskSplinePoint : public pyUniplug {
public:
	MaskSplinePoint(PyObject* pyobj) : pyUniplug(pyobj) {}

	MaskSplinePoint() : pyUniplug(0)
	{
		// not implemented
	}

	/** Getter: Coordinates of the first handle */
	std::array<float, 2> handle_left() {
		// TODO: MISSING DEREF! USE #DEFINE!
		PyObject *seqval = PyObject_GetAttrString(pyobjref, "handle_left");
		std::array<float, 2> resarr;
		for (int i = 0; i < 2; i++)
			resarr[i] = (float)PyFloat_AsDouble(PySequence_GetItem(seqval, i));
		return resarr;
	}

	/** Setter: Coordinates of the first handle */
	void handle_left(float values[2]) { /* not implemented */ }

	/** Getter: Coordinates of the control point */
	std::array<float, 2> co() {
		// TODO: MISSING DEREF! USE #DEFINE!
		PyObject *seqval = PyObject_GetAttrString(pyobjref, "co");
		std::array<float, 2> resarr;
		for (int i = 0; i < 2; i++)
			resarr[i] = (float)PyFloat_AsDouble(PySequence_GetItem(seqval, i));
		return resarr;
	}

	/** Setter: Coordinates of the control point */
	void co(float values[2]) { /* not implemented */ }

	/** Getter: Coordinates of the second handle */
	std::array<float, 2> handle_right() {
		// TODO: MISSING DEREF! USE #DEFINE!
		PyObject *seqval = PyObject_GetAttrString(pyobjref, "handle_right");
		std::array<float, 2> resarr;
		for (int i = 0; i < 2; i++)
			resarr[i] = (float)PyFloat_AsDouble(PySequence_GetItem(seqval, i));
		return resarr;
	}

	/** Setter: Coordinates of the second handle */
	void handle_right(float values[2]) { /* not implemented */ }

	enum handle_type_enum {
		handle_type_AUTO = 1,
		handle_type_VECTOR = 2,
		handle_type_ALIGNED = 3,
		handle_type_ALIGNED_DOUBLESIDE = 5,
		handle_type_FREE = 0,
	};

	/** Getter: Handle type */
	handle_type_enum handle_type() { /* not implemented */ throw NULL; }
	/** Setter: Handle type */
	void handle_type(handle_type_enum value) { /* not implemented */ }

	enum handle_left_type_enum {
		handle_left_type_AUTO = 1,
		handle_left_type_VECTOR = 2,
		handle_left_type_ALIGNED = 3,
		handle_left_type_ALIGNED_DOUBLESIDE = 5,
		handle_left_type_FREE = 0,
	};

	/** Getter: Handle type */
	handle_left_type_enum handle_left_type() { /* not implemented */ throw NULL; }
	/** Setter: Handle type */
	void handle_left_type(handle_left_type_enum value) { /* not implemented */ }

	enum handle_right_type_enum {
		handle_right_type_AUTO = 1,
		handle_right_type_VECTOR = 2,
		handle_right_type_ALIGNED = 3,
		handle_right_type_ALIGNED_DOUBLESIDE = 5,
		handle_right_type_FREE = 0,
	};

	/** Getter: Handle type */
	handle_right_type_enum handle_right_type() { /* not implemented */ throw NULL; }
	/** Setter: Handle type */
	void handle_right_type(handle_right_type_enum value) { /* not implemented */ }

	/** Getter: Weight of the point */
	float weight() { /* not implemented */ throw NULL; }
	/** Setter: Weight of the point */
	void weight(float value) {
		PyObject_SetAttrString(pyobjref, "weight", Py_BuildValue("f", value));
	}

	/** Getter: Selection status */
	bool select() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "select")) == 1;
	}

	/** Setter: Selection status */
	void select(bool value) {
		PyObject_SetAttrString(pyobjref, "select", Py_BuildValue("i", value));
	}

	/** Getter:  */
	MaskParent parent() {
		/* not implemented */ throw NULL;
	}

	/** Getter: Points defining feather */
	std::map<std::string, MaskSplinePointUW> feather_points() {
		// TODO: MISSING DEREF! USE #DEFINE!
		PyObject *seqval = PyObject_GetAttrString(pyobjref, "feather_points");
		PyObject *seqkeys = PyObject_CallMethod(seqval, "keys", NULL);
		std::map<std::string, MaskSplinePointUW> resmap;
		for (int i = 0; i < PySequence_Length(seqval); i++) {
			PyObject *keyobj = PySequence_GetItem(seqkeys, i);
			std::string key = PyBytes_AsString(PyUnicode_AsASCIIString(keyobj));
			MaskSplinePointUW value = MaskSplinePointUW(PySequence_GetItem(seqval, i));
			resmap.insert(std::pair<std::string,MaskSplinePointUW>(key, value));
		}
		return resmap;
	}

	/** Setter: Points defining feather */
	void feather_points(std::map<std::string, MaskSplinePointUW> value) { /* not implemented */ }

};

/**************** Mask spline ****************/

/**
 * Single spline used for defining mask shape
 */
class MaskSpline : public pyUniplug {
public:
	MaskSpline(PyObject* pyobj) : pyUniplug(pyobj) {}

	MaskSpline() : pyUniplug(0)
	{
		// not implemented
	}

	enum offset_mode_enum {
		offset_mode_EVEN = 0,
		offset_mode_SMOOTH = 1,
	};

	/** Getter: The method used for calculating the feather offset */
	offset_mode_enum offset_mode() { /* not implemented */ throw NULL; }
	/** Setter: The method used for calculating the feather offset */
	void offset_mode(offset_mode_enum value) { /* not implemented */ }

	enum weight_interpolation_enum {
		weight_interpolation_LINEAR = 1,
		weight_interpolation_EASE = 2,
	};

	/** Getter: The type of weight interpolation for spline */
	weight_interpolation_enum weight_interpolation() { /* not implemented */ throw NULL; }
	/** Setter: The type of weight interpolation for spline */
	void weight_interpolation(weight_interpolation_enum value) { /* not implemented */ }

	/** Getter: Make this spline a closed loop */
	bool use_cyclic() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_cyclic")) == 1;
	}

	/** Setter: Make this spline a closed loop */
	void use_cyclic(bool value) {
		PyObject_SetAttrString(pyobjref, "use_cyclic", Py_BuildValue("i", value));
	}

	/** Getter: Make this spline filled */
	bool use_fill() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_fill")) == 1;
	}

	/** Setter: Make this spline filled */
	void use_fill(bool value) {
		PyObject_SetAttrString(pyobjref, "use_fill", Py_BuildValue("i", value));
	}

	/** Getter: Prevent feather from self-intersections */
	bool use_self_intersection_check() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_self_intersection_check")) == 1;
	}

	/** Setter: Prevent feather from self-intersections */
	void use_self_intersection_check(bool value) {
		PyObject_SetAttrString(pyobjref, "use_self_intersection_check", Py_BuildValue("i", value));
	}

	/** Getter: Collection of points */
	std::map<std::string, MaskSplinePoint> points() {
		// TODO: MISSING DEREF! USE #DEFINE!
		PyObject *seqval = PyObject_GetAttrString(pyobjref, "points");
		PyObject *seqkeys = PyObject_CallMethod(seqval, "keys", NULL);
		std::map<std::string, MaskSplinePoint> resmap;
		for (int i = 0; i < PySequence_Length(seqval); i++) {
			PyObject *keyobj = PySequence_GetItem(seqkeys, i);
			std::string key = PyBytes_AsString(PyUnicode_AsASCIIString(keyobj));
			MaskSplinePoint value = MaskSplinePoint(PySequence_GetItem(seqval, i));
			resmap.insert(std::pair<std::string,MaskSplinePoint>(key, value));
		}
		return resmap;
	}

	/** Setter: Collection of points */
	void points(std::map<std::string, MaskSplinePoint> value) { /* not implemented */ }

};

/**************** Mask Layer ****************/

/**
 * Single layer used for masking pixels
 */
class MaskLayer : public pyUniplug {
public:
	MaskLayer(PyObject* pyobj) : pyUniplug(pyobj) {}

	MaskLayer() : pyUniplug(0)
	{
		// not implemented
	}

	/** Getter: Unique name of layer */
	std::string name() { /* not implemented */ throw NULL; }
	/** Setter: Unique name of layer */
	void name(const std::string& value) { /* not implemented */ }

	/** Getter: Collection of splines which defines this layer */
	std::map<std::string, MaskSpline> splines() {
		// TODO: MISSING DEREF! USE #DEFINE!
		PyObject *seqval = PyObject_GetAttrString(pyobjref, "splines");
		PyObject *seqkeys = PyObject_CallMethod(seqval, "keys", NULL);
		std::map<std::string, MaskSpline> resmap;
		for (int i = 0; i < PySequence_Length(seqval); i++) {
			PyObject *keyobj = PySequence_GetItem(seqkeys, i);
			std::string key = PyBytes_AsString(PyUnicode_AsASCIIString(keyobj));
			MaskSpline value = MaskSpline(PySequence_GetItem(seqval, i));
			resmap.insert(std::pair<std::string,MaskSpline>(key, value));
		}
		return resmap;
	}

	/** Setter: Collection of splines which defines this layer */
	void splines(std::map<std::string, MaskSpline> value) { /* not implemented */ }

	/** Getter: Restrict visibility in the viewport */
	bool hide() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "hide")) == 1;
	}

	/** Setter: Restrict visibility in the viewport */
	void hide(bool value) {
		PyObject_SetAttrString(pyobjref, "hide", Py_BuildValue("i", value));
	}

	/** Getter: Restrict selection in the viewport */
	bool hide_select() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "hide_select")) == 1;
	}

	/** Setter: Restrict selection in the viewport */
	void hide_select(bool value) {
		PyObject_SetAttrString(pyobjref, "hide_select", Py_BuildValue("i", value));
	}

	/** Getter: Restrict renderability */
	bool hide_render() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "hide_render")) == 1;
	}

	/** Setter: Restrict renderability */
	void hide_render(bool value) {
		PyObject_SetAttrString(pyobjref, "hide_render", Py_BuildValue("i", value));
	}

	/** Getter: Layer is selected for editing in the Dope Sheet */
	bool select() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "select")) == 1;
	}

	/** Setter: Layer is selected for editing in the Dope Sheet */
	void select(bool value) {
		PyObject_SetAttrString(pyobjref, "select", Py_BuildValue("i", value));
	}

	/** Getter: Render Opacity */
	float alpha() { /* not implemented */ throw NULL; }
	/** Setter: Render Opacity */
	void alpha(float value) {
		PyObject_SetAttrString(pyobjref, "alpha", Py_BuildValue("f", value));
	}

	enum blend_enum {
		blend_MERGE_ADD = 7,
		blend_MERGE_SUBTRACT = 8,
		blend_ADD = 0,
		blend_SUBTRACT = 1,
		blend_LIGHTEN = 2,
		blend_DARKEN = 3,
		blend_MUL = 4,
		blend_REPLACE = 5,
		blend_DIFFERENCE = 6,
	};

	/** Getter: Method of blending mask layers */
	blend_enum blend() { /* not implemented */ throw NULL; }
	/** Setter: Method of blending mask layers */
	void blend(blend_enum value) { /* not implemented */ }

	/** Getter: Invert the mask black/white */
	bool invert() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "invert")) == 1;
	}

	/** Setter: Invert the mask black/white */
	void invert(bool value) {
		PyObject_SetAttrString(pyobjref, "invert", Py_BuildValue("i", value));
	}

	enum falloff_enum {
		falloff_SMOOTH = 0,
		falloff_SPHERE = 1,
		falloff_ROOT = 2,
		falloff_INVERSE_SQUARE = 7,
		falloff_SHARP = 3,
		falloff_LINEAR = 4,
	};

	/** Getter: Falloff type the feather */
	falloff_enum falloff() { /* not implemented */ throw NULL; }
	/** Setter: Falloff type the feather */
	void falloff(falloff_enum value) { /* not implemented */ }

	/** Getter: Calculate holes when filling overlapping curves */
	bool use_fill_holes() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_fill_holes")) == 1;
	}

	/** Setter: Calculate holes when filling overlapping curves */
	void use_fill_holes(bool value) {
		PyObject_SetAttrString(pyobjref, "use_fill_holes", Py_BuildValue("i", value));
	}

	/** Getter: Calculate self intersections and overlap before filling */
	bool use_fill_overlap() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "use_fill_overlap")) == 1;
	}

	/** Setter: Calculate self intersections and overlap before filling */
	void use_fill_overlap(bool value) {
		PyObject_SetAttrString(pyobjref, "use_fill_overlap", Py_BuildValue("i", value));
	}

};

/**************** Mask ****************/

/**
 * Mask datablock defining mask for compositing
 */
class Mask : public ID {
public:
	Mask(PyObject* pyobj) : ID(pyobj) {}

	Mask() : ID(0)
	{
		// not implemented
	}

	/** Getter: Collection of layers which defines this mask */
	std::map<std::string, MaskLayer> layers() {
		// TODO: MISSING DEREF! USE #DEFINE!
		PyObject *seqval = PyObject_GetAttrString(pyobjref, "layers");
		PyObject *seqkeys = PyObject_CallMethod(seqval, "keys", NULL);
		std::map<std::string, MaskLayer> resmap;
		for (int i = 0; i < PySequence_Length(seqval); i++) {
			PyObject *keyobj = PySequence_GetItem(seqkeys, i);
			std::string key = PyBytes_AsString(PyUnicode_AsASCIIString(keyobj));
			MaskLayer value = MaskLayer(PySequence_GetItem(seqval, i));
			resmap.insert(std::pair<std::string,MaskLayer>(key, value));
		}
		return resmap;
	}

	/** Setter: Collection of layers which defines this mask */
	void layers(std::map<std::string, MaskLayer> value) { /* not implemented */ }

	/** Getter: Index of active layer in list of all mask's layers */
	int active_layer_index() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "active_layer_index"));
	}

	/** Setter: Index of active layer in list of all mask's layers */
	void active_layer_index(int value) {
		PyObject_SetAttrString(pyobjref, "active_layer_index", Py_BuildValue("i", value));
	}

	/** Getter: First frame of the mask (used for sequencer) */
	int frame_start() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "frame_start"));
	}

	/** Setter: First frame of the mask (used for sequencer) */
	void frame_start(int value) {
		PyObject_SetAttrString(pyobjref, "frame_start", Py_BuildValue("i", value));
	}

	/** Getter: Final frame of the mask (used for sequencer) */
	int frame_end() {
		return PyLong_AsLong(PyObject_GetAttrString(pyobjref, "frame_end"));
	}

	/** Setter: Final frame of the mask (used for sequencer) */
	void frame_end(int value) {
		PyObject_SetAttrString(pyobjref, "frame_end", Py_BuildValue("i", value));
	}

	/** Getter: Animation data for this datablock */
	AnimData animation_data() {
		/* not implemented */ throw NULL;
	}

};

} /* namespace UniplugBL */

/**************** Implementation ****************/

namespace UniplugBL {
	/**************** pyUniplug ****************/

	Context pyUniplug::context() {
		return Context(PyObject_GetAttrString(pyobjref, "context"));
	}

	/**************** Struct Definition ****************/

	// name_property
	StringProperty Struct::name_property() {
		return StringProperty(PyObject_GetAttrString(pyobjref, "name_property"));
	}

	// properties
	std::map<std::string, Property> Struct::properties() {
		// TODO: MISSING DEREF! USE #DEFINE!
		PyObject *seqval = PyObject_GetAttrString(pyobjref, "properties");
		PyObject *seqkeys = PyObject_CallMethod(seqval, "keys", NULL);
		std::map<std::string, Property> resmap;
		for (int i = 0; i < PySequence_Length(seqval); i++) {
			PyObject *keyobj = PySequence_GetItem(seqkeys, i);
			std::string key = PyBytes_AsString(PyUnicode_AsASCIIString(keyobj));
			Property value = Property(PySequence_GetItem(seqval, i));
			resmap.insert(std::pair<std::string,Property>(key, value));
		}
		return resmap;
	}

	void Struct::properties(std::map<std::string, Property> value) { /* not implemented */ }

	// functions
	std::map<std::string, Function> Struct::functions() {
		// TODO: MISSING DEREF! USE #DEFINE!
		PyObject *seqval = PyObject_GetAttrString(pyobjref, "functions");
		PyObject *seqkeys = PyObject_CallMethod(seqval, "keys", NULL);
		std::map<std::string, Function> resmap;
		for (int i = 0; i < PySequence_Length(seqval); i++) {
			PyObject *keyobj = PySequence_GetItem(seqkeys, i);
			std::string key = PyBytes_AsString(PyUnicode_AsASCIIString(keyobj));
			Function value = Function(PySequence_GetItem(seqval, i));
			resmap.insert(std::pair<std::string,Function>(key, value));
		}
		return resmap;
	}

	void Struct::functions(std::map<std::string, Function> value) { /* not implemented */ }

	/**************** Enum Definition ****************/

	// enum_items
	std::map<std::string, EnumPropertyItem> EnumProperty::enum_items() {
		// TODO: MISSING DEREF! USE #DEFINE!
		PyObject *seqval = PyObject_GetAttrString(pyobjref, "enum_items");
		PyObject *seqkeys = PyObject_CallMethod(seqval, "keys", NULL);
		std::map<std::string, EnumPropertyItem> resmap;
		for (int i = 0; i < PySequence_Length(seqval); i++) {
			PyObject *keyobj = PySequence_GetItem(seqkeys, i);
			std::string key = PyBytes_AsString(PyUnicode_AsASCIIString(keyobj));
			EnumPropertyItem value = EnumPropertyItem(PySequence_GetItem(seqval, i));
			resmap.insert(std::pair<std::string,EnumPropertyItem>(key, value));
		}
		return resmap;
	}

	void EnumProperty::enum_items(std::map<std::string, EnumPropertyItem> value) { /* not implemented */ }

	/**************** ID ****************/

	// library
	Library ID::library() {
		return Library(PyObject_GetAttrString(pyobjref, "library"));
	}

	AnimData ID::animation_data_create()
	{
		// not implemented
		return AnimData();
	}

	/**************** ID Property ****************/

	// group
	PropertyGroup PropertyGroupItem::group() {
		return PropertyGroup(PyObject_GetAttrString(pyobjref, "group"));
	}

	// collection
	std::map<std::string, PropertyGroup> PropertyGroupItem::collection() {
		// TODO: MISSING DEREF! USE #DEFINE!
		PyObject *seqval = PyObject_GetAttrString(pyobjref, "collection");
		PyObject *seqkeys = PyObject_CallMethod(seqval, "keys", NULL);
		std::map<std::string, PropertyGroup> resmap;
		for (int i = 0; i < PySequence_Length(seqval); i++) {
			PyObject *keyobj = PySequence_GetItem(seqkeys, i);
			std::string key = PyBytes_AsString(PyUnicode_AsASCIIString(keyobj));
			PropertyGroup value = PropertyGroup(PySequence_GetItem(seqval, i));
			resmap.insert(std::pair<std::string,PropertyGroup>(key, value));
		}
		return resmap;
	}

	void PropertyGroupItem::collection(std::map<std::string, PropertyGroup> value) { /* not implemented */ }

	// idp_array
	std::map<std::string, PropertyGroup> PropertyGroupItem::idp_array() {
		// TODO: MISSING DEREF! USE #DEFINE!
		PyObject *seqval = PyObject_GetAttrString(pyobjref, "idp_array");
		PyObject *seqkeys = PyObject_CallMethod(seqval, "keys", NULL);
		std::map<std::string, PropertyGroup> resmap;
		for (int i = 0; i < PySequence_Length(seqval); i++) {
			PyObject *keyobj = PySequence_GetItem(seqkeys, i);
			std::string key = PyBytes_AsString(PyUnicode_AsASCIIString(keyobj));
			PropertyGroup value = PropertyGroup(PySequence_GetItem(seqval, i));
			resmap.insert(std::pair<std::string,PropertyGroup>(key, value));
		}
		return resmap;
	}

	void PropertyGroupItem::idp_array(std::map<std::string, PropertyGroup> value) { /* not implemented */ }

	void IDMaterials::append(Material material)
	{
		// not implemented
	}

	Material IDMaterials::pop(int index, bool update_data)
	{
		// not implemented
		return Material();
	}

	/**************** Library ****************/

	// packed_file
	PackedFile Library::packed_file() {
		return PackedFile(PyObject_GetAttrString(pyobjref, "packed_file"));
	}

	/**************** Texture ****************/

	// color_ramp
	ColorRamp Texture::color_ramp() {
		return ColorRamp(PyObject_GetAttrString(pyobjref, "color_ramp"));
	}

	// node_tree
	NodeTree Texture::node_tree() {
		return NodeTree(PyObject_GetAttrString(pyobjref, "node_tree"));
	}

	// animation_data
	AnimData Texture::animation_data() {
		return AnimData(PyObject_GetAttrString(pyobjref, "animation_data"));
	}

	/**************** Image Texture ****************/

	// image
	Image ImageTexture::image() {
		return Image(PyObject_GetAttrString(pyobjref, "image"));
	}

	// image_user
	ImageUser ImageTexture::image_user() {
		return ImageUser(PyObject_GetAttrString(pyobjref, "image_user"));
	}

	/**************** Environment Map ****************/

	// image
	Image EnvironmentMapTexture::image() {
		return Image(PyObject_GetAttrString(pyobjref, "image"));
	}

	// image_user
	ImageUser EnvironmentMapTexture::image_user() {
		return ImageUser(PyObject_GetAttrString(pyobjref, "image_user"));
	}

	// environment_map
	EnvironmentMap EnvironmentMapTexture::environment_map() {
		return EnvironmentMap(PyObject_GetAttrString(pyobjref, "environment_map"));
	}

	/**************** PointDensity ****************/

	// object
	Object PointDensity::object_value() {
		return Object(PyObject_GetAttrString(pyobjref, "object"));
	}

	// particle_system
	ParticleSystem PointDensity::particle_system() {
		return ParticleSystem(PyObject_GetAttrString(pyobjref, "particle_system"));
	}

	// color_ramp
	ColorRamp PointDensity::color_ramp() {
		return ColorRamp(PyObject_GetAttrString(pyobjref, "color_ramp"));
	}

	// falloff_curve
	CurveMapping PointDensity::falloff_curve() {
		return CurveMapping(PyObject_GetAttrString(pyobjref, "falloff_curve"));
	}

	/**************** VoxelData ****************/

	// domain_object
	Object VoxelData::domain_object() {
		return Object(PyObject_GetAttrString(pyobjref, "domain_object"));
	}

	/**************** Voxel Data ****************/

	// image
	Image VoxelDataTexture::image() {
		return Image(PyObject_GetAttrString(pyobjref, "image"));
	}

	// image_user
	ImageUser VoxelDataTexture::image_user() {
		return ImageUser(PyObject_GetAttrString(pyobjref, "image_user"));
	}

	/**************** Ocean ****************/

	// ocean_object
	Object OceanTexData::ocean_object() {
		return Object(PyObject_GetAttrString(pyobjref, "ocean_object"));
	}

	/**************** EnvironmentMap ****************/

	// viewpoint_object
	Object EnvironmentMap::viewpoint_object() {
		return Object(PyObject_GetAttrString(pyobjref, "viewpoint_object"));
	}

	void EnvironmentMap::save(const std::string filepath, Scene scene, float layout[12])
	{
		// not implemented
	}

	/**************** Color Mapping ****************/

	// color_ramp
	ColorRamp ColorMapping::color_ramp() {
		return ColorRamp(PyObject_GetAttrString(pyobjref, "color_ramp"));
	}

	/**************** Action ****************/

	// fcurves
	std::map<std::string, FCurve> Action::fcurves() {
		// TODO: MISSING DEREF! USE #DEFINE!
		PyObject *seqval = PyObject_GetAttrString(pyobjref, "fcurves");
		PyObject *seqkeys = PyObject_CallMethod(seqval, "keys", NULL);
		std::map<std::string, FCurve> resmap;
		for (int i = 0; i < PySequence_Length(seqval); i++) {
			PyObject *keyobj = PySequence_GetItem(seqkeys, i);
			std::string key = PyBytes_AsString(PyUnicode_AsASCIIString(keyobj));
			FCurve value = FCurve(PySequence_GetItem(seqval, i));
			resmap.insert(std::pair<std::string,FCurve>(key, value));
		}
		return resmap;
	}

	void Action::fcurves(std::map<std::string, FCurve> value) { /* not implemented */ }

	// groups
	std::map<std::string, ActionGroup> Action::groups() {
		// TODO: MISSING DEREF! USE #DEFINE!
		PyObject *seqval = PyObject_GetAttrString(pyobjref, "groups");
		PyObject *seqkeys = PyObject_CallMethod(seqval, "keys", NULL);
		std::map<std::string, ActionGroup> resmap;
		for (int i = 0; i < PySequence_Length(seqval); i++) {
			PyObject *keyobj = PySequence_GetItem(seqkeys, i);
			std::string key = PyBytes_AsString(PyUnicode_AsASCIIString(keyobj));
			ActionGroup value = ActionGroup(PySequence_GetItem(seqval, i));
			resmap.insert(std::pair<std::string,ActionGroup>(key, value));
		}
		return resmap;
	}

	void Action::groups(std::map<std::string, ActionGroup> value) { /* not implemented */ }

	// pose_markers
	std::map<std::string, TimelineMarker> Action::pose_markers() {
		// TODO: MISSING DEREF! USE #DEFINE!
		PyObject *seqval = PyObject_GetAttrString(pyobjref, "pose_markers");
		PyObject *seqkeys = PyObject_CallMethod(seqval, "keys", NULL);
		std::map<std::string, TimelineMarker> resmap;
		for (int i = 0; i < PySequence_Length(seqval); i++) {
			PyObject *keyobj = PySequence_GetItem(seqkeys, i);
			std::string key = PyBytes_AsString(PyUnicode_AsASCIIString(keyobj));
			TimelineMarker value = TimelineMarker(PySequence_GetItem(seqval, i));
			resmap.insert(std::pair<std::string,TimelineMarker>(key, value));
		}
		return resmap;
	}

	void Action::pose_markers(std::map<std::string, TimelineMarker> value) { /* not implemented */ }

	FCurve ActionFCurves::create(const std::string data_path, int index, const std::string action_group)
	{
		// not implemented
		return FCurve();
	}

	void ActionFCurves::remove(FCurve fcurve)
	{
		// not implemented
	}

	ActionGroup ActionGroups::create(const std::string name)
	{
		// not implemented
		return ActionGroup();
	}

	void ActionGroups::remove(ActionGroup action_group)
	{
		// not implemented
	}

	/**************** Action Pose Markers ****************/

	// active
	TimelineMarker ActionPoseMarkers::active() {
		return TimelineMarker(PyObject_GetAttrString(pyobjref, "active"));
	}

	TimelineMarker ActionPoseMarkers::create(const std::string name)
	{
		// not implemented
		return TimelineMarker();
	}

	void ActionPoseMarkers::remove(TimelineMarker marker)
	{
		// not implemented
	}

	/**************** Action Group ****************/

	// channels
	std::map<std::string, FCurve> ActionGroup::channels() {
		// TODO: MISSING DEREF! USE #DEFINE!
		PyObject *seqval = PyObject_GetAttrString(pyobjref, "channels");
		PyObject *seqkeys = PyObject_CallMethod(seqval, "keys", NULL);
		std::map<std::string, FCurve> resmap;
		for (int i = 0; i < PySequence_Length(seqval); i++) {
			PyObject *keyobj = PySequence_GetItem(seqkeys, i);
			std::string key = PyBytes_AsString(PyUnicode_AsASCIIString(keyobj));
			FCurve value = FCurve(PySequence_GetItem(seqval, i));
			resmap.insert(std::pair<std::string,FCurve>(key, value));
		}
		return resmap;
	}

	void ActionGroup::channels(std::map<std::string, FCurve> value) { /* not implemented */ }

	// colors
	ThemeBoneColorSet ActionGroup::colors() {
		return ThemeBoneColorSet(PyObject_GetAttrString(pyobjref, "colors"));
	}

	/**************** Dope Sheet ****************/

	// filter_group
	Group DopeSheet::filter_group() {
		return Group(PyObject_GetAttrString(pyobjref, "filter_group"));
	}

	/**************** Animation Data ****************/

	// nla_tracks
	std::map<std::string, NlaTrack> AnimData::nla_tracks() {
		// TODO: MISSING DEREF! USE #DEFINE!
		PyObject *seqval = PyObject_GetAttrString(pyobjref, "nla_tracks");
		PyObject *seqkeys = PyObject_CallMethod(seqval, "keys", NULL);
		std::map<std::string, NlaTrack> resmap;
		for (int i = 0; i < PySequence_Length(seqval); i++) {
			PyObject *keyobj = PySequence_GetItem(seqkeys, i);
			std::string key = PyBytes_AsString(PyUnicode_AsASCIIString(keyobj));
			NlaTrack value = NlaTrack(PySequence_GetItem(seqval, i));
			resmap.insert(std::pair<std::string,NlaTrack>(key, value));
		}
		return resmap;
	}

	void AnimData::nla_tracks(std::map<std::string, NlaTrack> value) { /* not implemented */ }

	// drivers
	std::map<std::string, FCurve> AnimData::drivers() {
		// TODO: MISSING DEREF! USE #DEFINE!
		PyObject *seqval = PyObject_GetAttrString(pyobjref, "drivers");
		PyObject *seqkeys = PyObject_CallMethod(seqval, "keys", NULL);
		std::map<std::string, FCurve> resmap;
		for (int i = 0; i < PySequence_Length(seqval); i++) {
			PyObject *keyobj = PySequence_GetItem(seqkeys, i);
			std::string key = PyBytes_AsString(PyUnicode_AsASCIIString(keyobj));
			FCurve value = FCurve(PySequence_GetItem(seqval, i));
			resmap.insert(std::pair<std::string,FCurve>(key, value));
		}
		return resmap;
	}

	void AnimData::drivers(std::map<std::string, FCurve> value) { /* not implemented */ }

	/**************** NLA Tracks ****************/

	// active
	NlaTrack NlaTracks::active() {
		return NlaTrack(PyObject_GetAttrString(pyobjref, "active"));
	}

	NlaTrack NlaTracks::create(NlaTrack prev)
	{
		// not implemented
		return NlaTrack();
	}

	void NlaTracks::remove(NlaTrack track)
	{
		// not implemented
	}

	FCurve AnimDataDrivers::from_existing(FCurve src_driver)
	{
		// not implemented
		return FCurve();
	}

	/**************** Keying Set ****************/

	// type_info
	KeyingSetInfo KeyingSet::type_info() {
		return KeyingSetInfo(PyObject_GetAttrString(pyobjref, "type_info"));
	}

	// paths
	std::map<std::string, KeyingSetPath> KeyingSet::paths() {
		// TODO: MISSING DEREF! USE #DEFINE!
		PyObject *seqval = PyObject_GetAttrString(pyobjref, "paths");
		PyObject *seqkeys = PyObject_CallMethod(seqval, "keys", NULL);
		std::map<std::string, KeyingSetPath> resmap;
		for (int i = 0; i < PySequence_Length(seqval); i++) {
			PyObject *keyobj = PySequence_GetItem(seqkeys, i);
			std::string key = PyBytes_AsString(PyUnicode_AsASCIIString(keyobj));
			KeyingSetPath value = KeyingSetPath(PySequence_GetItem(seqval, i));
			resmap.insert(std::pair<std::string,KeyingSetPath>(key, value));
		}
		return resmap;
	}

	void KeyingSet::paths(std::map<std::string, KeyingSetPath> value) { /* not implemented */ }

	/**************** Keying set paths ****************/

	// active
	KeyingSetPath KeyingSetPaths::active() {
		return KeyingSetPath(PyObject_GetAttrString(pyobjref, "active"));
	}

	KeyingSetPath KeyingSetPaths::add(ID target_id, const std::string data_path, int index, keyingset_path_grouping_items group_method, const std::string group_name)
	{
		// not implemented
		return KeyingSetPath();
	}

	void KeyingSetPaths::remove(KeyingSetPath path)
	{
		// not implemented
	}

	/**************** Animation Visualization ****************/

	// onion_skin_frames
	AnimVizOnionSkinning AnimViz::onion_skin_frames() {
		return AnimVizOnionSkinning(PyObject_GetAttrString(pyobjref, "onion_skin_frames"));
	}

	// motion_path
	AnimVizMotionPaths AnimViz::motion_path() {
		return AnimVizMotionPaths(PyObject_GetAttrString(pyobjref, "motion_path"));
	}

	/**************** Motion Path ****************/

	// points
	std::map<std::string, MotionPathVert> MotionPath::points() {
		// TODO: MISSING DEREF! USE #DEFINE!
		PyObject *seqval = PyObject_GetAttrString(pyobjref, "points");
		PyObject *seqkeys = PyObject_CallMethod(seqval, "keys", NULL);
		std::map<std::string, MotionPathVert> resmap;
		for (int i = 0; i < PySequence_Length(seqval); i++) {
			PyObject *keyobj = PySequence_GetItem(seqkeys, i);
			std::string key = PyBytes_AsString(PyUnicode_AsASCIIString(keyobj));
			MotionPathVert value = MotionPathVert(PySequence_GetItem(seqval, i));
			resmap.insert(std::pair<std::string,MotionPathVert>(key, value));
		}
		return resmap;
	}

	void MotionPath::points(std::map<std::string, MotionPathVert> value) { /* not implemented */ }

	void Actuator::link(Controller controller)
	{
		// not implemented
	}

	void Actuator::unlink(Controller controller)
	{
		// not implemented
	}

	/**************** Motion Actuator ****************/

	// reference_object
	Object ObjectActuator::reference_object() {
		return Object(PyObject_GetAttrString(pyobjref, "reference_object"));
	}

	/**************** Camera Actuator ****************/

	// object
	Object CameraActuator::object_value() {
		return Object(PyObject_GetAttrString(pyobjref, "object"));
	}

	/**************** Sound ****************/

	// sound
	Sound SoundActuator::sound() {
		return Sound(PyObject_GetAttrString(pyobjref, "sound"));
	}

	/**************** Property Actuator ****************/

	// object
	Object PropertyActuator::object_value() {
		return Object(PyObject_GetAttrString(pyobjref, "object"));
	}

	/**************** Edit Object Actuator ****************/

	// object
	Object EditObjectActuator::object_value() {
		return Object(PyObject_GetAttrString(pyobjref, "object"));
	}

	// track_object
	Object EditObjectActuator::track_object() {
		return Object(PyObject_GetAttrString(pyobjref, "track_object"));
	}

	// mesh
	Mesh EditObjectActuator::mesh() {
		return Mesh(PyObject_GetAttrString(pyobjref, "mesh"));
	}

	/**************** Scene Actuator ****************/

	// camera
	Object SceneActuator::camera() {
		return Object(PyObject_GetAttrString(pyobjref, "camera"));
	}

	// scene
	Scene SceneActuator::scene() {
		return Scene(PyObject_GetAttrString(pyobjref, "scene"));
	}

	/**************** Filter 2D Actuator ****************/

	// glsl_shader
	Text Filter2DActuator::glsl_shader() {
		return Text(PyObject_GetAttrString(pyobjref, "glsl_shader"));
	}

	/**************** Parent Actuator ****************/

	// object
	Object ParentActuator::object_value() {
		return Object(PyObject_GetAttrString(pyobjref, "object"));
	}

	/**************** Armature Actuator ****************/

	// target
	Object ArmatureActuator::target() {
		return Object(PyObject_GetAttrString(pyobjref, "target"));
	}

	// secondary_target
	Object ArmatureActuator::secondary_target() {
		return Object(PyObject_GetAttrString(pyobjref, "secondary_target"));
	}

	/**************** Steering Actuator ****************/

	// target
	Object SteeringActuator::target() {
		return Object(PyObject_GetAttrString(pyobjref, "target"));
	}

	// navmesh
	Object SteeringActuator::navmesh() {
		return Object(PyObject_GetAttrString(pyobjref, "navmesh"));
	}

	/**************** Armature ****************/

	// bones
	std::map<std::string, Bone> Armature::bones() {
		// TODO: MISSING DEREF! USE #DEFINE!
		PyObject *seqval = PyObject_GetAttrString(pyobjref, "bones");
		PyObject *seqkeys = PyObject_CallMethod(seqval, "keys", NULL);
		std::map<std::string, Bone> resmap;
		for (int i = 0; i < PySequence_Length(seqval); i++) {
			PyObject *keyobj = PySequence_GetItem(seqkeys, i);
			std::string key = PyBytes_AsString(PyUnicode_AsASCIIString(keyobj));
			Bone value = Bone(PySequence_GetItem(seqval, i));
			resmap.insert(std::pair<std::string,Bone>(key, value));
		}
		return resmap;
	}

	void Armature::bones(std::map<std::string, Bone> value) { /* not implemented */ }

	// edit_bones
	std::map<std::string, EditBone> Armature::edit_bones() {
		// TODO: MISSING DEREF! USE #DEFINE!
		PyObject *seqval = PyObject_GetAttrString(pyobjref, "edit_bones");
		PyObject *seqkeys = PyObject_CallMethod(seqval, "keys", NULL);
		std::map<std::string, EditBone> resmap;
		for (int i = 0; i < PySequence_Length(seqval); i++) {
			PyObject *keyobj = PySequence_GetItem(seqkeys, i);
			std::string key = PyBytes_AsString(PyUnicode_AsASCIIString(keyobj));
			EditBone value = EditBone(PySequence_GetItem(seqval, i));
			resmap.insert(std::pair<std::string,EditBone>(key, value));
		}
		return resmap;
	}

	void Armature::edit_bones(std::map<std::string, EditBone> value) { /* not implemented */ }

	/**************** Armature Bones ****************/

	// active
	Bone ArmatureBones::active() {
		return Bone(PyObject_GetAttrString(pyobjref, "active"));
	}

	/**************** Armature EditBones ****************/

	// active
	EditBone ArmatureEditBones::active() {
		return EditBone(PyObject_GetAttrString(pyobjref, "active"));
	}

	EditBone ArmatureEditBones::create(const std::string name)
	{
		// not implemented
		return EditBone();
	}

	void ArmatureEditBones::remove(EditBone bone)
	{
		// not implemented
	}

	/**************** Goal ****************/

	// object
	Object BoidRuleGoal::object_value() {
		return Object(PyObject_GetAttrString(pyobjref, "object"));
	}

	/**************** Avoid ****************/

	// object
	Object BoidRuleAvoid::object_value() {
		return Object(PyObject_GetAttrString(pyobjref, "object"));
	}

	/**************** Follow Leader ****************/

	// object
	Object BoidRuleFollowLeader::object_value() {
		return Object(PyObject_GetAttrString(pyobjref, "object"));
	}

	/**************** Brush ****************/

	// curve
	CurveMapping Brush::curve() {
		return CurveMapping(PyObject_GetAttrString(pyobjref, "curve"));
	}

	// paint_curve
	PaintCurve Brush::paint_curve() {
		return PaintCurve(PyObject_GetAttrString(pyobjref, "paint_curve"));
	}

	// gradient
	ColorRamp Brush::gradient() {
		return ColorRamp(PyObject_GetAttrString(pyobjref, "gradient"));
	}

	// texture_slot
	BrushTextureSlot Brush::texture_slot() {
		return BrushTextureSlot(PyObject_GetAttrString(pyobjref, "texture_slot"));
	}

	// mask_texture_slot
	BrushTextureSlot Brush::mask_texture_slot() {
		return BrushTextureSlot(PyObject_GetAttrString(pyobjref, "mask_texture_slot"));
	}

	// clone_image
	Image Brush::clone_image() {
		return Image(PyObject_GetAttrString(pyobjref, "clone_image"));
	}

	// brush_capabilities
	BrushCapabilities Brush::brush_capabilities() {
		return BrushCapabilities(PyObject_GetAttrString(pyobjref, "brush_capabilities"));
	}

	// sculpt_capabilities
	SculptToolCapabilities Brush::sculpt_capabilities() {
		return SculptToolCapabilities(PyObject_GetAttrString(pyobjref, "sculpt_capabilities"));
	}

	// image_paint_capabilities
	ImapaintToolCapabilities Brush::image_paint_capabilities() {
		return ImapaintToolCapabilities(PyObject_GetAttrString(pyobjref, "image_paint_capabilities"));
	}

	/**************** Camera ****************/

	// stereo
	CameraStereoData Camera::stereo() {
		return CameraStereoData(PyObject_GetAttrString(pyobjref, "stereo"));
	}

	// dof_object
	Object Camera::dof_object() {
		return Object(PyObject_GetAttrString(pyobjref, "dof_object"));
	}

	// gpu_dof
	GPUDOFSettings Camera::gpu_dof() {
		return GPUDOFSettings(PyObject_GetAttrString(pyobjref, "gpu_dof"));
	}

	Camera::view_frame_result Camera::view_frame(Scene scene)
	{
		// not implemented
		return view_frame_result();
	}

	/**************** Cloth Settings ****************/

	// effector_weights
	EffectorWeights ClothSettings::effector_weights() {
		return EffectorWeights(PyObject_GetAttrString(pyobjref, "effector_weights"));
	}

	// rest_shape_key
	ShapeKey ClothSettings::rest_shape_key() {
		return ShapeKey(PyObject_GetAttrString(pyobjref, "rest_shape_key"));
	}

	/**************** Cloth Collision Settings ****************/

	// group
	Group ClothCollisionSettings::group() {
		return Group(PyObject_GetAttrString(pyobjref, "group"));
	}

	CurveMapPoint CurveMapPoints::create(float position, float value)
	{
		// not implemented
		return CurveMapPoint();
	}

	void CurveMapPoints::remove(CurveMapPoint point)
	{
		// not implemented
	}

	ColorRampElement ColorRampElements::create(float position)
	{
		// not implemented
		return ColorRampElement();
	}

	void ColorRampElements::remove(ColorRampElement element)
	{
		// not implemented
	}

	/**************** Constraint Target ****************/

	// target
	Object ConstraintTarget::target() {
		return Object(PyObject_GetAttrString(pyobjref, "target"));
	}

	/**************** Child Of Constraint ****************/

	// target
	Object ChildOfConstraint::target() {
		return Object(PyObject_GetAttrString(pyobjref, "target"));
	}

	/**************** Python Constraint ****************/

	// text
	Text PythonConstraint::text() {
		return Text(PyObject_GetAttrString(pyobjref, "text"));
	}

	/**************** Stretch To Constraint ****************/

	// target
	Object StretchToConstraint::target() {
		return Object(PyObject_GetAttrString(pyobjref, "target"));
	}

	/**************** Follow Path Constraint ****************/

	// target
	Object FollowPathConstraint::target() {
		return Object(PyObject_GetAttrString(pyobjref, "target"));
	}

	/**************** Locked Track Constraint ****************/

	// target
	Object LockedTrackConstraint::target() {
		return Object(PyObject_GetAttrString(pyobjref, "target"));
	}

	/**************** Action Constraint ****************/

	// target
	Object ActionConstraint::target() {
		return Object(PyObject_GetAttrString(pyobjref, "target"));
	}

	/**************** Copy Scale Constraint ****************/

	// target
	Object CopyScaleConstraint::target() {
		return Object(PyObject_GetAttrString(pyobjref, "target"));
	}

	/**************** Copy Location Constraint ****************/

	// target
	Object CopyLocationConstraint::target() {
		return Object(PyObject_GetAttrString(pyobjref, "target"));
	}

	/**************** Copy Rotation Constraint ****************/

	// target
	Object CopyRotationConstraint::target() {
		return Object(PyObject_GetAttrString(pyobjref, "target"));
	}

	/**************** Copy Transforms Constraint ****************/

	// target
	Object CopyTransformsConstraint::target() {
		return Object(PyObject_GetAttrString(pyobjref, "target"));
	}

	/**************** Floor Constraint ****************/

	// target
	Object FloorConstraint::target() {
		return Object(PyObject_GetAttrString(pyobjref, "target"));
	}

	/**************** Track To Constraint ****************/

	// target
	Object TrackToConstraint::target() {
		return Object(PyObject_GetAttrString(pyobjref, "target"));
	}

	/**************** Kinematic Constraint ****************/

	// target
	Object KinematicConstraint::target() {
		return Object(PyObject_GetAttrString(pyobjref, "target"));
	}

	// pole_target
	Object KinematicConstraint::pole_target() {
		return Object(PyObject_GetAttrString(pyobjref, "pole_target"));
	}

	/**************** Rigid Body Joint Constraint ****************/

	// target
	Object RigidBodyJointConstraint::target() {
		return Object(PyObject_GetAttrString(pyobjref, "target"));
	}

	// child
	Object RigidBodyJointConstraint::child() {
		return Object(PyObject_GetAttrString(pyobjref, "child"));
	}

	/**************** Clamp To Constraint ****************/

	// target
	Object ClampToConstraint::target() {
		return Object(PyObject_GetAttrString(pyobjref, "target"));
	}

	/**************** Limit Distance Constraint ****************/

	// target
	Object LimitDistanceConstraint::target() {
		return Object(PyObject_GetAttrString(pyobjref, "target"));
	}

	/**************** Transformation Constraint ****************/

	// target
	Object TransformConstraint::target() {
		return Object(PyObject_GetAttrString(pyobjref, "target"));
	}

	/**************** Shrinkwrap Constraint ****************/

	// target
	Object ShrinkwrapConstraint::target() {
		return Object(PyObject_GetAttrString(pyobjref, "target"));
	}

	/**************** Damped Track Constraint ****************/

	// target
	Object DampedTrackConstraint::target() {
		return Object(PyObject_GetAttrString(pyobjref, "target"));
	}

	/**************** Spline IK Constraint ****************/

	// target
	Object SplineIKConstraint::target() {
		return Object(PyObject_GetAttrString(pyobjref, "target"));
	}

	/**************** Pivot Constraint ****************/

	// target
	Object PivotConstraint::target() {
		return Object(PyObject_GetAttrString(pyobjref, "target"));
	}

	/**************** Follow Track Constraint ****************/

	// clip
	MovieClip FollowTrackConstraint::clip() {
		return MovieClip(PyObject_GetAttrString(pyobjref, "clip"));
	}

	// camera
	Object FollowTrackConstraint::camera() {
		return Object(PyObject_GetAttrString(pyobjref, "camera"));
	}

	// depth_object
	Object FollowTrackConstraint::depth_object() {
		return Object(PyObject_GetAttrString(pyobjref, "depth_object"));
	}

	/**************** Camera Solver Constraint ****************/

	// clip
	MovieClip CameraSolverConstraint::clip() {
		return MovieClip(PyObject_GetAttrString(pyobjref, "clip"));
	}

	/**************** Object Solver Constraint ****************/

	// clip
	MovieClip ObjectSolverConstraint::clip() {
		return MovieClip(PyObject_GetAttrString(pyobjref, "clip"));
	}

	// camera
	Object ObjectSolverConstraint::camera() {
		return Object(PyObject_GetAttrString(pyobjref, "camera"));
	}

	/**************** Context ****************/

	// window_manager
	WindowManager Context::window_manager() {
		return WindowManager(PyObject_GetAttrString(pyobjref, "window_manager"));
	}

	// window
	Window Context::window() {
		return Window(PyObject_GetAttrString(pyobjref, "window"));
	}

	// screen
	Screen Context::screen() {
		return Screen(PyObject_GetAttrString(pyobjref, "screen"));
	}

	// area
	Area Context::area() {
		return Area(PyObject_GetAttrString(pyobjref, "area"));
	}

	// space_data
	Space Context::space_data() {
		return Space(PyObject_GetAttrString(pyobjref, "space_data"));
	}

	// region
	Region Context::region() {
		return Region(PyObject_GetAttrString(pyobjref, "region"));
	}

	// region_data
	RegionView3D Context::region_data() {
		return RegionView3D(PyObject_GetAttrString(pyobjref, "region_data"));
	}

	// blend_data
	BlendData Context::blend_data() {
		return BlendData(PyObject_GetAttrString(pyobjref, "blend_data"));
	}

	// scene
	Scene Context::scene() {
		return Scene(PyObject_GetAttrString(pyobjref, "scene"));
	}

	// tool_settings
	ToolSettings Context::tool_settings() {
		return ToolSettings(PyObject_GetAttrString(pyobjref, "tool_settings"));
	}

	// user_preferences
	UserPreferences Context::user_preferences() {
		return UserPreferences(PyObject_GetAttrString(pyobjref, "user_preferences"));
	}

	void Controller::link(Sensor sensor, Actuator actuator)
	{
		// not implemented
	}

	void Controller::unlink(Sensor sensor, Actuator actuator)
	{
		// not implemented
	}

	/**************** Python Controller ****************/

	// text
	Text PythonController::text() {
		return Text(PyObject_GetAttrString(pyobjref, "text"));
	}

	/**************** Curve ****************/

	// shape_keys
	Key Curve::shape_keys() {
		return Key(PyObject_GetAttrString(pyobjref, "shape_keys"));
	}

	// splines
	std::map<std::string, Spline> Curve::splines() {
		// TODO: MISSING DEREF! USE #DEFINE!
		PyObject *seqval = PyObject_GetAttrString(pyobjref, "splines");
		PyObject *seqkeys = PyObject_CallMethod(seqval, "keys", NULL);
		std::map<std::string, Spline> resmap;
		for (int i = 0; i < PySequence_Length(seqval); i++) {
			PyObject *keyobj = PySequence_GetItem(seqkeys, i);
			std::string key = PyBytes_AsString(PyUnicode_AsASCIIString(keyobj));
			Spline value = Spline(PySequence_GetItem(seqval, i));
			resmap.insert(std::pair<std::string,Spline>(key, value));
		}
		return resmap;
	}

	void Curve::splines(std::map<std::string, Spline> value) { /* not implemented */ }

	// bevel_object
	Object Curve::bevel_object() {
		return Object(PyObject_GetAttrString(pyobjref, "bevel_object"));
	}

	// taper_object
	Object Curve::taper_object() {
		return Object(PyObject_GetAttrString(pyobjref, "taper_object"));
	}

	// materials
	std::map<std::string, Material> Curve::materials() {
		// TODO: MISSING DEREF! USE #DEFINE!
		PyObject *seqval = PyObject_GetAttrString(pyobjref, "materials");
		PyObject *seqkeys = PyObject_CallMethod(seqval, "keys", NULL);
		std::map<std::string, Material> resmap;
		for (int i = 0; i < PySequence_Length(seqval); i++) {
			PyObject *keyobj = PySequence_GetItem(seqkeys, i);
			std::string key = PyBytes_AsString(PyUnicode_AsASCIIString(keyobj));
			Material value = Material(PySequence_GetItem(seqval, i));
			resmap.insert(std::pair<std::string,Material>(key, value));
		}
		return resmap;
	}

	void Curve::materials(std::map<std::string, Material> value) { /* not implemented */ }

	/**************** Curve Splines ****************/

	// active
	Spline CurveSplines::active() {
		return Spline(PyObject_GetAttrString(pyobjref, "active"));
	}

	Spline CurveSplines::create(curve_type_items type)
	{
		// not implemented
		return Spline();
	}

	void CurveSplines::remove(Spline spline)
	{
		// not implemented
	}

	/**************** Text Curve ****************/

	// text_boxes
	std::map<std::string, TextBox> TextCurve::text_boxes() {
		// TODO: MISSING DEREF! USE #DEFINE!
		PyObject *seqval = PyObject_GetAttrString(pyobjref, "text_boxes");
		PyObject *seqkeys = PyObject_CallMethod(seqval, "keys", NULL);
		std::map<std::string, TextBox> resmap;
		for (int i = 0; i < PySequence_Length(seqval); i++) {
			PyObject *keyobj = PySequence_GetItem(seqkeys, i);
			std::string key = PyBytes_AsString(PyUnicode_AsASCIIString(keyobj));
			TextBox value = TextBox(PySequence_GetItem(seqval, i));
			resmap.insert(std::pair<std::string,TextBox>(key, value));
		}
		return resmap;
	}

	void TextCurve::text_boxes(std::map<std::string, TextBox> value) { /* not implemented */ }

	// body_format
	std::map<std::string, TextCharacterFormat> TextCurve::body_format() {
		// TODO: MISSING DEREF! USE #DEFINE!
		PyObject *seqval = PyObject_GetAttrString(pyobjref, "body_format");
		PyObject *seqkeys = PyObject_CallMethod(seqval, "keys", NULL);
		std::map<std::string, TextCharacterFormat> resmap;
		for (int i = 0; i < PySequence_Length(seqval); i++) {
			PyObject *keyobj = PySequence_GetItem(seqkeys, i);
			std::string key = PyBytes_AsString(PyUnicode_AsASCIIString(keyobj));
			TextCharacterFormat value = TextCharacterFormat(PySequence_GetItem(seqval, i));
			resmap.insert(std::pair<std::string,TextCharacterFormat>(key, value));
		}
		return resmap;
	}

	void TextCurve::body_format(std::map<std::string, TextCharacterFormat> value) { /* not implemented */ }

	// follow_curve
	Object TextCurve::follow_curve() {
		return Object(PyObject_GetAttrString(pyobjref, "follow_curve"));
	}

	// font
	VectorFont TextCurve::font() {
		return VectorFont(PyObject_GetAttrString(pyobjref, "font"));
	}

	// font_bold
	VectorFont TextCurve::font_bold() {
		return VectorFont(PyObject_GetAttrString(pyobjref, "font_bold"));
	}

	// font_italic
	VectorFont TextCurve::font_italic() {
		return VectorFont(PyObject_GetAttrString(pyobjref, "font_italic"));
	}

	// font_bold_italic
	VectorFont TextCurve::font_bold_italic() {
		return VectorFont(PyObject_GetAttrString(pyobjref, "font_bold_italic"));
	}

	// edit_format
	TextCharacterFormat TextCurve::edit_format() {
		return TextCharacterFormat(PyObject_GetAttrString(pyobjref, "edit_format"));
	}

	/**************** Canvas Settings ****************/

	// canvas_surfaces
	std::map<std::string, DynamicPaintSurface> DynamicPaintCanvasSettings::canvas_surfaces() {
		// TODO: MISSING DEREF! USE #DEFINE!
		PyObject *seqval = PyObject_GetAttrString(pyobjref, "canvas_surfaces");
		PyObject *seqkeys = PyObject_CallMethod(seqval, "keys", NULL);
		std::map<std::string, DynamicPaintSurface> resmap;
		for (int i = 0; i < PySequence_Length(seqval); i++) {
			PyObject *keyobj = PySequence_GetItem(seqkeys, i);
			std::string key = PyBytes_AsString(PyUnicode_AsASCIIString(keyobj));
			DynamicPaintSurface value = DynamicPaintSurface(PySequence_GetItem(seqval, i));
			resmap.insert(std::pair<std::string,DynamicPaintSurface>(key, value));
		}
		return resmap;
	}

	void DynamicPaintCanvasSettings::canvas_surfaces(std::map<std::string, DynamicPaintSurface> value) { /* not implemented */ }

	/**************** Canvas Surfaces ****************/

	// active
	DynamicPaintSurface DynamicPaintSurfaces::active() {
		return DynamicPaintSurface(PyObject_GetAttrString(pyobjref, "active"));
	}

	/**************** Brush Settings ****************/

	// material
	Material DynamicPaintBrushSettings::material() {
		return Material(PyObject_GetAttrString(pyobjref, "material"));
	}

	// particle_system
	ParticleSystem DynamicPaintBrushSettings::particle_system() {
		return ParticleSystem(PyObject_GetAttrString(pyobjref, "particle_system"));
	}

	/**************** Paint Surface ****************/

	// brush_group
	Group DynamicPaintSurface::brush_group() {
		return Group(PyObject_GetAttrString(pyobjref, "brush_group"));
	}

	// effector_weights
	EffectorWeights DynamicPaintSurface::effector_weights() {
		return EffectorWeights(PyObject_GetAttrString(pyobjref, "effector_weights"));
	}

	// point_cache
	PointCache DynamicPaintSurface::point_cache() {
		return PointCache(PyObject_GetAttrString(pyobjref, "point_cache"));
	}

	bool DynamicPaintSurface::output_exists(Object object_value, int index)
	{
		// not implemented
		return true;
	}

	/**************** F-Curve ****************/

	// driver
	Driver FCurve::driver() {
		return Driver(PyObject_GetAttrString(pyobjref, "driver"));
	}

	// sampled_points
	std::map<std::string, FCurveSample> FCurve::sampled_points() {
		// TODO: MISSING DEREF! USE #DEFINE!
		PyObject *seqval = PyObject_GetAttrString(pyobjref, "sampled_points");
		PyObject *seqkeys = PyObject_CallMethod(seqval, "keys", NULL);
		std::map<std::string, FCurveSample> resmap;
		for (int i = 0; i < PySequence_Length(seqval); i++) {
			PyObject *keyobj = PySequence_GetItem(seqkeys, i);
			std::string key = PyBytes_AsString(PyUnicode_AsASCIIString(keyobj));
			FCurveSample value = FCurveSample(PySequence_GetItem(seqval, i));
			resmap.insert(std::pair<std::string,FCurveSample>(key, value));
		}
		return resmap;
	}

	void FCurve::sampled_points(std::map<std::string, FCurveSample> value) { /* not implemented */ }

	// keyframe_points
	std::map<std::string, Keyframe> FCurve::keyframe_points() {
		// TODO: MISSING DEREF! USE #DEFINE!
		PyObject *seqval = PyObject_GetAttrString(pyobjref, "keyframe_points");
		PyObject *seqkeys = PyObject_CallMethod(seqval, "keys", NULL);
		std::map<std::string, Keyframe> resmap;
		for (int i = 0; i < PySequence_Length(seqval); i++) {
			PyObject *keyobj = PySequence_GetItem(seqkeys, i);
			std::string key = PyBytes_AsString(PyUnicode_AsASCIIString(keyobj));
			Keyframe value = Keyframe(PySequence_GetItem(seqval, i));
			resmap.insert(std::pair<std::string,Keyframe>(key, value));
		}
		return resmap;
	}

	void FCurve::keyframe_points(std::map<std::string, Keyframe> value) { /* not implemented */ }

	// modifiers
	std::map<std::string, FModifier> FCurve::modifiers() {
		// TODO: MISSING DEREF! USE #DEFINE!
		PyObject *seqval = PyObject_GetAttrString(pyobjref, "modifiers");
		PyObject *seqkeys = PyObject_CallMethod(seqval, "keys", NULL);
		std::map<std::string, FModifier> resmap;
		for (int i = 0; i < PySequence_Length(seqval); i++) {
			PyObject *keyobj = PySequence_GetItem(seqkeys, i);
			std::string key = PyBytes_AsString(PyUnicode_AsASCIIString(keyobj));
			FModifier value = FModifier(PySequence_GetItem(seqval, i));
			resmap.insert(std::pair<std::string,FModifier>(key, value));
		}
		return resmap;
	}

	void FCurve::modifiers(std::map<std::string, FModifier> value) { /* not implemented */ }

	Keyframe FCurveKeyframePoints::insert(float frame, float value, items options)
	{
		// not implemented
		return Keyframe();
	}

	void FCurveKeyframePoints::remove(Keyframe keyframe, bool fast)
	{
		// not implemented
	}

	/**************** F-Curve Modifiers ****************/

	// active
	FModifier FCurveModifiers::active() {
		return FModifier(PyObject_GetAttrString(pyobjref, "active"));
	}

	FModifier FCurveModifiers::create(fmodifier_type_items type)
	{
		// not implemented
		return FModifier();
	}

	void FCurveModifiers::remove(FModifier modifier)
	{
		// not implemented
	}

	DriverVariable ChannelDriverVariables::create()
	{
		// not implemented
		return DriverVariable();
	}

	void ChannelDriverVariables::remove(DriverVariable variable)
	{
		// not implemented
	}

	/**************** Envelope F-Modifier ****************/

	// control_points
	std::map<std::string, FModifierEnvelopeControlPoint> FModifierEnvelope::control_points() {
		// TODO: MISSING DEREF! USE #DEFINE!
		PyObject *seqval = PyObject_GetAttrString(pyobjref, "control_points");
		PyObject *seqkeys = PyObject_CallMethod(seqval, "keys", NULL);
		std::map<std::string, FModifierEnvelopeControlPoint> resmap;
		for (int i = 0; i < PySequence_Length(seqval); i++) {
			PyObject *keyobj = PySequence_GetItem(seqkeys, i);
			std::string key = PyBytes_AsString(PyUnicode_AsASCIIString(keyobj));
			FModifierEnvelopeControlPoint value = FModifierEnvelopeControlPoint(PySequence_GetItem(seqval, i));
			resmap.insert(std::pair<std::string,FModifierEnvelopeControlPoint>(key, value));
		}
		return resmap;
	}

	void FModifierEnvelope::control_points(std::map<std::string, FModifierEnvelopeControlPoint> value) { /* not implemented */ }

	FModifierEnvelopeControlPoint FModifierEnvelopeControlPoints::add(float frame)
	{
		// not implemented
		return FModifierEnvelopeControlPoint();
	}

	void FModifierEnvelopeControlPoints::remove(FModifierEnvelopeControlPoint point)
	{
		// not implemented
	}

	/**************** Domain Fluid Simulation Settings ****************/

	// fluid_mesh_vertices
	std::map<std::string, FluidMeshVertex> DomainFluidSettings::fluid_mesh_vertices() {
		// TODO: MISSING DEREF! USE #DEFINE!
		PyObject *seqval = PyObject_GetAttrString(pyobjref, "fluid_mesh_vertices");
		PyObject *seqkeys = PyObject_CallMethod(seqval, "keys", NULL);
		std::map<std::string, FluidMeshVertex> resmap;
		for (int i = 0; i < PySequence_Length(seqval); i++) {
			PyObject *keyobj = PySequence_GetItem(seqkeys, i);
			std::string key = PyBytes_AsString(PyUnicode_AsASCIIString(keyobj));
			FluidMeshVertex value = FluidMeshVertex(PySequence_GetItem(seqval, i));
			resmap.insert(std::pair<std::string,FluidMeshVertex>(key, value));
		}
		return resmap;
	}

	void DomainFluidSettings::fluid_mesh_vertices(std::map<std::string, FluidMeshVertex> value) { /* not implemented */ }

	/**************** Grease Pencil ****************/

	// layers
	std::map<std::string, GPencilLayer> GreasePencil::layers() {
		// TODO: MISSING DEREF! USE #DEFINE!
		PyObject *seqval = PyObject_GetAttrString(pyobjref, "layers");
		PyObject *seqkeys = PyObject_CallMethod(seqval, "keys", NULL);
		std::map<std::string, GPencilLayer> resmap;
		for (int i = 0; i < PySequence_Length(seqval); i++) {
			PyObject *keyobj = PySequence_GetItem(seqkeys, i);
			std::string key = PyBytes_AsString(PyUnicode_AsASCIIString(keyobj));
			GPencilLayer value = GPencilLayer(PySequence_GetItem(seqval, i));
			resmap.insert(std::pair<std::string,GPencilLayer>(key, value));
		}
		return resmap;
	}

	void GreasePencil::layers(std::map<std::string, GPencilLayer> value) { /* not implemented */ }

	/**************** Grease Pencil Layers ****************/

	// active
	GPencilLayer GreasePencilLayers::active() {
		return GPencilLayer(PyObject_GetAttrString(pyobjref, "active"));
	}

	GPencilLayer GreasePencilLayers::create(const std::string name, bool set_active)
	{
		// not implemented
		return GPencilLayer();
	}

	void GreasePencilLayers::remove(GPencilLayer layer)
	{
		// not implemented
	}

	/**************** Grease Pencil Layer ****************/

	// frames
	std::map<std::string, GPencilFrame> GPencilLayer::frames() {
		// TODO: MISSING DEREF! USE #DEFINE!
		PyObject *seqval = PyObject_GetAttrString(pyobjref, "frames");
		PyObject *seqkeys = PyObject_CallMethod(seqval, "keys", NULL);
		std::map<std::string, GPencilFrame> resmap;
		for (int i = 0; i < PySequence_Length(seqval); i++) {
			PyObject *keyobj = PySequence_GetItem(seqkeys, i);
			std::string key = PyBytes_AsString(PyUnicode_AsASCIIString(keyobj));
			GPencilFrame value = GPencilFrame(PySequence_GetItem(seqval, i));
			resmap.insert(std::pair<std::string,GPencilFrame>(key, value));
		}
		return resmap;
	}

	void GPencilLayer::frames(std::map<std::string, GPencilFrame> value) { /* not implemented */ }

	// active_frame
	GPencilFrame GPencilLayer::active_frame() {
		return GPencilFrame(PyObject_GetAttrString(pyobjref, "active_frame"));
	}

	GPencilFrame GPencilFrames::create(int frame_number)
	{
		// not implemented
		return GPencilFrame();
	}

	void GPencilFrames::remove(GPencilFrame frame)
	{
		// not implemented
	}

	GPencilFrame GPencilFrames::copy(GPencilFrame source)
	{
		// not implemented
		return GPencilFrame();
	}

	/**************** Grease Pencil Frame ****************/

	// strokes
	std::map<std::string, GPencilStroke> GPencilFrame::strokes() {
		// TODO: MISSING DEREF! USE #DEFINE!
		PyObject *seqval = PyObject_GetAttrString(pyobjref, "strokes");
		PyObject *seqkeys = PyObject_CallMethod(seqval, "keys", NULL);
		std::map<std::string, GPencilStroke> resmap;
		for (int i = 0; i < PySequence_Length(seqval); i++) {
			PyObject *keyobj = PySequence_GetItem(seqkeys, i);
			std::string key = PyBytes_AsString(PyUnicode_AsASCIIString(keyobj));
			GPencilStroke value = GPencilStroke(PySequence_GetItem(seqval, i));
			resmap.insert(std::pair<std::string,GPencilStroke>(key, value));
		}
		return resmap;
	}

	void GPencilFrame::strokes(std::map<std::string, GPencilStroke> value) { /* not implemented */ }

	GPencilStroke GPencilStrokes::create()
	{
		// not implemented
		return GPencilStroke();
	}

	void GPencilStrokes::remove(GPencilStroke stroke)
	{
		// not implemented
	}

	/**************** Grease Pencil Stroke ****************/

	// points
	std::map<std::string, GPencilStrokePoint> GPencilStroke::points() {
		// TODO: MISSING DEREF! USE #DEFINE!
		PyObject *seqval = PyObject_GetAttrString(pyobjref, "points");
		PyObject *seqkeys = PyObject_CallMethod(seqval, "keys", NULL);
		std::map<std::string, GPencilStrokePoint> resmap;
		for (int i = 0; i < PySequence_Length(seqval); i++) {
			PyObject *keyobj = PySequence_GetItem(seqkeys, i);
			std::string key = PyBytes_AsString(PyUnicode_AsASCIIString(keyobj));
			GPencilStrokePoint value = GPencilStrokePoint(PySequence_GetItem(seqval, i));
			resmap.insert(std::pair<std::string,GPencilStrokePoint>(key, value));
		}
		return resmap;
	}

	void GPencilStroke::points(std::map<std::string, GPencilStrokePoint> value) { /* not implemented */ }

	/**************** Group ****************/

	// objects
	std::map<std::string, Object> Group::objects() {
		// TODO: MISSING DEREF! USE #DEFINE!
		PyObject *seqval = PyObject_GetAttrString(pyobjref, "objects");
		PyObject *seqkeys = PyObject_CallMethod(seqval, "keys", NULL);
		std::map<std::string, Object> resmap;
		for (int i = 0; i < PySequence_Length(seqval); i++) {
			PyObject *keyobj = PySequence_GetItem(seqkeys, i);
			std::string key = PyBytes_AsString(PyUnicode_AsASCIIString(keyobj));
			Object value = Object(PySequence_GetItem(seqval, i));
			resmap.insert(std::pair<std::string,Object>(key, value));
		}
		return resmap;
	}

	void Group::objects(std::map<std::string, Object> value) { /* not implemented */ }

	void GroupObjects::link(Object object_value)
	{
		// not implemented
	}

	void GroupObjects::unlink(Object object_value)
	{
		// not implemented
	}

	/**************** Render Slots ****************/

	// active
	RenderSlot RenderSlots::active() {
		return RenderSlot(PyObject_GetAttrString(pyobjref, "active"));
	}

	/**************** Image ****************/

	// packed_file
	PackedFile Image::packed_file() {
		return PackedFile(PyObject_GetAttrString(pyobjref, "packed_file"));
	}

	// packed_files
	std::map<std::string, ImagePackedFile> Image::packed_files() {
		// TODO: MISSING DEREF! USE #DEFINE!
		PyObject *seqval = PyObject_GetAttrString(pyobjref, "packed_files");
		PyObject *seqkeys = PyObject_CallMethod(seqval, "keys", NULL);
		std::map<std::string, ImagePackedFile> resmap;
		for (int i = 0; i < PySequence_Length(seqval); i++) {
			PyObject *keyobj = PySequence_GetItem(seqkeys, i);
			std::string key = PyBytes_AsString(PyUnicode_AsASCIIString(keyobj));
			ImagePackedFile value = ImagePackedFile(PySequence_GetItem(seqval, i));
			resmap.insert(std::pair<std::string,ImagePackedFile>(key, value));
		}
		return resmap;
	}

	void Image::packed_files(std::map<std::string, ImagePackedFile> value) { /* not implemented */ }

	// stereo_3d_format
	Stereo3dFormat Image::stereo_3d_format() {
		return Stereo3dFormat(PyObject_GetAttrString(pyobjref, "stereo_3d_format"));
	}

	void Image::save_render(const std::string filepath, Scene scene)
	{
		// not implemented
	}

	std::string Image::filepath_from_user(ImageUser image_user)
	{
		// not implemented
		throw NULL;
	}

	/**************** ImagePackedFile ****************/

	// packed_file
	PackedFile ImagePackedFile::packed_file() {
		return PackedFile(PyObject_GetAttrString(pyobjref, "packed_file"));
	}

	/**************** Key ****************/

	// reference_key
	ShapeKey Key::reference_key() {
		return ShapeKey(PyObject_GetAttrString(pyobjref, "reference_key"));
	}

	// key_blocks
	std::map<std::string, ShapeKey> Key::key_blocks() {
		// TODO: MISSING DEREF! USE #DEFINE!
		PyObject *seqval = PyObject_GetAttrString(pyobjref, "key_blocks");
		PyObject *seqkeys = PyObject_CallMethod(seqval, "keys", NULL);
		std::map<std::string, ShapeKey> resmap;
		for (int i = 0; i < PySequence_Length(seqval); i++) {
			PyObject *keyobj = PySequence_GetItem(seqkeys, i);
			std::string key = PyBytes_AsString(PyUnicode_AsASCIIString(keyobj));
			ShapeKey value = ShapeKey(PySequence_GetItem(seqval, i));
			resmap.insert(std::pair<std::string,ShapeKey>(key, value));
		}
		return resmap;
	}

	void Key::key_blocks(std::map<std::string, ShapeKey> value) { /* not implemented */ }

	/**************** Lamp ****************/

	// node_tree
	NodeTree Lamp::node_tree() {
		return NodeTree(PyObject_GetAttrString(pyobjref, "node_tree"));
	}

	// texture_slots
	std::map<std::string, LampTextureSlot> Lamp::texture_slots() {
		// TODO: MISSING DEREF! USE #DEFINE!
		PyObject *seqval = PyObject_GetAttrString(pyobjref, "texture_slots");
		PyObject *seqkeys = PyObject_CallMethod(seqval, "keys", NULL);
		std::map<std::string, LampTextureSlot> resmap;
		for (int i = 0; i < PySequence_Length(seqval); i++) {
			PyObject *keyobj = PySequence_GetItem(seqkeys, i);
			std::string key = PyBytes_AsString(PyUnicode_AsASCIIString(keyobj));
			LampTextureSlot value = LampTextureSlot(PySequence_GetItem(seqval, i));
			resmap.insert(std::pair<std::string,LampTextureSlot>(key, value));
		}
		return resmap;
	}

	void Lamp::texture_slots(std::map<std::string, LampTextureSlot> value) { /* not implemented */ }

	LampTextureSlot LampTextureSlots::add()
	{
		// not implemented
		return LampTextureSlot();
	}

	LampTextureSlot LampTextureSlots::create(int index)
	{
		// not implemented
		return LampTextureSlot();
	}

	/**************** Sun Lamp ****************/

	// sky
	LampSkySettings SunLamp::sky() {
		return LampSkySettings(PyObject_GetAttrString(pyobjref, "sky"));
	}

	/**************** Lamp Texture Slot ****************/

	// object
	Object LampTextureSlot::object_value() {
		return Object(PyObject_GetAttrString(pyobjref, "object"));
	}

	/**************** Lattice ****************/

	// points
	std::map<std::string, LatticePoint> Lattice::points() {
		// TODO: MISSING DEREF! USE #DEFINE!
		PyObject *seqval = PyObject_GetAttrString(pyobjref, "points");
		PyObject *seqkeys = PyObject_CallMethod(seqval, "keys", NULL);
		std::map<std::string, LatticePoint> resmap;
		for (int i = 0; i < PySequence_Length(seqval); i++) {
			PyObject *keyobj = PySequence_GetItem(seqkeys, i);
			std::string key = PyBytes_AsString(PyUnicode_AsASCIIString(keyobj));
			LatticePoint value = LatticePoint(PySequence_GetItem(seqval, i));
			resmap.insert(std::pair<std::string,LatticePoint>(key, value));
		}
		return resmap;
	}

	void Lattice::points(std::map<std::string, LatticePoint> value) { /* not implemented */ }

	/**************** LatticePoint ****************/

	// groups
	std::map<std::string, VertexGroupElement> LatticePoint::groups() {
		// TODO: MISSING DEREF! USE #DEFINE!
		PyObject *seqval = PyObject_GetAttrString(pyobjref, "groups");
		PyObject *seqkeys = PyObject_CallMethod(seqval, "keys", NULL);
		std::map<std::string, VertexGroupElement> resmap;
		for (int i = 0; i < PySequence_Length(seqval); i++) {
			PyObject *keyobj = PySequence_GetItem(seqkeys, i);
			std::string key = PyBytes_AsString(PyUnicode_AsASCIIString(keyobj));
			VertexGroupElement value = VertexGroupElement(PySequence_GetItem(seqval, i));
			resmap.insert(std::pair<std::string,VertexGroupElement>(key, value));
		}
		return resmap;
	}

	void LatticePoint::groups(std::map<std::string, VertexGroupElement> value) { /* not implemented */ }

	/**************** Distance from Object ****************/

	// target
	Object LineStyleColorModifier_DistanceFromObject::target() {
		return Object(PyObject_GetAttrString(pyobjref, "target"));
	}

	/**************** Distance from Object ****************/

	// target
	Object LineStyleAlphaModifier_DistanceFromObject::target() {
		return Object(PyObject_GetAttrString(pyobjref, "target"));
	}

	/**************** Distance from Object ****************/

	// target
	Object LineStyleThicknessModifier_DistanceFromObject::target() {
		return Object(PyObject_GetAttrString(pyobjref, "target"));
	}

	/**************** Freestyle Line Style ****************/

	// texture_slots
	std::map<std::string, LineStyleTextureSlot> FreestyleLineStyle::texture_slots() {
		// TODO: MISSING DEREF! USE #DEFINE!
		PyObject *seqval = PyObject_GetAttrString(pyobjref, "texture_slots");
		PyObject *seqkeys = PyObject_CallMethod(seqval, "keys", NULL);
		std::map<std::string, LineStyleTextureSlot> resmap;
		for (int i = 0; i < PySequence_Length(seqval); i++) {
			PyObject *keyobj = PySequence_GetItem(seqkeys, i);
			std::string key = PyBytes_AsString(PyUnicode_AsASCIIString(keyobj));
			LineStyleTextureSlot value = LineStyleTextureSlot(PySequence_GetItem(seqval, i));
			resmap.insert(std::pair<std::string,LineStyleTextureSlot>(key, value));
		}
		return resmap;
	}

	void FreestyleLineStyle::texture_slots(std::map<std::string, LineStyleTextureSlot> value) { /* not implemented */ }

	// node_tree
	NodeTree FreestyleLineStyle::node_tree() {
		return NodeTree(PyObject_GetAttrString(pyobjref, "node_tree"));
	}

	LineStyleTextureSlot LineStyleTextureSlots::add()
	{
		// not implemented
		return LineStyleTextureSlot();
	}

	LineStyleTextureSlot LineStyleTextureSlots::create(int index)
	{
		// not implemented
		return LineStyleTextureSlot();
	}

	LineStyleColorModifier LineStyleColorModifiers::create(const std::string name, linestyle_color_modifier_type_items type)
	{
		// not implemented
		return LineStyleColorModifier();
	}

	void LineStyleColorModifiers::remove(LineStyleColorModifier modifier)
	{
		// not implemented
	}

	LineStyleAlphaModifier LineStyleAlphaModifiers::create(const std::string name, linestyle_alpha_modifier_type_items type)
	{
		// not implemented
		return LineStyleAlphaModifier();
	}

	void LineStyleAlphaModifiers::remove(LineStyleAlphaModifier modifier)
	{
		// not implemented
	}

	LineStyleThicknessModifier LineStyleThicknessModifiers::create(const std::string name, linestyle_thickness_modifier_type_items type)
	{
		// not implemented
		return LineStyleThicknessModifier();
	}

	void LineStyleThicknessModifiers::remove(LineStyleThicknessModifier modifier)
	{
		// not implemented
	}

	LineStyleGeometryModifier LineStyleGeometryModifiers::create(const std::string name, linestyle_geometry_modifier_type_items type)
	{
		// not implemented
		return LineStyleGeometryModifier();
	}

	void LineStyleGeometryModifiers::remove(LineStyleGeometryModifier modifier)
	{
		// not implemented
	}

	/**************** Blendfile Data ****************/

	// scenes
	std::map<std::string, Scene> BlendData::scenes() {
		// TODO: MISSING DEREF! USE #DEFINE!
		PyObject *seqval = PyObject_GetAttrString(pyobjref, "scenes");
		PyObject *seqkeys = PyObject_CallMethod(seqval, "keys", NULL);
		std::map<std::string, Scene> resmap;
		for (int i = 0; i < PySequence_Length(seqval); i++) {
			PyObject *keyobj = PySequence_GetItem(seqkeys, i);
			std::string key = PyBytes_AsString(PyUnicode_AsASCIIString(keyobj));
			Scene value = Scene(PySequence_GetItem(seqval, i));
			resmap.insert(std::pair<std::string,Scene>(key, value));
		}
		return resmap;
	}

	void BlendData::scenes(std::map<std::string, Scene> value) { /* not implemented */ }

	// objects
	std::map<std::string, Object> BlendData::objects() {
		// TODO: MISSING DEREF! USE #DEFINE!
		PyObject *seqval = PyObject_GetAttrString(pyobjref, "objects");
		PyObject *seqkeys = PyObject_CallMethod(seqval, "keys", NULL);
		std::map<std::string, Object> resmap;
		for (int i = 0; i < PySequence_Length(seqval); i++) {
			PyObject *keyobj = PySequence_GetItem(seqkeys, i);
			std::string key = PyBytes_AsString(PyUnicode_AsASCIIString(keyobj));
			Object value = Object(PySequence_GetItem(seqval, i));
			resmap.insert(std::pair<std::string,Object>(key, value));
		}
		return resmap;
	}

	void BlendData::objects(std::map<std::string, Object> value) { /* not implemented */ }

	// materials
	std::map<std::string, Material> BlendData::materials() {
		// TODO: MISSING DEREF! USE #DEFINE!
		PyObject *seqval = PyObject_GetAttrString(pyobjref, "materials");
		PyObject *seqkeys = PyObject_CallMethod(seqval, "keys", NULL);
		std::map<std::string, Material> resmap;
		for (int i = 0; i < PySequence_Length(seqval); i++) {
			PyObject *keyobj = PySequence_GetItem(seqkeys, i);
			std::string key = PyBytes_AsString(PyUnicode_AsASCIIString(keyobj));
			Material value = Material(PySequence_GetItem(seqval, i));
			resmap.insert(std::pair<std::string,Material>(key, value));
		}
		return resmap;
	}

	void BlendData::materials(std::map<std::string, Material> value) { /* not implemented */ }

	// node_groups
	std::map<std::string, NodeTree> BlendData::node_groups() {
		// TODO: MISSING DEREF! USE #DEFINE!
		PyObject *seqval = PyObject_GetAttrString(pyobjref, "node_groups");
		PyObject *seqkeys = PyObject_CallMethod(seqval, "keys", NULL);
		std::map<std::string, NodeTree> resmap;
		for (int i = 0; i < PySequence_Length(seqval); i++) {
			PyObject *keyobj = PySequence_GetItem(seqkeys, i);
			std::string key = PyBytes_AsString(PyUnicode_AsASCIIString(keyobj));
			NodeTree value = NodeTree(PySequence_GetItem(seqval, i));
			resmap.insert(std::pair<std::string,NodeTree>(key, value));
		}
		return resmap;
	}

	void BlendData::node_groups(std::map<std::string, NodeTree> value) { /* not implemented */ }

	// meshes
	std::map<std::string, Mesh> BlendData::meshes() {
		// TODO: MISSING DEREF! USE #DEFINE!
		PyObject *seqval = PyObject_GetAttrString(pyobjref, "meshes");
		PyObject *seqkeys = PyObject_CallMethod(seqval, "keys", NULL);
		std::map<std::string, Mesh> resmap;
		for (int i = 0; i < PySequence_Length(seqval); i++) {
			PyObject *keyobj = PySequence_GetItem(seqkeys, i);
			std::string key = PyBytes_AsString(PyUnicode_AsASCIIString(keyobj));
			Mesh value = Mesh(PySequence_GetItem(seqval, i));
			resmap.insert(std::pair<std::string,Mesh>(key, value));
		}
		return resmap;
	}

	void BlendData::meshes(std::map<std::string, Mesh> value) { /* not implemented */ }

	// screens
	std::map<std::string, Screen> BlendData::screens() {
		// TODO: MISSING DEREF! USE #DEFINE!
		PyObject *seqval = PyObject_GetAttrString(pyobjref, "screens");
		PyObject *seqkeys = PyObject_CallMethod(seqval, "keys", NULL);
		std::map<std::string, Screen> resmap;
		for (int i = 0; i < PySequence_Length(seqval); i++) {
			PyObject *keyobj = PySequence_GetItem(seqkeys, i);
			std::string key = PyBytes_AsString(PyUnicode_AsASCIIString(keyobj));
			Screen value = Screen(PySequence_GetItem(seqval, i));
			resmap.insert(std::pair<std::string,Screen>(key, value));
		}
		return resmap;
	}

	void BlendData::screens(std::map<std::string, Screen> value) { /* not implemented */ }

	// window_managers
	std::map<std::string, WindowManager> BlendData::window_managers() {
		// TODO: MISSING DEREF! USE #DEFINE!
		PyObject *seqval = PyObject_GetAttrString(pyobjref, "window_managers");
		PyObject *seqkeys = PyObject_CallMethod(seqval, "keys", NULL);
		std::map<std::string, WindowManager> resmap;
		for (int i = 0; i < PySequence_Length(seqval); i++) {
			PyObject *keyobj = PySequence_GetItem(seqkeys, i);
			std::string key = PyBytes_AsString(PyUnicode_AsASCIIString(keyobj));
			WindowManager value = WindowManager(PySequence_GetItem(seqval, i));
			resmap.insert(std::pair<std::string,WindowManager>(key, value));
		}
		return resmap;
	}

	void BlendData::window_managers(std::map<std::string, WindowManager> value) { /* not implemented */ }

	// metaballs
	std::map<std::string, MetaBall> BlendData::metaballs() {
		// TODO: MISSING DEREF! USE #DEFINE!
		PyObject *seqval = PyObject_GetAttrString(pyobjref, "metaballs");
		PyObject *seqkeys = PyObject_CallMethod(seqval, "keys", NULL);
		std::map<std::string, MetaBall> resmap;
		for (int i = 0; i < PySequence_Length(seqval); i++) {
			PyObject *keyobj = PySequence_GetItem(seqkeys, i);
			std::string key = PyBytes_AsString(PyUnicode_AsASCIIString(keyobj));
			MetaBall value = MetaBall(PySequence_GetItem(seqval, i));
			resmap.insert(std::pair<std::string,MetaBall>(key, value));
		}
		return resmap;
	}

	void BlendData::metaballs(std::map<std::string, MetaBall> value) { /* not implemented */ }

	// fonts
	std::map<std::string, VectorFont> BlendData::fonts() {
		// TODO: MISSING DEREF! USE #DEFINE!
		PyObject *seqval = PyObject_GetAttrString(pyobjref, "fonts");
		PyObject *seqkeys = PyObject_CallMethod(seqval, "keys", NULL);
		std::map<std::string, VectorFont> resmap;
		for (int i = 0; i < PySequence_Length(seqval); i++) {
			PyObject *keyobj = PySequence_GetItem(seqkeys, i);
			std::string key = PyBytes_AsString(PyUnicode_AsASCIIString(keyobj));
			VectorFont value = VectorFont(PySequence_GetItem(seqval, i));
			resmap.insert(std::pair<std::string,VectorFont>(key, value));
		}
		return resmap;
	}

	void BlendData::fonts(std::map<std::string, VectorFont> value) { /* not implemented */ }

	// worlds
	std::map<std::string, World> BlendData::worlds() {
		// TODO: MISSING DEREF! USE #DEFINE!
		PyObject *seqval = PyObject_GetAttrString(pyobjref, "worlds");
		PyObject *seqkeys = PyObject_CallMethod(seqval, "keys", NULL);
		std::map<std::string, World> resmap;
		for (int i = 0; i < PySequence_Length(seqval); i++) {
			PyObject *keyobj = PySequence_GetItem(seqkeys, i);
			std::string key = PyBytes_AsString(PyUnicode_AsASCIIString(keyobj));
			World value = World(PySequence_GetItem(seqval, i));
			resmap.insert(std::pair<std::string,World>(key, value));
		}
		return resmap;
	}

	void BlendData::worlds(std::map<std::string, World> value) { /* not implemented */ }

	// texts
	std::map<std::string, Text> BlendData::texts() {
		// TODO: MISSING DEREF! USE #DEFINE!
		PyObject *seqval = PyObject_GetAttrString(pyobjref, "texts");
		PyObject *seqkeys = PyObject_CallMethod(seqval, "keys", NULL);
		std::map<std::string, Text> resmap;
		for (int i = 0; i < PySequence_Length(seqval); i++) {
			PyObject *keyobj = PySequence_GetItem(seqkeys, i);
			std::string key = PyBytes_AsString(PyUnicode_AsASCIIString(keyobj));
			Text value = Text(PySequence_GetItem(seqval, i));
			resmap.insert(std::pair<std::string,Text>(key, value));
		}
		return resmap;
	}

	void BlendData::texts(std::map<std::string, Text> value) { /* not implemented */ }

	// speakers
	std::map<std::string, Speaker> BlendData::speakers() {
		// TODO: MISSING DEREF! USE #DEFINE!
		PyObject *seqval = PyObject_GetAttrString(pyobjref, "speakers");
		PyObject *seqkeys = PyObject_CallMethod(seqval, "keys", NULL);
		std::map<std::string, Speaker> resmap;
		for (int i = 0; i < PySequence_Length(seqval); i++) {
			PyObject *keyobj = PySequence_GetItem(seqkeys, i);
			std::string key = PyBytes_AsString(PyUnicode_AsASCIIString(keyobj));
			Speaker value = Speaker(PySequence_GetItem(seqval, i));
			resmap.insert(std::pair<std::string,Speaker>(key, value));
		}
		return resmap;
	}

	void BlendData::speakers(std::map<std::string, Speaker> value) { /* not implemented */ }

	// sounds
	std::map<std::string, Sound> BlendData::sounds() {
		// TODO: MISSING DEREF! USE #DEFINE!
		PyObject *seqval = PyObject_GetAttrString(pyobjref, "sounds");
		PyObject *seqkeys = PyObject_CallMethod(seqval, "keys", NULL);
		std::map<std::string, Sound> resmap;
		for (int i = 0; i < PySequence_Length(seqval); i++) {
			PyObject *keyobj = PySequence_GetItem(seqkeys, i);
			std::string key = PyBytes_AsString(PyUnicode_AsASCIIString(keyobj));
			Sound value = Sound(PySequence_GetItem(seqval, i));
			resmap.insert(std::pair<std::string,Sound>(key, value));
		}
		return resmap;
	}

	void BlendData::sounds(std::map<std::string, Sound> value) { /* not implemented */ }

	// particles
	std::map<std::string, ParticleSettings> BlendData::particles() {
		// TODO: MISSING DEREF! USE #DEFINE!
		PyObject *seqval = PyObject_GetAttrString(pyobjref, "particles");
		PyObject *seqkeys = PyObject_CallMethod(seqval, "keys", NULL);
		std::map<std::string, ParticleSettings> resmap;
		for (int i = 0; i < PySequence_Length(seqval); i++) {
			PyObject *keyobj = PySequence_GetItem(seqkeys, i);
			std::string key = PyBytes_AsString(PyUnicode_AsASCIIString(keyobj));
			ParticleSettings value = ParticleSettings(PySequence_GetItem(seqval, i));
			resmap.insert(std::pair<std::string,ParticleSettings>(key, value));
		}
		return resmap;
	}

	void BlendData::particles(std::map<std::string, ParticleSettings> value) { /* not implemented */ }

	// palettes
	std::map<std::string, Palette> BlendData::palettes() {
		// TODO: MISSING DEREF! USE #DEFINE!
		PyObject *seqval = PyObject_GetAttrString(pyobjref, "palettes");
		PyObject *seqkeys = PyObject_CallMethod(seqval, "keys", NULL);
		std::map<std::string, Palette> resmap;
		for (int i = 0; i < PySequence_Length(seqval); i++) {
			PyObject *keyobj = PySequence_GetItem(seqkeys, i);
			std::string key = PyBytes_AsString(PyUnicode_AsASCIIString(keyobj));
			Palette value = Palette(PySequence_GetItem(seqval, i));
			resmap.insert(std::pair<std::string,Palette>(key, value));
		}
		return resmap;
	}

	void BlendData::palettes(std::map<std::string, Palette> value) { /* not implemented */ }

	// movieclips
	std::map<std::string, MovieClip> BlendData::movieclips() {
		// TODO: MISSING DEREF! USE #DEFINE!
		PyObject *seqval = PyObject_GetAttrString(pyobjref, "movieclips");
		PyObject *seqkeys = PyObject_CallMethod(seqval, "keys", NULL);
		std::map<std::string, MovieClip> resmap;
		for (int i = 0; i < PySequence_Length(seqval); i++) {
			PyObject *keyobj = PySequence_GetItem(seqkeys, i);
			std::string key = PyBytes_AsString(PyUnicode_AsASCIIString(keyobj));
			MovieClip value = MovieClip(PySequence_GetItem(seqval, i));
			resmap.insert(std::pair<std::string,MovieClip>(key, value));
		}
		return resmap;
	}

	void BlendData::movieclips(std::map<std::string, MovieClip> value) { /* not implemented */ }

	// masks
	std::map<std::string, Mask> BlendData::masks() {
		// TODO: MISSING DEREF! USE #DEFINE!
		PyObject *seqval = PyObject_GetAttrString(pyobjref, "masks");
		PyObject *seqkeys = PyObject_CallMethod(seqval, "keys", NULL);
		std::map<std::string, Mask> resmap;
		for (int i = 0; i < PySequence_Length(seqval); i++) {
			PyObject *keyobj = PySequence_GetItem(seqkeys, i);
			std::string key = PyBytes_AsString(PyUnicode_AsASCIIString(keyobj));
			Mask value = Mask(PySequence_GetItem(seqval, i));
			resmap.insert(std::pair<std::string,Mask>(key, value));
		}
		return resmap;
	}

	void BlendData::masks(std::map<std::string, Mask> value) { /* not implemented */ }

	Camera BlendDataCameras::create(const std::string name)
	{
		// not implemented
		return Camera();
	}

	void BlendDataCameras::remove(Camera camera)
	{
		// not implemented
	}

	Scene BlendDataScenes::create(const std::string name)
	{
		// not implemented
		return Scene();
	}

	void BlendDataScenes::remove(Scene scene)
	{
		// not implemented
	}

	Object BlendDataObjects::create(const std::string name, ID object_data)
	{
		// not implemented
		return Object();
	}

	void BlendDataObjects::remove(Object object_value)
	{
		// not implemented
	}

	Material BlendDataMaterials::create(const std::string name)
	{
		// not implemented
		return Material();
	}

	void BlendDataMaterials::remove(Material material)
	{
		// not implemented
	}

	NodeTree BlendDataNodeTrees::create(const std::string name, dummy_items type)
	{
		// not implemented
		return NodeTree();
	}

	void BlendDataNodeTrees::remove(NodeTree tree)
	{
		// not implemented
	}

	Mesh BlendDataMeshes::create(const std::string name)
	{
		// not implemented
		return Mesh();
	}

	Mesh BlendDataMeshes::new_from_object(Scene scene, Object object_value, bool apply_modifiers, mesh_type_items settings, bool calc_tessface, bool calc_undeformed)
	{
		// not implemented
		return Mesh();
	}

	void BlendDataMeshes::remove(Mesh mesh)
	{
		// not implemented
	}

	Lamp BlendDataLamps::create(const std::string name, lamp_type_items type)
	{
		// not implemented
		return Lamp();
	}

	void BlendDataLamps::remove(Lamp lamp)
	{
		// not implemented
	}

	Image BlendDataImages::create(const std::string name, int width, int height, bool alpha, bool float_buffer, bool stereo3d)
	{
		// not implemented
		return Image();
	}

	Image BlendDataImages::load(const std::string filepath)
	{
		// not implemented
		return Image();
	}

	void BlendDataImages::remove(Image image)
	{
		// not implemented
	}

	Lattice BlendDataLattices::create(const std::string name)
	{
		// not implemented
		return Lattice();
	}

	void BlendDataLattices::remove(Lattice lattice)
	{
		// not implemented
	}

	Curve BlendDataCurves::create(const std::string name, object_type_curve_items type)
	{
		// not implemented
		return Curve();
	}

	void BlendDataCurves::remove(Curve curve)
	{
		// not implemented
	}

	MetaBall BlendDataMetaBalls::create(const std::string name)
	{
		// not implemented
		return MetaBall();
	}

	void BlendDataMetaBalls::remove(MetaBall metaball)
	{
		// not implemented
	}

	VectorFont BlendDataFonts::load(const std::string filepath)
	{
		// not implemented
		return VectorFont();
	}

	void BlendDataFonts::remove(VectorFont vfont)
	{
		// not implemented
	}

	Brush BlendDataBrushes::create(const std::string name)
	{
		// not implemented
		return Brush();
	}

	void BlendDataBrushes::remove(Brush brush)
	{
		// not implemented
	}

	World BlendDataWorlds::create(const std::string name)
	{
		// not implemented
		return World();
	}

	void BlendDataWorlds::remove(World world)
	{
		// not implemented
	}

	Group BlendDataGroups::create(const std::string name)
	{
		// not implemented
		return Group();
	}

	void BlendDataGroups::remove(Group group)
	{
		// not implemented
	}

	Text BlendDataTexts::create(const std::string name)
	{
		// not implemented
		return Text();
	}

	void BlendDataTexts::remove(Text text)
	{
		// not implemented
	}

	Text BlendDataTexts::load(const std::string filepath, bool internal)
	{
		// not implemented
		return Text();
	}

	Speaker BlendDataSpeakers::create(const std::string name)
	{
		// not implemented
		return Speaker();
	}

	void BlendDataSpeakers::remove(Speaker speaker)
	{
		// not implemented
	}

	Sound BlendDataSounds::load(const std::string filepath)
	{
		// not implemented
		return Sound();
	}

	void BlendDataSounds::remove(Sound sound)
	{
		// not implemented
	}

	Armature BlendDataArmatures::create(const std::string name)
	{
		// not implemented
		return Armature();
	}

	void BlendDataArmatures::remove(Armature armature)
	{
		// not implemented
	}

	Action BlendDataActions::create(const std::string name)
	{
		// not implemented
		return Action();
	}

	void BlendDataActions::remove(Action action)
	{
		// not implemented
	}

	ParticleSettings BlendDataParticles::create(const std::string name)
	{
		// not implemented
		return ParticleSettings();
	}

	void BlendDataParticles::remove(ParticleSettings particle)
	{
		// not implemented
	}

	Palette BlendDataPalettes::create(const std::string name)
	{
		// not implemented
		return Palette();
	}

	void BlendDataPalettes::remove(Palette palette)
	{
		// not implemented
	}

	GreasePencil BlendDataGreasePencils::create(const std::string name)
	{
		// not implemented
		return GreasePencil();
	}

	void BlendDataGreasePencils::remove(GreasePencil grease_pencil)
	{
		// not implemented
	}

	void BlendDataMovieClips::remove(MovieClip clip)
	{
		// not implemented
	}

	MovieClip BlendDataMovieClips::load(const std::string filepath)
	{
		// not implemented
		return MovieClip();
	}

	Mask BlendDataMasks::create(const std::string name)
	{
		// not implemented
		return Mask();
	}

	void BlendDataMasks::remove(Mask mask)
	{
		// not implemented
	}

	FreestyleLineStyle BlendDataLineStyles::create(const std::string name)
	{
		// not implemented
		return FreestyleLineStyle();
	}

	void BlendDataLineStyles::remove(FreestyleLineStyle linestyle)
	{
		// not implemented
	}

	/**************** Material ****************/

	// raytrace_mirror
	MaterialRaytraceMirror Material::raytrace_mirror() {
		return MaterialRaytraceMirror(PyObject_GetAttrString(pyobjref, "raytrace_mirror"));
	}

	// raytrace_transparency
	MaterialRaytraceTransparency Material::raytrace_transparency() {
		return MaterialRaytraceTransparency(PyObject_GetAttrString(pyobjref, "raytrace_transparency"));
	}

	// volume
	MaterialVolume Material::volume() {
		return MaterialVolume(PyObject_GetAttrString(pyobjref, "volume"));
	}

	// halo
	MaterialHalo Material::halo() {
		return MaterialHalo(PyObject_GetAttrString(pyobjref, "halo"));
	}

	// subsurface_scattering
	MaterialSubsurfaceScattering Material::subsurface_scattering() {
		return MaterialSubsurfaceScattering(PyObject_GetAttrString(pyobjref, "subsurface_scattering"));
	}

	// strand
	MaterialStrand Material::strand() {
		return MaterialStrand(PyObject_GetAttrString(pyobjref, "strand"));
	}

	// physics
	MaterialPhysics Material::physics() {
		return MaterialPhysics(PyObject_GetAttrString(pyobjref, "physics"));
	}

	// game_settings
	MaterialGameSettings Material::game_settings() {
		return MaterialGameSettings(PyObject_GetAttrString(pyobjref, "game_settings"));
	}

	// node_tree
	NodeTree Material::node_tree() {
		return NodeTree(PyObject_GetAttrString(pyobjref, "node_tree"));
	}

	// texture_slots
	std::map<std::string, MaterialTextureSlot> Material::texture_slots() {
		// TODO: MISSING DEREF! USE #DEFINE!
		PyObject *seqval = PyObject_GetAttrString(pyobjref, "texture_slots");
		PyObject *seqkeys = PyObject_CallMethod(seqval, "keys", NULL);
		std::map<std::string, MaterialTextureSlot> resmap;
		for (int i = 0; i < PySequence_Length(seqval); i++) {
			PyObject *keyobj = PySequence_GetItem(seqkeys, i);
			std::string key = PyBytes_AsString(PyUnicode_AsASCIIString(keyobj));
			MaterialTextureSlot value = MaterialTextureSlot(PySequence_GetItem(seqval, i));
			resmap.insert(std::pair<std::string,MaterialTextureSlot>(key, value));
		}
		return resmap;
	}

	void Material::texture_slots(std::map<std::string, MaterialTextureSlot> value) { /* not implemented */ }

	// texture_paint_slots
	std::map<std::string, TexPaintSlot> Material::texture_paint_slots() {
		// TODO: MISSING DEREF! USE #DEFINE!
		PyObject *seqval = PyObject_GetAttrString(pyobjref, "texture_paint_slots");
		PyObject *seqkeys = PyObject_CallMethod(seqval, "keys", NULL);
		std::map<std::string, TexPaintSlot> resmap;
		for (int i = 0; i < PySequence_Length(seqval); i++) {
			PyObject *keyobj = PySequence_GetItem(seqkeys, i);
			std::string key = PyBytes_AsString(PyUnicode_AsASCIIString(keyobj));
			TexPaintSlot value = TexPaintSlot(PySequence_GetItem(seqval, i));
			resmap.insert(std::pair<std::string,TexPaintSlot>(key, value));
		}
		return resmap;
	}

	void Material::texture_paint_slots(std::map<std::string, TexPaintSlot> value) { /* not implemented */ }

	MaterialTextureSlot MaterialTextureSlots::add()
	{
		// not implemented
		return MaterialTextureSlot();
	}

	MaterialTextureSlot MaterialTextureSlots::create(int index)
	{
		// not implemented
		return MaterialTextureSlot();
	}

	/**************** Material Texture Slot ****************/

	// object
	Object MaterialTextureSlot::object_value() {
		return Object(PyObject_GetAttrString(pyobjref, "object"));
	}

	/**************** Mesh ****************/

	// vertices
	std::map<std::string, MeshVertex> Mesh::vertices() {
		// TODO: MISSING DEREF! USE #DEFINE!
		PyObject *seqval = PyObject_GetAttrString(pyobjref, "vertices");
		PyObject *seqkeys = PyObject_CallMethod(seqval, "keys", NULL);
		std::map<std::string, MeshVertex> resmap;
		for (int i = 0; i < PySequence_Length(seqval); i++) {
			PyObject *keyobj = PySequence_GetItem(seqkeys, i);
			std::string key = PyBytes_AsString(PyUnicode_AsASCIIString(keyobj));
			MeshVertex value = MeshVertex(PySequence_GetItem(seqval, i));
			resmap.insert(std::pair<std::string,MeshVertex>(key, value));
		}
		return resmap;
	}

	void Mesh::vertices(std::map<std::string, MeshVertex> value) { /* not implemented */ }

	// edges
	std::map<std::string, MeshEdge> Mesh::edges() {
		// TODO: MISSING DEREF! USE #DEFINE!
		PyObject *seqval = PyObject_GetAttrString(pyobjref, "edges");
		PyObject *seqkeys = PyObject_CallMethod(seqval, "keys", NULL);
		std::map<std::string, MeshEdge> resmap;
		for (int i = 0; i < PySequence_Length(seqval); i++) {
			PyObject *keyobj = PySequence_GetItem(seqkeys, i);
			std::string key = PyBytes_AsString(PyUnicode_AsASCIIString(keyobj));
			MeshEdge value = MeshEdge(PySequence_GetItem(seqval, i));
			resmap.insert(std::pair<std::string,MeshEdge>(key, value));
		}
		return resmap;
	}

	void Mesh::edges(std::map<std::string, MeshEdge> value) { /* not implemented */ }

	// tessfaces
	std::map<std::string, MeshTessFace> Mesh::tessfaces() {
		// TODO: MISSING DEREF! USE #DEFINE!
		PyObject *seqval = PyObject_GetAttrString(pyobjref, "tessfaces");
		PyObject *seqkeys = PyObject_CallMethod(seqval, "keys", NULL);
		std::map<std::string, MeshTessFace> resmap;
		for (int i = 0; i < PySequence_Length(seqval); i++) {
			PyObject *keyobj = PySequence_GetItem(seqkeys, i);
			std::string key = PyBytes_AsString(PyUnicode_AsASCIIString(keyobj));
			MeshTessFace value = MeshTessFace(PySequence_GetItem(seqval, i));
			resmap.insert(std::pair<std::string,MeshTessFace>(key, value));
		}
		return resmap;
	}

	void Mesh::tessfaces(std::map<std::string, MeshTessFace> value) { /* not implemented */ }

	// loops
	std::map<std::string, MeshLoop> Mesh::loops() {
		// TODO: MISSING DEREF! USE #DEFINE!
		PyObject *seqval = PyObject_GetAttrString(pyobjref, "loops");
		PyObject *seqkeys = PyObject_CallMethod(seqval, "keys", NULL);
		std::map<std::string, MeshLoop> resmap;
		for (int i = 0; i < PySequence_Length(seqval); i++) {
			PyObject *keyobj = PySequence_GetItem(seqkeys, i);
			std::string key = PyBytes_AsString(PyUnicode_AsASCIIString(keyobj));
			MeshLoop value = MeshLoop(PySequence_GetItem(seqval, i));
			resmap.insert(std::pair<std::string,MeshLoop>(key, value));
		}
		return resmap;
	}

	void Mesh::loops(std::map<std::string, MeshLoop> value) { /* not implemented */ }

	// polygons
	std::map<std::string, MeshPolygon> Mesh::polygons() {
		// TODO: MISSING DEREF! USE #DEFINE!
		PyObject *seqval = PyObject_GetAttrString(pyobjref, "polygons");
		PyObject *seqkeys = PyObject_CallMethod(seqval, "keys", NULL);
		std::map<std::string, MeshPolygon> resmap;
		for (int i = 0; i < PySequence_Length(seqval); i++) {
			PyObject *keyobj = PySequence_GetItem(seqkeys, i);
			std::string key = PyBytes_AsString(PyUnicode_AsASCIIString(keyobj));
			MeshPolygon value = MeshPolygon(PySequence_GetItem(seqval, i));
			resmap.insert(std::pair<std::string,MeshPolygon>(key, value));
		}
		return resmap;
	}

	void Mesh::polygons(std::map<std::string, MeshPolygon> value) { /* not implemented */ }

	// uv_layers
	std::map<std::string, MeshUVLoopLayer> Mesh::uv_layers() {
		// TODO: MISSING DEREF! USE #DEFINE!
		PyObject *seqval = PyObject_GetAttrString(pyobjref, "uv_layers");
		PyObject *seqkeys = PyObject_CallMethod(seqval, "keys", NULL);
		std::map<std::string, MeshUVLoopLayer> resmap;
		for (int i = 0; i < PySequence_Length(seqval); i++) {
			PyObject *keyobj = PySequence_GetItem(seqkeys, i);
			std::string key = PyBytes_AsString(PyUnicode_AsASCIIString(keyobj));
			MeshUVLoopLayer value = MeshUVLoopLayer(PySequence_GetItem(seqval, i));
			resmap.insert(std::pair<std::string,MeshUVLoopLayer>(key, value));
		}
		return resmap;
	}

	void Mesh::uv_layers(std::map<std::string, MeshUVLoopLayer> value) { /* not implemented */ }

	// uv_layer_clone
	MeshUVLoopLayer Mesh::uv_layer_clone() {
		return MeshUVLoopLayer(PyObject_GetAttrString(pyobjref, "uv_layer_clone"));
	}

	// uv_layer_stencil
	MeshUVLoopLayer Mesh::uv_layer_stencil() {
		return MeshUVLoopLayer(PyObject_GetAttrString(pyobjref, "uv_layer_stencil"));
	}

	// tessface_uv_textures
	std::map<std::string, MeshTextureFaceLayer> Mesh::tessface_uv_textures() {
		// TODO: MISSING DEREF! USE #DEFINE!
		PyObject *seqval = PyObject_GetAttrString(pyobjref, "tessface_uv_textures");
		PyObject *seqkeys = PyObject_CallMethod(seqval, "keys", NULL);
		std::map<std::string, MeshTextureFaceLayer> resmap;
		for (int i = 0; i < PySequence_Length(seqval); i++) {
			PyObject *keyobj = PySequence_GetItem(seqkeys, i);
			std::string key = PyBytes_AsString(PyUnicode_AsASCIIString(keyobj));
			MeshTextureFaceLayer value = MeshTextureFaceLayer(PySequence_GetItem(seqval, i));
			resmap.insert(std::pair<std::string,MeshTextureFaceLayer>(key, value));
		}
		return resmap;
	}

	void Mesh::tessface_uv_textures(std::map<std::string, MeshTextureFaceLayer> value) { /* not implemented */ }

	// uv_textures
	std::map<std::string, MeshTexturePolyLayer> Mesh::uv_textures() {
		// TODO: MISSING DEREF! USE #DEFINE!
		PyObject *seqval = PyObject_GetAttrString(pyobjref, "uv_textures");
		PyObject *seqkeys = PyObject_CallMethod(seqval, "keys", NULL);
		std::map<std::string, MeshTexturePolyLayer> resmap;
		for (int i = 0; i < PySequence_Length(seqval); i++) {
			PyObject *keyobj = PySequence_GetItem(seqkeys, i);
			std::string key = PyBytes_AsString(PyUnicode_AsASCIIString(keyobj));
			MeshTexturePolyLayer value = MeshTexturePolyLayer(PySequence_GetItem(seqval, i));
			resmap.insert(std::pair<std::string,MeshTexturePolyLayer>(key, value));
		}
		return resmap;
	}

	void Mesh::uv_textures(std::map<std::string, MeshTexturePolyLayer> value) { /* not implemented */ }

	// uv_texture_clone
	MeshTexturePolyLayer Mesh::uv_texture_clone() {
		return MeshTexturePolyLayer(PyObject_GetAttrString(pyobjref, "uv_texture_clone"));
	}

	// uv_texture_stencil
	MeshTexturePolyLayer Mesh::uv_texture_stencil() {
		return MeshTexturePolyLayer(PyObject_GetAttrString(pyobjref, "uv_texture_stencil"));
	}

	// tessface_vertex_colors
	std::map<std::string, MeshColorLayer> Mesh::tessface_vertex_colors() {
		// TODO: MISSING DEREF! USE #DEFINE!
		PyObject *seqval = PyObject_GetAttrString(pyobjref, "tessface_vertex_colors");
		PyObject *seqkeys = PyObject_CallMethod(seqval, "keys", NULL);
		std::map<std::string, MeshColorLayer> resmap;
		for (int i = 0; i < PySequence_Length(seqval); i++) {
			PyObject *keyobj = PySequence_GetItem(seqkeys, i);
			std::string key = PyBytes_AsString(PyUnicode_AsASCIIString(keyobj));
			MeshColorLayer value = MeshColorLayer(PySequence_GetItem(seqval, i));
			resmap.insert(std::pair<std::string,MeshColorLayer>(key, value));
		}
		return resmap;
	}

	void Mesh::tessface_vertex_colors(std::map<std::string, MeshColorLayer> value) { /* not implemented */ }

	// vertex_colors
	std::map<std::string, MeshLoopColorLayer> Mesh::vertex_colors() {
		// TODO: MISSING DEREF! USE #DEFINE!
		PyObject *seqval = PyObject_GetAttrString(pyobjref, "vertex_colors");
		PyObject *seqkeys = PyObject_CallMethod(seqval, "keys", NULL);
		std::map<std::string, MeshLoopColorLayer> resmap;
		for (int i = 0; i < PySequence_Length(seqval); i++) {
			PyObject *keyobj = PySequence_GetItem(seqkeys, i);
			std::string key = PyBytes_AsString(PyUnicode_AsASCIIString(keyobj));
			MeshLoopColorLayer value = MeshLoopColorLayer(PySequence_GetItem(seqval, i));
			resmap.insert(std::pair<std::string,MeshLoopColorLayer>(key, value));
		}
		return resmap;
	}

	void Mesh::vertex_colors(std::map<std::string, MeshLoopColorLayer> value) { /* not implemented */ }

	// vertex_layers_float
	std::map<std::string, MeshVertexFloatPropertyLayer> Mesh::vertex_layers_float() {
		// TODO: MISSING DEREF! USE #DEFINE!
		PyObject *seqval = PyObject_GetAttrString(pyobjref, "vertex_layers_float");
		PyObject *seqkeys = PyObject_CallMethod(seqval, "keys", NULL);
		std::map<std::string, MeshVertexFloatPropertyLayer> resmap;
		for (int i = 0; i < PySequence_Length(seqval); i++) {
			PyObject *keyobj = PySequence_GetItem(seqkeys, i);
			std::string key = PyBytes_AsString(PyUnicode_AsASCIIString(keyobj));
			MeshVertexFloatPropertyLayer value = MeshVertexFloatPropertyLayer(PySequence_GetItem(seqval, i));
			resmap.insert(std::pair<std::string,MeshVertexFloatPropertyLayer>(key, value));
		}
		return resmap;
	}

	void Mesh::vertex_layers_float(std::map<std::string, MeshVertexFloatPropertyLayer> value) { /* not implemented */ }

	// vertex_layers_int
	std::map<std::string, MeshVertexIntPropertyLayer> Mesh::vertex_layers_int() {
		// TODO: MISSING DEREF! USE #DEFINE!
		PyObject *seqval = PyObject_GetAttrString(pyobjref, "vertex_layers_int");
		PyObject *seqkeys = PyObject_CallMethod(seqval, "keys", NULL);
		std::map<std::string, MeshVertexIntPropertyLayer> resmap;
		for (int i = 0; i < PySequence_Length(seqval); i++) {
			PyObject *keyobj = PySequence_GetItem(seqkeys, i);
			std::string key = PyBytes_AsString(PyUnicode_AsASCIIString(keyobj));
			MeshVertexIntPropertyLayer value = MeshVertexIntPropertyLayer(PySequence_GetItem(seqval, i));
			resmap.insert(std::pair<std::string,MeshVertexIntPropertyLayer>(key, value));
		}
		return resmap;
	}

	void Mesh::vertex_layers_int(std::map<std::string, MeshVertexIntPropertyLayer> value) { /* not implemented */ }

	// vertex_layers_string
	std::map<std::string, MeshVertexStringPropertyLayer> Mesh::vertex_layers_string() {
		// TODO: MISSING DEREF! USE #DEFINE!
		PyObject *seqval = PyObject_GetAttrString(pyobjref, "vertex_layers_string");
		PyObject *seqkeys = PyObject_CallMethod(seqval, "keys", NULL);
		std::map<std::string, MeshVertexStringPropertyLayer> resmap;
		for (int i = 0; i < PySequence_Length(seqval); i++) {
			PyObject *keyobj = PySequence_GetItem(seqkeys, i);
			std::string key = PyBytes_AsString(PyUnicode_AsASCIIString(keyobj));
			MeshVertexStringPropertyLayer value = MeshVertexStringPropertyLayer(PySequence_GetItem(seqval, i));
			resmap.insert(std::pair<std::string,MeshVertexStringPropertyLayer>(key, value));
		}
		return resmap;
	}

	void Mesh::vertex_layers_string(std::map<std::string, MeshVertexStringPropertyLayer> value) { /* not implemented */ }

	// polygon_layers_float
	std::map<std::string, MeshPolygonFloatPropertyLayer> Mesh::polygon_layers_float() {
		// TODO: MISSING DEREF! USE #DEFINE!
		PyObject *seqval = PyObject_GetAttrString(pyobjref, "polygon_layers_float");
		PyObject *seqkeys = PyObject_CallMethod(seqval, "keys", NULL);
		std::map<std::string, MeshPolygonFloatPropertyLayer> resmap;
		for (int i = 0; i < PySequence_Length(seqval); i++) {
			PyObject *keyobj = PySequence_GetItem(seqkeys, i);
			std::string key = PyBytes_AsString(PyUnicode_AsASCIIString(keyobj));
			MeshPolygonFloatPropertyLayer value = MeshPolygonFloatPropertyLayer(PySequence_GetItem(seqval, i));
			resmap.insert(std::pair<std::string,MeshPolygonFloatPropertyLayer>(key, value));
		}
		return resmap;
	}

	void Mesh::polygon_layers_float(std::map<std::string, MeshPolygonFloatPropertyLayer> value) { /* not implemented */ }

	// polygon_layers_int
	std::map<std::string, MeshPolygonIntPropertyLayer> Mesh::polygon_layers_int() {
		// TODO: MISSING DEREF! USE #DEFINE!
		PyObject *seqval = PyObject_GetAttrString(pyobjref, "polygon_layers_int");
		PyObject *seqkeys = PyObject_CallMethod(seqval, "keys", NULL);
		std::map<std::string, MeshPolygonIntPropertyLayer> resmap;
		for (int i = 0; i < PySequence_Length(seqval); i++) {
			PyObject *keyobj = PySequence_GetItem(seqkeys, i);
			std::string key = PyBytes_AsString(PyUnicode_AsASCIIString(keyobj));
			MeshPolygonIntPropertyLayer value = MeshPolygonIntPropertyLayer(PySequence_GetItem(seqval, i));
			resmap.insert(std::pair<std::string,MeshPolygonIntPropertyLayer>(key, value));
		}
		return resmap;
	}

	void Mesh::polygon_layers_int(std::map<std::string, MeshPolygonIntPropertyLayer> value) { /* not implemented */ }

	// polygon_layers_string
	std::map<std::string, MeshPolygonStringPropertyLayer> Mesh::polygon_layers_string() {
		// TODO: MISSING DEREF! USE #DEFINE!
		PyObject *seqval = PyObject_GetAttrString(pyobjref, "polygon_layers_string");
		PyObject *seqkeys = PyObject_CallMethod(seqval, "keys", NULL);
		std::map<std::string, MeshPolygonStringPropertyLayer> resmap;
		for (int i = 0; i < PySequence_Length(seqval); i++) {
			PyObject *keyobj = PySequence_GetItem(seqkeys, i);
			std::string key = PyBytes_AsString(PyUnicode_AsASCIIString(keyobj));
			MeshPolygonStringPropertyLayer value = MeshPolygonStringPropertyLayer(PySequence_GetItem(seqval, i));
			resmap.insert(std::pair<std::string,MeshPolygonStringPropertyLayer>(key, value));
		}
		return resmap;
	}

	void Mesh::polygon_layers_string(std::map<std::string, MeshPolygonStringPropertyLayer> value) { /* not implemented */ }

	// skin_vertices
	std::map<std::string, MeshSkinVertexLayer> Mesh::skin_vertices() {
		// TODO: MISSING DEREF! USE #DEFINE!
		PyObject *seqval = PyObject_GetAttrString(pyobjref, "skin_vertices");
		PyObject *seqkeys = PyObject_CallMethod(seqval, "keys", NULL);
		std::map<std::string, MeshSkinVertexLayer> resmap;
		for (int i = 0; i < PySequence_Length(seqval); i++) {
			PyObject *keyobj = PySequence_GetItem(seqkeys, i);
			std::string key = PyBytes_AsString(PyUnicode_AsASCIIString(keyobj));
			MeshSkinVertexLayer value = MeshSkinVertexLayer(PySequence_GetItem(seqval, i));
			resmap.insert(std::pair<std::string,MeshSkinVertexLayer>(key, value));
		}
		return resmap;
	}

	void Mesh::skin_vertices(std::map<std::string, MeshSkinVertexLayer> value) { /* not implemented */ }

	// vertex_paint_masks
	std::map<std::string, MeshPaintMaskLayer> Mesh::vertex_paint_masks() {
		// TODO: MISSING DEREF! USE #DEFINE!
		PyObject *seqval = PyObject_GetAttrString(pyobjref, "vertex_paint_masks");
		PyObject *seqkeys = PyObject_CallMethod(seqval, "keys", NULL);
		std::map<std::string, MeshPaintMaskLayer> resmap;
		for (int i = 0; i < PySequence_Length(seqval); i++) {
			PyObject *keyobj = PySequence_GetItem(seqkeys, i);
			std::string key = PyBytes_AsString(PyUnicode_AsASCIIString(keyobj));
			MeshPaintMaskLayer value = MeshPaintMaskLayer(PySequence_GetItem(seqval, i));
			resmap.insert(std::pair<std::string,MeshPaintMaskLayer>(key, value));
		}
		return resmap;
	}

	void Mesh::vertex_paint_masks(std::map<std::string, MeshPaintMaskLayer> value) { /* not implemented */ }

	/**************** UV Loop Layers ****************/

	// active
	MeshUVLoopLayer UVLoopLayers::active() {
		return MeshUVLoopLayer(PyObject_GetAttrString(pyobjref, "active"));
	}

	/**************** UV Maps ****************/

	// active
	MeshTextureFaceLayer TessfaceUVTextures::active() {
		return MeshTextureFaceLayer(PyObject_GetAttrString(pyobjref, "active"));
	}

	MeshTextureFaceLayer TessfaceUVTextures::create(const std::string name)
	{
		// not implemented
		return MeshTextureFaceLayer();
	}

	/**************** UV Maps ****************/

	// active
	MeshTexturePolyLayer UVTextures::active() {
		return MeshTexturePolyLayer(PyObject_GetAttrString(pyobjref, "active"));
	}

	MeshTexturePolyLayer UVTextures::create(const std::string name)
	{
		// not implemented
		return MeshTexturePolyLayer();
	}

	void UVTextures::remove(MeshTexturePolyLayer layer)
	{
		// not implemented
	}

	/**************** Vertex Colors ****************/

	// active
	MeshColorLayer VertexColors::active() {
		return MeshColorLayer(PyObject_GetAttrString(pyobjref, "active"));
	}

	MeshColorLayer VertexColors::create(const std::string name)
	{
		// not implemented
		return MeshColorLayer();
	}

	/**************** Loop Colors ****************/

	// active
	MeshLoopColorLayer LoopColors::active() {
		return MeshLoopColorLayer(PyObject_GetAttrString(pyobjref, "active"));
	}

	MeshLoopColorLayer LoopColors::create(const std::string name)
	{
		// not implemented
		return MeshLoopColorLayer();
	}

	void LoopColors::remove(MeshLoopColorLayer layer)
	{
		// not implemented
	}

	MeshVertexFloatPropertyLayer VertexFloatProperties::create(const std::string name)
	{
		// not implemented
		return MeshVertexFloatPropertyLayer();
	}

	MeshVertexIntPropertyLayer VertexIntProperties::create(const std::string name)
	{
		// not implemented
		return MeshVertexIntPropertyLayer();
	}

	MeshVertexStringPropertyLayer VertexStringProperties::create(const std::string name)
	{
		// not implemented
		return MeshVertexStringPropertyLayer();
	}

	MeshPolygonFloatPropertyLayer PolygonFloatProperties::create(const std::string name)
	{
		// not implemented
		return MeshPolygonFloatPropertyLayer();
	}

	MeshPolygonIntPropertyLayer PolygonIntProperties::create(const std::string name)
	{
		// not implemented
		return MeshPolygonIntPropertyLayer();
	}

	MeshPolygonStringPropertyLayer PolygonStringProperties::create(const std::string name)
	{
		// not implemented
		return MeshPolygonStringPropertyLayer();
	}

	/**************** Mesh Skin Vertex Layer ****************/

	// data
	std::map<std::string, MeshSkinVertex> MeshSkinVertexLayer::data() {
		// TODO: MISSING DEREF! USE #DEFINE!
		PyObject *seqval = PyObject_GetAttrString(pyobjref, "data");
		PyObject *seqkeys = PyObject_CallMethod(seqval, "keys", NULL);
		std::map<std::string, MeshSkinVertex> resmap;
		for (int i = 0; i < PySequence_Length(seqval); i++) {
			PyObject *keyobj = PySequence_GetItem(seqkeys, i);
			std::string key = PyBytes_AsString(PyUnicode_AsASCIIString(keyobj));
			MeshSkinVertex value = MeshSkinVertex(PySequence_GetItem(seqval, i));
			resmap.insert(std::pair<std::string,MeshSkinVertex>(key, value));
		}
		return resmap;
	}

	void MeshSkinVertexLayer::data(std::map<std::string, MeshSkinVertex> value) { /* not implemented */ }

	/**************** Mesh Paint Mask Layer ****************/

	// data
	std::map<std::string, MeshPaintMaskProperty> MeshPaintMaskLayer::data() {
		// TODO: MISSING DEREF! USE #DEFINE!
		PyObject *seqval = PyObject_GetAttrString(pyobjref, "data");
		PyObject *seqkeys = PyObject_CallMethod(seqval, "keys", NULL);
		std::map<std::string, MeshPaintMaskProperty> resmap;
		for (int i = 0; i < PySequence_Length(seqval); i++) {
			PyObject *keyobj = PySequence_GetItem(seqkeys, i);
			std::string key = PyBytes_AsString(PyUnicode_AsASCIIString(keyobj));
			MeshPaintMaskProperty value = MeshPaintMaskProperty(PySequence_GetItem(seqval, i));
			resmap.insert(std::pair<std::string,MeshPaintMaskProperty>(key, value));
		}
		return resmap;
	}

	void MeshPaintMaskLayer::data(std::map<std::string, MeshPaintMaskProperty> value) { /* not implemented */ }

	/**************** Mesh Vertex ****************/

	// groups
	std::map<std::string, VertexGroupElement> MeshVertex::groups() {
		// TODO: MISSING DEREF! USE #DEFINE!
		PyObject *seqval = PyObject_GetAttrString(pyobjref, "groups");
		PyObject *seqkeys = PyObject_CallMethod(seqval, "keys", NULL);
		std::map<std::string, VertexGroupElement> resmap;
		for (int i = 0; i < PySequence_Length(seqval); i++) {
			PyObject *keyobj = PySequence_GetItem(seqkeys, i);
			std::string key = PyBytes_AsString(PyUnicode_AsASCIIString(keyobj));
			VertexGroupElement value = VertexGroupElement(PySequence_GetItem(seqval, i));
			resmap.insert(std::pair<std::string,VertexGroupElement>(key, value));
		}
		return resmap;
	}

	void MeshVertex::groups(std::map<std::string, VertexGroupElement> value) { /* not implemented */ }

	/**************** MeshUVLoopLayer ****************/

	// data
	std::map<std::string, MeshUVLoop> MeshUVLoopLayer::data() {
		// TODO: MISSING DEREF! USE #DEFINE!
		PyObject *seqval = PyObject_GetAttrString(pyobjref, "data");
		PyObject *seqkeys = PyObject_CallMethod(seqval, "keys", NULL);
		std::map<std::string, MeshUVLoop> resmap;
		for (int i = 0; i < PySequence_Length(seqval); i++) {
			PyObject *keyobj = PySequence_GetItem(seqkeys, i);
			std::string key = PyBytes_AsString(PyUnicode_AsASCIIString(keyobj));
			MeshUVLoop value = MeshUVLoop(PySequence_GetItem(seqval, i));
			resmap.insert(std::pair<std::string,MeshUVLoop>(key, value));
		}
		return resmap;
	}

	void MeshUVLoopLayer::data(std::map<std::string, MeshUVLoop> value) { /* not implemented */ }

	/**************** Mesh UV Map ****************/

	// data
	std::map<std::string, MeshTextureFace> MeshTextureFaceLayer::data() {
		// TODO: MISSING DEREF! USE #DEFINE!
		PyObject *seqval = PyObject_GetAttrString(pyobjref, "data");
		PyObject *seqkeys = PyObject_CallMethod(seqval, "keys", NULL);
		std::map<std::string, MeshTextureFace> resmap;
		for (int i = 0; i < PySequence_Length(seqval); i++) {
			PyObject *keyobj = PySequence_GetItem(seqkeys, i);
			std::string key = PyBytes_AsString(PyUnicode_AsASCIIString(keyobj));
			MeshTextureFace value = MeshTextureFace(PySequence_GetItem(seqval, i));
			resmap.insert(std::pair<std::string,MeshTextureFace>(key, value));
		}
		return resmap;
	}

	void MeshTextureFaceLayer::data(std::map<std::string, MeshTextureFace> value) { /* not implemented */ }

	/**************** Mesh UV Map ****************/

	// data
	std::map<std::string, MeshTexturePoly> MeshTexturePolyLayer::data() {
		// TODO: MISSING DEREF! USE #DEFINE!
		PyObject *seqval = PyObject_GetAttrString(pyobjref, "data");
		PyObject *seqkeys = PyObject_CallMethod(seqval, "keys", NULL);
		std::map<std::string, MeshTexturePoly> resmap;
		for (int i = 0; i < PySequence_Length(seqval); i++) {
			PyObject *keyobj = PySequence_GetItem(seqkeys, i);
			std::string key = PyBytes_AsString(PyUnicode_AsASCIIString(keyobj));
			MeshTexturePoly value = MeshTexturePoly(PySequence_GetItem(seqval, i));
			resmap.insert(std::pair<std::string,MeshTexturePoly>(key, value));
		}
		return resmap;
	}

	void MeshTexturePolyLayer::data(std::map<std::string, MeshTexturePoly> value) { /* not implemented */ }

	/**************** Mesh Vertex Color Layer ****************/

	// data
	std::map<std::string, MeshColor> MeshColorLayer::data() {
		// TODO: MISSING DEREF! USE #DEFINE!
		PyObject *seqval = PyObject_GetAttrString(pyobjref, "data");
		PyObject *seqkeys = PyObject_CallMethod(seqval, "keys", NULL);
		std::map<std::string, MeshColor> resmap;
		for (int i = 0; i < PySequence_Length(seqval); i++) {
			PyObject *keyobj = PySequence_GetItem(seqkeys, i);
			std::string key = PyBytes_AsString(PyUnicode_AsASCIIString(keyobj));
			MeshColor value = MeshColor(PySequence_GetItem(seqval, i));
			resmap.insert(std::pair<std::string,MeshColor>(key, value));
		}
		return resmap;
	}

	void MeshColorLayer::data(std::map<std::string, MeshColor> value) { /* not implemented */ }

	/**************** Mesh Vertex Color Layer ****************/

	// data
	std::map<std::string, MeshLoopColor> MeshLoopColorLayer::data() {
		// TODO: MISSING DEREF! USE #DEFINE!
		PyObject *seqval = PyObject_GetAttrString(pyobjref, "data");
		PyObject *seqkeys = PyObject_CallMethod(seqval, "keys", NULL);
		std::map<std::string, MeshLoopColor> resmap;
		for (int i = 0; i < PySequence_Length(seqval); i++) {
			PyObject *keyobj = PySequence_GetItem(seqkeys, i);
			std::string key = PyBytes_AsString(PyUnicode_AsASCIIString(keyobj));
			MeshLoopColor value = MeshLoopColor(PySequence_GetItem(seqval, i));
			resmap.insert(std::pair<std::string,MeshLoopColor>(key, value));
		}
		return resmap;
	}

	void MeshLoopColorLayer::data(std::map<std::string, MeshLoopColor> value) { /* not implemented */ }

	/**************** Mesh Vertex Float Property Layer ****************/

	// data
	std::map<std::string, MeshVertexFloatProperty> MeshVertexFloatPropertyLayer::data() {
		// TODO: MISSING DEREF! USE #DEFINE!
		PyObject *seqval = PyObject_GetAttrString(pyobjref, "data");
		PyObject *seqkeys = PyObject_CallMethod(seqval, "keys", NULL);
		std::map<std::string, MeshVertexFloatProperty> resmap;
		for (int i = 0; i < PySequence_Length(seqval); i++) {
			PyObject *keyobj = PySequence_GetItem(seqkeys, i);
			std::string key = PyBytes_AsString(PyUnicode_AsASCIIString(keyobj));
			MeshVertexFloatProperty value = MeshVertexFloatProperty(PySequence_GetItem(seqval, i));
			resmap.insert(std::pair<std::string,MeshVertexFloatProperty>(key, value));
		}
		return resmap;
	}

	void MeshVertexFloatPropertyLayer::data(std::map<std::string, MeshVertexFloatProperty> value) { /* not implemented */ }

	/**************** Mesh Polygon Float Property Layer ****************/

	// data
	std::map<std::string, MeshPolygonFloatProperty> MeshPolygonFloatPropertyLayer::data() {
		// TODO: MISSING DEREF! USE #DEFINE!
		PyObject *seqval = PyObject_GetAttrString(pyobjref, "data");
		PyObject *seqkeys = PyObject_CallMethod(seqval, "keys", NULL);
		std::map<std::string, MeshPolygonFloatProperty> resmap;
		for (int i = 0; i < PySequence_Length(seqval); i++) {
			PyObject *keyobj = PySequence_GetItem(seqkeys, i);
			std::string key = PyBytes_AsString(PyUnicode_AsASCIIString(keyobj));
			MeshPolygonFloatProperty value = MeshPolygonFloatProperty(PySequence_GetItem(seqval, i));
			resmap.insert(std::pair<std::string,MeshPolygonFloatProperty>(key, value));
		}
		return resmap;
	}

	void MeshPolygonFloatPropertyLayer::data(std::map<std::string, MeshPolygonFloatProperty> value) { /* not implemented */ }

	/**************** Mesh Vertex Int Property Layer ****************/

	// data
	std::map<std::string, MeshVertexIntProperty> MeshVertexIntPropertyLayer::data() {
		// TODO: MISSING DEREF! USE #DEFINE!
		PyObject *seqval = PyObject_GetAttrString(pyobjref, "data");
		PyObject *seqkeys = PyObject_CallMethod(seqval, "keys", NULL);
		std::map<std::string, MeshVertexIntProperty> resmap;
		for (int i = 0; i < PySequence_Length(seqval); i++) {
			PyObject *keyobj = PySequence_GetItem(seqkeys, i);
			std::string key = PyBytes_AsString(PyUnicode_AsASCIIString(keyobj));
			MeshVertexIntProperty value = MeshVertexIntProperty(PySequence_GetItem(seqval, i));
			resmap.insert(std::pair<std::string,MeshVertexIntProperty>(key, value));
		}
		return resmap;
	}

	void MeshVertexIntPropertyLayer::data(std::map<std::string, MeshVertexIntProperty> value) { /* not implemented */ }

	/**************** Mesh Polygon Int Property Layer ****************/

	// data
	std::map<std::string, MeshPolygonIntProperty> MeshPolygonIntPropertyLayer::data() {
		// TODO: MISSING DEREF! USE #DEFINE!
		PyObject *seqval = PyObject_GetAttrString(pyobjref, "data");
		PyObject *seqkeys = PyObject_CallMethod(seqval, "keys", NULL);
		std::map<std::string, MeshPolygonIntProperty> resmap;
		for (int i = 0; i < PySequence_Length(seqval); i++) {
			PyObject *keyobj = PySequence_GetItem(seqkeys, i);
			std::string key = PyBytes_AsString(PyUnicode_AsASCIIString(keyobj));
			MeshPolygonIntProperty value = MeshPolygonIntProperty(PySequence_GetItem(seqval, i));
			resmap.insert(std::pair<std::string,MeshPolygonIntProperty>(key, value));
		}
		return resmap;
	}

	void MeshPolygonIntPropertyLayer::data(std::map<std::string, MeshPolygonIntProperty> value) { /* not implemented */ }

	/**************** Mesh Vertex String Property Layer ****************/

	// data
	std::map<std::string, MeshVertexStringProperty> MeshVertexStringPropertyLayer::data() {
		// TODO: MISSING DEREF! USE #DEFINE!
		PyObject *seqval = PyObject_GetAttrString(pyobjref, "data");
		PyObject *seqkeys = PyObject_CallMethod(seqval, "keys", NULL);
		std::map<std::string, MeshVertexStringProperty> resmap;
		for (int i = 0; i < PySequence_Length(seqval); i++) {
			PyObject *keyobj = PySequence_GetItem(seqkeys, i);
			std::string key = PyBytes_AsString(PyUnicode_AsASCIIString(keyobj));
			MeshVertexStringProperty value = MeshVertexStringProperty(PySequence_GetItem(seqval, i));
			resmap.insert(std::pair<std::string,MeshVertexStringProperty>(key, value));
		}
		return resmap;
	}

	void MeshVertexStringPropertyLayer::data(std::map<std::string, MeshVertexStringProperty> value) { /* not implemented */ }

	/**************** Mesh Polygon String Property Layer ****************/

	// data
	std::map<std::string, MeshPolygonStringProperty> MeshPolygonStringPropertyLayer::data() {
		// TODO: MISSING DEREF! USE #DEFINE!
		PyObject *seqval = PyObject_GetAttrString(pyobjref, "data");
		PyObject *seqkeys = PyObject_CallMethod(seqval, "keys", NULL);
		std::map<std::string, MeshPolygonStringProperty> resmap;
		for (int i = 0; i < PySequence_Length(seqval); i++) {
			PyObject *keyobj = PySequence_GetItem(seqkeys, i);
			std::string key = PyBytes_AsString(PyUnicode_AsASCIIString(keyobj));
			MeshPolygonStringProperty value = MeshPolygonStringProperty(PySequence_GetItem(seqval, i));
			resmap.insert(std::pair<std::string,MeshPolygonStringProperty>(key, value));
		}
		return resmap;
	}

	void MeshPolygonStringPropertyLayer::data(std::map<std::string, MeshPolygonStringProperty> value) { /* not implemented */ }

	/**************** Meta Elements ****************/

	// active
	MetaElement MetaBallElements::active() {
		return MetaElement(PyObject_GetAttrString(pyobjref, "active"));
	}

	MetaElement MetaBallElements::create(metaelem_type_items type)
	{
		// not implemented
		return MetaElement();
	}

	void MetaBallElements::remove(MetaElement element)
	{
		// not implemented
	}

	/**************** Lattice Modifier ****************/

	// object
	Object LatticeModifier::object_value() {
		return Object(PyObject_GetAttrString(pyobjref, "object"));
	}

	/**************** Curve Modifier ****************/

	// object
	Object CurveModifier::object_value() {
		return Object(PyObject_GetAttrString(pyobjref, "object"));
	}

	/**************** Mirror Modifier ****************/

	// mirror_object
	Object MirrorModifier::mirror_object() {
		return Object(PyObject_GetAttrString(pyobjref, "mirror_object"));
	}

	/**************** Wave Modifier ****************/

	// start_position_object
	Object WaveModifier::start_position_object() {
		return Object(PyObject_GetAttrString(pyobjref, "start_position_object"));
	}

	// texture_coords_object
	Object WaveModifier::texture_coords_object() {
		return Object(PyObject_GetAttrString(pyobjref, "texture_coords_object"));
	}

	/**************** Armature Modifier ****************/

	// object
	Object ArmatureModifier::object_value() {
		return Object(PyObject_GetAttrString(pyobjref, "object"));
	}

	/**************** Hook Modifier ****************/

	// object
	Object HookModifier::object_value() {
		return Object(PyObject_GetAttrString(pyobjref, "object"));
	}

	/**************** Soft Body Modifier ****************/

	// settings
	SoftBodySettings SoftBodyModifier::settings() {
		return SoftBodySettings(PyObject_GetAttrString(pyobjref, "settings"));
	}

	// point_cache
	PointCache SoftBodyModifier::point_cache() {
		return PointCache(PyObject_GetAttrString(pyobjref, "point_cache"));
	}

	/**************** Boolean Modifier ****************/

	// object
	Object BooleanModifier::object_value() {
		return Object(PyObject_GetAttrString(pyobjref, "object"));
	}

	/**************** Array Modifier ****************/

	// curve
	Object ArrayModifier::curve() {
		return Object(PyObject_GetAttrString(pyobjref, "curve"));
	}

	// offset_object
	Object ArrayModifier::offset_object() {
		return Object(PyObject_GetAttrString(pyobjref, "offset_object"));
	}

	// start_cap
	Object ArrayModifier::start_cap() {
		return Object(PyObject_GetAttrString(pyobjref, "start_cap"));
	}

	// end_cap
	Object ArrayModifier::end_cap() {
		return Object(PyObject_GetAttrString(pyobjref, "end_cap"));
	}

	/**************** Displace Modifier ****************/

	// texture_coords_object
	Object DisplaceModifier::texture_coords_object() {
		return Object(PyObject_GetAttrString(pyobjref, "texture_coords_object"));
	}

	/**************** UV Project Modifier ****************/

	// projectors
	std::map<std::string, UVProjector> UVProjectModifier::projectors() {
		// TODO: MISSING DEREF! USE #DEFINE!
		PyObject *seqval = PyObject_GetAttrString(pyobjref, "projectors");
		PyObject *seqkeys = PyObject_CallMethod(seqval, "keys", NULL);
		std::map<std::string, UVProjector> resmap;
		for (int i = 0; i < PySequence_Length(seqval); i++) {
			PyObject *keyobj = PySequence_GetItem(seqkeys, i);
			std::string key = PyBytes_AsString(PyUnicode_AsASCIIString(keyobj));
			UVProjector value = UVProjector(PySequence_GetItem(seqval, i));
			resmap.insert(std::pair<std::string,UVProjector>(key, value));
		}
		return resmap;
	}

	void UVProjectModifier::projectors(std::map<std::string, UVProjector> value) { /* not implemented */ }

	/**************** UVProjector ****************/

	// object
	Object UVProjector::object_value() {
		return Object(PyObject_GetAttrString(pyobjref, "object"));
	}

	/**************** Cast Modifier ****************/

	// object
	Object CastModifier::object_value() {
		return Object(PyObject_GetAttrString(pyobjref, "object"));
	}

	/**************** MeshDeform Modifier ****************/

	// object
	Object MeshDeformModifier::object_value() {
		return Object(PyObject_GetAttrString(pyobjref, "object"));
	}

	/**************** ParticleSystem Modifier ****************/

	// particle_system
	ParticleSystem ParticleSystemModifier::particle_system() {
		return ParticleSystem(PyObject_GetAttrString(pyobjref, "particle_system"));
	}

	/**************** ParticleInstance Modifier ****************/

	// object
	Object ParticleInstanceModifier::object_value() {
		return Object(PyObject_GetAttrString(pyobjref, "object"));
	}

	/**************** Cloth Modifier ****************/

	// point_cache
	PointCache ClothModifier::point_cache() {
		return PointCache(PyObject_GetAttrString(pyobjref, "point_cache"));
	}

	/**************** Collision Modifier ****************/

	// settings
	CollisionSettings CollisionModifier::settings() {
		return CollisionSettings(PyObject_GetAttrString(pyobjref, "settings"));
	}

	/**************** Shrinkwrap Modifier ****************/

	// target
	Object ShrinkwrapModifier::target() {
		return Object(PyObject_GetAttrString(pyobjref, "target"));
	}

	// auxiliary_target
	Object ShrinkwrapModifier::auxiliary_target() {
		return Object(PyObject_GetAttrString(pyobjref, "auxiliary_target"));
	}

	/**************** Mask Modifier ****************/

	// armature
	Object MaskModifier::armature() {
		return Object(PyObject_GetAttrString(pyobjref, "armature"));
	}

	/**************** SimpleDeform Modifier ****************/

	// origin
	Object SimpleDeformModifier::origin() {
		return Object(PyObject_GetAttrString(pyobjref, "origin"));
	}

	/**************** Warp Modifier ****************/

	// object_from
	Object WarpModifier::object_from() {
		return Object(PyObject_GetAttrString(pyobjref, "object_from"));
	}

	// object_to
	Object WarpModifier::object_to() {
		return Object(PyObject_GetAttrString(pyobjref, "object_to"));
	}

	// texture_coords_object
	Object WarpModifier::texture_coords_object() {
		return Object(PyObject_GetAttrString(pyobjref, "texture_coords_object"));
	}

	/**************** Smoke Modifier ****************/

	// domain_settings
	SmokeDomainSettings SmokeModifier::domain_settings() {
		return SmokeDomainSettings(PyObject_GetAttrString(pyobjref, "domain_settings"));
	}

	// flow_settings
	SmokeFlowSettings SmokeModifier::flow_settings() {
		return SmokeFlowSettings(PyObject_GetAttrString(pyobjref, "flow_settings"));
	}

	// coll_settings
	SmokeCollSettings SmokeModifier::coll_settings() {
		return SmokeCollSettings(PyObject_GetAttrString(pyobjref, "coll_settings"));
	}

	/**************** Screw Modifier ****************/

	// object
	Object ScrewModifier::object_value() {
		return Object(PyObject_GetAttrString(pyobjref, "object"));
	}

	/**************** UVWarp Modifier ****************/

	// object_from
	Object UVWarpModifier::object_from() {
		return Object(PyObject_GetAttrString(pyobjref, "object_from"));
	}

	// object_to
	Object UVWarpModifier::object_to() {
		return Object(PyObject_GetAttrString(pyobjref, "object_to"));
	}

	/**************** WeightVG Edit Modifier ****************/

	// mask_tex_map_object
	Object VertexWeightEditModifier::mask_tex_map_object() {
		return Object(PyObject_GetAttrString(pyobjref, "mask_tex_map_object"));
	}

	/**************** WeightVG Mix Modifier ****************/

	// mask_tex_map_object
	Object VertexWeightMixModifier::mask_tex_map_object() {
		return Object(PyObject_GetAttrString(pyobjref, "mask_tex_map_object"));
	}

	/**************** WeightVG Proximity Modifier ****************/

	// target
	Object VertexWeightProximityModifier::target() {
		return Object(PyObject_GetAttrString(pyobjref, "target"));
	}

	// mask_tex_map_object
	Object VertexWeightProximityModifier::mask_tex_map_object() {
		return Object(PyObject_GetAttrString(pyobjref, "mask_tex_map_object"));
	}

	/**************** Data Transfer Modifier ****************/

	// object
	Object DataTransferModifier::object_value() {
		return Object(PyObject_GetAttrString(pyobjref, "object"));
	}

	/**************** Normal Edit Modifier ****************/

	// target
	Object NormalEditModifier::target() {
		return Object(PyObject_GetAttrString(pyobjref, "target"));
	}

	/**************** NLA Track ****************/

	// strips
	std::map<std::string, NlaStrip> NlaTrack::strips() {
		// TODO: MISSING DEREF! USE #DEFINE!
		PyObject *seqval = PyObject_GetAttrString(pyobjref, "strips");
		PyObject *seqkeys = PyObject_CallMethod(seqval, "keys", NULL);
		std::map<std::string, NlaStrip> resmap;
		for (int i = 0; i < PySequence_Length(seqval); i++) {
			PyObject *keyobj = PySequence_GetItem(seqkeys, i);
			std::string key = PyBytes_AsString(PyUnicode_AsASCIIString(keyobj));
			NlaStrip value = NlaStrip(PySequence_GetItem(seqval, i));
			resmap.insert(std::pair<std::string,NlaStrip>(key, value));
		}
		return resmap;
	}

	void NlaTrack::strips(std::map<std::string, NlaStrip> value) { /* not implemented */ }

	NlaStrip NlaStrips::create(const std::string name, int start, Action action)
	{
		// not implemented
		return NlaStrip();
	}

	void NlaStrips::remove(NlaStrip strip)
	{
		// not implemented
	}

	/**************** Node Socket ****************/

	// node
	Node NodeSocket::node() {
		return Node(PyObject_GetAttrString(pyobjref, "node"));
	}

	/**************** Node ****************/

	// internal_links
	std::map<std::string, NodeLink> Node::internal_links() {
		// TODO: MISSING DEREF! USE #DEFINE!
		PyObject *seqval = PyObject_GetAttrString(pyobjref, "internal_links");
		PyObject *seqkeys = PyObject_CallMethod(seqval, "keys", NULL);
		std::map<std::string, NodeLink> resmap;
		for (int i = 0; i < PySequence_Length(seqval); i++) {
			PyObject *keyobj = PySequence_GetItem(seqkeys, i);
			std::string key = PyBytes_AsString(PyUnicode_AsASCIIString(keyobj));
			NodeLink value = NodeLink(PySequence_GetItem(seqval, i));
			resmap.insert(std::pair<std::string,NodeLink>(key, value));
		}
		return resmap;
	}

	void Node::internal_links(std::map<std::string, NodeLink> value) { /* not implemented */ }

	NodeSocket NodeInputs::create(const std::string type, const std::string name, const std::string identifier)
	{
		// not implemented
		return NodeSocket();
	}

	void NodeInputs::remove(NodeSocket socket)
	{
		// not implemented
	}

	NodeSocket NodeOutputs::create(const std::string type, const std::string name, const std::string identifier)
	{
		// not implemented
		return NodeSocket();
	}

	void NodeOutputs::remove(NodeSocket socket)
	{
		// not implemented
	}

	bool NodeInternal::poll(NodeTree node_tree)
	{
		// not implemented
		return true;
	}

	bool NodeInternal::poll_instance(NodeTree node_tree)
	{
		// not implemented
		return true;
	}

	void NodeInternal::draw_buttons(Context context, UILayout layout)
	{
		// not implemented
	}

	void NodeInternal::draw_buttons_ext(Context context, UILayout layout)
	{
		// not implemented
	}

	/**************** Nodes ****************/

	// active
	Node Nodes::active() {
		return Node(PyObject_GetAttrString(pyobjref, "active"));
	}

	Node Nodes::create(const std::string type)
	{
		// not implemented
		return Node();
	}

	void Nodes::remove(Node node)
	{
		// not implemented
	}

	NodeLink NodeLinks::create(NodeSocket input, NodeSocket output, bool verify_limits)
	{
		// not implemented
		return NodeLink();
	}

	void NodeLinks::remove(NodeLink link)
	{
		// not implemented
	}

	NodeSocketInterface NodeTreeInputs::create(const std::string type, const std::string name)
	{
		// not implemented
		return NodeSocketInterface();
	}

	void NodeTreeInputs::remove(NodeSocketInterface socket)
	{
		// not implemented
	}

	NodeSocketInterface NodeTreeOutputs::create(const std::string type, const std::string name)
	{
		// not implemented
		return NodeSocketInterface();
	}

	void NodeTreeOutputs::remove(NodeSocketInterface socket)
	{
		// not implemented
	}

	void NodeSocketStandard::draw(Context context, UILayout layout, Node node, const std::string text)
	{
		// not implemented
	}

	void NodeSocketInterfaceStandard::draw(Context context, UILayout layout)
	{
		// not implemented
	}

	/**************** Frame ****************/

	// text
	Text NodeFrame::text() {
		return Text(PyObject_GetAttrString(pyobjref, "text"));
	}

	/**************** Lamp Data ****************/

	// lamp_object
	Object ShaderNodeLampData::lamp_object() {
		return Object(PyObject_GetAttrString(pyobjref, "lamp_object"));
	}

	/**************** Script ****************/

	// script
	Text ShaderNodeScript::script() {
		return Text(PyObject_GetAttrString(pyobjref, "script"));
	}

	/**************** Texture Coordinate ****************/

	// object
	Object ShaderNodeTexCoord::object_value() {
		return Object(PyObject_GetAttrString(pyobjref, "object"));
	}

	/**************** Render Layers ****************/

	// scene
	Scene CompositorNodeRLayers::scene() {
		return Scene(PyObject_GetAttrString(pyobjref, "scene"));
	}

	/**************** File Output ****************/

	// format
	ImageFormatSettings CompositorNodeOutputFile::format() {
		return ImageFormatSettings(PyObject_GetAttrString(pyobjref, "format"));
	}

	// file_slots
	std::map<std::string, NodeOutputFileSlotFile> CompositorNodeOutputFile::file_slots() {
		// TODO: MISSING DEREF! USE #DEFINE!
		PyObject *seqval = PyObject_GetAttrString(pyobjref, "file_slots");
		PyObject *seqkeys = PyObject_CallMethod(seqval, "keys", NULL);
		std::map<std::string, NodeOutputFileSlotFile> resmap;
		for (int i = 0; i < PySequence_Length(seqval); i++) {
			PyObject *keyobj = PySequence_GetItem(seqkeys, i);
			std::string key = PyBytes_AsString(PyUnicode_AsASCIIString(keyobj));
			NodeOutputFileSlotFile value = NodeOutputFileSlotFile(PySequence_GetItem(seqval, i));
			resmap.insert(std::pair<std::string,NodeOutputFileSlotFile>(key, value));
		}
		return resmap;
	}

	void CompositorNodeOutputFile::file_slots(std::map<std::string, NodeOutputFileSlotFile> value) { /* not implemented */ }

	// layer_slots
	std::map<std::string, NodeOutputFileSlotLayer> CompositorNodeOutputFile::layer_slots() {
		// TODO: MISSING DEREF! USE #DEFINE!
		PyObject *seqval = PyObject_GetAttrString(pyobjref, "layer_slots");
		PyObject *seqkeys = PyObject_CallMethod(seqval, "keys", NULL);
		std::map<std::string, NodeOutputFileSlotLayer> resmap;
		for (int i = 0; i < PySequence_Length(seqval); i++) {
			PyObject *keyobj = PySequence_GetItem(seqkeys, i);
			std::string key = PyBytes_AsString(PyUnicode_AsASCIIString(keyobj));
			NodeOutputFileSlotLayer value = NodeOutputFileSlotLayer(PySequence_GetItem(seqval, i));
			resmap.insert(std::pair<std::string,NodeOutputFileSlotLayer>(key, value));
		}
		return resmap;
	}

	void CompositorNodeOutputFile::layer_slots(std::map<std::string, NodeOutputFileSlotLayer> value) { /* not implemented */ }

	NodeSocket CompositorNodeOutputFileFileSlots::create(const std::string name)
	{
		// not implemented
		return NodeSocket();
	}

	void CompositorNodeOutputFileFileSlots::remove(NodeSocket socket)
	{
		// not implemented
	}

	NodeSocket CompositorNodeOutputFileLayerSlots::create(const std::string name)
	{
		// not implemented
		return NodeSocket();
	}

	void CompositorNodeOutputFileLayerSlots::remove(NodeSocket socket)
	{
		// not implemented
	}

	/**************** Defocus ****************/

	// scene
	Scene CompositorNodeDefocus::scene() {
		return Scene(PyObject_GetAttrString(pyobjref, "scene"));
	}

	/**************** Movie Clip ****************/

	// clip
	MovieClip CompositorNodeMovieClip::clip() {
		return MovieClip(PyObject_GetAttrString(pyobjref, "clip"));
	}

	/**************** Stabilize 2D ****************/

	// clip
	MovieClip CompositorNodeStabilize::clip() {
		return MovieClip(PyObject_GetAttrString(pyobjref, "clip"));
	}

	/**************** Movie Distortion ****************/

	// clip
	MovieClip CompositorNodeMovieDistortion::clip() {
		return MovieClip(PyObject_GetAttrString(pyobjref, "clip"));
	}

	/**************** Mask ****************/

	// mask
	Mask CompositorNodeMask::mask() {
		return Mask(PyObject_GetAttrString(pyobjref, "mask"));
	}

	/**************** Keying Screen ****************/

	// clip
	MovieClip CompositorNodeKeyingScreen::clip() {
		return MovieClip(PyObject_GetAttrString(pyobjref, "clip"));
	}

	/**************** Track Position ****************/

	// clip
	MovieClip CompositorNodeTrackPos::clip() {
		return MovieClip(PyObject_GetAttrString(pyobjref, "clip"));
	}

	/**************** Plane Track Deform ****************/

	// clip
	MovieClip CompositorNodePlaneTrackDeform::clip() {
		return MovieClip(PyObject_GetAttrString(pyobjref, "clip"));
	}

	/**************** Output File Slot ****************/

	// format
	ImageFormatSettings NodeOutputFileSlotFile::format() {
		return ImageFormatSettings(PyObject_GetAttrString(pyobjref, "format"));
	}

	/**************** Object ****************/

	// material_slots
	std::map<std::string, MaterialSlot> Object::material_slots() {
		// TODO: MISSING DEREF! USE #DEFINE!
		PyObject *seqval = PyObject_GetAttrString(pyobjref, "material_slots");
		PyObject *seqkeys = PyObject_CallMethod(seqval, "keys", NULL);
		std::map<std::string, MaterialSlot> resmap;
		for (int i = 0; i < PySequence_Length(seqval); i++) {
			PyObject *keyobj = PySequence_GetItem(seqkeys, i);
			std::string key = PyBytes_AsString(PyUnicode_AsASCIIString(keyobj));
			MaterialSlot value = MaterialSlot(PySequence_GetItem(seqval, i));
			resmap.insert(std::pair<std::string,MaterialSlot>(key, value));
		}
		return resmap;
	}

	void Object::material_slots(std::map<std::string, MaterialSlot> value) { /* not implemented */ }

	// game
	GameObjectSettings Object::game() {
		return GameObjectSettings(PyObject_GetAttrString(pyobjref, "game"));
	}

	// vertex_groups
	std::map<std::string, VertexGroup> Object::vertex_groups() {
		// TODO: MISSING DEREF! USE #DEFINE!
		PyObject *seqval = PyObject_GetAttrString(pyobjref, "vertex_groups");
		PyObject *seqkeys = PyObject_CallMethod(seqval, "keys", NULL);
		std::map<std::string, VertexGroup> resmap;
		for (int i = 0; i < PySequence_Length(seqval); i++) {
			PyObject *keyobj = PySequence_GetItem(seqkeys, i);
			std::string key = PyBytes_AsString(PyUnicode_AsASCIIString(keyobj));
			VertexGroup value = VertexGroup(PySequence_GetItem(seqval, i));
			resmap.insert(std::pair<std::string,VertexGroup>(key, value));
		}
		return resmap;
	}

	void Object::vertex_groups(std::map<std::string, VertexGroup> value) { /* not implemented */ }

	// field
	FieldSettings Object::field() {
		return FieldSettings(PyObject_GetAttrString(pyobjref, "field"));
	}

	// collision
	CollisionSettings Object::collision() {
		return CollisionSettings(PyObject_GetAttrString(pyobjref, "collision"));
	}

	// soft_body
	SoftBodySettings Object::soft_body() {
		return SoftBodySettings(PyObject_GetAttrString(pyobjref, "soft_body"));
	}

	// particle_systems
	std::map<std::string, ParticleSystem> Object::particle_systems() {
		// TODO: MISSING DEREF! USE #DEFINE!
		PyObject *seqval = PyObject_GetAttrString(pyobjref, "particle_systems");
		PyObject *seqkeys = PyObject_CallMethod(seqval, "keys", NULL);
		std::map<std::string, ParticleSystem> resmap;
		for (int i = 0; i < PySequence_Length(seqval); i++) {
			PyObject *keyobj = PySequence_GetItem(seqkeys, i);
			std::string key = PyBytes_AsString(PyUnicode_AsASCIIString(keyobj));
			ParticleSystem value = ParticleSystem(PySequence_GetItem(seqval, i));
			resmap.insert(std::pair<std::string,ParticleSystem>(key, value));
		}
		return resmap;
	}

	void Object::particle_systems(std::map<std::string, ParticleSystem> value) { /* not implemented */ }

	// rigid_body
	RigidBodyObject Object::rigid_body() {
		return RigidBodyObject(PyObject_GetAttrString(pyobjref, "rigid_body"));
	}

	// rigid_body_constraint
	RigidBodyConstraint Object::rigid_body_constraint() {
		return RigidBodyConstraint(PyObject_GetAttrString(pyobjref, "rigid_body_constraint"));
	}

	// dupli_list
	std::map<std::string, DupliObject> Object::dupli_list() {
		// TODO: MISSING DEREF! USE #DEFINE!
		PyObject *seqval = PyObject_GetAttrString(pyobjref, "dupli_list");
		PyObject *seqkeys = PyObject_CallMethod(seqval, "keys", NULL);
		std::map<std::string, DupliObject> resmap;
		for (int i = 0; i < PySequence_Length(seqval); i++) {
			PyObject *keyobj = PySequence_GetItem(seqkeys, i);
			std::string key = PyBytes_AsString(PyUnicode_AsASCIIString(keyobj));
			DupliObject value = DupliObject(PySequence_GetItem(seqval, i));
			resmap.insert(std::pair<std::string,DupliObject>(key, value));
		}
		return resmap;
	}

	void Object::dupli_list(std::map<std::string, DupliObject> value) { /* not implemented */ }

	// pose
	Pose Object::pose() {
		return Pose(PyObject_GetAttrString(pyobjref, "pose"));
	}

	// lod_levels
	std::map<std::string, LodLevel> Object::lod_levels() {
		// TODO: MISSING DEREF! USE #DEFINE!
		PyObject *seqval = PyObject_GetAttrString(pyobjref, "lod_levels");
		PyObject *seqkeys = PyObject_CallMethod(seqval, "keys", NULL);
		std::map<std::string, LodLevel> resmap;
		for (int i = 0; i < PySequence_Length(seqval); i++) {
			PyObject *keyobj = PySequence_GetItem(seqkeys, i);
			std::string key = PyBytes_AsString(PyUnicode_AsASCIIString(keyobj));
			LodLevel value = LodLevel(PySequence_GetItem(seqval, i));
			resmap.insert(std::pair<std::string,LodLevel>(key, value));
		}
		return resmap;
	}

	void Object::lod_levels(std::map<std::string, LodLevel> value) { /* not implemented */ }

	std::array<float, 16> Object::convert_space(PoseBone pose_bone, float matrix[16], space_items from_space, space_items to_space)
	{
		// not implemented
		throw NULL;
	}

	Object::camera_fit_coords_result Object::camera_fit_coords(Scene scene, int coordinates_len, float coordinates)
	{
		// not implemented
		return camera_fit_coords_result();
	}

	Mesh Object::to_mesh(Scene scene, bool apply_modifiers, mesh_type_items settings, bool calc_tessface, bool calc_undeformed)
	{
		// not implemented
		return Mesh();
	}

	void Object::dupli_list_create(Scene scene, dupli_eval_mode_items settings)
	{
		// not implemented
	}

	bool Object::is_visible(Scene scene)
	{
		// not implemented
		return true;
	}

	bool Object::is_modified(Scene scene, mesh_type_items settings)
	{
		// not implemented
		return true;
	}

	bool Object::is_deform_modified(Scene scene, mesh_type_items settings)
	{
		// not implemented
		return true;
	}

	Modifier ObjectModifiers::create(const std::string name, modifier_type_items type)
	{
		// not implemented
		return Modifier();
	}

	void ObjectModifiers::remove(Modifier modifier)
	{
		// not implemented
	}

	/**************** Object Constraints ****************/

	// active
	Constraint ObjectConstraints::active() {
		return Constraint(PyObject_GetAttrString(pyobjref, "active"));
	}

	Constraint ObjectConstraints::create(constraint_type_items type)
	{
		// not implemented
		return Constraint();
	}

	void ObjectConstraints::remove(Constraint constraint)
	{
		// not implemented
	}

	/**************** Vertex Groups ****************/

	// active
	VertexGroup VertexGroups::active() {
		return VertexGroup(PyObject_GetAttrString(pyobjref, "active"));
	}

	VertexGroup VertexGroups::create(const std::string name)
	{
		// not implemented
		return VertexGroup();
	}

	void VertexGroups::remove(VertexGroup group)
	{
		// not implemented
	}

	/**************** Particle Systems ****************/

	// active
	ParticleSystem ParticleSystems::active() {
		return ParticleSystem(PyObject_GetAttrString(pyobjref, "active"));
	}

	/**************** Game Object Settings ****************/

	// sensors
	std::map<std::string, Sensor> GameObjectSettings::sensors() {
		// TODO: MISSING DEREF! USE #DEFINE!
		PyObject *seqval = PyObject_GetAttrString(pyobjref, "sensors");
		PyObject *seqkeys = PyObject_CallMethod(seqval, "keys", NULL);
		std::map<std::string, Sensor> resmap;
		for (int i = 0; i < PySequence_Length(seqval); i++) {
			PyObject *keyobj = PySequence_GetItem(seqkeys, i);
			std::string key = PyBytes_AsString(PyUnicode_AsASCIIString(keyobj));
			Sensor value = Sensor(PySequence_GetItem(seqval, i));
			resmap.insert(std::pair<std::string,Sensor>(key, value));
		}
		return resmap;
	}

	void GameObjectSettings::sensors(std::map<std::string, Sensor> value) { /* not implemented */ }

	// properties
	std::map<std::string, GameProperty> GameObjectSettings::properties() {
		// TODO: MISSING DEREF! USE #DEFINE!
		PyObject *seqval = PyObject_GetAttrString(pyobjref, "properties");
		PyObject *seqkeys = PyObject_CallMethod(seqval, "keys", NULL);
		std::map<std::string, GameProperty> resmap;
		for (int i = 0; i < PySequence_Length(seqval); i++) {
			PyObject *keyobj = PySequence_GetItem(seqkeys, i);
			std::string key = PyBytes_AsString(PyUnicode_AsASCIIString(keyobj));
			GameProperty value = GameProperty(PySequence_GetItem(seqval, i));
			resmap.insert(std::pair<std::string,GameProperty>(key, value));
		}
		return resmap;
	}

	void GameObjectSettings::properties(std::map<std::string, GameProperty> value) { /* not implemented */ }

	// soft_body
	GameSoftBodySettings GameObjectSettings::soft_body() {
		return GameSoftBodySettings(PyObject_GetAttrString(pyobjref, "soft_body"));
	}

	void ObjectBase::layers_from_view(SpaceView3D view)
	{
		// not implemented
	}

	/**************** Object Duplicate ****************/

	// particle_system
	ParticleSystem DupliObject::particle_system() {
		return ParticleSystem(PyObject_GetAttrString(pyobjref, "particle_system"));
	}

	/**************** Palette Splines ****************/

	// active
	PaletteColor PaletteColors::active() {
		return PaletteColor(PyObject_GetAttrString(pyobjref, "active"));
	}

	PaletteColor PaletteColors::create()
	{
		// not implemented
		return PaletteColor();
	}

	void PaletteColors::remove(PaletteColor color)
	{
		// not implemented
	}

	std::array<float, 3> ParticleHairKey::co_object(Object object_value, ParticleSystemModifier modifier, Particle particle)
	{
		// not implemented
		throw NULL;
	}

	/**************** Particle System ****************/

	// settings
	ParticleSettings ParticleSystem::settings() {
		return ParticleSettings(PyObject_GetAttrString(pyobjref, "settings"));
	}

	void ParticleSystem::set_resolution(Scene scene, Object object_value, resolution_items resolution)
	{
		// not implemented
	}

	ParticleSettingsTextureSlot ParticleSettingsTextureSlots::add()
	{
		// not implemented
		return ParticleSettingsTextureSlot();
	}

	ParticleSettingsTextureSlot ParticleSettingsTextureSlots::create(int index)
	{
		// not implemented
		return ParticleSettingsTextureSlot();
	}

	/**************** Pose ****************/

	// bones
	std::map<std::string, PoseBone> Pose::bones() {
		// TODO: MISSING DEREF! USE #DEFINE!
		PyObject *seqval = PyObject_GetAttrString(pyobjref, "bones");
		PyObject *seqkeys = PyObject_CallMethod(seqval, "keys", NULL);
		std::map<std::string, PoseBone> resmap;
		for (int i = 0; i < PySequence_Length(seqval); i++) {
			PyObject *keyobj = PySequence_GetItem(seqkeys, i);
			std::string key = PyBytes_AsString(PyUnicode_AsASCIIString(keyobj));
			PoseBone value = PoseBone(PySequence_GetItem(seqval, i));
			resmap.insert(std::pair<std::string,PoseBone>(key, value));
		}
		return resmap;
	}

	void Pose::bones(std::map<std::string, PoseBone> value) { /* not implemented */ }

	// bone_groups
	std::map<std::string, BoneGroup> Pose::bone_groups() {
		// TODO: MISSING DEREF! USE #DEFINE!
		PyObject *seqval = PyObject_GetAttrString(pyobjref, "bone_groups");
		PyObject *seqkeys = PyObject_CallMethod(seqval, "keys", NULL);
		std::map<std::string, BoneGroup> resmap;
		for (int i = 0; i < PySequence_Length(seqval); i++) {
			PyObject *keyobj = PySequence_GetItem(seqkeys, i);
			std::string key = PyBytes_AsString(PyUnicode_AsASCIIString(keyobj));
			BoneGroup value = BoneGroup(PySequence_GetItem(seqval, i));
			resmap.insert(std::pair<std::string,BoneGroup>(key, value));
		}
		return resmap;
	}

	void Pose::bone_groups(std::map<std::string, BoneGroup> value) { /* not implemented */ }

	// ik_param
	IKParam Pose::ik_param() {
		return IKParam(PyObject_GetAttrString(pyobjref, "ik_param"));
	}

	/**************** Bone Groups ****************/

	// active
	BoneGroup BoneGroups::active() {
		return BoneGroup(PyObject_GetAttrString(pyobjref, "active"));
	}

	BoneGroup BoneGroups::create(const std::string name)
	{
		// not implemented
		return BoneGroup();
	}

	void BoneGroups::remove(BoneGroup group)
	{
		// not implemented
	}

	/**************** Pose Bone ****************/

	// bone_group
	BoneGroup PoseBone::bone_group() {
		return BoneGroup(PyObject_GetAttrString(pyobjref, "bone_group"));
	}

	/**************** PoseBone Constraints ****************/

	// active
	Constraint PoseBoneConstraints::active() {
		return Constraint(PyObject_GetAttrString(pyobjref, "active"));
	}

	Constraint PoseBoneConstraints::create(constraint_type_items type)
	{
		// not implemented
		return Constraint();
	}

	void PoseBoneConstraints::remove(Constraint constraint)
	{
		// not implemented
	}

	/**************** Bone Group ****************/

	// colors
	ThemeBoneColorSet BoneGroup::colors() {
		return ThemeBoneColorSet(PyObject_GetAttrString(pyobjref, "colors"));
	}

	/**************** Render Engine ****************/

	// render
	RenderSettings RenderEngine::render() {
		return RenderSettings(PyObject_GetAttrString(pyobjref, "render"));
	}

	RenderResult RenderEngine::begin_result(int x, int y, int w, int h, const std::string layer, const std::string view)
	{
		// not implemented
		return RenderResult();
	}

	void RenderEngine::update_result(RenderResult result)
	{
		// not implemented
	}

	void RenderEngine::end_result(RenderResult result, bool cancel, bool do_merge_results)
	{
		// not implemented
	}

	void RenderEngine::bind_display_space_shader(Scene scene)
	{
		// not implemented
	}

	bool RenderEngine::support_display_space_shader(Scene scene)
	{
		// not implemented
		return true;
	}

	/**************** Render Result ****************/

	// layers
	std::map<std::string, RenderLayer> RenderResult::layers() {
		// TODO: MISSING DEREF! USE #DEFINE!
		PyObject *seqval = PyObject_GetAttrString(pyobjref, "layers");
		PyObject *seqkeys = PyObject_CallMethod(seqval, "keys", NULL);
		std::map<std::string, RenderLayer> resmap;
		for (int i = 0; i < PySequence_Length(seqval); i++) {
			PyObject *keyobj = PySequence_GetItem(seqkeys, i);
			std::string key = PyBytes_AsString(PyUnicode_AsASCIIString(keyobj));
			RenderLayer value = RenderLayer(PySequence_GetItem(seqval, i));
			resmap.insert(std::pair<std::string,RenderLayer>(key, value));
		}
		return resmap;
	}

	void RenderResult::layers(std::map<std::string, RenderLayer> value) { /* not implemented */ }

	// views
	std::map<std::string, RenderView> RenderResult::views() {
		// TODO: MISSING DEREF! USE #DEFINE!
		PyObject *seqval = PyObject_GetAttrString(pyobjref, "views");
		PyObject *seqkeys = PyObject_CallMethod(seqval, "keys", NULL);
		std::map<std::string, RenderView> resmap;
		for (int i = 0; i < PySequence_Length(seqval); i++) {
			PyObject *keyobj = PySequence_GetItem(seqkeys, i);
			std::string key = PyBytes_AsString(PyUnicode_AsASCIIString(keyobj));
			RenderView value = RenderView(PySequence_GetItem(seqval, i));
			resmap.insert(std::pair<std::string,RenderView>(key, value));
		}
		return resmap;
	}

	void RenderResult::views(std::map<std::string, RenderView> value) { /* not implemented */ }

	/**************** Render Layer ****************/

	// passes
	std::map<std::string, RenderPass> RenderLayer::passes() {
		// TODO: MISSING DEREF! USE #DEFINE!
		PyObject *seqval = PyObject_GetAttrString(pyobjref, "passes");
		PyObject *seqkeys = PyObject_CallMethod(seqval, "keys", NULL);
		std::map<std::string, RenderPass> resmap;
		for (int i = 0; i < PySequence_Length(seqval); i++) {
			PyObject *keyobj = PySequence_GetItem(seqkeys, i);
			std::string key = PyBytes_AsString(PyUnicode_AsASCIIString(keyobj));
			RenderPass value = RenderPass(PySequence_GetItem(seqval, i));
			resmap.insert(std::pair<std::string,RenderPass>(key, value));
		}
		return resmap;
	}

	void RenderLayer::passes(std::map<std::string, RenderPass> value) { /* not implemented */ }

	RenderPass RenderPasses::find_by_type(render_pass_type_items pass_type, const std::string view)
	{
		// not implemented
		return RenderPass();
	}

	/**************** Scene ****************/

	// world
	World Scene::world() {
		return World(PyObject_GetAttrString(pyobjref, "world"));
	}

	// sequence_editor
	SequenceEditor Scene::sequence_editor() {
		return SequenceEditor(PyObject_GetAttrString(pyobjref, "sequence_editor"));
	}

	// tool_settings
	ToolSettings Scene::tool_settings() {
		return ToolSettings(PyObject_GetAttrString(pyobjref, "tool_settings"));
	}

	// unit_settings
	UnitSettings Scene::unit_settings() {
		return UnitSettings(PyObject_GetAttrString(pyobjref, "unit_settings"));
	}

	// render
	RenderSettings Scene::render() {
		return RenderSettings(PyObject_GetAttrString(pyobjref, "render"));
	}

	// safe_areas
	DisplaySafeAreas Scene::safe_areas() {
		return DisplaySafeAreas(PyObject_GetAttrString(pyobjref, "safe_areas"));
	}

	// timeline_markers
	std::map<std::string, TimelineMarker> Scene::timeline_markers() {
		// TODO: MISSING DEREF! USE #DEFINE!
		PyObject *seqval = PyObject_GetAttrString(pyobjref, "timeline_markers");
		PyObject *seqkeys = PyObject_CallMethod(seqval, "keys", NULL);
		std::map<std::string, TimelineMarker> resmap;
		for (int i = 0; i < PySequence_Length(seqval); i++) {
			PyObject *keyobj = PySequence_GetItem(seqkeys, i);
			std::string key = PyBytes_AsString(PyUnicode_AsASCIIString(keyobj));
			TimelineMarker value = TimelineMarker(PySequence_GetItem(seqval, i));
			resmap.insert(std::pair<std::string,TimelineMarker>(key, value));
		}
		return resmap;
	}

	void Scene::timeline_markers(std::map<std::string, TimelineMarker> value) { /* not implemented */ }

	// game_settings
	SceneGameData Scene::game_settings() {
		return SceneGameData(PyObject_GetAttrString(pyobjref, "game_settings"));
	}

	// orientations
	std::map<std::string, TransformOrientation> Scene::orientations() {
		// TODO: MISSING DEREF! USE #DEFINE!
		PyObject *seqval = PyObject_GetAttrString(pyobjref, "orientations");
		PyObject *seqkeys = PyObject_CallMethod(seqval, "keys", NULL);
		std::map<std::string, TransformOrientation> resmap;
		for (int i = 0; i < PySequence_Length(seqval); i++) {
			PyObject *keyobj = PySequence_GetItem(seqkeys, i);
			std::string key = PyBytes_AsString(PyUnicode_AsASCIIString(keyobj));
			TransformOrientation value = TransformOrientation(PySequence_GetItem(seqval, i));
			resmap.insert(std::pair<std::string,TransformOrientation>(key, value));
		}
		return resmap;
	}

	void Scene::orientations(std::map<std::string, TransformOrientation> value) { /* not implemented */ }

	// active_clip
	MovieClip Scene::active_clip() {
		return MovieClip(PyObject_GetAttrString(pyobjref, "active_clip"));
	}

	SequenceEditor Scene::sequence_editor_create()
	{
		// not implemented
		return SequenceEditor();
	}

	/**************** Scene Bases ****************/

	// active
	ObjectBase SceneBases::active() {
		return ObjectBase(PyObject_GetAttrString(pyobjref, "active"));
	}

	/**************** Scene Objects ****************/

	// active
	Object SceneObjects::active() {
		return Object(PyObject_GetAttrString(pyobjref, "active"));
	}

	ObjectBase SceneObjects::link(Object object_value)
	{
		// not implemented
		return ObjectBase();
	}

	void SceneObjects::unlink(Object object_value)
	{
		// not implemented
	}

	/**************** Keying Sets ****************/

	// active
	KeyingSet KeyingSets::active() {
		return KeyingSet(PyObject_GetAttrString(pyobjref, "active"));
	}

	KeyingSet KeyingSets::create(const std::string idname, const std::string name)
	{
		// not implemented
		return KeyingSet();
	}

	/**************** Keying Sets All ****************/

	// active
	KeyingSet KeyingSetsAll::active() {
		return KeyingSet(PyObject_GetAttrString(pyobjref, "active"));
	}

	TimelineMarker TimelineMarkers::create(const std::string name, int frame)
	{
		// not implemented
		return TimelineMarker();
	}

	void TimelineMarkers::remove(TimelineMarker marker)
	{
		// not implemented
	}

	/**************** Tool Settings ****************/

	// sculpt
	Sculpt ToolSettings::sculpt() {
		return Sculpt(PyObject_GetAttrString(pyobjref, "sculpt"));
	}

	// vertex_paint
	VertexPaint ToolSettings::vertex_paint() {
		return VertexPaint(PyObject_GetAttrString(pyobjref, "vertex_paint"));
	}

	// weight_paint
	VertexPaint ToolSettings::weight_paint() {
		return VertexPaint(PyObject_GetAttrString(pyobjref, "weight_paint"));
	}

	// image_paint
	ImagePaint ToolSettings::image_paint() {
		return ImagePaint(PyObject_GetAttrString(pyobjref, "image_paint"));
	}

	// uv_sculpt
	UvSculpt ToolSettings::uv_sculpt() {
		return UvSculpt(PyObject_GetAttrString(pyobjref, "uv_sculpt"));
	}

	// particle_edit
	ParticleEdit ToolSettings::particle_edit() {
		return ParticleEdit(PyObject_GetAttrString(pyobjref, "particle_edit"));
	}

	// unified_paint_settings
	UnifiedPaintSettings ToolSettings::unified_paint_settings() {
		return UnifiedPaintSettings(PyObject_GetAttrString(pyobjref, "unified_paint_settings"));
	}

	// statvis
	MeshStatVis ToolSettings::statvis() {
		return MeshStatVis(PyObject_GetAttrString(pyobjref, "statvis"));
	}

	/**************** Game Data ****************/

	// dome_text
	Text SceneGameData::dome_text() {
		return Text(PyObject_GetAttrString(pyobjref, "dome_text"));
	}

	// recast_data
	SceneGameRecastData SceneGameData::recast_data() {
		return SceneGameRecastData(PyObject_GetAttrString(pyobjref, "recast_data"));
	}

	/**************** Render Data ****************/

	// layers
	std::map<std::string, SceneRenderLayer> RenderSettings::layers() {
		// TODO: MISSING DEREF! USE #DEFINE!
		PyObject *seqval = PyObject_GetAttrString(pyobjref, "layers");
		PyObject *seqkeys = PyObject_CallMethod(seqval, "keys", NULL);
		std::map<std::string, SceneRenderLayer> resmap;
		for (int i = 0; i < PySequence_Length(seqval); i++) {
			PyObject *keyobj = PySequence_GetItem(seqkeys, i);
			std::string key = PyBytes_AsString(PyUnicode_AsASCIIString(keyobj));
			SceneRenderLayer value = SceneRenderLayer(PySequence_GetItem(seqval, i));
			resmap.insert(std::pair<std::string,SceneRenderLayer>(key, value));
		}
		return resmap;
	}

	void RenderSettings::layers(std::map<std::string, SceneRenderLayer> value) { /* not implemented */ }

	// views
	std::map<std::string, SceneRenderView> RenderSettings::views() {
		// TODO: MISSING DEREF! USE #DEFINE!
		PyObject *seqval = PyObject_GetAttrString(pyobjref, "views");
		PyObject *seqkeys = PyObject_CallMethod(seqval, "keys", NULL);
		std::map<std::string, SceneRenderView> resmap;
		for (int i = 0; i < PySequence_Length(seqval); i++) {
			PyObject *keyobj = PySequence_GetItem(seqkeys, i);
			std::string key = PyBytes_AsString(PyUnicode_AsASCIIString(keyobj));
			SceneRenderView value = SceneRenderView(PySequence_GetItem(seqval, i));
			resmap.insert(std::pair<std::string,SceneRenderView>(key, value));
		}
		return resmap;
	}

	void RenderSettings::views(std::map<std::string, SceneRenderView> value) { /* not implemented */ }

	// stereo_views
	std::map<std::string, SceneRenderView> RenderSettings::stereo_views() {
		// TODO: MISSING DEREF! USE #DEFINE!
		PyObject *seqval = PyObject_GetAttrString(pyobjref, "stereo_views");
		PyObject *seqkeys = PyObject_CallMethod(seqval, "keys", NULL);
		std::map<std::string, SceneRenderView> resmap;
		for (int i = 0; i < PySequence_Length(seqval); i++) {
			PyObject *keyobj = PySequence_GetItem(seqkeys, i);
			std::string key = PyBytes_AsString(PyUnicode_AsASCIIString(keyobj));
			SceneRenderView value = SceneRenderView(PySequence_GetItem(seqval, i));
			resmap.insert(std::pair<std::string,SceneRenderView>(key, value));
		}
		return resmap;
	}

	void RenderSettings::stereo_views(std::map<std::string, SceneRenderView> value) { /* not implemented */ }

	// bake
	BakeSettings RenderSettings::bake() {
		return BakeSettings(PyObject_GetAttrString(pyobjref, "bake"));
	}

	/**************** Render Layers ****************/

	// active
	SceneRenderLayer RenderLayers::active() {
		return SceneRenderLayer(PyObject_GetAttrString(pyobjref, "active"));
	}

	SceneRenderLayer RenderLayers::create(const std::string name)
	{
		// not implemented
		return SceneRenderLayer();
	}

	void RenderLayers::remove(SceneRenderLayer layer)
	{
		// not implemented
	}

	/**************** Render Views ****************/

	// active
	SceneRenderView RenderViews::active() {
		return SceneRenderView(PyObject_GetAttrString(pyobjref, "active"));
	}

	SceneRenderView RenderViews::create(const std::string name)
	{
		// not implemented
		return SceneRenderView();
	}

	void RenderViews::remove(SceneRenderView view)
	{
		// not implemented
	}

	/**************** Scene Render Layer ****************/

	// freestyle_settings
	FreestyleSettings SceneRenderLayer::freestyle_settings() {
		return FreestyleSettings(PyObject_GetAttrString(pyobjref, "freestyle_settings"));
	}

	/**************** Freestyle Module ****************/

	// script
	Text FreestyleModuleSettings::script() {
		return Text(PyObject_GetAttrString(pyobjref, "script"));
	}

	FreestyleModuleSettings FreestyleModules::create()
	{
		// not implemented
		return FreestyleModuleSettings();
	}

	void FreestyleModules::remove(FreestyleModuleSettings module)
	{
		// not implemented
	}

	/**************** Line Sets ****************/

	// active
	FreestyleLineSet Linesets::active() {
		return FreestyleLineSet(PyObject_GetAttrString(pyobjref, "active"));
	}

	FreestyleLineSet Linesets::create(const std::string name)
	{
		// not implemented
		return FreestyleLineSet();
	}

	void Linesets::remove(FreestyleLineSet lineset)
	{
		// not implemented
	}

	/**************** Screen ****************/

	// areas
	std::map<std::string, Area> Screen::areas() {
		// TODO: MISSING DEREF! USE #DEFINE!
		PyObject *seqval = PyObject_GetAttrString(pyobjref, "areas");
		PyObject *seqkeys = PyObject_CallMethod(seqval, "keys", NULL);
		std::map<std::string, Area> resmap;
		for (int i = 0; i < PySequence_Length(seqval); i++) {
			PyObject *keyobj = PySequence_GetItem(seqkeys, i);
			std::string key = PyBytes_AsString(PyUnicode_AsASCIIString(keyobj));
			Area value = Area(PySequence_GetItem(seqval, i));
			resmap.insert(std::pair<std::string,Area>(key, value));
		}
		return resmap;
	}

	void Screen::areas(std::map<std::string, Area> value) { /* not implemented */ }

	/**************** Area ****************/

	// spaces
	std::map<std::string, Space> Area::spaces() {
		// TODO: MISSING DEREF! USE #DEFINE!
		PyObject *seqval = PyObject_GetAttrString(pyobjref, "spaces");
		PyObject *seqkeys = PyObject_CallMethod(seqval, "keys", NULL);
		std::map<std::string, Space> resmap;
		for (int i = 0; i < PySequence_Length(seqval); i++) {
			PyObject *keyobj = PySequence_GetItem(seqkeys, i);
			std::string key = PyBytes_AsString(PyUnicode_AsASCIIString(keyobj));
			Space value = Space(PySequence_GetItem(seqval, i));
			resmap.insert(std::pair<std::string,Space>(key, value));
		}
		return resmap;
	}

	void Area::spaces(std::map<std::string, Space> value) { /* not implemented */ }

	// regions
	std::map<std::string, Region> Area::regions() {
		// TODO: MISSING DEREF! USE #DEFINE!
		PyObject *seqval = PyObject_GetAttrString(pyobjref, "regions");
		PyObject *seqkeys = PyObject_CallMethod(seqval, "keys", NULL);
		std::map<std::string, Region> resmap;
		for (int i = 0; i < PySequence_Length(seqval); i++) {
			PyObject *keyobj = PySequence_GetItem(seqkeys, i);
			std::string key = PyBytes_AsString(PyUnicode_AsASCIIString(keyobj));
			Region value = Region(PySequence_GetItem(seqval, i));
			resmap.insert(std::pair<std::string,Region>(key, value));
		}
		return resmap;
	}

	void Area::regions(std::map<std::string, Region> value) { /* not implemented */ }

	/**************** Area Spaces ****************/

	// active
	Space AreaSpaces::active() {
		return Space(PyObject_GetAttrString(pyobjref, "active"));
	}

	/**************** Region ****************/

	// view2d
	View2D Region::view2d() {
		return View2D(PyObject_GetAttrString(pyobjref, "view2d"));
	}

	/**************** Particle Edit ****************/

	// brush
	ParticleBrush ParticleEdit::brush() {
		return ParticleBrush(PyObject_GetAttrString(pyobjref, "brush"));
	}

	/**************** Sequence ****************/

	// modifiers
	std::map<std::string, SequenceModifier> Sequence::modifiers() {
		// TODO: MISSING DEREF! USE #DEFINE!
		PyObject *seqval = PyObject_GetAttrString(pyobjref, "modifiers");
		PyObject *seqkeys = PyObject_CallMethod(seqval, "keys", NULL);
		std::map<std::string, SequenceModifier> resmap;
		for (int i = 0; i < PySequence_Length(seqval); i++) {
			PyObject *keyobj = PySequence_GetItem(seqkeys, i);
			std::string key = PyBytes_AsString(PyUnicode_AsASCIIString(keyobj));
			SequenceModifier value = SequenceModifier(PySequence_GetItem(seqval, i));
			resmap.insert(std::pair<std::string,SequenceModifier>(key, value));
		}
		return resmap;
	}

	void Sequence::modifiers(std::map<std::string, SequenceModifier> value) { /* not implemented */ }

	SequenceModifier SequenceModifiers::create(const std::string name, sequence_modifier_type_items type)
	{
		// not implemented
		return SequenceModifier();
	}

	void SequenceModifiers::remove(SequenceModifier modifier)
	{
		// not implemented
	}

	Sequence Sequences::new_clip(const std::string name, MovieClip clip, int channel, int frame_start)
	{
		// not implemented
		return Sequence();
	}

	Sequence Sequences::new_mask(const std::string name, Mask mask, int channel, int frame_start)
	{
		// not implemented
		return Sequence();
	}

	Sequence Sequences::new_scene(const std::string name, Scene scene, int channel, int frame_start)
	{
		// not implemented
		return Sequence();
	}

	Sequence Sequences::new_image(const std::string name, const std::string filepath, int channel, int frame_start)
	{
		// not implemented
		return Sequence();
	}

	Sequence Sequences::new_movie(const std::string name, const std::string filepath, int channel, int frame_start)
	{
		// not implemented
		return Sequence();
	}

	Sequence Sequences::new_sound(const std::string name, const std::string filepath, int channel, int frame_start)
	{
		// not implemented
		return Sequence();
	}

	Sequence Sequences::new_effect(const std::string name, seq_effect_items type, int channel, int frame_start, int frame_end, Sequence seq1, Sequence seq2, Sequence seq3)
	{
		// not implemented
		return Sequence();
	}

	void Sequences::remove(Sequence sequence)
	{
		// not implemented
	}

	SequenceElement SequenceElements::append(const std::string filename)
	{
		// not implemented
		return SequenceElement();
	}

	/**************** Mask Sequence ****************/

	// mask
	Mask MaskSequence::mask() {
		return Mask(PyObject_GetAttrString(pyobjref, "mask"));
	}

	/**************** Sound Sequence ****************/

	// sound
	Sound SoundSequence::sound() {
		return Sound(PyObject_GetAttrString(pyobjref, "sound"));
	}

	/**************** SequenceModifier ****************/

	// input_mask_id
	Mask SequenceModifier::input_mask_id() {
		return Mask(PyObject_GetAttrString(pyobjref, "input_mask_id"));
	}

	/**************** Space Image Editor ****************/

	// uv_editor
	SpaceUVEditor SpaceImageEditor::uv_editor() {
		return SpaceUVEditor(PyObject_GetAttrString(pyobjref, "uv_editor"));
	}

	// mask
	Mask SpaceImageEditor::mask() {
		return Mask(PyObject_GetAttrString(pyobjref, "mask"));
	}

	/**************** Space Text Editor ****************/

	// text
	Text SpaceTextEditor::text() {
		return Text(PyObject_GetAttrString(pyobjref, "text"));
	}

	/**************** Space File Browser ****************/

	// active_operator
	Operator SpaceFileBrowser::active_operator() {
		return Operator(PyObject_GetAttrString(pyobjref, "active_operator"));
	}

	// operator
	Operator SpaceFileBrowser::operator_value() {
		return Operator(PyObject_GetAttrString(pyobjref, "operator"));
	}

	/**************** Background Image ****************/

	// clip
	MovieClip BackgroundImage::clip() {
		return MovieClip(PyObject_GetAttrString(pyobjref, "clip"));
	}

	// clip_user
	MovieClipUser BackgroundImage::clip_user() {
		return MovieClipUser(PyObject_GetAttrString(pyobjref, "clip_user"));
	}

	/**************** 3D View Space ****************/

	// region_3d
	RegionView3D SpaceView3D::region_3d() {
		return RegionView3D(PyObject_GetAttrString(pyobjref, "region_3d"));
	}

	// region_quadviews
	std::map<std::string, RegionView3D> SpaceView3D::region_quadviews() {
		// TODO: MISSING DEREF! USE #DEFINE!
		PyObject *seqval = PyObject_GetAttrString(pyobjref, "region_quadviews");
		PyObject *seqkeys = PyObject_CallMethod(seqval, "keys", NULL);
		std::map<std::string, RegionView3D> resmap;
		for (int i = 0; i < PySequence_Length(seqval); i++) {
			PyObject *keyobj = PySequence_GetItem(seqkeys, i);
			std::string key = PyBytes_AsString(PyUnicode_AsASCIIString(keyobj));
			RegionView3D value = RegionView3D(PySequence_GetItem(seqval, i));
			resmap.insert(std::pair<std::string,RegionView3D>(key, value));
		}
		return resmap;
	}

	void SpaceView3D::region_quadviews(std::map<std::string, RegionView3D> value) { /* not implemented */ }

	BackgroundImage BackgroundImages::create()
	{
		// not implemented
		return BackgroundImage();
	}

	void BackgroundImages::remove(BackgroundImage image)
	{
		// not implemented
	}

	/**************** Space Console ****************/

	// history
	std::map<std::string, ConsoleLine> SpaceConsole::history() {
		// TODO: MISSING DEREF! USE #DEFINE!
		PyObject *seqval = PyObject_GetAttrString(pyobjref, "history");
		PyObject *seqkeys = PyObject_CallMethod(seqval, "keys", NULL);
		std::map<std::string, ConsoleLine> resmap;
		for (int i = 0; i < PySequence_Length(seqval); i++) {
			PyObject *keyobj = PySequence_GetItem(seqkeys, i);
			std::string key = PyBytes_AsString(PyUnicode_AsASCIIString(keyobj));
			ConsoleLine value = ConsoleLine(PySequence_GetItem(seqval, i));
			resmap.insert(std::pair<std::string,ConsoleLine>(key, value));
		}
		return resmap;
	}

	void SpaceConsole::history(std::map<std::string, ConsoleLine> value) { /* not implemented */ }

	// scrollback
	std::map<std::string, ConsoleLine> SpaceConsole::scrollback() {
		// TODO: MISSING DEREF! USE #DEFINE!
		PyObject *seqval = PyObject_GetAttrString(pyobjref, "scrollback");
		PyObject *seqkeys = PyObject_CallMethod(seqval, "keys", NULL);
		std::map<std::string, ConsoleLine> resmap;
		for (int i = 0; i < PySequence_Length(seqval); i++) {
			PyObject *keyobj = PySequence_GetItem(seqkeys, i);
			std::string key = PyBytes_AsString(PyUnicode_AsASCIIString(keyobj));
			ConsoleLine value = ConsoleLine(PySequence_GetItem(seqval, i));
			resmap.insert(std::pair<std::string,ConsoleLine>(key, value));
		}
		return resmap;
	}

	void SpaceConsole::scrollback(std::map<std::string, ConsoleLine> value) { /* not implemented */ }

	void SpaceNodeEditorPath::start(NodeTree node_tree)
	{
		// not implemented
	}

	void SpaceNodeEditorPath::append(NodeTree node_tree, Node node)
	{
		// not implemented
	}

	/**************** Space Clip Editor ****************/

	// clip
	MovieClip SpaceClipEditor::clip() {
		return MovieClip(PyObject_GetAttrString(pyobjref, "clip"));
	}

	// clip_user
	MovieClipUser SpaceClipEditor::clip_user() {
		return MovieClipUser(PyObject_GetAttrString(pyobjref, "clip_user"));
	}

	// mask
	Mask SpaceClipEditor::mask() {
		return Mask(PyObject_GetAttrString(pyobjref, "mask"));
	}

	// scopes
	MovieClipScopes SpaceClipEditor::scopes() {
		return MovieClipScopes(PyObject_GetAttrString(pyobjref, "scopes"));
	}

	/**************** Speaker ****************/

	// sound
	Sound Speaker::sound() {
		return Sound(PyObject_GetAttrString(pyobjref, "sound"));
	}

	OperatorProperties UILayout::operator_value(const std::string operator_value, const std::string text, const std::string text_ctxt, bool translate, icon_items icon, bool emboss, int icon_value)
	{
		// not implemented
		return OperatorProperties();
	}

	void UILayout::template_marker(AnyType data, const std::string property, MovieClipUser clip_user, MovieTrackingTrack track, bool compact)
	{
		// not implemented
	}

	void UILayout::template_movieclip_information(AnyType data, const std::string property, MovieClipUser clip_user)
	{
		// not implemented
	}

	void UILayout::template_keymap_item_properties(KeyMapItem item)
	{
		// not implemented
	}

	/**************** User Preferences ****************/

	// addons
	std::map<std::string, Addon> UserPreferences::addons() {
		// TODO: MISSING DEREF! USE #DEFINE!
		PyObject *seqval = PyObject_GetAttrString(pyobjref, "addons");
		PyObject *seqkeys = PyObject_CallMethod(seqval, "keys", NULL);
		std::map<std::string, Addon> resmap;
		for (int i = 0; i < PySequence_Length(seqval); i++) {
			PyObject *keyobj = PySequence_GetItem(seqkeys, i);
			std::string key = PyBytes_AsString(PyUnicode_AsASCIIString(keyobj));
			Addon value = Addon(PySequence_GetItem(seqval, i));
			resmap.insert(std::pair<std::string,Addon>(key, value));
		}
		return resmap;
	}

	void UserPreferences::addons(std::map<std::string, Addon> value) { /* not implemented */ }

	// autoexec_paths
	std::map<std::string, PathCompare> UserPreferences::autoexec_paths() {
		// TODO: MISSING DEREF! USE #DEFINE!
		PyObject *seqval = PyObject_GetAttrString(pyobjref, "autoexec_paths");
		PyObject *seqkeys = PyObject_CallMethod(seqval, "keys", NULL);
		std::map<std::string, PathCompare> resmap;
		for (int i = 0; i < PySequence_Length(seqval); i++) {
			PyObject *keyobj = PySequence_GetItem(seqkeys, i);
			std::string key = PyBytes_AsString(PyUnicode_AsASCIIString(keyobj));
			PathCompare value = PathCompare(PySequence_GetItem(seqval, i));
			resmap.insert(std::pair<std::string,PathCompare>(key, value));
		}
		return resmap;
	}

	void UserPreferences::autoexec_paths(std::map<std::string, PathCompare> value) { /* not implemented */ }

	// view
	UserPreferencesView UserPreferences::view() {
		return UserPreferencesView(PyObject_GetAttrString(pyobjref, "view"));
	}

	// edit
	UserPreferencesEdit UserPreferences::edit() {
		return UserPreferencesEdit(PyObject_GetAttrString(pyobjref, "edit"));
	}

	// inputs
	UserPreferencesInput UserPreferences::inputs() {
		return UserPreferencesInput(PyObject_GetAttrString(pyobjref, "inputs"));
	}

	// filepaths
	UserPreferencesFilePaths UserPreferences::filepaths() {
		return UserPreferencesFilePaths(PyObject_GetAttrString(pyobjref, "filepaths"));
	}

	// system
	UserPreferencesSystem UserPreferences::system() {
		return UserPreferencesSystem(PyObject_GetAttrString(pyobjref, "system"));
	}

	Addon Addons::create()
	{
		// not implemented
		return Addon();
	}

	void Addons::remove(Addon addon)
	{
		// not implemented
	}

	PathCompare PathCompareCollection::create()
	{
		// not implemented
		return PathCompare();
	}

	void PathCompareCollection::remove(PathCompare pathcmp)
	{
		// not implemented
	}

	/**************** Addon ****************/

	// preferences
	AddonPreferences Addon::preferences() {
		return AddonPreferences(PyObject_GetAttrString(pyobjref, "preferences"));
	}

	/**************** Operator ****************/

	// properties
	OperatorProperties Operator::properties() {
		return OperatorProperties(PyObject_GetAttrString(pyobjref, "properties"));
	}

	// options
	OperatorOptions Operator::options() {
		return OperatorOptions(PyObject_GetAttrString(pyobjref, "options"));
	}

	// macros
	std::map<std::string, Macro> Operator::macros() {
		// TODO: MISSING DEREF! USE #DEFINE!
		PyObject *seqval = PyObject_GetAttrString(pyobjref, "macros");
		PyObject *seqkeys = PyObject_CallMethod(seqval, "keys", NULL);
		std::map<std::string, Macro> resmap;
		for (int i = 0; i < PySequence_Length(seqval); i++) {
			PyObject *keyobj = PySequence_GetItem(seqkeys, i);
			std::string key = PyBytes_AsString(PyUnicode_AsASCIIString(keyobj));
			Macro value = Macro(PySequence_GetItem(seqval, i));
			resmap.insert(std::pair<std::string,Macro>(key, value));
		}
		return resmap;
	}

	void Operator::macros(std::map<std::string, Macro> value) { /* not implemented */ }

	/**************** Window ****************/

	// stereo_3d_display
	Stereo3dDisplay Window::stereo_3d_display() {
		return Stereo3dDisplay(PyObject_GetAttrString(pyobjref, "stereo_3d_display"));
	}

	/**************** Window Manager ****************/

	// keyconfigs
	std::map<std::string, KeyConfig> WindowManager::keyconfigs() {
		// TODO: MISSING DEREF! USE #DEFINE!
		PyObject *seqval = PyObject_GetAttrString(pyobjref, "keyconfigs");
		PyObject *seqkeys = PyObject_CallMethod(seqval, "keys", NULL);
		std::map<std::string, KeyConfig> resmap;
		for (int i = 0; i < PySequence_Length(seqval); i++) {
			PyObject *keyobj = PySequence_GetItem(seqkeys, i);
			std::string key = PyBytes_AsString(PyUnicode_AsASCIIString(keyobj));
			KeyConfig value = KeyConfig(PySequence_GetItem(seqval, i));
			resmap.insert(std::pair<std::string,KeyConfig>(key, value));
		}
		return resmap;
	}

	void WindowManager::keyconfigs(std::map<std::string, KeyConfig> value) { /* not implemented */ }

	/**************** KeyConfigs ****************/

	// active
	KeyConfig KeyConfigurations::active() {
		return KeyConfig(PyObject_GetAttrString(pyobjref, "active"));
	}

	// default
	KeyConfig KeyConfigurations::default_value() {
		return KeyConfig(PyObject_GetAttrString(pyobjref, "default"));
	}

	// addon
	KeyConfig KeyConfigurations::addon() {
		return KeyConfig(PyObject_GetAttrString(pyobjref, "addon"));
	}

	// user
	KeyConfig KeyConfigurations::user() {
		return KeyConfig(PyObject_GetAttrString(pyobjref, "user"));
	}

	KeyConfig KeyConfigurations::create(const std::string name)
	{
		// not implemented
		return KeyConfig();
	}

	void KeyConfigurations::remove(KeyConfig keyconfig)
	{
		// not implemented
	}

	/**************** Key Configuration ****************/

	// keymaps
	std::map<std::string, KeyMap> KeyConfig::keymaps() {
		// TODO: MISSING DEREF! USE #DEFINE!
		PyObject *seqval = PyObject_GetAttrString(pyobjref, "keymaps");
		PyObject *seqkeys = PyObject_CallMethod(seqval, "keys", NULL);
		std::map<std::string, KeyMap> resmap;
		for (int i = 0; i < PySequence_Length(seqval); i++) {
			PyObject *keyobj = PySequence_GetItem(seqkeys, i);
			std::string key = PyBytes_AsString(PyUnicode_AsASCIIString(keyobj));
			KeyMap value = KeyMap(PySequence_GetItem(seqval, i));
			resmap.insert(std::pair<std::string,KeyMap>(key, value));
		}
		return resmap;
	}

	void KeyConfig::keymaps(std::map<std::string, KeyMap> value) { /* not implemented */ }

	KeyMap KeyMaps::create(const std::string name, space_type_items space_type, region_type_items region_type, bool modal)
	{
		// not implemented
		return KeyMap();
	}

	void KeyMaps::remove(KeyMap keymap)
	{
		// not implemented
	}

	KeyMap KeyMaps::find(const std::string name, space_type_items space_type, region_type_items region_type)
	{
		// not implemented
		return KeyMap();
	}

	KeyMap KeyMaps::find_modal(const std::string name)
	{
		// not implemented
		return KeyMap();
	}

	/**************** Key Map ****************/

	// keymap_items
	std::map<std::string, KeyMapItem> KeyMap::keymap_items() {
		// TODO: MISSING DEREF! USE #DEFINE!
		PyObject *seqval = PyObject_GetAttrString(pyobjref, "keymap_items");
		PyObject *seqkeys = PyObject_CallMethod(seqval, "keys", NULL);
		std::map<std::string, KeyMapItem> resmap;
		for (int i = 0; i < PySequence_Length(seqval); i++) {
			PyObject *keyobj = PySequence_GetItem(seqkeys, i);
			std::string key = PyBytes_AsString(PyUnicode_AsASCIIString(keyobj));
			KeyMapItem value = KeyMapItem(PySequence_GetItem(seqval, i));
			resmap.insert(std::pair<std::string,KeyMapItem>(key, value));
		}
		return resmap;
	}

	void KeyMap::keymap_items(std::map<std::string, KeyMapItem> value) { /* not implemented */ }

	void KeyMap::restore_item_to_default(KeyMapItem item)
	{
		// not implemented
	}

	KeyMapItem KeyMapItems::create(const std::string idname, event_type_items type, event_value_items value, bool any, bool shift, bool ctrl, bool alt, bool oskey, event_type_items key_modifier, bool head)
	{
		// not implemented
		return KeyMapItem();
	}

	KeyMapItem KeyMapItems::new_modal(const std::string propvalue, event_type_items type, event_value_items value, bool any, bool shift, bool ctrl, bool alt, bool oskey, event_type_items key_modifier)
	{
		// not implemented
		return KeyMapItem();
	}

	void KeyMapItems::remove(KeyMapItem item)
	{
		// not implemented
	}

	KeyMapItem KeyMapItems::from_id(int id)
	{
		// not implemented
		return KeyMapItem();
	}

	/**************** World ****************/

	// texture_slots
	std::map<std::string, WorldTextureSlot> World::texture_slots() {
		// TODO: MISSING DEREF! USE #DEFINE!
		PyObject *seqval = PyObject_GetAttrString(pyobjref, "texture_slots");
		PyObject *seqkeys = PyObject_CallMethod(seqval, "keys", NULL);
		std::map<std::string, WorldTextureSlot> resmap;
		for (int i = 0; i < PySequence_Length(seqval); i++) {
			PyObject *keyobj = PySequence_GetItem(seqkeys, i);
			std::string key = PyBytes_AsString(PyUnicode_AsASCIIString(keyobj));
			WorldTextureSlot value = WorldTextureSlot(PySequence_GetItem(seqval, i));
			resmap.insert(std::pair<std::string,WorldTextureSlot>(key, value));
		}
		return resmap;
	}

	void World::texture_slots(std::map<std::string, WorldTextureSlot> value) { /* not implemented */ }

	// light_settings
	WorldLighting World::light_settings() {
		return WorldLighting(PyObject_GetAttrString(pyobjref, "light_settings"));
	}

	// mist_settings
	WorldMistSettings World::mist_settings() {
		return WorldMistSettings(PyObject_GetAttrString(pyobjref, "mist_settings"));
	}

	WorldTextureSlot WorldTextureSlots::add()
	{
		// not implemented
		return WorldTextureSlot();
	}

	WorldTextureSlot WorldTextureSlots::create(int index)
	{
		// not implemented
		return WorldTextureSlot();
	}

	/**************** MovieClip ****************/

	// tracking
	MovieTracking MovieClip::tracking() {
		return MovieTracking(PyObject_GetAttrString(pyobjref, "tracking"));
	}

	// proxy
	MovieClipProxy MovieClip::proxy() {
		return MovieClipProxy(PyObject_GetAttrString(pyobjref, "proxy"));
	}

	MovieTrackingMarker MovieTrackingMarkers::find_frame(int frame, bool exact)
	{
		// not implemented
		return MovieTrackingMarker();
	}

	MovieTrackingMarker MovieTrackingMarkers::insert_frame(int frame, float co[2])
	{
		// not implemented
		return MovieTrackingMarker();
	}

	MovieTrackingPlaneMarker MovieTrackingPlaneMarkers::find_frame(int frame, bool exact)
	{
		// not implemented
		return MovieTrackingPlaneMarker();
	}

	MovieTrackingPlaneMarker MovieTrackingPlaneMarkers::insert_frame(int frame)
	{
		// not implemented
		return MovieTrackingPlaneMarker();
	}

	/**************** Movie Tracks ****************/

	// active
	MovieTrackingTrack MovieTrackingTracks::active() {
		return MovieTrackingTrack(PyObject_GetAttrString(pyobjref, "active"));
	}

	MovieTrackingTrack MovieTrackingTracks::create(const std::string name, int frame)
	{
		// not implemented
		return MovieTrackingTrack();
	}

	/**************** Movie Plane Tracks ****************/

	// active
	MovieTrackingPlaneTrack MovieTrackingPlaneTracks::active() {
		return MovieTrackingPlaneTrack(PyObject_GetAttrString(pyobjref, "active"));
	}

	/**************** Movie Tracks ****************/

	// active
	MovieTrackingTrack MovieTrackingObjectTracks::active() {
		return MovieTrackingTrack(PyObject_GetAttrString(pyobjref, "active"));
	}

	MovieTrackingTrack MovieTrackingObjectTracks::create(const std::string name, int frame)
	{
		// not implemented
		return MovieTrackingTrack();
	}

	/**************** Plane Tracks ****************/

	// active
	MovieTrackingTrack MovieTrackingObjectPlaneTracks::active() {
		return MovieTrackingTrack(PyObject_GetAttrString(pyobjref, "active"));
	}

	MovieReconstructedCamera MovieTrackingReconstructedCameras::find_frame(int frame)
	{
		// not implemented
		return MovieReconstructedCamera();
	}

	/**************** Movie Objects ****************/

	// active
	MovieTrackingObject MovieTrackingObjects::active() {
		return MovieTrackingObject(PyObject_GetAttrString(pyobjref, "active"));
	}

	MovieTrackingObject MovieTrackingObjects::create(const std::string name)
	{
		// not implemented
		return MovieTrackingObject();
	}

	void MovieTrackingObjects::remove(MovieTrackingObject object_value)
	{
		// not implemented
	}

	/**************** Mask Splines ****************/

	// active
	MaskSpline MaskSplines::active() {
		return MaskSpline(PyObject_GetAttrString(pyobjref, "active"));
	}

	// active_point
	MaskSplinePoint MaskSplines::active_point() {
		return MaskSplinePoint(PyObject_GetAttrString(pyobjref, "active_point"));
	}

	MaskSpline MaskSplines::create()
	{
		// not implemented
		return MaskSpline();
	}

	void MaskSplines::remove(MaskSpline spline)
	{
		// not implemented
	}

	void MaskSplinePoints::remove(MaskSplinePoint point)
	{
		// not implemented
	}

	/**************** Mask Layers ****************/

	// active
	MaskLayer MaskLayers::active() {
		return MaskLayer(PyObject_GetAttrString(pyobjref, "active"));
	}

	MaskLayer MaskLayers::create(const std::string name)
	{
		// not implemented
		return MaskLayer();
	}

	void MaskLayers::remove(MaskLayer layer)
	{
		// not implemented
	}

}

#endif /* __UNIPLUG_BLENDER_CPP_H__ */

